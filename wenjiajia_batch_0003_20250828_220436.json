{
  "metadata": {
    "batch_number": 3,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:39.491876",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "1056/G",
      "title": "G. Take Metro",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test1024 megabytes",
      "input_spec": "InputThe first line contains two integers nn and mm (3≤n≤1053≤n≤105, 1≤m<n1≤m<n) — the total number of stations and the number of stations that have red interior.The second line contains two integers ss and tt (1≤s≤n1≤s≤n, 1≤t≤10121≤t≤1012) — the starting station and the initial value of tt.",
      "output_spec": "OutputOutput the only integer — the station where Arkady will exit the metro.",
      "sample_tests": "ExamplesInputCopy10 4\n3 1\nOutputCopy4\nInputCopy10 4\n3 5\nOutputCopy4\nInputCopy10543 437\n5492 1947349\nOutputCopy438",
      "description": "G. Take Metro\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test1024 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and mm (3≤n≤1053≤n≤105, 1≤m<n1≤m<n) — the total number of stations and the number of stations that have red interior.The second line contains two integers ss and tt (1≤s≤n1≤s≤n, 1≤t≤10121≤t≤1012) — the starting station and the initial value of tt.\n\nOutputOutput the only integer — the station where Arkady will exit the metro.\n\nInputCopy10 4\n3 1\nOutputCopy4\nInputCopy10 4\n3 5\nOutputCopy4\nInputCopy10543 437\n5492 1947349\nOutputCopy438\n\nInputCopy10 4\n3 1\n\nOutputCopy4\n\nInputCopy10 4\n3 5\n\nOutputCopy4\n\nInputCopy10543 437\n5492 1947349\n\nOutputCopy438\n\nNoteConsider the first example. There are 1010 stations and the first 44 of them are red. Arkady starts at station 33 with value t=1t=1, so just rides 11 station in clockwise direction and ends up on the station 44.In the second example the metro is same as in the first example, but Arkady starts at station 33 with value t=5t=5.   It is a red station so he rides 55 stations in clockwise direction and leaves the train at station 88.  It is a blue station, so he rides 44 stations in counter-clockwise direction and leaves at station 44.  It is a red station, so he rides 33 stations in clockwise direction and leaves at station 77.  It is a blue station, so he rides 22 stations in counter-clockwise direction and leaves at station 55.  It is a blue station, so he rides 11 station in counter-clockwise direction and leaves at station 44.  Now t=0t=0, so Arkady exits metro at the station 44.",
      "solutions": [
        {
          "title": "Mail.Ru Cup 2018 Round 3 - Codeforces",
          "content": "Hi!Tomorrow, at Monday, November 26, 2018 at 00:35UTC+8 we will host the final round of Mail.Ru Cup 2018. The problems were authored and prepared by Codeforces team: me, Dmitry cdkrot Sayutin, Ildar 300iq Gainullin and Mike MikeMirzayanov Mirzayanov, and also Maxim Neon Mezhcheryakov. Huge thanks to Grigory vintage_Vlad_Makeev Reznikov abd Kamil Errichto Debowski for problems' testing!This round is the final in the new championship called Mail.Ru Cup, you can learn more about it following the link. The round will be rated for everybody!After the round we will know who will get the following prizes: First place — Apple MacBook Air Second and third place — Apple iPad Fourth, fifth, sixth places — Samsung Gear S3 Traditionally, the top 100 championship participants will get cool T-shirts! In each round, top 100 participants get prize points according to the table. The championship's result of a participant is the sum of the two largest results he gets on the three rounds. The results of the two first rounds are published here. In case of ties in the top six places, they will be broken by the sum of in-round scores in the corresponding (best for the participant) two rounds.There will be eight problems and two and a half hours to solve them.Good luck!P. S. MikeMirzayanov invites everybody to the official Codeforces channel in Telegram: t.me/codeforces_official.The round has finished, thanks everybody, hope you liked the problems!Congratolations to the winners of the third round of Mail.Ru Cup 2018: Radewoosh V--o_o--V ch_egor ksun48 RAVEman The results of the Cup will be announced shortly.The editorial is here.",
          "author": "KAN",
          "url": "https://codeforces.com/blog/entry/63426",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1633
        },
        {
          "title": "Mail.Ru Cup 2018 Round 3 Editorial - Codeforces",
          "content": "1056A - Determine LineThis is a simple implementation problem. A tram line is suitable if it appears at all stops, i.e. exactly nn times. Make an array of 100100 integers and count how many times each integer appears. Then just output each index where the array hits nn.Author, preparation: KAN. 1056B - Divide CandiesWe are asked to count the number of pairs (i,j)(i,j) so that (i2+j2)modm=0(i2+j2)modm=0. Note that (i2+j2)modm=((imodm)2+(jmodm)2)modm(i2+j2)modm=((imodm)2+(jmodm)2)modm. Thus the answer is equal for all pairs (i,j)(i,j) that have equal values (imodm,jmodm)=(x,y)(imodm,jmodm)=(x,y). Let's loop through all possible pairs of (x,y)(x,y) (there are m2m2 of them), check if (x2+y2)modm=0(x2+y2)modm=0 and if yes, add to the answer the number of suitable pairs (i,j)(i,j), that is easy to compute in O(1)O(1).The complexity of the solution is O(m2)O(m2).Author, preparation: cdkrot. 1056C - Pick HeroesFirst suppose we have the first turn. Let's look at what total power we can grab. There are two types of heroes: those who have a special pair and those who don't.In each pair, one of the heroes will go into your team and one into the other. So the maximum we can get here is the sum of powers of the best in corresponding pairs heroes.Now consider only the heroes that don't have pairs. I claim that you and your opponent will pick heroes from this list alternating turns. Indeed, picking a \"paired\" hero doesn't change the turns order because the opponent will also pick a \"paired\" hero. From this point it is easy to see that the best you can get from \"unpaired\" heroes is the sum of powers of the first, the third, the fifth and so on heroes, if sorted in decreasing order of power.Now that we have proved the maximum constraint on our total power, let's build an algorithm that always reaches this power. If the first turn is ours, we have the initiative and the natural idea is not to lose it. Indeed, we can first pick all best \"paired\" heroes and then just keep picking the best remaining hero till the end. Since in the first part the opponent has to follow the rule about \"paired\" heroes, he won't be able to prevent us from taking the desired sum of power.If our turn is the second one, we don't have any option until all \"paired\" heroes are gone or the opponent gives the initiative back to us choosing an \"unpaired\" hero. Starting from this point we can use the same strategy as if we had the first turn.The solution can be implemented in linear time.Author, preparation: KAN. 1056D - Decorate Apple TreeI'll try two describe two different approaches to this problem. A more intuitive solution. We are asked to output the number of colors for all kk, let's reverse the problem and count the maximum kk for all possible number of colors cc. We can see that if we a junction is happy then all junctions in its subtree are also happy. So we're interested in selecting some set of junctions so that their subtrees are disjoint and have no more than cc leaves, and we want to maximize the total size of these subtrees. This can be done greedily from the root: if a subtree is small enough, take it all, in the other case go to its children instead. We can see that a subtree is in the answer set for all cc not less than the size of the subtree and less than the size of the parent's subtree. We can easily compute this range for all junction in one deep-first search and sum the answer on these segments. A more professional solution. Note that a junction can be happy only when the number of colors is at least the number of leaves in it. The rule is that this is the only condition needed: indeed, if we color the leaves cyclically in the order of Euler tour, all such junctions will be happy. So the answer for the number of colors is simply the number of junctions that have at most cc leaves in the subtree Both solutions can be implemented in O(n)O(n).Author, preparation: KAN. 1056E - Check TranscriptionThe solution builds on one key observation.Suppose we know the length of r0r0. Then, since the number of '0' and '1' is fixed and the length of the resulting string is also fixed, we know the length of r1r1 (or know, that there is no integer-sized r1r1 possible).So let's bruteforce the length of r0r0, calculate the length of r1r1 and then check whether the corresponding substrings of tt are equal (so r0r0 and r1r1 can be defined correctly).Sounds like O(|s||t|)O(|s||t|) (since the number of candidates is ≤|t|≤|t| and check can be done in |s||s|, for example with hashes)? Haha, it is O(|t|)O(|t|).First, notice that it is not exactly important whether we bruteforce length of r0r0 or r1r1 — one of them defines the other one.So suppose we are bruteforcing over the letter with larger number of occurrences in pattern string ss.Let's denote it's number of occurrences as cc, this way, clearly, there are at most |t|c|t|c candidates. And each candidate is checked in |s||s|. So the whole time is |t|c|s||t|c|s|Since we used the more frequent letter, c≥|s|2c≥|s|2. And hence |t|c|s|≤2|t||t|c|s|≤2|t|.Authors: MikeMirzayanov, cdkrot, preparation: cdkrot. 1056F - Write The ContestFirstly, if we fix some set of problems to solve, it's always optimal to solve them from the hardest one to the easiest one. That implies a solution which processes all problems and decides which of them will be solved in sorted order.Secondly, suppose Polycarp doesn't train at all, and for some fixed set of kk problems it will take him 10k+m10k+m minutes, where 10k10k is the time spent on watching the series, and mm is the time spent on actually solving the problems. If Polycarp would raise his skill to ss before solving all the problems, then it would take him 10k+ms10k+ms minutes to solve the same set of problems in the same order. So if we fix a set of problems and compute mm for it, it's easy to see that if Polycarp trains for tt minutes, then it will take him 10k+m1+Ct+t10k+m1+Ct+t minutes to train and solve all the problems. This function f(t)=10k+m1+Ct+tf(t)=10k+m1+Ct+t can be minimized with ternary search or some pen and paper work.This function also gives us the following: among two sets of problems with equal total score and equal number of problems it's optimal to choose the set having smaller value of mm. So we can write a knapsack-like dynamic programming: dpx,kdpx,k — the smallest possible value of mm for a set of kk problems with total score xx. After computing these dynamic programming values, for a given pair (x,k)(x,k) it's easy to check if the time required to obtain this result does not exceed TT: just minimize the function f(t)=10k+dpx,k1+Ct+tf(t)=10k+dpx,k1+Ct+t.Author, preparation: Neon. 1056G - Take MetroThere were a variety of approaches to this problem. In all of them you first have to note that there are only n2n2 different positions describes as pairs (station, TmodnTmodn). Now if you manually perform several first steps to make Tmodn=0Tmodn=0, you will have to perform T/nT/n large steps, each of them is to have nn rides with T=nT=n, T=n−1T=n−1, ..., T=1T=1. If you compute for each station the station you will end up after a large step, you will get a functional graph where you will easily find the answer, computing a period and a pre-period. The question is how to get the graph. The first approach is to be strong and code a persistent treap (or any other persistent data structure that supports split and merge). This approach is O(nlog(n))O(nlog⁡(n)). The second approach is... to rely that the cycle is not large and compute all large tests in a straightforward way. This also works fast, but we don't have a proof for that. Author, preparation: KAN. 1056H - Detect RobotsThe solution is sqrt decomposition. Let's divide the rides into two groups: with length greater than RR and with length smaller than RR.Now let's reformulate the problem a bit: for each pair of paths you have to check the following: for each aa and bb that appear in this order in both paths, the next crossroads after aa should be same in both paths. Now it's easy to check this condition for a pair of paths from the second set in a straightforward way.Now iterate through a path from the first set and any other set. Let's first the last common crossroads in the paths. Now when you iterate through all common points, it is easy to check the aforementioned condition.Choosing R=O(n−−√)R=O(n), the solution can be implemented in O(nn−−√)O(nn).Author KAN, preparation: KAN, 300iq.Huge thanks to cdkrot and 300iq for discussing the problems and general invaluable help in preparation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63461",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1056\\s*G"
          },
          "content_length": 8544
        }
      ],
      "code_examples": [
        {
          "title": "Mail.Ru Cup 2018 Round 3 Editorial - Codeforces - Code 1",
          "code": "for (int i = k; i > 0; --i) {\n   if (s > 0) s -= i;\n   else s += i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63461",
          "author": "jiangly"
        },
        {
          "title": "Mail.Ru Cup 2018 Round 3 Editorial - Codeforces - Code 2",
          "code": "for (int i = k; i > 0; --i) {\n   if (s > 0) s -= i;\n   else s += i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63461",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n - 1, \"m\");\n    inf.readEoln();\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    long long t = inf.readLong(1LL, 1000000000000LL, \"t\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n - 1, \"m\");\n    inf.readEoln();\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    long long t = inf.readLong(1LL, 1000000000000LL, \"t\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n - 1, \"m\");\n    inf.readEoln();\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    long long t = inf.readLong(1LL, 1000000000000LL, \"t\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int s = opt<int>(\"s\", -1);\n    long long t = opt<long long>(\"t\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Set default random values if not provided\n    if (n == -1) n = rnd.next(3, 100000);\n    if (m == -1) m = rnd.next(1, n - 1);\n    if (s == -1) s = rnd.next(1, n);\n    if (t == -1) t = rnd.next(1LL, 1000000000000LL);\n\n    // Adjust according to type\n    if (type == \"max_n_t\") {\n        n = 100000;\n        t = 1000000000000LL;\n        m = rnd.next(1, n - 1);\n        s = rnd.next(1, n);\n    } else if (type == \"min_n_t\") {\n        n = 3;\n        t = 1;\n        m = 1;\n        s = 1;\n    } else if (type == \"random_large\") {\n        n = rnd.next(50000, 100000);\n        t = rnd.next(500000000000LL, 1000000000000LL);\n        m = rnd.next(1, n - 1);\n        s = rnd.next(1, n);\n    } else if (type == \"random_small\") {\n        n = rnd.next(3, 10);\n        t = rnd.next(1LL, 1000LL);\n        m = rnd.next(1, n - 1);\n        s = rnd.next(1, n);\n    } else if (type == \"m1\") {\n        m = 1;\n    } else if (type == \"mn1\") {\n        m = n - 1;\n    } else if (type == \"s1\") {\n        s = 1;\n    } else if (type == \"sn\") {\n        s = n;\n    } else if (type == \"t1\") {\n        t = 1;\n    } else if (type == \"tmax\") {\n        t = 1000000000000LL;\n    } else if (type == \"boundary_m\") {\n        m = (rnd.next(0, 1) == 0) ? 1 : n - 1;\n    } else if (type == \"station_m\") {\n        m = rnd.next(1, n - 1);\n        s = m;\n    } else if (type == \"station_m1\") {\n        m = rnd.next(1, n - 1);\n        s = m + 1;\n        if (s > n) s = 1;\n    } else if (type == \"large_t_small_n\") {\n        n = rnd.next(3, 100);\n        t = 1000000000000LL;\n    } else if (type == \"small_t_large_n\") {\n        n = 100000;\n        t = 1;\n    }\n\n    // Ensure constraints\n    if (m < 1) m = 1;\n    if (m >= n) m = n - 1;\n    if (s < 1) s = 1;\n    if (s > n) s = n;\n    if (t < 1) t = 1;\n    if (t > 1000000000000LL) t = 1000000000000LL;\n    if (n < 3) n = 3;\n    if (n > 100000) n = 100000;\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d %lld\\n\", s, t);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int s = opt<int>(\"s\", -1);\n    long long t = opt<long long>(\"t\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Set default random values if not provided\n    if (n == -1) n = rnd.next(3, 100000);\n    if (m == -1) m = rnd.next(1, n - 1);\n    if (s == -1) s = rnd.next(1, n);\n    if (t == -1) t = rnd.next(1LL, 1000000000000LL);\n\n    // Adjust according to type\n    if (type == \"max_n_t\") {\n        n = 100000;\n        t = 1000000000000LL;\n        m = rnd.next(1, n - 1);\n        s = rnd.next(1, n);\n    } else if (type == \"min_n_t\") {\n        n = 3;\n        t = 1;\n        m = 1;\n        s = 1;\n    } else if (type == \"random_large\") {\n        n = rnd.next(50000, 100000);\n        t = rnd.next(500000000000LL, 1000000000000LL);\n        m = rnd.next(1, n - 1);\n        s = rnd.next(1, n);\n    } else if (type == \"random_small\") {\n        n = rnd.next(3, 10);\n        t = rnd.next(1LL, 1000LL);\n        m = rnd.next(1, n - 1);\n        s = rnd.next(1, n);\n    } else if (type == \"m1\") {\n        m = 1;\n    } else if (type == \"mn1\") {\n        m = n - 1;\n    } else if (type == \"s1\") {\n        s = 1;\n    } else if (type == \"sn\") {\n        s = n;\n    } else if (type == \"t1\") {\n        t = 1;\n    } else if (type == \"tmax\") {\n        t = 1000000000000LL;\n    } else if (type == \"boundary_m\") {\n        m = (rnd.next(0, 1) == 0) ? 1 : n - 1;\n    } else if (type == \"station_m\") {\n        m = rnd.next(1, n - 1);\n        s = m;\n    } else if (type == \"station_m1\") {\n        m = rnd.next(1, n - 1);\n        s = m + 1;\n        if (s > n) s = 1;\n    } else if (type == \"large_t_small_n\") {\n        n = rnd.next(3, 100);\n        t = 1000000000000LL;\n    } else if (type == \"small_t_large_n\") {\n        n = 100000;\n        t = 1;\n    }\n\n    // Ensure constraints\n    if (m < 1) m = 1;\n    if (m >= n) m = n - 1;\n    if (s < 1) s = 1;\n    if (s > n) s = n;\n    if (t < 1) t = 1;\n    if (t > 1000000000000LL) t = 1000000000000LL;\n    if (n < 3) n = 3;\n    if (n > 100000) n = 100000;\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d %lld\\n\", s, t);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n\n./gen -type max_n_t\n./gen -type max_n_t\n\n./gen -type min_n_t\n\n./gen -type m1\n./gen -type m1 -n 100000\n./gen -type m1 -n 3\n\n./gen -type mn1\n./gen -type mn1 -n 100000\n./gen -type mn1 -n 3\n\n./gen -type s1\n./gen -type s1 -n 100000\n\n./gen -type sn\n./gen -type sn -n 100000\n\n./gen -type t1\n\n./gen -type tmax\n\n./gen -type boundary_m\n./gen -type boundary_m\n\n./gen -type station_m\n./gen -type station_m1\n\n./gen -type large_t_small_n\n\n./gen -type small_t_large_n\n\n./gen -n 99999 -m 50000\n./gen -n 100000 -m 99999 -type random\n\n./gen -s 1 -t 1000000000000 -type random\n./gen -s 100000 -t 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:11:55.863802",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1056/H",
      "title": "H. Detect Robots",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test1024 megabytes",
      "input_spec": "InputEach test contains one or more test cases. The first line contains a single integer tt (1≤t≤3⋅1051≤t≤3⋅105) — the number of test cases.The first line of each test case contains a single integer nn (1≤n≤3⋅1051≤n≤3⋅105) — the number of crossroads in the city.The next line contains a single integer qq (1≤q≤3⋅1051≤q≤3⋅105) — the number of rides available to you.Each of the following qq lines starts with a single integer kk (2≤k≤n2≤k≤n) — the number of crossroads visited by the driver on this ride. It is followed by kk integers c1c1, c2c2, ..., ckck (1≤ci≤n1≤ci≤n) — the crossroads in the order the driver visited them. It is guaranteed that all crossroads in one ride are distinct.It is guaranteed that the sum of values kk among all rides of all test cases does not exceed 3⋅1053⋅105.It is guaranteed that the sum of values nn and the sum of values qq doesn't exceed 3⋅1053⋅105 among all test cases.",
      "output_spec": "OutputOutput a single line for each test case.If the driver can be a robot, output \"Robot\" in a single line. Otherwise, output \"Human\".You can print each letter in any case (upper or lower).",
      "sample_tests": "ExamplesInputCopy1\n5\n2\n4 1 2 3 5\n3 1 4 3\nOutputCopyHuman\nInputCopy1\n4\n4\n3 1 2 3\n3 2 3 4\n3 3 4 1\n3 4 1 2\nOutputCopyRobot",
      "description": "H. Detect Robots\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test1024 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputEach test contains one or more test cases. The first line contains a single integer tt (1≤t≤3⋅1051≤t≤3⋅105) — the number of test cases.The first line of each test case contains a single integer nn (1≤n≤3⋅1051≤n≤3⋅105) — the number of crossroads in the city.The next line contains a single integer qq (1≤q≤3⋅1051≤q≤3⋅105) — the number of rides available to you.Each of the following qq lines starts with a single integer kk (2≤k≤n2≤k≤n) — the number of crossroads visited by the driver on this ride. It is followed by kk integers c1c1, c2c2, ..., ckck (1≤ci≤n1≤ci≤n) — the crossroads in the order the driver visited them. It is guaranteed that all crossroads in one ride are distinct.It is guaranteed that the sum of values kk among all rides of all test cases does not exceed 3⋅1053⋅105.It is guaranteed that the sum of values nn and the sum of values qq doesn't exceed 3⋅1053⋅105 among all test cases.\n\nOutputOutput a single line for each test case.If the driver can be a robot, output \"Robot\" in a single line. Otherwise, output \"Human\".You can print each letter in any case (upper or lower).\n\nInputCopy1\n5\n2\n4 1 2 3 5\n3 1 4 3\nOutputCopyHuman\nInputCopy1\n4\n4\n3 1 2 3\n3 2 3 4\n3 3 4 1\n3 4 1 2\nOutputCopyRobot\n\nInputCopy1\n5\n2\n4 1 2 3 5\n3 1 4 3\n\nOutputCopyHuman\n\nInputCopy1\n4\n4\n3 1 2 3\n3 2 3 4\n3 3 4 1\n3 4 1 2\n\nOutputCopyRobot\n\nNoteIn the first example it is clear that the driver used two different ways to get from crossroads 11 to crossroads 33. It must be a human.In the second example the driver always drives the cycle 1→2→3→4→11→2→3→4→1 until he reaches destination.",
      "solutions": [
        {
          "title": "Mail.Ru Cup 2018 Round 3 - Codeforces",
          "content": "Hi!Tomorrow, at Monday, November 26, 2018 at 00:35UTC+8 we will host the final round of Mail.Ru Cup 2018. The problems were authored and prepared by Codeforces team: me, Dmitry cdkrot Sayutin, Ildar 300iq Gainullin and Mike MikeMirzayanov Mirzayanov, and also Maxim Neon Mezhcheryakov. Huge thanks to Grigory vintage_Vlad_Makeev Reznikov abd Kamil Errichto Debowski for problems' testing!This round is the final in the new championship called Mail.Ru Cup, you can learn more about it following the link. The round will be rated for everybody!After the round we will know who will get the following prizes: First place — Apple MacBook Air Second and third place — Apple iPad Fourth, fifth, sixth places — Samsung Gear S3 Traditionally, the top 100 championship participants will get cool T-shirts! In each round, top 100 participants get prize points according to the table. The championship's result of a participant is the sum of the two largest results he gets on the three rounds. The results of the two first rounds are published here. In case of ties in the top six places, they will be broken by the sum of in-round scores in the corresponding (best for the participant) two rounds.There will be eight problems and two and a half hours to solve them.Good luck!P. S. MikeMirzayanov invites everybody to the official Codeforces channel in Telegram: t.me/codeforces_official.The round has finished, thanks everybody, hope you liked the problems!Congratolations to the winners of the third round of Mail.Ru Cup 2018: Radewoosh V--o_o--V ch_egor ksun48 RAVEman The results of the Cup will be announced shortly.The editorial is here.",
          "author": "KAN",
          "url": "https://codeforces.com/blog/entry/63426",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1633
        },
        {
          "title": "Mail.Ru Cup 2018 Round 3 Editorial - Codeforces",
          "content": "1056A - Determine LineThis is a simple implementation problem. A tram line is suitable if it appears at all stops, i.e. exactly nn times. Make an array of 100100 integers and count how many times each integer appears. Then just output each index where the array hits nn.Author, preparation: KAN. 1056B - Divide CandiesWe are asked to count the number of pairs (i,j)(i,j) so that (i2+j2)modm=0(i2+j2)modm=0. Note that (i2+j2)modm=((imodm)2+(jmodm)2)modm(i2+j2)modm=((imodm)2+(jmodm)2)modm. Thus the answer is equal for all pairs (i,j)(i,j) that have equal values (imodm,jmodm)=(x,y)(imodm,jmodm)=(x,y). Let's loop through all possible pairs of (x,y)(x,y) (there are m2m2 of them), check if (x2+y2)modm=0(x2+y2)modm=0 and if yes, add to the answer the number of suitable pairs (i,j)(i,j), that is easy to compute in O(1)O(1).The complexity of the solution is O(m2)O(m2).Author, preparation: cdkrot. 1056C - Pick HeroesFirst suppose we have the first turn. Let's look at what total power we can grab. There are two types of heroes: those who have a special pair and those who don't.In each pair, one of the heroes will go into your team and one into the other. So the maximum we can get here is the sum of powers of the best in corresponding pairs heroes.Now consider only the heroes that don't have pairs. I claim that you and your opponent will pick heroes from this list alternating turns. Indeed, picking a \"paired\" hero doesn't change the turns order because the opponent will also pick a \"paired\" hero. From this point it is easy to see that the best you can get from \"unpaired\" heroes is the sum of powers of the first, the third, the fifth and so on heroes, if sorted in decreasing order of power.Now that we have proved the maximum constraint on our total power, let's build an algorithm that always reaches this power. If the first turn is ours, we have the initiative and the natural idea is not to lose it. Indeed, we can first pick all best \"paired\" heroes and then just keep picking the best remaining hero till the end. Since in the first part the opponent has to follow the rule about \"paired\" heroes, he won't be able to prevent us from taking the desired sum of power.If our turn is the second one, we don't have any option until all \"paired\" heroes are gone or the opponent gives the initiative back to us choosing an \"unpaired\" hero. Starting from this point we can use the same strategy as if we had the first turn.The solution can be implemented in linear time.Author, preparation: KAN. 1056D - Decorate Apple TreeI'll try two describe two different approaches to this problem. A more intuitive solution. We are asked to output the number of colors for all kk, let's reverse the problem and count the maximum kk for all possible number of colors cc. We can see that if we a junction is happy then all junctions in its subtree are also happy. So we're interested in selecting some set of junctions so that their subtrees are disjoint and have no more than cc leaves, and we want to maximize the total size of these subtrees. This can be done greedily from the root: if a subtree is small enough, take it all, in the other case go to its children instead. We can see that a subtree is in the answer set for all cc not less than the size of the subtree and less than the size of the parent's subtree. We can easily compute this range for all junction in one deep-first search and sum the answer on these segments. A more professional solution. Note that a junction can be happy only when the number of colors is at least the number of leaves in it. The rule is that this is the only condition needed: indeed, if we color the leaves cyclically in the order of Euler tour, all such junctions will be happy. So the answer for the number of colors is simply the number of junctions that have at most cc leaves in the subtree Both solutions can be implemented in O(n)O(n).Author, preparation: KAN. 1056E - Check TranscriptionThe solution builds on one key observation.Suppose we know the length of r0r0. Then, since the number of '0' and '1' is fixed and the length of the resulting string is also fixed, we know the length of r1r1 (or know, that there is no integer-sized r1r1 possible).So let's bruteforce the length of r0r0, calculate the length of r1r1 and then check whether the corresponding substrings of tt are equal (so r0r0 and r1r1 can be defined correctly).Sounds like O(|s||t|)O(|s||t|) (since the number of candidates is ≤|t|≤|t| and check can be done in |s||s|, for example with hashes)? Haha, it is O(|t|)O(|t|).First, notice that it is not exactly important whether we bruteforce length of r0r0 or r1r1 — one of them defines the other one.So suppose we are bruteforcing over the letter with larger number of occurrences in pattern string ss.Let's denote it's number of occurrences as cc, this way, clearly, there are at most |t|c|t|c candidates. And each candidate is checked in |s||s|. So the whole time is |t|c|s||t|c|s|Since we used the more frequent letter, c≥|s|2c≥|s|2. And hence |t|c|s|≤2|t||t|c|s|≤2|t|.Authors: MikeMirzayanov, cdkrot, preparation: cdkrot. 1056F - Write The ContestFirstly, if we fix some set of problems to solve, it's always optimal to solve them from the hardest one to the easiest one. That implies a solution which processes all problems and decides which of them will be solved in sorted order.Secondly, suppose Polycarp doesn't train at all, and for some fixed set of kk problems it will take him 10k+m10k+m minutes, where 10k10k is the time spent on watching the series, and mm is the time spent on actually solving the problems. If Polycarp would raise his skill to ss before solving all the problems, then it would take him 10k+ms10k+ms minutes to solve the same set of problems in the same order. So if we fix a set of problems and compute mm for it, it's easy to see that if Polycarp trains for tt minutes, then it will take him 10k+m1+Ct+t10k+m1+Ct+t minutes to train and solve all the problems. This function f(t)=10k+m1+Ct+tf(t)=10k+m1+Ct+t can be minimized with ternary search or some pen and paper work.This function also gives us the following: among two sets of problems with equal total score and equal number of problems it's optimal to choose the set having smaller value of mm. So we can write a knapsack-like dynamic programming: dpx,kdpx,k — the smallest possible value of mm for a set of kk problems with total score xx. After computing these dynamic programming values, for a given pair (x,k)(x,k) it's easy to check if the time required to obtain this result does not exceed TT: just minimize the function f(t)=10k+dpx,k1+Ct+tf(t)=10k+dpx,k1+Ct+t.Author, preparation: Neon. 1056G - Take MetroThere were a variety of approaches to this problem. In all of them you first have to note that there are only n2n2 different positions describes as pairs (station, TmodnTmodn). Now if you manually perform several first steps to make Tmodn=0Tmodn=0, you will have to perform T/nT/n large steps, each of them is to have nn rides with T=nT=n, T=n−1T=n−1, ..., T=1T=1. If you compute for each station the station you will end up after a large step, you will get a functional graph where you will easily find the answer, computing a period and a pre-period. The question is how to get the graph. The first approach is to be strong and code a persistent treap (or any other persistent data structure that supports split and merge). This approach is O(nlog(n))O(nlog⁡(n)). The second approach is... to rely that the cycle is not large and compute all large tests in a straightforward way. This also works fast, but we don't have a proof for that. Author, preparation: KAN. 1056H - Detect RobotsThe solution is sqrt decomposition. Let's divide the rides into two groups: with length greater than RR and with length smaller than RR.Now let's reformulate the problem a bit: for each pair of paths you have to check the following: for each aa and bb that appear in this order in both paths, the next crossroads after aa should be same in both paths. Now it's easy to check this condition for a pair of paths from the second set in a straightforward way.Now iterate through a path from the first set and any other set. Let's first the last common crossroads in the paths. Now when you iterate through all common points, it is easy to check the aforementioned condition.Choosing R=O(n−−√)R=O(n), the solution can be implemented in O(nn−−√)O(nn).Author KAN, preparation: KAN, 300iq.Huge thanks to cdkrot and 300iq for discussing the problems and general invaluable help in preparation!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63461",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1056\\s*H"
          },
          "content_length": 8544
        }
      ],
      "code_examples": [
        {
          "title": "Mail.Ru Cup 2018 Round 3 Editorial - Codeforces - Code 1",
          "code": "for (int i = k; i > 0; --i) {\n   if (s > 0) s -= i;\n   else s += i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63461",
          "author": "jiangly"
        },
        {
          "title": "Mail.Ru Cup 2018 Round 3 Editorial - Codeforces - Code 2",
          "code": "for (int i = k; i > 0; --i) {\n   if (s > 0) s -= i;\n   else s += i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63461",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 300000, \"t\");\n    inf.readEoln();\n\n    int total_n = 0;\n    int total_q = 0;\n    int total_k = 0;\n\n    for (int test_case = 1; test_case <= t; ++test_case) {\n        int n = inf.readInt(1, 300000, \"n\");\n        inf.readEoln();\n\n        total_n += n;\n        ensuref(total_n <= 300000, \"Total n over all test cases is %d, which exceeds 300000\", total_n);\n\n        int q = inf.readInt(1, 300000, \"q\");\n        inf.readEoln();\n\n        total_q += q;\n        ensuref(total_q <= 300000, \"Total q over all test cases is %d, which exceeds 300000\", total_q);\n\n        for (int i = 0; i < q; ++i) {\n\n            int k = inf.readInt(2, n, \"k\");\n\n            total_k += k;\n            ensuref(total_k <= 300000, \"Total sum of k over all rides is %d, which exceeds 300000\", total_k);\n\n            inf.readSpace();\n\n            vector<int> c = inf.readInts(k, 1, n);\n            inf.readEoln();\n\n            set<int> c_set(c.begin(), c.end());\n            ensuref((int)c_set.size() == k, \"All c_i in a ride must be distinct, but only %d unique values found\", (int)c_set.size());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 300000, \"t\");\n    inf.readEoln();\n\n    int total_n = 0;\n    int total_q = 0;\n    int total_k = 0;\n\n    for (int test_case = 1; test_case <= t; ++test_case) {\n        int n = inf.readInt(1, 300000, \"n\");\n        inf.readEoln();\n\n        total_n += n;\n        ensuref(total_n <= 300000, \"Total n over all test cases is %d, which exceeds 300000\", total_n);\n\n        int q = inf.readInt(1, 300000, \"q\");\n        inf.readEoln();\n\n        total_q += q;\n        ensuref(total_q <= 300000, \"Total q over all test cases is %d, which exceeds 300000\", total_q);\n\n        for (int i = 0; i < q; ++i) {\n\n            int k = inf.readInt(2, n, \"k\");\n\n            total_k += k;\n            ensuref(total_k <= 300000, \"Total sum of k over all rides is %d, which exceeds 300000\", total_k);\n\n            inf.readSpace();\n\n            vector<int> c = inf.readInts(k, 1, n);\n            inf.readEoln();\n\n            set<int> c_set(c.begin(), c.end());\n            ensuref((int)c_set.size() == k, \"All c_i in a ride must be distinct, but only %d unique values found\", (int)c_set.size());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 300000, \"t\");\n    inf.readEoln();\n\n    int total_n = 0;\n    int total_q = 0;\n    int total_k = 0;\n\n    for (int test_case = 1; test_case <= t; ++test_case) {\n        int n = inf.readInt(1, 300000, \"n\");\n        inf.readEoln();\n\n        total_n += n;\n        ensuref(total_n <= 300000, \"Total n over all test cases is %d, which exceeds 300000\", total_n);\n\n        int q = inf.readInt(1, 300000, \"q\");\n        inf.readEoln();\n\n        total_q += q;\n        ensuref(total_q <= 300000, \"Total q over all test cases is %d, which exceeds 300000\", total_q);\n\n        for (int i = 0; i < q; ++i) {\n\n            int k = inf.readInt(2, n, \"k\");\n\n            total_k += k;\n            ensuref(total_k <= 300000, \"Total sum of k over all rides is %d, which exceeds 300000\", total_k);\n\n            inf.readSpace();\n\n            vector<int> c = inf.readInts(k, 1, n);\n            inf.readEoln();\n\n            set<int> c_set(c.begin(), c.end());\n            ensuref((int)c_set.size() == k, \"All c_i in a ride must be distinct, but only %d unique values found\", (int)c_set.size());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int t = inf.readInt(); // Read the number of test cases\n\n    for (int testCase = 1; testCase <= t; ++testCase) {\n        string juryAns = ans.readToken(); // Read the jury's answer for the test case\n        string userAns = ouf.readToken(); // Read the contestant's answer for the test case\n\n        // Convert both answers to lowercase for case-insensitive comparison\n        string juryAnsLower = juryAns;\n        transform(juryAnsLower.begin(), juryAnsLower.end(), juryAnsLower.begin(), ::tolower);\n\n        string userAnsLower = userAns;\n        transform(userAnsLower.begin(), userAnsLower.end(), userAnsLower.begin(), ::tolower);\n\n        // Check if the jury's answer is valid\n        if (juryAnsLower != \"robot\" && juryAnsLower != \"human\") {\n            quitf(_fail, \"Jury output contains invalid word '%s' in test case %d\", juryAns.c_str(), testCase);\n        }\n        // Check if the contestant's answer is valid\n        if (userAnsLower != \"robot\" && userAnsLower != \"human\") {\n            quitf(_wa, \"Invalid output '%s' in test case %d\", userAns.c_str(), testCase);\n        }\n        // Compare the contestant's answer with the jury's answer\n        if (juryAnsLower != userAnsLower) {\n            quitf(_wa, \"Wrong answer on test case %d: expected '%s', found '%s'\", testCase, juryAns.c_str(), userAns.c_str());\n        }\n    }\n\n    // Check for any extra output in the contestant's output\n    if (!ouf.seekEof()) {\n        quitf(_wa, \"Extra data in the output after test cases\");\n    }\n\n    quitf(_ok, \"%d test cases passed\", t);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate test case for \"robot\" type\nvoid generate_robot_test_case(int n, int q) {\n    // Build a random tree of n nodes\n    vector<int> parent(n + 1);\n    for (int i = 2; i <= n; ++i) {\n        // Parent of node i is random between 1 and i-1\n        parent[i] = rnd.next(1, i - 1);\n    }\n    // Build the adjacency list for the tree\n    vector<vector<int>> adj(n + 1);\n    for (int i = 2; i <= n; ++i) {\n        int u = i, v = parent[i];\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    // Now generate q rides, making sure sum of k ≤ 300000\n    int total_k = 0;\n    for (int i = 0; i < q; ++i) {\n        if (total_k >= 300000) break; // Exceeding sum of k limit, stop generating rides\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        while (b == a) b = rnd.next(1, n);\n        // Find the path from a to b\n        vector<int> path;\n        vector<int> visited(n + 1, 0);\n        function<bool(int, int)> dfs = [&](int u, int p) {\n            path.push_back(u);\n            visited[u] = 1;\n            if (u == b) return true;\n            for (int v : adj[u]) {\n                if (v != p && !visited[v]) {\n                    if (dfs(v, u)) return true;\n                }\n            }\n            path.pop_back();\n            return false;\n        };\n        path.clear();\n        dfs(a, -1);\n        total_k += path.size();\n        printf(\"%d\", (int)path.size());\n        for (int node : path) {\n            printf(\" %d\", node);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Function to generate test case for \"human\" type\nvoid generate_human_test_case(int n, int q) {\n    // Build a ring (cycle) of n nodes\n    vector<vector<int>> adj(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        int u = i;\n        int v = (i % n) + 1; // Next node, with wrap-around\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    // Now generate q rides\n    int total_k = 0;\n    for (int i = 0; i < q; ++i) {\n        if (total_k >= 300000) break; // Exceeding sum of k limit, stop generating rides\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        while (b == a) b = rnd.next(1, n);\n        vector<int> path;\n        if (i % 2 == 0) {\n            // Clockwise path from a to b\n            int u = a;\n            while (true) {\n                path.push_back(u);\n                if (u == b) break;\n                u = u % n + 1; // Move to next node\n            }\n        } else {\n            // Counter-clockwise path from a to b\n            int u = a;\n            while (true) {\n                path.push_back(u);\n                if (u == b) break;\n                u = (u - 2 + n) % n + 1; // Move to previous node\n            }\n        }\n        total_k += path.size();\n        printf(\"%d\", (int)path.size());\n        for (int node : path) {\n            printf(\" %d\", node);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of crossroads\n    int q = opt<int>(\"q\"); // Number of rides\n    string type = opt<string>(\"type\", \"robot\"); // Test case type: \"robot\" or \"human\"\n\n    // Output the test case\n    printf(\"1\\n\"); // t = 1\n    printf(\"%d\\n\", n);\n    printf(\"%d\\n\", q);\n\n    if (type == \"robot\") {\n        generate_robot_test_case(n, q);\n    } else if (type == \"human\") {\n        generate_human_test_case(n, q);\n    } else {\n        // Default to \"robot\" if type is unrecognized\n        generate_robot_test_case(n, q);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate test case for \"robot\" type\nvoid generate_robot_test_case(int n, int q) {\n    // Build a random tree of n nodes\n    vector<int> parent(n + 1);\n    for (int i = 2; i <= n; ++i) {\n        // Parent of node i is random between 1 and i-1\n        parent[i] = rnd.next(1, i - 1);\n    }\n    // Build the adjacency list for the tree\n    vector<vector<int>> adj(n + 1);\n    for (int i = 2; i <= n; ++i) {\n        int u = i, v = parent[i];\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    // Now generate q rides, making sure sum of k ≤ 300000\n    int total_k = 0;\n    for (int i = 0; i < q; ++i) {\n        if (total_k >= 300000) break; // Exceeding sum of k limit, stop generating rides\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        while (b == a) b = rnd.next(1, n);\n        // Find the path from a to b\n        vector<int> path;\n        vector<int> visited(n + 1, 0);\n        function<bool(int, int)> dfs = [&](int u, int p) {\n            path.push_back(u);\n            visited[u] = 1;\n            if (u == b) return true;\n            for (int v : adj[u]) {\n                if (v != p && !visited[v]) {\n                    if (dfs(v, u)) return true;\n                }\n            }\n            path.pop_back();\n            return false;\n        };\n        path.clear();\n        dfs(a, -1);\n        total_k += path.size();\n        printf(\"%d\", (int)path.size());\n        for (int node : path) {\n            printf(\" %d\", node);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Function to generate test case for \"human\" type\nvoid generate_human_test_case(int n, int q) {\n    // Build a ring (cycle) of n nodes\n    vector<vector<int>> adj(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        int u = i;\n        int v = (i % n) + 1; // Next node, with wrap-around\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    // Now generate q rides\n    int total_k = 0;\n    for (int i = 0; i < q; ++i) {\n        if (total_k >= 300000) break; // Exceeding sum of k limit, stop generating rides\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        while (b == a) b = rnd.next(1, n);\n        vector<int> path;\n        if (i % 2 == 0) {\n            // Clockwise path from a to b\n            int u = a;\n            while (true) {\n                path.push_back(u);\n                if (u == b) break;\n                u = u % n + 1; // Move to next node\n            }\n        } else {\n            // Counter-clockwise path from a to b\n            int u = a;\n            while (true) {\n                path.push_back(u);\n                if (u == b) break;\n                u = (u - 2 + n) % n + 1; // Move to previous node\n            }\n        }\n        total_k += path.size();\n        printf(\"%d\", (int)path.size());\n        for (int node : path) {\n            printf(\" %d\", node);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of crossroads\n    int q = opt<int>(\"q\"); // Number of rides\n    string type = opt<string>(\"type\", \"robot\"); // Test case type: \"robot\" or \"human\"\n\n    // Output the test case\n    printf(\"1\\n\"); // t = 1\n    printf(\"%d\\n\", n);\n    printf(\"%d\\n\", q);\n\n    if (type == \"robot\") {\n        generate_robot_test_case(n, q);\n    } else if (type == \"human\") {\n        generate_human_test_case(n, q);\n    } else {\n        // Default to \"robot\" if type is unrecognized\n        generate_robot_test_case(n, q);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -q 2 -type robot\n./gen -n 5 -q 2 -type human\n\n./gen -n 10 -q 3 -type robot\n./gen -n 10 -q 3 -type human\n\n./gen -n 20 -q 5 -type robot\n./gen -n 20 -q 5 -type human\n\n./gen -n 50 -q 10 -type robot\n./gen -n 50 -q 10 -type human\n\n./gen -n 100 -q 20 -type robot\n./gen -n 100 -q 20 -type human\n\n./gen -n 200 -q 40 -type robot\n./gen -n 200 -q 40 -type human\n\n./gen -n 500 -q 100 -type robot\n./gen -n 500 -q 100 -type human\n\n./gen -n 1000 -q 200 -type robot\n./gen -n 1000 -q 200 -type human\n\n./gen -n 2000 -q 400 -type robot\n./gen -n 2000 -q 400 -type human\n\n./gen -n 5000 -q 1000 -type robot\n./gen -n 5000 -q 1000 -type human\n\n./gen -n 10000 -q 2000 -type robot\n./gen -n 10000 -q 2000 -type human\n\n./gen -n 20000 -q 4000 -type robot\n./gen -n 20000 -q 4000 -type human\n\n./gen -n 50000 -q 5000 -type robot\n./gen -n 50000 -q 5000 -type human\n\n./gen -n 100000 -q 10000 -type robot\n./gen -n 100000 -q 10000 -type human\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:11:57.398249",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1059/A",
      "title": "A. Cashier",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers nn, LL and aa (0≤n≤1050≤n≤105, 1≤L≤1091≤L≤109, 1≤a≤L1≤a≤L).The ii-th of the next nn lines contains two integers titi and lili (0≤ti≤L−10≤ti≤L−1, 1≤li≤L1≤li≤L). It is guaranteed that ti+li≤ti+1ti+li≤ti+1 and tn+ln≤Ltn+ln≤L.",
      "output_spec": "OutputOutput one integer  — the maximum number of breaks.",
      "sample_tests": "ExamplesInputCopy2 11 30 11 1OutputCopy3InputCopy0 5 2OutputCopy2InputCopy1 3 21 2OutputCopy0",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers nn, LL and aa (0≤n≤1050≤n≤105, 1≤L≤1091≤L≤109, 1≤a≤L1≤a≤L).The ii-th of the next nn lines contains two integers titi and lili (0≤ti≤L−10≤ti≤L−1, 1≤li≤L1≤li≤L). It is guaranteed that ti+li≤ti+1ti+li≤ti+1 and tn+ln≤Ltn+ln≤L.\n\nOutputOutput one integer  — the maximum number of breaks.\n\nInputCopy2 11 30 11 1OutputCopy3InputCopy0 5 2OutputCopy2InputCopy1 3 21 2OutputCopy0\n\nInputCopy2 11 30 11 1\n\nOutputCopy3\n\nInputCopy0 5 2\n\nOutputCopy2\n\nInputCopy1 3 21 2\n\nOutputCopy0\n\nNoteIn the first sample Vasya can take 33 breaks starting after 22, 55 and 88 minutes after the beginning of the day.In the second sample Vasya can take 22 breaks starting after 00 and 22 minutes after the beginning of the day.In the third sample Vasya can't take any breaks.",
      "solutions": [
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces",
          "content": "Hello!Codeforces Round #514 (Div. 2) will start tomorrow, October 05, 17:35 (UTC+3). This round will be rated for the second division (with rating lower than 2100).Many thanks to KAN for his help with the problems and round coordination, Aleks5d and Um_nik for testing this round, and MikeMirzayanov for his awesome Codeforces and Polygon platforms.There will be 5 problems for 2 hours. The scoring distribution will be announced later.UPD: the scoring distribution will be 500-1000-1500-2000-2500UPD2: Congratulations to the winners! Div. 2: 1. qingczha 2. PaidySung 3. Hyperbolic 4. memopaper 5. rekuBoth divisions: 1. Radewoosh 2. qingczha 3. natsugiri 4. nuip 5. PaidySungUPD3: editorialGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62212",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces",
          "content": "1059A - Cashier Tutorial1059A - CashierThere are only n+1n+1 possible segments of time when Vasya can take breaks: between the consecutive clients, before the first client, and after the last client. If the length of the ii-th such segment is ss, Vasya may take at most ⌊sa⌋⌊sa⌋ breaks, so we just sum those values over the n+1n+1 possible segments. Time complexity is O(n)O(n). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}1059B - Forgery Tutorial1059B - ForgeryEach empty cell forbids to put a pen into every neighbor. Also, the border of the grid is forbidden. Let's mark all the forbidden cells. Now we have to check if for each filled cell there is at least one non-forbidden neighbor. Time complexity is O(nm)O(nm). Code#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}1059C - Sequence Transformation Tutorial1059C - Sequence TransformationThe answers for n≤3n≤3 are given in the samples. Now suppose that n≥4n≥4. The maximum result must have the earliest appearance of an integer different from 11. If n≥4n≥4, the earliest integer that may appear is 22. So initially we must remove all odd integers and for each of them append 11 to the answer. But now the rest of the answer is simply the answer for ⌊n2⌋⌊n2⌋ multiplied by 22. That gives us an O(n)O(n) solution. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}1059D - Nature Reserve Tutorial1059D - Nature ReserveIf there are both positive and negative yiyi, the answer is −1−1. Now assume that yi>0yi>0. Key observation: the answer can be binary searched. How to check if there is a valid circle with radius RR? Firstly, the center of such circle is on the line y=Ry=R. Every point must be not farther than RR from the center. It means that the center is inside or on the boundary of all circles (pi,R)(pi,R). The intersection of every such circle with y=Ry=R creates a segment (possibly empty). If the intersection of all such segments is non-empty, there exists some valid circle. Total complexity is O(nlogC)O(nlog⁡C). There is also an O(nlogn)O(nlog⁡n) solution, but it's much harder to implement. Code#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}1059E - Split the Tree Tutorial1059E - Split the TreeThere are two solutions. Both of them find the answer for each subtree in dfs: firstly for children, then for the vertex itself. In both solutions, we firstly calculate for each vertex how far up a vertical path starting at this vertex may go. It can be done with binary lifting in O(nlogn)O(nlog⁡n).Now let's describe the first solution. Let dpidpi be the answer for the subtree of the ii-th vertex. Let dp_sumidp_sumi be the sum of dpjdpj where jj is a child of ii. Suppose we want to include the ii-th vertex in the path starting at some vertex jj. Let {vk}{vk} be the set of vertices on the path between ii and jj. Then the answer for ii in this case equals 1+∑vk(dp_sumvk−dpvk)1+∑vk(dp_sumvk−dpvk) (if we assume that initially dpi=0dpi=0). So we need to calculate the minimum such value for all jj in the subtree of ii, for which we can create a path from jj to ii. Let's build a segment tree over the Euler tour of the tree. After processing vertex ii, we add dp_sumi−dpidp_sumi−dpi on the segment that corresponds to the subtree of ii. If after processing the vertex there are some vertices in it's subtree, for which there can be a vertical path to ii, but there cannot be a vertical path to pipi, we set the value at the corresponding position in the Euler tour to ∞∞.The second solution is much simpler. When calculating the answers, in case of tie let's choose the answer where the path going through the root of the subtree may go further. Then the answers can be updated greedily.Both solutions work in O(nlogn)O(nlog⁡n). Code (first solution)#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n} Code (second solution)#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62238",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1059\\s*A"
          },
          "content_length": 11434
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 1",
          "code": "Score distribution !!??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 2",
          "code": "Score distribution !!??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 3",
          "code": "h = abs(y - r); sqrt( r * r - h * h )  ---> WA4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 4",
          "code": "sqrt( 2*r*y - y*y) - AC !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 5",
          "code": "sqrt(A * A - B * B) = sqrt((A - B) * (A + B)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 6",
          "code": "1 1 1 2 2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 7",
          "code": "1 1 1 2 2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 8",
          "code": "r * r - (y - r) * (y - r)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 9",
          "code": "y * (2 * r - y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 10",
          "code": "r*r - (r-y)*(r-y) = (r + (r-y)) * (r - (r-y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 11",
          "code": "r*r - (r-y)*(r-y) = (r + (r-y)) * (r - (r-y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 12",
          "code": "sqrt((r + (r-y)) * (r - (r-y))) \n= sqrt(r+(r-y)) * sqrt(r - (r-y)) \n= sqrt(2*r-y) * sqrt(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 13",
          "code": "sqrt((r + (r-y)) * (r - (r-y))) \n= sqrt(r+(r-y)) * sqrt(r - (r-y)) \n= sqrt(2*r-y) * sqrt(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "int seq[maxn]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "floor(n/ K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "floor(n / GCD) - floor(n / M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "sum[vertex]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "sum[current_vertex] - sum[stack[position]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "int n;\ncin >> n;\ncout << n << ' ' << n << ' ' << n+1 << endl;\nfor (int i = 1; i <= n; i++) cout << 1 << \" \\n\"[i==n];\nfor (int i = 2; i <= n/2; i++) cout << i-1 << ' ';\nfor (int i = n/2+1; i <= n; i++) cout << n/2 << \" \\n\"[i==n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    long long L = inf.readLong(1LL, 1000000000LL, \"L\");\n    inf.readSpace();\n    long long a = inf.readLong(1LL, L, \"a\");\n    inf.readEoln();\n\n    long long previous_end_time = 0;\n    for (int i = 0; i < n; ++i) {\n        long long t_i = inf.readLong(0LL, L - 1LL, \"t_i\");\n        inf.readSpace();\n        long long l_i = inf.readLong(1LL, L, \"l_i\");\n        inf.readEoln();\n\n        ensuref(t_i >= previous_end_time, \n            \"Customer %d arrives before previous customer's service ends\", i + 1);\n\n        previous_end_time = t_i + l_i;\n        ensuref(previous_end_time <= L, \n            \"Service of customer %d ends after the day ends\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    long long L = inf.readLong(1LL, 1000000000LL, \"L\");\n    inf.readSpace();\n    long long a = inf.readLong(1LL, L, \"a\");\n    inf.readEoln();\n\n    long long previous_end_time = 0;\n    for (int i = 0; i < n; ++i) {\n        long long t_i = inf.readLong(0LL, L - 1LL, \"t_i\");\n        inf.readSpace();\n        long long l_i = inf.readLong(1LL, L, \"l_i\");\n        inf.readEoln();\n\n        ensuref(t_i >= previous_end_time, \n            \"Customer %d arrives before previous customer's service ends\", i + 1);\n\n        previous_end_time = t_i + l_i;\n        ensuref(previous_end_time <= L, \n            \"Service of customer %d ends after the day ends\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    long long L = inf.readLong(1LL, 1000000000LL, \"L\");\n    inf.readSpace();\n    long long a = inf.readLong(1LL, L, \"a\");\n    inf.readEoln();\n\n    long long previous_end_time = 0;\n    for (int i = 0; i < n; ++i) {\n        long long t_i = inf.readLong(0LL, L - 1LL, \"t_i\");\n        inf.readSpace();\n        long long l_i = inf.readLong(1LL, L, \"l_i\");\n        inf.readEoln();\n\n        ensuref(t_i >= previous_end_time, \n            \"Customer %d arrives before previous customer's service ends\", i + 1);\n\n        previous_end_time = t_i + l_i;\n        ensuref(previous_end_time <= L, \n            \"Service of customer %d ends after the day ends\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    long long L = opt<long long>(\"L\");\n    int a = opt<int>(\"a\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> t;\n    vector<long long> l;\n    vector<long long> gaps;\n\n    if (type == \"no_customers\") {\n        n = 0;\n        // No customers\n    } else if (type == \"full_day_busy\") {\n        // Customers fill up the entire day\n        n = 1;\n        t.push_back(0);\n        l.push_back(L);\n    } else if (type == \"random\") {\n        // Generate random customers with random gaps\n        t.resize(n);\n        l.assign(n, 1); // l_i = 1\n        // total_time = n + total_gap_time <= L\n        long long total_gap_time = L - n;\n        if (total_gap_time < 0) total_gap_time = 0;\n        vector<long long> separators;\n        separators.push_back(0);\n        separators.push_back(total_gap_time);\n        for(int i = 0; i < n-1; ++i){\n            separators.push_back(rnd.next(0LL, total_gap_time));\n        }\n        sort(separators.begin(), separators.end());\n        gaps.resize(n+1);\n        for(int i = 0; i < n; ++i){\n            gaps[i] = separators[i+1] - separators[i];\n        }\n        gaps[n] = 0; // Last gap\n        // Build t_i\n        long long time = gaps[0];\n        for(int i = 0; i < n; ++i){\n            t[i] = time;\n            time += l[i] + gaps[i+1];\n        }\n    } else if (type == \"max_breaks\") {\n        // Maximize gaps to maximize breaks\n        t.resize(n);\n        l.assign(n, 1); // l_i = 1\n        long long total_gap_time = L - n;\n        gaps.resize(n+1);\n        gaps[0] = total_gap_time; // All gap before first customer\n        for(int i = 1; i <= n; ++i){\n            gaps[i] = 0;\n        }\n        // Build t_i\n        long long time = gaps[0];\n        for(int i = 0; i < n; ++i){\n            t[i] = time;\n            time += l[i] + gaps[i+1];\n        }\n    } else if (type == \"min_breaks\") {\n        // Minimize gaps to minimize breaks\n        t.resize(n);\n        l.resize(n);\n        long long time = 0;\n        // Distribute L equally among l_i\n        long long base_l_i = L / n;\n        long long remaining = L % n;\n        for(int i = 0; i < n; ++i){\n            l[i] = base_l_i;\n            if(i < remaining){\n                l[i]++;\n            }\n            t[i] = time;\n            time += l[i];\n        }\n    } else if (type == \"edge_cases\") {\n        // Edge cases with t_i at 0 or L - 1\n        n = 2;\n        t.push_back(0);\n        l.push_back(1);\n        t.push_back(L - 1);\n        l.push_back(1);\n        // Ensure t_i + l_i <= L\n        if(t[1] + l[1] > L){\n            l[1] = L - t[1];\n        }\n    }\n\n    // Output n, L, a\n    printf(\"%d %lld %d\\n\", n, L, a);\n\n    // Output t_i and l_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", t[i], l[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    long long L = opt<long long>(\"L\");\n    int a = opt<int>(\"a\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> t;\n    vector<long long> l;\n    vector<long long> gaps;\n\n    if (type == \"no_customers\") {\n        n = 0;\n        // No customers\n    } else if (type == \"full_day_busy\") {\n        // Customers fill up the entire day\n        n = 1;\n        t.push_back(0);\n        l.push_back(L);\n    } else if (type == \"random\") {\n        // Generate random customers with random gaps\n        t.resize(n);\n        l.assign(n, 1); // l_i = 1\n        // total_time = n + total_gap_time <= L\n        long long total_gap_time = L - n;\n        if (total_gap_time < 0) total_gap_time = 0;\n        vector<long long> separators;\n        separators.push_back(0);\n        separators.push_back(total_gap_time);\n        for(int i = 0; i < n-1; ++i){\n            separators.push_back(rnd.next(0LL, total_gap_time));\n        }\n        sort(separators.begin(), separators.end());\n        gaps.resize(n+1);\n        for(int i = 0; i < n; ++i){\n            gaps[i] = separators[i+1] - separators[i];\n        }\n        gaps[n] = 0; // Last gap\n        // Build t_i\n        long long time = gaps[0];\n        for(int i = 0; i < n; ++i){\n            t[i] = time;\n            time += l[i] + gaps[i+1];\n        }\n    } else if (type == \"max_breaks\") {\n        // Maximize gaps to maximize breaks\n        t.resize(n);\n        l.assign(n, 1); // l_i = 1\n        long long total_gap_time = L - n;\n        gaps.resize(n+1);\n        gaps[0] = total_gap_time; // All gap before first customer\n        for(int i = 1; i <= n; ++i){\n            gaps[i] = 0;\n        }\n        // Build t_i\n        long long time = gaps[0];\n        for(int i = 0; i < n; ++i){\n            t[i] = time;\n            time += l[i] + gaps[i+1];\n        }\n    } else if (type == \"min_breaks\") {\n        // Minimize gaps to minimize breaks\n        t.resize(n);\n        l.resize(n);\n        long long time = 0;\n        // Distribute L equally among l_i\n        long long base_l_i = L / n;\n        long long remaining = L % n;\n        for(int i = 0; i < n; ++i){\n            l[i] = base_l_i;\n            if(i < remaining){\n                l[i]++;\n            }\n            t[i] = time;\n            time += l[i];\n        }\n    } else if (type == \"edge_cases\") {\n        // Edge cases with t_i at 0 or L - 1\n        n = 2;\n        t.push_back(0);\n        l.push_back(1);\n        t.push_back(L - 1);\n        l.push_back(1);\n        // Ensure t_i + l_i <= L\n        if(t[1] + l[1] > L){\n            l[1] = L - t[1];\n        }\n    }\n\n    // Output n, L, a\n    printf(\"%d %lld %d\\n\", n, L, a);\n\n    // Output t_i and l_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", t[i], l[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# No customers\n./gen -n 0 -L 100 -a 1 -type no_customers\n./gen -n 0 -L 1000 -a 10 -type no_customers\n\n# Full day busy\n./gen -n 1 -L 100 -a 1 -type full_day_busy\n./gen -n 1 -L 1000000 -a 100 -type full_day_busy\n\n# Random test cases\n./gen -n 10 -L 100 -a 5 -type random\n./gen -n 100 -L 1000 -a 10 -type random\n./gen -n 1000 -L 100000 -a 100 -type random\n./gen -n 100000 -L 1000000000 -a 1000000 -type random\n\n# Maximize breaks\n./gen -n 1 -L 100 -a 1 -type max_breaks\n./gen -n 10 -L 1000 -a 5 -type max_breaks\n./gen -n 100 -L 10000 -a 10 -type max_breaks\n./gen -n 1000 -L 100000 -a 100 -type max_breaks\n\n# Minimize breaks\n./gen -n 1 -L 1 -a 1 -type min_breaks\n./gen -n 10 -L 100 -a 10 -type min_breaks\n./gen -n 100 -L 1000 -a 100 -type min_breaks\n./gen -n 1000 -L 100000 -a 1000 -type min_breaks\n\n# Edge cases\n./gen -n 2 -L 100 -a 1 -type edge_cases\n./gen -n 2 -L 1000000 -a 1000 -type edge_cases\n./gen -n 2 -L 1000000000 -a 1000000000 -type edge_cases\n\n# Test with a = L\n./gen -n 0 -L 100 -a 100 -type no_customers\n./gen -n 1 -L 100 -a 100 -type full_day_busy\n./gen -n 10 -L 1000 -a 1000 -type max_breaks\n./gen -n 100000 -L 1000000000 -a 1000000000 -type random\n\n# Test with a = 1\n./gen -n 100000 -L 1000000000 -a 1 -type random\n./gen -n 100000 -L 1000000000 -a 1 -type max_breaks\n./gen -n 100000 -L 1000000000 -a 1 -type min_breaks\n\n# Additional random tests\n./gen -n 50000 -L 500000000 -a 100000 -type random\n./gen -n 50000 -L 500000000 -a 100000 -type max_breaks\n./gen -n 50000 -L 500000000 -a 100000 -type min_breaks\n\n# Small L\n./gen -n 0 -L 1 -a 1 -type no_customers\n./gen -n 1 -L 1 -a 1 -type full_day_busy\n./gen -n 1 -L 1 -a 1 -type min_breaks\n\n# Maximum values\n./gen -n 100000 -L 1000000000 -a 1 -type max_breaks\n./gen -n 100000 -L 1000000000 -a 1000000000 -type min_breaks\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:11:59.532575",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1059/B",
      "title": "B. Forgery",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers nn and mm (3≤n,m≤10003≤n,m≤1000).Then nn lines follow, each contains mm characters. Each of the characters is either '.', representing an empty cell, or '#', representing an ink filled cell.",
      "output_spec": "OutputIf Andrey can forge the signature, output \"YES\". Otherwise output \"NO\".You can print each letter in any case (upper or lower).",
      "sample_tests": "ExamplesInputCopy3 3####.####OutputCopyYESInputCopy3 3#########OutputCopyNOInputCopy4 3############OutputCopyYESInputCopy5 7........#####..#.#.#..#####........OutputCopyYES",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two integers nn and mm (3≤n,m≤10003≤n,m≤1000).Then nn lines follow, each contains mm characters. Each of the characters is either '.', representing an empty cell, or '#', representing an ink filled cell.\n\nOutputIf Andrey can forge the signature, output \"YES\". Otherwise output \"NO\".You can print each letter in any case (upper or lower).\n\nInputCopy3 3####.####OutputCopyYESInputCopy3 3#########OutputCopyNOInputCopy4 3############OutputCopyYESInputCopy5 7........#####..#.#.#..#####........OutputCopyYES\n\nInputCopy3 3####.####\n\nOutputCopyYES\n\nInputCopy3 3#########\n\nOutputCopyNO\n\nInputCopy4 3############\n\nOutputCopyYES\n\nInputCopy5 7........#####..#.#.#..#####........\n\nOutputCopyYES\n\nNoteIn the first sample Andrey can paint the border of the square with the center in (2,2)(2,2).In the second sample the signature is impossible to forge.In the third sample Andrey can paint the borders of the squares with the centers in (2,2)(2,2) and (3,2)(3,2):   we have a clear paper: ............  use the pen with center at (2,2)(2,2). ####.####...  use the pen with center at (3,2)(3,2). ############ In the fourth sample Andrey can paint the borders of the squares with the centers in (3,3)(3,3) and (3,5)(3,5).",
      "solutions": [
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces",
          "content": "Hello!Codeforces Round #514 (Div. 2) will start tomorrow, October 05, 17:35 (UTC+3). This round will be rated for the second division (with rating lower than 2100).Many thanks to KAN for his help with the problems and round coordination, Aleks5d and Um_nik for testing this round, and MikeMirzayanov for his awesome Codeforces and Polygon platforms.There will be 5 problems for 2 hours. The scoring distribution will be announced later.UPD: the scoring distribution will be 500-1000-1500-2000-2500UPD2: Congratulations to the winners! Div. 2: 1. qingczha 2. PaidySung 3. Hyperbolic 4. memopaper 5. rekuBoth divisions: 1. Radewoosh 2. qingczha 3. natsugiri 4. nuip 5. PaidySungUPD3: editorialGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62212",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces",
          "content": "1059A - Cashier Tutorial1059A - CashierThere are only n+1n+1 possible segments of time when Vasya can take breaks: between the consecutive clients, before the first client, and after the last client. If the length of the ii-th such segment is ss, Vasya may take at most ⌊sa⌋⌊sa⌋ breaks, so we just sum those values over the n+1n+1 possible segments. Time complexity is O(n)O(n). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}1059B - Forgery Tutorial1059B - ForgeryEach empty cell forbids to put a pen into every neighbor. Also, the border of the grid is forbidden. Let's mark all the forbidden cells. Now we have to check if for each filled cell there is at least one non-forbidden neighbor. Time complexity is O(nm)O(nm). Code#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}1059C - Sequence Transformation Tutorial1059C - Sequence TransformationThe answers for n≤3n≤3 are given in the samples. Now suppose that n≥4n≥4. The maximum result must have the earliest appearance of an integer different from 11. If n≥4n≥4, the earliest integer that may appear is 22. So initially we must remove all odd integers and for each of them append 11 to the answer. But now the rest of the answer is simply the answer for ⌊n2⌋⌊n2⌋ multiplied by 22. That gives us an O(n)O(n) solution. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}1059D - Nature Reserve Tutorial1059D - Nature ReserveIf there are both positive and negative yiyi, the answer is −1−1. Now assume that yi>0yi>0. Key observation: the answer can be binary searched. How to check if there is a valid circle with radius RR? Firstly, the center of such circle is on the line y=Ry=R. Every point must be not farther than RR from the center. It means that the center is inside or on the boundary of all circles (pi,R)(pi,R). The intersection of every such circle with y=Ry=R creates a segment (possibly empty). If the intersection of all such segments is non-empty, there exists some valid circle. Total complexity is O(nlogC)O(nlog⁡C). There is also an O(nlogn)O(nlog⁡n) solution, but it's much harder to implement. Code#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}1059E - Split the Tree Tutorial1059E - Split the TreeThere are two solutions. Both of them find the answer for each subtree in dfs: firstly for children, then for the vertex itself. In both solutions, we firstly calculate for each vertex how far up a vertical path starting at this vertex may go. It can be done with binary lifting in O(nlogn)O(nlog⁡n).Now let's describe the first solution. Let dpidpi be the answer for the subtree of the ii-th vertex. Let dp_sumidp_sumi be the sum of dpjdpj where jj is a child of ii. Suppose we want to include the ii-th vertex in the path starting at some vertex jj. Let {vk}{vk} be the set of vertices on the path between ii and jj. Then the answer for ii in this case equals 1+∑vk(dp_sumvk−dpvk)1+∑vk(dp_sumvk−dpvk) (if we assume that initially dpi=0dpi=0). So we need to calculate the minimum such value for all jj in the subtree of ii, for which we can create a path from jj to ii. Let's build a segment tree over the Euler tour of the tree. After processing vertex ii, we add dp_sumi−dpidp_sumi−dpi on the segment that corresponds to the subtree of ii. If after processing the vertex there are some vertices in it's subtree, for which there can be a vertical path to ii, but there cannot be a vertical path to pipi, we set the value at the corresponding position in the Euler tour to ∞∞.The second solution is much simpler. When calculating the answers, in case of tie let's choose the answer where the path going through the root of the subtree may go further. Then the answers can be updated greedily.Both solutions work in O(nlogn)O(nlog⁡n). Code (first solution)#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n} Code (second solution)#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62238",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1059\\s*B"
          },
          "content_length": 11434
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 1",
          "code": "Score distribution !!??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 2",
          "code": "Score distribution !!??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 3",
          "code": "h = abs(y - r); sqrt( r * r - h * h )  ---> WA4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 4",
          "code": "sqrt( 2*r*y - y*y) - AC !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 5",
          "code": "sqrt(A * A - B * B) = sqrt((A - B) * (A + B)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 6",
          "code": "1 1 1 2 2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 7",
          "code": "1 1 1 2 2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 8",
          "code": "r * r - (y - r) * (y - r)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 9",
          "code": "y * (2 * r - y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 10",
          "code": "r*r - (r-y)*(r-y) = (r + (r-y)) * (r - (r-y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 11",
          "code": "r*r - (r-y)*(r-y) = (r + (r-y)) * (r - (r-y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 12",
          "code": "sqrt((r + (r-y)) * (r - (r-y))) \n= sqrt(r+(r-y)) * sqrt(r - (r-y)) \n= sqrt(2*r-y) * sqrt(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 13",
          "code": "sqrt((r + (r-y)) * (r - (r-y))) \n= sqrt(r+(r-y)) * sqrt(r - (r-y)) \n= sqrt(2*r-y) * sqrt(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "int seq[maxn]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "floor(n/ K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "floor(n / GCD) - floor(n / M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "sum[vertex]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "sum[current_vertex] - sum[stack[position]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "int n;\ncin >> n;\ncout << n << ' ' << n << ' ' << n+1 << endl;\nfor (int i = 1; i <= n; i++) cout << 1 << \" \\n\"[i==n];\nfor (int i = 2; i <= n/2; i++) cout << i-1 << ' ';\nfor (int i = n/2+1; i <= n; i++) cout << n/2 << \" \\n\"[i==n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[\\\\.\\\\#]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[\\\\.\\\\#]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[\\\\.\\\\#]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"empty\") {\n        // The grid is already initialized with '.'\n    } else if (type == \"full\") {\n        // Set all cells to '#'\n        for(int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n    } else if (type == \"random\") {\n        // Randomly fill with '#' and '.'\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(2) ? '#' : '.';\n    } else if (type == \"minimal_possible\") {\n        // Generate a minimal possible grid (n = m = 3)\n        assert(n == 3 && m == 3);\n        grid[0] = \"###\";\n        grid[1] = \"#.#\";\n        grid[2] = \"###\";\n    } else if (type == \"minimal_impossible\") {\n        // Generate a minimal impossible grid (n = m = 3)\n        assert(n == 3 && m == 3);\n        grid[0] = \"###\";\n        grid[1] = \"###\";\n        grid[2] = \"###\";\n    } else if (type == \"maximal_possible\") {\n        // Generate a maximal possible grid\n        for (int i = 1; i < n - 1; ++i)\n            for (int j = 1; j < m - 1; ++j) {\n                // Place the pen at (i,j)\n                for (int dx = -1; dx <= 1; ++dx)\n                    for (int dy = -1; dy <=1; ++dy)\n                        if (!(dx == 0 && dy == 0)) {\n                            int x = i + dx;\n                            int y = j + dy;\n                            if (x >= 0 && x < n && y >= 0 && y < m)\n                                grid[x][y] = '#';\n                        }\n            }\n    } else if (type == \"maximal_impossible\") {\n        // Set all cells to '#'\n        for(int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n    } else if (type == \"impossible_corner\") {\n        // Place '#' in a corner that cannot be covered\n        grid[0][0] = '#';\n    } else if (type == \"possible_multiple_pens\") {\n        // Generate a grid requiring multiple pens\n        for(int i = 1; i < n - 1; i += 2)\n            for(int j = 1; j < m - 1; j += 2)\n                for (int dx = -1; dx <= 1; ++dx)\n                    for (int dy = -1; dy <=1; ++dy)\n                        if (!(dx == 0 && dy == 0)) {\n                            int x = i + dx;\n                            int y = j + dy;\n                            grid[x][y] = '#';\n                        }\n    } else if (type == \"impossible_single_uncovered\") {\n        // Generate a grid almost possible but with one impossible cell\n        for (int i = 1; i < n - 1; ++i)\n            for (int j = 1; j < m - 1; ++j)\n                for (int dx = -1; dx <= 1; ++dx)\n                    for (int dy = -1; dy <=1; ++dy)\n                        if (!(dx == 0 && dy == 0)) {\n                            int x = i + dx;\n                            int y = j + dy;\n                            grid[x][y] = '#';\n                        }\n        // Place a '#' in a corner\n        grid[0][0] = '#';\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"empty\") {\n        // The grid is already initialized with '.'\n    } else if (type == \"full\") {\n        // Set all cells to '#'\n        for(int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n    } else if (type == \"random\") {\n        // Randomly fill with '#' and '.'\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(2) ? '#' : '.';\n    } else if (type == \"minimal_possible\") {\n        // Generate a minimal possible grid (n = m = 3)\n        assert(n == 3 && m == 3);\n        grid[0] = \"###\";\n        grid[1] = \"#.#\";\n        grid[2] = \"###\";\n    } else if (type == \"minimal_impossible\") {\n        // Generate a minimal impossible grid (n = m = 3)\n        assert(n == 3 && m == 3);\n        grid[0] = \"###\";\n        grid[1] = \"###\";\n        grid[2] = \"###\";\n    } else if (type == \"maximal_possible\") {\n        // Generate a maximal possible grid\n        for (int i = 1; i < n - 1; ++i)\n            for (int j = 1; j < m - 1; ++j) {\n                // Place the pen at (i,j)\n                for (int dx = -1; dx <= 1; ++dx)\n                    for (int dy = -1; dy <=1; ++dy)\n                        if (!(dx == 0 && dy == 0)) {\n                            int x = i + dx;\n                            int y = j + dy;\n                            if (x >= 0 && x < n && y >= 0 && y < m)\n                                grid[x][y] = '#';\n                        }\n            }\n    } else if (type == \"maximal_impossible\") {\n        // Set all cells to '#'\n        for(int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n    } else if (type == \"impossible_corner\") {\n        // Place '#' in a corner that cannot be covered\n        grid[0][0] = '#';\n    } else if (type == \"possible_multiple_pens\") {\n        // Generate a grid requiring multiple pens\n        for(int i = 1; i < n - 1; i += 2)\n            for(int j = 1; j < m - 1; j += 2)\n                for (int dx = -1; dx <= 1; ++dx)\n                    for (int dy = -1; dy <=1; ++dy)\n                        if (!(dx == 0 && dy == 0)) {\n                            int x = i + dx;\n                            int y = j + dy;\n                            grid[x][y] = '#';\n                        }\n    } else if (type == \"impossible_single_uncovered\") {\n        // Generate a grid almost possible but with one impossible cell\n        for (int i = 1; i < n - 1; ++i)\n            for (int j = 1; j < m - 1; ++j)\n                for (int dx = -1; dx <= 1; ++dx)\n                    for (int dy = -1; dy <=1; ++dy)\n                        if (!(dx == 0 && dy == 0)) {\n                            int x = i + dx;\n                            int y = j + dy;\n                            grid[x][y] = '#';\n                        }\n        // Place a '#' in a corner\n        grid[0][0] = '#';\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 3 -type minimal_possible\n./gen -n 3 -m 3 -type minimal_impossible\n./gen -n 3 -m 3 -type empty\n./gen -n 3 -m 3 -type full\n\n./gen -n 5 -m 5 -type possible_multiple_pens\n./gen -n 5 -m 5 -type impossible_single_uncovered\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type maximal_possible\n\n./gen -n 1000 -m 1000 -type maximal_possible\n./gen -n 1000 -m 1000 -type maximal_impossible\n\n./gen -n 1000 -m 1000 -type impossible_corner\n\n./gen -n 1000 -m 1000 -type possible_multiple_pens\n./gen -n 1000 -m 1000 -type impossible_single_uncovered\n\n./gen -n 500 -m 500 -type random\n./gen -n 500 -m 500 -type random\n\n./gen -n 998 -m 999 -type maximal_possible\n\n./gen -n 999 -m 1000 -type maximal_impossible\n\n./gen -n 3 -m 1000 -type maximal_possible\n./gen -n 1000 -m 3 -type maximal_possible\n\n./gen -n 3 -m 1000 -type maximal_impossible\n./gen -n 1000 -m 3 -type maximal_impossible\n\n./gen -n 3 -m 3 -type impossible_corner\n\n./gen -n 100 -m 100 -type random\n./gen -n 200 -m 200 -type random\n./gen -n 300 -m 300 -type random\n./gen -n 500 -m 500 -type random\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 998 -m 1000 -type impossible_single_uncovered\n./gen -n 1000 -m 998 -type impossible_single_uncovered\n./gen -n 3 -m 4 -type empty\n./gen -n 4 -m 3 -type full\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:01.826331",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1059/C",
      "title": "C. Sequence Transformation",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and only line of input contains one integer nn (1≤n≤1061≤n≤106).",
      "output_spec": "OutputOutput nn integers  — the lexicographically maximum result of the transformation.",
      "sample_tests": "ExamplesInputCopy3OutputCopy1 1 3 InputCopy2OutputCopy1 2 InputCopy1OutputCopy1",
      "description": "C. Sequence Transformation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first and only line of input contains one integer nn (1≤n≤1061≤n≤106).\n\nOutputOutput nn integers  — the lexicographically maximum result of the transformation.\n\nInputCopy3OutputCopy1 1 3 InputCopy2OutputCopy1 2 InputCopy1OutputCopy1\n\nOutputCopy1 1 3\n\nOutputCopy1 2\n\nOutputCopy1\n\nNoteIn the first sample the answer may be achieved this way:  Append GCD(1,2,3)=1(1,2,3)=1, remove 22.  Append GCD(1,3)=1(1,3)=1, remove 11.  Append GCD(3)=3(3)=3, remove 33. We get the sequence [1,1,3][1,1,3] as the result.",
      "solutions": [
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces",
          "content": "Hello!Codeforces Round #514 (Div. 2) will start tomorrow, October 05, 17:35 (UTC+3). This round will be rated for the second division (with rating lower than 2100).Many thanks to KAN for his help with the problems and round coordination, Aleks5d and Um_nik for testing this round, and MikeMirzayanov for his awesome Codeforces and Polygon platforms.There will be 5 problems for 2 hours. The scoring distribution will be announced later.UPD: the scoring distribution will be 500-1000-1500-2000-2500UPD2: Congratulations to the winners! Div. 2: 1. qingczha 2. PaidySung 3. Hyperbolic 4. memopaper 5. rekuBoth divisions: 1. Radewoosh 2. qingczha 3. natsugiri 4. nuip 5. PaidySungUPD3: editorialGood luck!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/62212",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces",
          "content": "1059A - Cashier Tutorial1059A - CashierThere are only n+1n+1 possible segments of time when Vasya can take breaks: between the consecutive clients, before the first client, and after the last client. If the length of the ii-th such segment is ss, Vasya may take at most ⌊sa⌋⌊sa⌋ breaks, so we just sum those values over the n+1n+1 possible segments. Time complexity is O(n)O(n). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}1059B - Forgery Tutorial1059B - ForgeryEach empty cell forbids to put a pen into every neighbor. Also, the border of the grid is forbidden. Let's mark all the forbidden cells. Now we have to check if for each filled cell there is at least one non-forbidden neighbor. Time complexity is O(nm)O(nm). Code#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}1059C - Sequence Transformation Tutorial1059C - Sequence TransformationThe answers for n≤3n≤3 are given in the samples. Now suppose that n≥4n≥4. The maximum result must have the earliest appearance of an integer different from 11. If n≥4n≥4, the earliest integer that may appear is 22. So initially we must remove all odd integers and for each of them append 11 to the answer. But now the rest of the answer is simply the answer for ⌊n2⌋⌊n2⌋ multiplied by 22. That gives us an O(n)O(n) solution. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}1059D - Nature Reserve Tutorial1059D - Nature ReserveIf there are both positive and negative yiyi, the answer is −1−1. Now assume that yi>0yi>0. Key observation: the answer can be binary searched. How to check if there is a valid circle with radius RR? Firstly, the center of such circle is on the line y=Ry=R. Every point must be not farther than RR from the center. It means that the center is inside or on the boundary of all circles (pi,R)(pi,R). The intersection of every such circle with y=Ry=R creates a segment (possibly empty). If the intersection of all such segments is non-empty, there exists some valid circle. Total complexity is O(nlogC)O(nlog⁡C). There is also an O(nlogn)O(nlog⁡n) solution, but it's much harder to implement. Code#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}1059E - Split the Tree Tutorial1059E - Split the TreeThere are two solutions. Both of them find the answer for each subtree in dfs: firstly for children, then for the vertex itself. In both solutions, we firstly calculate for each vertex how far up a vertical path starting at this vertex may go. It can be done with binary lifting in O(nlogn)O(nlog⁡n).Now let's describe the first solution. Let dpidpi be the answer for the subtree of the ii-th vertex. Let dp_sumidp_sumi be the sum of dpjdpj where jj is a child of ii. Suppose we want to include the ii-th vertex in the path starting at some vertex jj. Let {vk}{vk} be the set of vertices on the path between ii and jj. Then the answer for ii in this case equals 1+∑vk(dp_sumvk−dpvk)1+∑vk(dp_sumvk−dpvk) (if we assume that initially dpi=0dpi=0). So we need to calculate the minimum such value for all jj in the subtree of ii, for which we can create a path from jj to ii. Let's build a segment tree over the Euler tour of the tree. After processing vertex ii, we add dp_sumi−dpidp_sumi−dpi on the segment that corresponds to the subtree of ii. If after processing the vertex there are some vertices in it's subtree, for which there can be a vertical path to ii, but there cannot be a vertical path to pipi, we set the value at the corresponding position in the Euler tour to ∞∞.The second solution is much simpler. When calculating the answers, in case of tie let's choose the answer where the path going through the root of the subtree may go further. Then the answers can be updated greedily.Both solutions work in O(nlogn)O(nlog⁡n). Code (first solution)#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n} Code (second solution)#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/62238",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1059\\s*C"
          },
          "content_length": 11434
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 1",
          "code": "Score distribution !!??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 2",
          "code": "Score distribution !!??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 3",
          "code": "h = abs(y - r); sqrt( r * r - h * h )  ---> WA4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 4",
          "code": "sqrt( 2*r*y - y*y) - AC !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 5",
          "code": "sqrt(A * A - B * B) = sqrt((A - B) * (A + B)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 6",
          "code": "1 1 1 2 2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 7",
          "code": "1 1 1 2 2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 8",
          "code": "r * r - (y - r) * (y - r)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 9",
          "code": "y * (2 * r - y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 10",
          "code": "r*r - (r-y)*(r-y) = (r + (r-y)) * (r - (r-y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 11",
          "code": "r*r - (r-y)*(r-y) = (r + (r-y)) * (r - (r-y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 12",
          "code": "sqrt((r + (r-y)) * (r - (r-y))) \n= sqrt(r+(r-y)) * sqrt(r - (r-y)) \n= sqrt(2*r-y) * sqrt(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 13",
          "code": "sqrt((r + (r-y)) * (r - (r-y))) \n= sqrt(r+(r-y)) * sqrt(r - (r-y)) \n= sqrt(2*r-y) * sqrt(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "int seq[maxn]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "floor(n/ K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "floor(n / GCD) - floor(n / M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "sum[vertex]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "sum[current_vertex] - sum[stack[position]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "int n;\ncin >> n;\ncout << n << ' ' << n << ' ' << n+1 << endl;\nfor (int i = 1; i <= n; i++) cout << 1 << \" \\n\"[i==n];\nfor (int i = 2; i <= n/2; i++) cout << i-1 << ' ';\nfor (int i = n/2+1; i <= n; i++) cout << n/2 << \" \\n\"[i==n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n;\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"preset\") {\n        n = opt<int>(\"n\");\n    } else if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000000;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 100);\n    } else if (type == \"medium\") {\n        n = rnd.next(101, 1000);\n    } else if (type == \"large\") {\n        n = rnd.next(100001, 1000000);\n    } else if (type == \"even\") {\n        n = rnd.next(1, 500000) * 2;\n    } else if (type == \"odd\") {\n        n = rnd.next(1, 500000) * 2 - 1;\n    } else if (type == \"special\") {\n        // Any special value to test specific cases, for example:\n        n = rnd.next(1, 1000000);\n        // Here you can set n to any specific value that might cause mistakes in contestants' solutions\n    } else {\n        // Default to random\n        n = rnd.next(1, 1000000);\n    }\n\n    // Ensure n is within the constraints\n    n = max(1, min(n, 1000000));\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n;\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"preset\") {\n        n = opt<int>(\"n\");\n    } else if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000000;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 100);\n    } else if (type == \"medium\") {\n        n = rnd.next(101, 1000);\n    } else if (type == \"large\") {\n        n = rnd.next(100001, 1000000);\n    } else if (type == \"even\") {\n        n = rnd.next(1, 500000) * 2;\n    } else if (type == \"odd\") {\n        n = rnd.next(1, 500000) * 2 - 1;\n    } else if (type == \"special\") {\n        // Any special value to test specific cases, for example:\n        n = rnd.next(1, 1000000);\n        // Here you can set n to any specific value that might cause mistakes in contestants' solutions\n    } else {\n        // Default to random\n        n = rnd.next(1, 1000000);\n    }\n\n    // Ensure n is within the constraints\n    n = max(1, min(n, 1000000));\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type small\n./gen -type medium\n./gen -type large\n./gen -type even\n./gen -type odd\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type preset -n 1\n./gen -type preset -n 2\n./gen -type preset -n 3\n./gen -type preset -n 4\n./gen -type preset -n 5\n./gen -type preset -n 10\n./gen -type preset -n 50\n./gen -type preset -n 100\n./gen -type preset -n 500\n./gen -type preset -n 1000\n./gen -type preset -n 5000\n./gen -type preset -n 10000\n./gen -type preset -n 50000\n./gen -type preset -n 100000\n./gen -type preset -n 500000\n./gen -type preset -n 999999\n./gen -type preset -n 1000000\n\n./gen -type special\n./gen -type special\n./gen -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:03.928757",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1059/D",
      "title": "D. Nature Reserve",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer nn (1≤n≤1051≤n≤105) — the number of animals. Each of the next nn lines contains two integers xixi, yiyi (−107≤xi,yi≤107−107≤xi,yi≤107) — the coordinates of the ii-th animal's lair. It is guaranteed that yi≠0yi≠0. No two lairs coincide.",
      "output_spec": "OutputIf the reserve cannot be built, print −1−1. Otherwise print the minimum radius. Your answer will be accepted if absolute or relative error does not exceed 10−610−6.Formally, let your answer be aa, and the jury's answer be bb. Your answer is considered correct if |a−b|max(1,|b|)≤10−6|a−b|max(1,|b|)≤10−6.",
      "sample_tests": "ExamplesInputCopy10 1OutputCopy0.5InputCopy30 10 20 -3OutputCopy-1InputCopy20 11 1OutputCopy0.625",
      "description": "D. Nature Reserve\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one integer nn (1≤n≤1051≤n≤105) — the number of animals. Each of the next nn lines contains two integers xixi, yiyi (−107≤xi,yi≤107−107≤xi,yi≤107) — the coordinates of the ii-th animal's lair. It is guaranteed that yi≠0yi≠0. No two lairs coincide.\n\nOutputIf the reserve cannot be built, print −1−1. Otherwise print the minimum radius. Your answer will be accepted if absolute or relative error does not exceed 10−610−6.Formally, let your answer be aa, and the jury's answer be bb. Your answer is considered correct if |a−b|max(1,|b|)≤10−6|a−b|max(1,|b|)≤10−6.\n\nInputCopy10 1OutputCopy0.5InputCopy30 10 20 -3OutputCopy-1InputCopy20 11 1OutputCopy0.625\n\nInputCopy10 1\n\nOutputCopy0.5\n\nInputCopy30 10 20 -3\n\nOutputCopy-1\n\nInputCopy20 11 1\n\nOutputCopy0.625\n\nNoteIn the first sample it is optimal to build the reserve with the radius equal to 0.50.5 and the center in (0, 0.5)(0, 0.5).In the second sample it is impossible to build a reserve.In the third sample it is optimal to build the reserve with the radius equal to 5858 and the center in (12, 58)(12, 58).",
      "solutions": [
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces",
          "content": "Hello!Codeforces Round #514 (Div. 2) will start tomorrow, October 05, 17:35 (UTC+3). This round will be rated for the second division (with rating lower than 2100).Many thanks to KAN for his help with the problems and round coordination, Aleks5d and Um_nik for testing this round, and MikeMirzayanov for his awesome Codeforces and Polygon platforms.There will be 5 problems for 2 hours. The scoring distribution will be announced later.UPD: the scoring distribution will be 500-1000-1500-2000-2500UPD2: Congratulations to the winners! Div. 2: 1. qingczha 2. PaidySung 3. Hyperbolic 4. memopaper 5. rekuBoth divisions: 1. Radewoosh 2. qingczha 3. natsugiri 4. nuip 5. PaidySungUPD3: editorialGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62212",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces",
          "content": "1059A - Cashier Tutorial1059A - CashierThere are only n+1n+1 possible segments of time when Vasya can take breaks: between the consecutive clients, before the first client, and after the last client. If the length of the ii-th such segment is ss, Vasya may take at most ⌊sa⌋⌊sa⌋ breaks, so we just sum those values over the n+1n+1 possible segments. Time complexity is O(n)O(n). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}1059B - Forgery Tutorial1059B - ForgeryEach empty cell forbids to put a pen into every neighbor. Also, the border of the grid is forbidden. Let's mark all the forbidden cells. Now we have to check if for each filled cell there is at least one non-forbidden neighbor. Time complexity is O(nm)O(nm). Code#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}1059C - Sequence Transformation Tutorial1059C - Sequence TransformationThe answers for n≤3n≤3 are given in the samples. Now suppose that n≥4n≥4. The maximum result must have the earliest appearance of an integer different from 11. If n≥4n≥4, the earliest integer that may appear is 22. So initially we must remove all odd integers and for each of them append 11 to the answer. But now the rest of the answer is simply the answer for ⌊n2⌋⌊n2⌋ multiplied by 22. That gives us an O(n)O(n) solution. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}1059D - Nature Reserve Tutorial1059D - Nature ReserveIf there are both positive and negative yiyi, the answer is −1−1. Now assume that yi>0yi>0. Key observation: the answer can be binary searched. How to check if there is a valid circle with radius RR? Firstly, the center of such circle is on the line y=Ry=R. Every point must be not farther than RR from the center. It means that the center is inside or on the boundary of all circles (pi,R)(pi,R). The intersection of every such circle with y=Ry=R creates a segment (possibly empty). If the intersection of all such segments is non-empty, there exists some valid circle. Total complexity is O(nlogC)O(nlog⁡C). There is also an O(nlogn)O(nlog⁡n) solution, but it's much harder to implement. Code#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}1059E - Split the Tree Tutorial1059E - Split the TreeThere are two solutions. Both of them find the answer for each subtree in dfs: firstly for children, then for the vertex itself. In both solutions, we firstly calculate for each vertex how far up a vertical path starting at this vertex may go. It can be done with binary lifting in O(nlogn)O(nlog⁡n).Now let's describe the first solution. Let dpidpi be the answer for the subtree of the ii-th vertex. Let dp_sumidp_sumi be the sum of dpjdpj where jj is a child of ii. Suppose we want to include the ii-th vertex in the path starting at some vertex jj. Let {vk}{vk} be the set of vertices on the path between ii and jj. Then the answer for ii in this case equals 1+∑vk(dp_sumvk−dpvk)1+∑vk(dp_sumvk−dpvk) (if we assume that initially dpi=0dpi=0). So we need to calculate the minimum such value for all jj in the subtree of ii, for which we can create a path from jj to ii. Let's build a segment tree over the Euler tour of the tree. After processing vertex ii, we add dp_sumi−dpidp_sumi−dpi on the segment that corresponds to the subtree of ii. If after processing the vertex there are some vertices in it's subtree, for which there can be a vertical path to ii, but there cannot be a vertical path to pipi, we set the value at the corresponding position in the Euler tour to ∞∞.The second solution is much simpler. When calculating the answers, in case of tie let's choose the answer where the path going through the root of the subtree may go further. Then the answers can be updated greedily.Both solutions work in O(nlogn)O(nlog⁡n). Code (first solution)#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n} Code (second solution)#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62238",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1059\\s*D"
          },
          "content_length": 11434
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 1",
          "code": "Score distribution !!??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 2",
          "code": "Score distribution !!??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 3",
          "code": "h = abs(y - r); sqrt( r * r - h * h )  ---> WA4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 4",
          "code": "sqrt( 2*r*y - y*y) - AC !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 5",
          "code": "sqrt(A * A - B * B) = sqrt((A - B) * (A + B)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 6",
          "code": "1 1 1 2 2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 7",
          "code": "1 1 1 2 2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 8",
          "code": "r * r - (y - r) * (y - r)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 9",
          "code": "y * (2 * r - y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 10",
          "code": "r*r - (r-y)*(r-y) = (r + (r-y)) * (r - (r-y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 11",
          "code": "r*r - (r-y)*(r-y) = (r + (r-y)) * (r - (r-y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 12",
          "code": "sqrt((r + (r-y)) * (r - (r-y))) \n= sqrt(r+(r-y)) * sqrt(r - (r-y)) \n= sqrt(2*r-y) * sqrt(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 13",
          "code": "sqrt((r + (r-y)) * (r - (r-y))) \n= sqrt(r+(r-y)) * sqrt(r - (r-y)) \n= sqrt(2*r-y) * sqrt(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "int seq[maxn]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "floor(n/ K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "floor(n / GCD) - floor(n / M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "sum[vertex]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "sum[current_vertex] - sum[stack[position]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "int n;\ncin >> n;\ncout << n << ' ' << n << ' ' << n+1 << endl;\nfor (int i = 1; i <= n; i++) cout << 1 << \" \\n\"[i==n];\nfor (int i = 2; i <= n/2; i++) cout << i-1 << ' ';\nfor (int i = n/2+1; i <= n; i++) cout << n/2 << \" \\n\"[i==n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    set<pair<int, int>> lairs;\n    for (int i = 0; i < n; ++i) {\n        int x_i = inf.readInt(-10000000, 10000000, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(-10000000, 10000000, \"y_i\");\n        ensuref(y_i != 0, \"y_i (animal %d) must not be zero\", i+1);\n        inf.readEoln();\n        pair<int, int> p = make_pair(x_i, y_i);\n        ensuref(lairs.find(p) == lairs.end(), \"No two lairs can be at the same coordinates, duplicate at lair %d\", i+1);\n        lairs.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    set<pair<int, int>> lairs;\n    for (int i = 0; i < n; ++i) {\n        int x_i = inf.readInt(-10000000, 10000000, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(-10000000, 10000000, \"y_i\");\n        ensuref(y_i != 0, \"y_i (animal %d) must not be zero\", i+1);\n        inf.readEoln();\n        pair<int, int> p = make_pair(x_i, y_i);\n        ensuref(lairs.find(p) == lairs.end(), \"No two lairs can be at the same coordinates, duplicate at lair %d\", i+1);\n        lairs.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    set<pair<int, int>> lairs;\n    for (int i = 0; i < n; ++i) {\n        int x_i = inf.readInt(-10000000, 10000000, \"x_i\");\n        inf.readSpace();\n        int y_i = inf.readInt(-10000000, 10000000, \"y_i\");\n        ensuref(y_i != 0, \"y_i (animal %d) must not be zero\", i+1);\n        inf.readEoln();\n        pair<int, int> p = make_pair(x_i, y_i);\n        ensuref(lairs.find(p) == lairs.end(), \"No two lairs can be at the same coordinates, duplicate at lair %d\", i+1);\n        lairs.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  We read n from inf, then read each of the n lairs (two integers each).\n  After consuming all input, we read the solution (jury's) answer from ans\n  and the contestant's output (ouf) as a token. If the jury's answer is\n  -1, we accept the contestant's output only if it's within 1e-6 of -1.\n  Otherwise, we check relative or absolute error versus the jury's answer.\n  |ans - out| / max(1, |ans|) <= 1e-6\n*/\n\nstatic const double EPS = 1e-6;\n\n// Tries to parse a string as a floating-point number.\n// Returns {true, value} on success, {false, 0.0} if it fails.\npair<bool, double> tryParseDouble(const string &s)\n{\n    try {\n        long double val = stold(s);\n        return {true, (double)val};\n    } catch(...) {\n        return {false, 0.0};\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Consume the entire problem input from inf to avoid blocking/timeout:\n    int n = inf.readInt();\n    for (int i = 0; i < n; i++) {\n        // Each lair is two integers, just read & ignore them here.\n        inf.readInt();\n        inf.readInt();\n    }\n\n    // Make sure the jury's answer file is not empty; read a double from ans.\n    if (ans.seekEof())\n        quitf(_fail, \"Jury's answer file is empty or missing the answer.\");\n\n    double juryVal = ans.readDouble();  // Read official answer (could be -1 or >= 0).\n\n    // Now read a single token from the contestant’s output.\n    // If the contestant’s output is empty, it's WA.\n    if (ouf.seekEof())\n        quitf(_wa, \"Contestant output is empty; expected a radius or -1.\");\n\n    string contestantStr = ouf.readToken();\n\n    // Attempt to parse the contestant's string as a double.\n    auto parsed = tryParseDouble(contestantStr);\n    if (!parsed.first)\n        quitf(_wa, \"Cannot parse \\\"%s\\\" as a floating-point number.\",\n              contestantStr.c_str());\n    double contestantVal = parsed.second;\n\n    // If the jury's answer is -1, the contestant must also be \"close\" to -1.\n    // We'll check absolute difference, though for -1 we could do the usual\n    // relative check as well.\n    if (fabs(juryVal + 1.0) < 1e-15) {\n        double diff = fabs(contestantVal + 1.0);\n        if (diff <= EPS)\n            quitf(_ok, \"Correct: both answers declare impossibility (within tolerance).\");\n        else\n            quitf(_wa, \"Expected -1, but got %.18g (diff = %.9g)\", contestantVal, diff);\n    }\n\n    // Otherwise, the jury's answer is not -1. The contestant should not print -1.\n    if (fabs(contestantVal + 1.0) < 1e-15)\n        quitf(_wa, \"Jury answered a valid radius, but contestant answered -1.\");\n\n    double diff = fabs(juryVal - contestantVal);\n    double base = max(1.0, fabs(juryVal));\n    if (diff <= EPS * base)\n        quitf(_ok, \"Correct within the relative/absolute error of 1e-6.\");\n    else\n        quitf(_wa, \"Wrong radius. Jury's=%.9f, contestant=%.9f, diff=%.9f, tolerance=%.9f.\",\n              juryVal, contestantVal, diff, EPS*base);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y = rnd.next(-10000000, 10000000);\n            while (y == 0)\n                y = rnd.next(-10000000, 10000000);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"all_above\") {\n        /* All points with y_i > 0 */\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y = rnd.next(1, 10000000);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"all_below\") {\n        /* All points with y_i < 0 */\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y = rnd.next(-10000000, -1);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"both_sides\") {\n        /* Points on both sides of the river */\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y;\n            if (i % 2 == 0)\n                y = rnd.next(1, 10000000);\n            else\n                y = rnd.next(-10000000, -1);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"impossible\") {\n        /* Create a case where it's impossible to build the reserve */\n        for (int i = 0; i < n / 2; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y = rnd.next(1, 10000000);\n            points.emplace_back(x, y);\n            points.emplace_back(x, -y);\n        }\n        if (n % 2 == 1) {\n            int x = rnd.next(-10000000, 10000000);\n            int y = rnd.next(1, 10000000);\n            points.emplace_back(x, y);\n        }\n        shuffle(points.begin(), points.end());\n    } else if (type == \"edge_case\") {\n        /* Points very close to the river */\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y;\n            do {\n                y = rnd.next(-10, 10);\n            } while (y == 0);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"clustered\") {\n        /* All points clustered together */\n        int x_center = rnd.next(-10000000, 10000000);\n        int y_center = rnd.next(-10000000, 10000000);\n        if (y_center == 0) y_center = 1;\n        for (int i = 0; i < n; ++i) {\n            int x = x_center + rnd.next(-10, 10);\n            int y = y_center + rnd.next(-10, 10);\n            if (y == 0) y = 1;\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"max_coordinates\") {\n        /* Points at the extreme coordinates */\n        for (int i = 0; i < n; ++i) {\n            int x = (i % 2 == 0) ? -10000000 : 10000000;\n            int y = (i % 2 == 0) ? -10000000 : 10000000;\n            if (y == 0) y = 1;\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"precision\") {\n        /* Points testing precision issues */\n        double R = rnd.next(1e6, 1e7);\n        double angle_increment = 2 * M_PI / n;\n        double centerX = 0; \n        double centerY = R + rnd.next(-10, 10);\n        for (int i = 0; i < n; ++i) {\n            double angle = i * angle_increment;\n            double x = centerX + R * cos(angle);\n            double y = centerY + R * sin(angle);\n            if (abs(y) < 1) y = (y >= 0) ? 1 : -1;\n            points.emplace_back((int)x, (int)y);\n        }\n    }\n\n    /* Ensure no duplicate points */\n    set<pair<int, int>> unique_points;\n    vector<pair<int, int>> final_points;\n    for (auto p : points) {\n        if (unique_points.count(p) == 0 && p.second != 0) {\n            unique_points.insert(p);\n            final_points.push_back(p);\n        }\n    }\n    while (final_points.size() < n) {\n        int x = rnd.next(-10000000, 10000000);\n        int y = rnd.next(-10000000, 10000000);\n        while (y == 0)\n            y = rnd.next(-10000000, 10000000);\n        if (unique_points.count({x, y}) == 0) {\n            unique_points.insert({x, y});\n            final_points.push_back({x, y});\n        }\n    }\n\n    /* Output */\n    printf(\"%d\\n\", n);\n    for (auto p : final_points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y = rnd.next(-10000000, 10000000);\n            while (y == 0)\n                y = rnd.next(-10000000, 10000000);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"all_above\") {\n        /* All points with y_i > 0 */\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y = rnd.next(1, 10000000);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"all_below\") {\n        /* All points with y_i < 0 */\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y = rnd.next(-10000000, -1);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"both_sides\") {\n        /* Points on both sides of the river */\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y;\n            if (i % 2 == 0)\n                y = rnd.next(1, 10000000);\n            else\n                y = rnd.next(-10000000, -1);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"impossible\") {\n        /* Create a case where it's impossible to build the reserve */\n        for (int i = 0; i < n / 2; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y = rnd.next(1, 10000000);\n            points.emplace_back(x, y);\n            points.emplace_back(x, -y);\n        }\n        if (n % 2 == 1) {\n            int x = rnd.next(-10000000, 10000000);\n            int y = rnd.next(1, 10000000);\n            points.emplace_back(x, y);\n        }\n        shuffle(points.begin(), points.end());\n    } else if (type == \"edge_case\") {\n        /* Points very close to the river */\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000000, 10000000);\n            int y;\n            do {\n                y = rnd.next(-10, 10);\n            } while (y == 0);\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"clustered\") {\n        /* All points clustered together */\n        int x_center = rnd.next(-10000000, 10000000);\n        int y_center = rnd.next(-10000000, 10000000);\n        if (y_center == 0) y_center = 1;\n        for (int i = 0; i < n; ++i) {\n            int x = x_center + rnd.next(-10, 10);\n            int y = y_center + rnd.next(-10, 10);\n            if (y == 0) y = 1;\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"max_coordinates\") {\n        /* Points at the extreme coordinates */\n        for (int i = 0; i < n; ++i) {\n            int x = (i % 2 == 0) ? -10000000 : 10000000;\n            int y = (i % 2 == 0) ? -10000000 : 10000000;\n            if (y == 0) y = 1;\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"precision\") {\n        /* Points testing precision issues */\n        double R = rnd.next(1e6, 1e7);\n        double angle_increment = 2 * M_PI / n;\n        double centerX = 0; \n        double centerY = R + rnd.next(-10, 10);\n        for (int i = 0; i < n; ++i) {\n            double angle = i * angle_increment;\n            double x = centerX + R * cos(angle);\n            double y = centerY + R * sin(angle);\n            if (abs(y) < 1) y = (y >= 0) ? 1 : -1;\n            points.emplace_back((int)x, (int)y);\n        }\n    }\n\n    /* Ensure no duplicate points */\n    set<pair<int, int>> unique_points;\n    vector<pair<int, int>> final_points;\n    for (auto p : points) {\n        if (unique_points.count(p) == 0 && p.second != 0) {\n            unique_points.insert(p);\n            final_points.push_back(p);\n        }\n    }\n    while (final_points.size() < n) {\n        int x = rnd.next(-10000000, 10000000);\n        int y = rnd.next(-10000000, 10000000);\n        while (y == 0)\n            y = rnd.next(-10000000, 10000000);\n        if (unique_points.count({x, y}) == 0) {\n            unique_points.insert({x, y});\n            final_points.push_back({x, y});\n        }\n    }\n\n    /* Output */\n    printf(\"%d\\n\", n);\n    for (auto p : final_points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_above\n./gen -n 1 -type all_below\n./gen -n 1 -type impossible\n./gen -n 1 -type edge_case\n\n./gen -n 2 -type random\n./gen -n 2 -type both_sides\n./gen -n 2 -type impossible\n./gen -n 2 -type clustered\n\n./gen -n 10 -type random\n./gen -n 10 -type edge_case\n./gen -n 10 -type impossible\n\n./gen -n 100 -type random\n./gen -n 100 -type all_above\n./gen -n 100 -type all_below\n./gen -n 100 -type both_sides\n./gen -n 100 -type impossible\n./gen -n 100 -type clustered\n./gen -n 100 -type edge_case\n\n./gen -n 1000 -type random\n./gen -n 1000 -type precision\n\n./gen -n 10000 -type random\n./gen -n 10000 -type impossible\n./gen -n 10000 -type edge_case\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_above\n./gen -n 100000 -type both_sides\n./gen -n 100000 -type impossible\n./gen -n 100000 -type precision\n\n./gen -n 99999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:05.920164",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1059/E",
      "title": "E. Split the Tree",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers nn, LL, SS (1≤n≤1051≤n≤105, 1≤L≤1051≤L≤105, 1≤S≤10181≤S≤1018) — the number of vertices, the maximum number of vertices in one path and the maximum sum in one path.The second line contains nn integers w1,w2,…,wnw1,w2,…,wn (1≤wi≤1091≤wi≤109) — the numbers in the vertices of the tree.The third line contains n−1n−1 integers p2,…,pnp2,…,pn (1≤pi<i1≤pi<i), where pipi is the parent of the ii-th vertex in the tree.",
      "output_spec": "OutputOutput one number  — the minimum number of vertical paths. If it is impossible to split the tree, output −1−1.",
      "sample_tests": "ExamplesInputCopy3 1 31 2 31 1OutputCopy3InputCopy3 3 61 2 31 1OutputCopy2InputCopy1 1 1000010001OutputCopy-1",
      "description": "E. Split the Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers nn, LL, SS (1≤n≤1051≤n≤105, 1≤L≤1051≤L≤105, 1≤S≤10181≤S≤1018) — the number of vertices, the maximum number of vertices in one path and the maximum sum in one path.The second line contains nn integers w1,w2,…,wnw1,w2,…,wn (1≤wi≤1091≤wi≤109) — the numbers in the vertices of the tree.The third line contains n−1n−1 integers p2,…,pnp2,…,pn (1≤pi<i1≤pi<i), where pipi is the parent of the ii-th vertex in the tree.\n\nOutputOutput one number  — the minimum number of vertical paths. If it is impossible to split the tree, output −1−1.\n\nInputCopy3 1 31 2 31 1OutputCopy3InputCopy3 3 61 2 31 1OutputCopy2InputCopy1 1 1000010001OutputCopy-1\n\nInputCopy3 1 31 2 31 1\n\nOutputCopy3\n\nInputCopy3 3 61 2 31 1\n\nOutputCopy2\n\nInputCopy1 1 1000010001\n\nOutputCopy-1\n\nNoteIn the first sample the tree is split into {1}, {2}, {3}{1}, {2}, {3}.In the second sample the tree is split into {1, 2}, {3}{1, 2}, {3} or {1, 3}, {2}{1, 3}, {2}.In the third sample it is impossible to split the tree.",
      "solutions": [
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces",
          "content": "Hello!Codeforces Round #514 (Div. 2) will start tomorrow, October 05, 17:35 (UTC+3). This round will be rated for the second division (with rating lower than 2100).Many thanks to KAN for his help with the problems and round coordination, Aleks5d and Um_nik for testing this round, and MikeMirzayanov for his awesome Codeforces and Polygon platforms.There will be 5 problems for 2 hours. The scoring distribution will be announced later.UPD: the scoring distribution will be 500-1000-1500-2000-2500UPD2: Congratulations to the winners! Div. 2: 1. qingczha 2. PaidySung 3. Hyperbolic 4. memopaper 5. rekuBoth divisions: 1. Radewoosh 2. qingczha 3. natsugiri 4. nuip 5. PaidySungUPD3: editorialGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62212",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 701
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces",
          "content": "1059A - Cashier Tutorial1059A - CashierThere are only n+1n+1 possible segments of time when Vasya can take breaks: between the consecutive clients, before the first client, and after the last client. If the length of the ii-th such segment is ss, Vasya may take at most ⌊sa⌋⌊sa⌋ breaks, so we just sum those values over the n+1n+1 possible segments. Time complexity is O(n)O(n). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}1059B - Forgery Tutorial1059B - ForgeryEach empty cell forbids to put a pen into every neighbor. Also, the border of the grid is forbidden. Let's mark all the forbidden cells. Now we have to check if for each filled cell there is at least one non-forbidden neighbor. Time complexity is O(nm)O(nm). Code#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}1059C - Sequence Transformation Tutorial1059C - Sequence TransformationThe answers for n≤3n≤3 are given in the samples. Now suppose that n≥4n≥4. The maximum result must have the earliest appearance of an integer different from 11. If n≥4n≥4, the earliest integer that may appear is 22. So initially we must remove all odd integers and for each of them append 11 to the answer. But now the rest of the answer is simply the answer for ⌊n2⌋⌊n2⌋ multiplied by 22. That gives us an O(n)O(n) solution. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}1059D - Nature Reserve Tutorial1059D - Nature ReserveIf there are both positive and negative yiyi, the answer is −1−1. Now assume that yi>0yi>0. Key observation: the answer can be binary searched. How to check if there is a valid circle with radius RR? Firstly, the center of such circle is on the line y=Ry=R. Every point must be not farther than RR from the center. It means that the center is inside or on the boundary of all circles (pi,R)(pi,R). The intersection of every such circle with y=Ry=R creates a segment (possibly empty). If the intersection of all such segments is non-empty, there exists some valid circle. Total complexity is O(nlogC)O(nlog⁡C). There is also an O(nlogn)O(nlog⁡n) solution, but it's much harder to implement. Code#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}1059E - Split the Tree Tutorial1059E - Split the TreeThere are two solutions. Both of them find the answer for each subtree in dfs: firstly for children, then for the vertex itself. In both solutions, we firstly calculate for each vertex how far up a vertical path starting at this vertex may go. It can be done with binary lifting in O(nlogn)O(nlog⁡n).Now let's describe the first solution. Let dpidpi be the answer for the subtree of the ii-th vertex. Let dp_sumidp_sumi be the sum of dpjdpj where jj is a child of ii. Suppose we want to include the ii-th vertex in the path starting at some vertex jj. Let {vk}{vk} be the set of vertices on the path between ii and jj. Then the answer for ii in this case equals 1+∑vk(dp_sumvk−dpvk)1+∑vk(dp_sumvk−dpvk) (if we assume that initially dpi=0dpi=0). So we need to calculate the minimum such value for all jj in the subtree of ii, for which we can create a path from jj to ii. Let's build a segment tree over the Euler tour of the tree. After processing vertex ii, we add dp_sumi−dpidp_sumi−dpi on the segment that corresponds to the subtree of ii. If after processing the vertex there are some vertices in it's subtree, for which there can be a vertical path to ii, but there cannot be a vertical path to pipi, we set the value at the corresponding position in the Euler tour to ∞∞.The second solution is much simpler. When calculating the answers, in case of tie let's choose the answer where the path going through the root of the subtree may go further. Then the answers can be updated greedily.Both solutions work in O(nlogn)O(nlog⁡n). Code (first solution)#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n} Code (second solution)#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62238",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1059\\s*E"
          },
          "content_length": 11434
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 1",
          "code": "Score distribution !!??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 2",
          "code": "Score distribution !!??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 3",
          "code": "h = abs(y - r); sqrt( r * r - h * h )  ---> WA4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 4",
          "code": "sqrt( 2*r*y - y*y) - AC !",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 5",
          "code": "sqrt(A * A - B * B) = sqrt((A - B) * (A + B)).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 6",
          "code": "1 1 1 2 2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 7",
          "code": "1 1 1 2 2 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 8",
          "code": "r * r - (y - r) * (y - r)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 9",
          "code": "y * (2 * r - y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 10",
          "code": "r*r - (r-y)*(r-y) = (r + (r-y)) * (r - (r-y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 11",
          "code": "r*r - (r-y)*(r-y) = (r + (r-y)) * (r - (r-y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 12",
          "code": "sqrt((r + (r-y)) * (r - (r-y))) \n= sqrt(r+(r-y)) * sqrt(r - (r-y)) \n= sqrt(2*r-y) * sqrt(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) - Codeforces - Code 13",
          "code": "sqrt((r + (r-y)) * (r - (r-y))) \n= sqrt(r+(r-y)) * sqrt(r - (r-y)) \n= sqrt(2*r-y) * sqrt(y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62212",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = (int)1e3 + 3;\n\nint n, m;\nchar a[maxn][maxn];\nbool can[maxn][maxn];\nvector<int> must_have[maxn][maxn];\n\ninline bool inside(int x, int y){\n\treturn x >= 0 && y >= 0 && x < n && y < m;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcan[i][j] = true;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tdo{\n\t\t\t\ta[i][j] = getc(stdin);\n\t\t\t}while(a[i][j] != '.' && a[i][j] != '#');\n\t\t\tfor(int dx = -1; dx <= 1; dx++)\n\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\t\t\tif(abs(dx) + abs(dy) == 0 || !inside(i + dx, j + dy))continue;\n\t\t\t\t\tif(a[i][j] == '.')can[i + dx][j + dy] = false;\n\t\t\t\t\telse if (i + dx != 0 && j + dy != 0 && i + dx != n - 1 && j + dy != m - 1)must_have[i][j].push_back((i + dx) * m + j + dy);\n\t\t\t\t}\n\t\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tbool good = false;\n\t\t\tif(a[i][j] == '.')continue;\n\t\t\tfor(int cand : must_have[i][j]){\n\t\t\t\tint x = cand/m, y = cand%m;\n\t\t\t\tgood |= can[x][y];\n\t\t\t}\n\t\t\tif(!good){printf(\"NO\"); return 0;}\n\t\t}\n\tprintf(\"YES\");\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 6;\n\nint seq[maxn];\nint ans[maxn];\nint ptr = 0;\n\nvoid solve(int n, int mul){\n\tif(n == 1){ans[ptr++] = mul; return;}\n\tif(n == 2){ans[ptr++] = mul; ans[ptr++] = mul * 2; return;}\n\tif(n == 3){ans[ptr++] = mul; ans[ptr++] = mul; ans[ptr++] = mul * 3; return;}\n\tfor(int i = 0; i < n; i++)if(seq[i]&1)ans[ptr++] = mul;\n\tfor(int i = 0; i < n/2; i++)seq[i] = seq[2*i + 1]/2;\n\tsolve(n/2, mul * 2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)seq[i] = i + 1;\n\tsolve(n, 1);\n\tfor(int i = 0; i < n; i++)printf(\"%d \", ans[i]);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double dbl;\n\nconst dbl eps = 1e-9;\n\ninline bool gt(const dbl & x, const dbl & y){\n\treturn x > y + eps;\n}\n\ninline bool lt(const dbl & x, const dbl & y){\n\treturn y > x + eps;\n}\n\ninline dbl safe_sqrt(const dbl & D){\n\treturn D < 0 ? 0 : sqrt(D);\n}\n\nstruct pt{\n\tdbl x, y;\n\tpt(){}\n\tpt(dbl a, dbl b):x(a), y(b){}\n};\n\n\nconst int N = 1e5 + 5;\nconst int STEPS = 150;\n\nint n;\npt p[N];\n\ninline bool can(dbl R){\n\tdbl l = -1e16 - 1, r = 1e16 + 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdbl b = -2 * p[i].x;\n\t\tdbl c = p[i].x * p[i].x + p[i].y * p[i].y - 2 * p[i].y * R;\n\t\tdbl D = b * b - 4 * c;\n\t\tif(lt(D, 0))\n\t\t\treturn false;\n\t\tD = safe_sqrt(D);\n\t\tdbl x1 = p[i].x - D/2, x2 = p[i].x + D/2;\n\t\tl = max(l, x1);\n\t\tr = min(r, x2);\n\t}\n\treturn !gt(l, r);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool has_positive = false, has_negative = false;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = pt(x, y);\n\t\tif(y > 0)has_positive = true;\n\t\telse has_negative = true;\n\t}\n\tif(has_positive && has_negative){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tif(has_negative){\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i].y = -p[i].y;\n\t}\n\tdbl L = 0, R = 1e16;\n\tstd::function<dbl(dbl, dbl)> get_mid;\n\tif(can(1)){\n\t\tR = 1;\n\t\tget_mid = [](dbl l, dbl r){return (l + r)/2.0;};\n\t}\n\telse{\n\t\tL = 1;\n\t\tget_mid = [](dbl l, dbl r){return sqrt(l * r);};\n\t}\n\tfor(int step = 0; step < STEPS; step++){\n\t\tdbl mid = get_mid(L, R);\n\t\tif(can(mid))\n\t\t\tR = mid;\n\t\telse\n\t\t\tL = mid;\n\t}\n\tcout.precision(16);\n\tcout << fixed << get_mid(L, R) << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nll t[4 * maxn];\nll t_add[4 * maxn];\nint cid = 0;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint p[maxn][lg];\nll dp[maxn];\nint id[maxn], rb[maxn];\nll dp_sum[maxn];\nvector<int> rm[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\tup[v] = v;\n\tid[v] = rb[v] = cid++;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\trm[up[v]].push_back(v);\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t\trb[v] = max(rb[v], rb[u]);\n\t}\n}\n\ninline void push(int v){\n\tt[2*v] += t_add[v];\n\tt[2*v + 1] += t_add[v];\n\tt_add[2*v] += t_add[v];\n\tt_add[2*v + 1] += t_add[v];\n\tt_add[v] = 0;\n}\n\nvoid build_tree(int v, int l, int r){\n\tt[v] = inf;\n\tif(l == r)\n\t\treturn;\n\tint mid = (l + r)/2;\n\tbuild_tree(2*v, l, mid);\n\tbuild_tree(2*v + 1, mid + 1, r);\n}\n\nll get_tree(int v, int l, int r, int ul, int ur){\n\tif(ul > ur)\n\t\treturn inf;\n\tif(l == ul && r == ur)\n\t\treturn t[v];\n\tpush(v);\n\tint mid = (l + r)/2;\n\treturn min(get_tree(2*v, l, mid, ul, min(ur, mid)), get_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur));\n}\n\nvoid set_tree(int v, int l, int r, int pos, ll val){\n\tif(l == r){\n\t\tt[v] = val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tif(pos <= mid)\n\t\tset_tree(2*v, l, mid, pos, val);\n\telse\n\t\tset_tree(2*v + 1, mid + 1, r, pos, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\nvoid add_tree(int v, int l, int r, int ul, int ur, ll val){\n\tif(ul > ur)return;\n\tif(l == ul && r == ur){\n\t\tt[v] += val;\n\t\tt_add[v] += val;\n\t\treturn;\n\t}\n\tpush(v);\n\tint mid = (l + r)/2;\n\tadd_tree(2*v, l, mid, ul, min(ur, mid), val);\n\tadd_tree(2*v + 1, mid + 1, r, max(ul, mid + 1), ur, val);\n\tt[v] = min(t[2*v], t[2*v + 1]);\n}\n\ninline void upd(int v){\n\tdp[v] = 1 + get_tree(1, 0, n - 1, id[v], rb[v]);\n}\n\ninline void add(int v){\n\tset_tree(1, 0, n - 1, id[v], 0);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], dp_sum[v] - dp[v]);\n}\n\ninline void remove(int v){\n\tset_tree(1, 0, n - 1, id[v], inf);\n}\n\nvoid solve(int v){\n\tfor(int u : down[v]){\n\t\tsolve(u);\n\t\tdp_sum[v] += dp[u];\n\t}\n\tadd(v);\n\tdp[v] = maxn;\n\tupd(v);\n\tadd_tree(1, 0, n - 1, id[v], rb[v], -dp[v]);\n\tfor(int u : rm[v])\n\t\tremove(u);\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tbuild_tree(1, 0, n - 1);\n\tsolve(0);\n\tprintf(\"%lld\", dp[0]);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nconst int lg = 20;\nconst ll inf = 1e18;\n\nint n, L;\nll S;\nint w[maxn];\nvector<int> down[maxn];\nll sum[maxn];\nint up[maxn];\nint h[maxn];\nint p[maxn][lg];\nint path[maxn];\n\ninline ll get_sum(int v){\n\treturn v == -1 ? 0 : sum[v];\n}\n\nvoid preprocess(int v, int pr = -1){\n\tsum[v] = get_sum(pr) + w[v];\n\tp[v][0] = pr;\n\th[v] = pr == -1 ? 0 : (1 + h[pr]);\n\tup[v] = v;\n\tfor(int i = 1; i < lg; i++)\n\t\tp[v][i] = p[v][i - 1] == -1 ? -1 : p[p[v][i - 1]][i - 1];\n\tint dist = L - 1;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tif(p[up[v]][i] == -1 || (1<<i) > dist)continue;\n\t\tif(get_sum(v) - get_sum(p[up[v]][i]) + w[p[up[v]][i]] <= S){\n\t\t\tdist -= 1<<i;\n\t\t\tup[v] = p[up[v]][i];\n\t\t}\n\t}\n\tfor(int u : down[v]){\n\t\tpreprocess(u, v);\n\t}\n}\n\nint solve(int v){\n\tint ans = 0;\n\tint best = -1;\n\tfor(int u : down[v]){\n\t\tans += solve(u);\n\t\tif(path[u] == u)continue;\n\t\tif(best == -1 || h[best] > h[path[u]])\n\t\t\tbest = path[u];\n\t}\n\tif(best == -1){\n\t\tbest = up[v];\n\t\t++ans;\n\t}\n\tpath[v] = best;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d%d%lld\", &n, &L, &S);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &w[i]);\n\t\tif(w[i] > S){printf(\"-1\"); return 0;}\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint j;\n\t\tscanf(\"%d\", &j);\n\t\tdown[--j].push_back(i);\n\t}\n\tpreprocess(0);\n\tprintf(\"%d\", solve(0));\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "int seq[maxn]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "floor(n/ K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "floor(n / GCD) - floor(n / M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "sum[vertex]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "sum[current_vertex] - sum[stack[position]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #514 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "int n;\ncin >> n;\ncout << n << ' ' << n << ' ' << n+1 << endl;\nfor (int i = 1; i <= n; i++) cout << 1 << \" \\n\"[i==n];\nfor (int i = 2; i <= n/2; i++) cout << i-1 << ' ';\nfor (int i = n/2+1; i <= n; i++) cout << n/2 << \" \\n\"[i==n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62238",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000); // n ∈ [1,1e5]\n    inf.readSpace();\n    int L = inf.readInt(1, 100000); // L ∈ [1,1e5]\n    inf.readSpace();\n    long long S = inf.readLong(1LL, 1000000000000000000LL); // S ∈ [1,1e18]\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 1000000000); // w_i ∈ [1,1e9]\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    vector<vector<int>> adj(n + 1);\n\n    for (int i = 2; i <= n; i++) {\n        int p_i = inf.readInt(1, i - 1); // p_i ∈ [1,i-1]\n        parent[i] = p_i;\n        adj[p_i].push_back(i);\n        if (i != n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    // Check that the tree is connected\n    vector<bool> visited(n + 1, false);\n\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n\n    dfs(1);\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"The tree is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000); // n ∈ [1,1e5]\n    inf.readSpace();\n    int L = inf.readInt(1, 100000); // L ∈ [1,1e5]\n    inf.readSpace();\n    long long S = inf.readLong(1LL, 1000000000000000000LL); // S ∈ [1,1e18]\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 1000000000); // w_i ∈ [1,1e9]\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    vector<vector<int>> adj(n + 1);\n\n    for (int i = 2; i <= n; i++) {\n        int p_i = inf.readInt(1, i - 1); // p_i ∈ [1,i-1]\n        parent[i] = p_i;\n        adj[p_i].push_back(i);\n        if (i != n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    // Check that the tree is connected\n    vector<bool> visited(n + 1, false);\n\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n\n    dfs(1);\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"The tree is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000); // n ∈ [1,1e5]\n    inf.readSpace();\n    int L = inf.readInt(1, 100000); // L ∈ [1,1e5]\n    inf.readSpace();\n    long long S = inf.readLong(1LL, 1000000000000000000LL); // S ∈ [1,1e18]\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 1000000000); // w_i ∈ [1,1e9]\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    vector<vector<int>> adj(n + 1);\n\n    for (int i = 2; i <= n; i++) {\n        int p_i = inf.readInt(1, i - 1); // p_i ∈ [1,i-1]\n        parent[i] = p_i;\n        adj[p_i].push_back(i);\n        if (i != n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    // Check that the tree is connected\n    vector<bool> visited(n + 1, false);\n\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n\n    dfs(1);\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"The tree is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read command-line options\n    int n = opt<int>(\"n\");\n    int L = opt<int>(\"L\");\n    long long S = opt<long long>(\"S\");\n    string wtype = opt<string>(\"wtype\", \"random\");\n    string ttype = opt<string>(\"ttype\", \"random\");\n\n    // Check constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= L && L <= 100000);\n    ensure(1 <= S && S <= 1000000000000000000LL); // 1e18\n\n    // Generate weights w_i\n    vector<int> w(n);\n    if (wtype == \"const1\") {\n        fill(w.begin(), w.end(), 1);\n    } else if (wtype == \"constmax\") {\n        fill(w.begin(), w.end(), 1000000000); // 1e9\n    } else if (wtype == \"impossible\") {\n        // Ensure S is less than 1e9\n        if (S >= 1000000000LL) {\n            S = 1000000000LL - 1;\n        }\n        // Generate random weights\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, 1000000000);\n        }\n        // Ensure at least one w_i > S\n        int idx = rnd.next(0, n - 1);\n        w[idx] = int(S + 1);\n    } else {\n        // Random weights\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Generate tree structure\n    vector<int> p(n); // p[0] is unused\n    if (ttype == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            p[i] = i; // Parent of node i + 1 is node i\n        }\n    } else if (ttype == \"star\") {\n        for (int i = 1; i < n; ++i) {\n            p[i] = 1; // Parent is root\n        }\n    } else if (ttype == \"balanced\") {\n        // Build a balanced tree\n        vector<int> nodes = {1};\n        int idx = 0;\n        for (int i = 2; i <= n; ++i) {\n            p[i - 1] = nodes[idx];\n            nodes.push_back(i);\n            idx = (idx + 1) % nodes.size();\n        }\n    } else {\n        // Random tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = rnd.next(1, i);\n        }\n    }\n\n    // Output n, L, S\n    printf(\"%d %d %lld\\n\", n, L, S);\n    // Output w_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", w[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n    // Output p_i for i = 2 to n\n    for (int i = 1; i < n; ++i) {\n        printf(\"%d%c\", p[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read command-line options\n    int n = opt<int>(\"n\");\n    int L = opt<int>(\"L\");\n    long long S = opt<long long>(\"S\");\n    string wtype = opt<string>(\"wtype\", \"random\");\n    string ttype = opt<string>(\"ttype\", \"random\");\n\n    // Check constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= L && L <= 100000);\n    ensure(1 <= S && S <= 1000000000000000000LL); // 1e18\n\n    // Generate weights w_i\n    vector<int> w(n);\n    if (wtype == \"const1\") {\n        fill(w.begin(), w.end(), 1);\n    } else if (wtype == \"constmax\") {\n        fill(w.begin(), w.end(), 1000000000); // 1e9\n    } else if (wtype == \"impossible\") {\n        // Ensure S is less than 1e9\n        if (S >= 1000000000LL) {\n            S = 1000000000LL - 1;\n        }\n        // Generate random weights\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, 1000000000);\n        }\n        // Ensure at least one w_i > S\n        int idx = rnd.next(0, n - 1);\n        w[idx] = int(S + 1);\n    } else {\n        // Random weights\n        for (int i = 0; i < n; ++i) {\n            w[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Generate tree structure\n    vector<int> p(n); // p[0] is unused\n    if (ttype == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            p[i] = i; // Parent of node i + 1 is node i\n        }\n    } else if (ttype == \"star\") {\n        for (int i = 1; i < n; ++i) {\n            p[i] = 1; // Parent is root\n        }\n    } else if (ttype == \"balanced\") {\n        // Build a balanced tree\n        vector<int> nodes = {1};\n        int idx = 0;\n        for (int i = 2; i <= n; ++i) {\n            p[i - 1] = nodes[idx];\n            nodes.push_back(i);\n            idx = (idx + 1) % nodes.size();\n        }\n    } else {\n        // Random tree\n        for (int i = 1; i < n; ++i) {\n            p[i] = rnd.next(1, i);\n        }\n    }\n\n    // Output n, L, S\n    printf(\"%d %d %lld\\n\", n, L, S);\n    // Output w_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", w[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n    // Output p_i for i = 2 to n\n    for (int i = 1; i < n; ++i) {\n        printf(\"%d%c\", p[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, chain tree, weights = 1\n./gen -n 1 -L 1 -S 1 -wtype const1 -ttype chain\n./gen -n 5 -L 2 -S 10 -wtype const1 -ttype chain\n\n# Small n, star tree, weights = max\n./gen -n 5 -L 3 -S 1000000000000 -wtype constmax -ttype star\n\n# Small n, random tree, random weights\n./gen -n 5 -L 5 -S 1000000000 -wtype random -ttype random\n\n# Medium n, chain tree, weights = 1\n./gen -n 100 -L 50 -S 50 -wtype const1 -ttype chain\n\n# Medium n, balanced tree, weights = random\n./gen -n 100 -L 10 -S 1000000000 -wtype random -ttype balanced\n\n# Medium n, star tree, weights = impossible case\n./gen -n 100 -L 20 -S 1000000 -wtype impossible -ttype star\n\n# Large n, chain tree, weights = max\n./gen -n 100000 -L 100000 -S 1000000000000000 -wtype constmax -ttype chain\n\n# Large n, random tree, weights = random\n./gen -n 100000 -L 100000 -S 1000000000000000000 -wtype random -ttype random\n\n# Large n, balanced tree, weights = const1\n./gen -n 100000 -L 1 -S 1 -wtype const1 -ttype balanced\n\n# Impossible case, w_i > S\n./gen -n 10 -L 5 -S 1000000 -wtype impossible -ttype random\n\n# Impossible case, S too small\n./gen -n 1000 -L 1000 -S 1 -wtype const1 -ttype chain\n\n# L = 1, forces maximum number of paths\n./gen -n 10000 -L 1 -S 1000000000 -wtype random -ttype random\n\n# L maximum, S maximum, random weights and tree\n./gen -n 100000 -L 100000 -S 1000000000000000000 -wtype random -ttype random\n\n# Weights equal to S, should be possible\n./gen -n 100 -L 100 -S 1000000000 -wtype constmax -ttype random\n\n# Weights close to S, but possible\n./gen -n 1000 -L 500 -S 999999999 -wtype random -ttype random\n\n# Star tree, small S, impossible\n./gen -n 50 -L 10 -S 1 -wtype const1 -ttype star\n\n# Balanced tree, weights = 1, L small\n./gen -n 10000 -L 2 -S 2 -wtype const1 -ttype balanced\n\n# Chain tree, all weights random\n./gen -n 100000 -L 10000 -S 100000000000 -wtype random -ttype chain\n\n# Random tree, weights = max, S large\n./gen -n 100000 -L 50000 -S 1000000000 -wtype constmax -ttype random\n\n# n = 1, single node, S smaller than w_i\n./gen -n 1 -L 1 -S 1 -wtype constmax -ttype chain\n\n# n = 1, single node, possible\n./gen -n 1 -L 1 -S 1000000000000 -wtype constmax -ttype chain\n\n# Minimal S, minimal L\n./gen -n 100000 -L 1 -S 1 -wtype const1 -ttype random\n\n# Maximal S, minimal L\n./gen -n 100000 -L 1 -S 1000000000000000000 -wtype random -ttype random\n\n# Maximal L, minimal S\n./gen -n 100000 -L 100000 -S 1 -wtype const1 -ttype random\n\n# All weights are 1, S is large\n./gen -n 100000 -L 100000 -S 1000000000000000000 -wtype const1 -ttype balanced\n\n# All weights are max, S is max\n./gen -n 100000 -L 100000 -S 1000000000000000000 -wtype constmax -ttype balanced\n\n# Random tree, impossible due to weight sum\n./gen -n 1000 -L 10 -S 1000 -wtype impossible -ttype random\n\n# Chain tree, impossible due to L\n./gen -n 10000 -L 5 -S 1000000000 -wtype const1 -ttype chain\n\n# Star tree, possible\n./gen -n 50000 -L 50000 -S 1000000000 -wtype random -ttype star\n\n# Balanced tree, with large weights and small S\n./gen -n 10000 -L 1000 -S 1000000 -wtype constmax -ttype balanced\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:07.925287",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "106/A",
      "title": "A. Card Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the tramp suit. It is \"S\", \"H\", \"D\" or \"C\".The second line contains the description of the two different cards. Each card is described by one word consisting of two symbols. The first symbol stands for the rank (\"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\" and \"A\"), and the second one stands for the suit (\"S\", \"H\", \"D\" and \"C\").",
      "output_spec": "OutputPrint \"YES\" (without the quotes) if the first cards beats the second one. Otherwise, print \"NO\" (also without the quotes).",
      "sample_tests": "ExamplesInputCopyHQH 9SOutputCopyYESInputCopyS8D 6DOutputCopyYESInputCopyC7H ASOutputCopyNO",
      "description": "A. Card Game\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the tramp suit. It is \"S\", \"H\", \"D\" or \"C\".The second line contains the description of the two different cards. Each card is described by one word consisting of two symbols. The first symbol stands for the rank (\"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\" and \"A\"), and the second one stands for the suit (\"S\", \"H\", \"D\" and \"C\").\n\nOutputPrint \"YES\" (without the quotes) if the first cards beats the second one. Otherwise, print \"NO\" (also without the quotes).\n\nInputCopyHQH 9SOutputCopyYESInputCopyS8D 6DOutputCopyYESInputCopyC7H ASOutputCopyNO\n\nInputCopyHQH 9S\n\nOutputCopyYES\n\nInputCopyS8D 6D\n\nOutputCopyYES\n\nInputCopyC7H AS\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Solutions for Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "A. (link) Solution of this problem is written in the fourth paragraph of the statements. You should carefully read and implement it. Only one difficult part is how to to determine which card has higher rank. You can for every card iterate over array [ '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' ] and determine numbers of ranks in this array. Finally, just compare them. B. (link) You can create array for all laptops where true for outdated laptop and false otherwise. Value of every cell of this array you can determine by iterating over all laptops and comparing all their parameters. At the end you should itarate over all laptops once again and choose cheapest one that is not outdated.C. (link) Let create array dp by size n x m. dp[i][j] means maximum number of tugriks that the baker can earn if he used i grams of dough and cook buns with stuffings of types 1..j.Initially dp[i][0] is 0 for all i.You can easily calculate this dp:dp[i][j] = max{ dp[i-c[j]*k][j-1] + d[j]*k } for every k from 0 to a[j]/b[j], for which i-c[j]*k>=0The answer will be max{ dp[k][m] + ((n-k)/c0)*d0 } for every k from 0 to n.Of course, all divisions in editorial of this problem are integer.Solution works in O(nma), where a is maximum a_i.D. (link) Solution is simulation of all insrtuctions from all of local sights. But naive solution doesn't fit into time limit. You should speed up this solution and do every instruction in O(1).You can use one of following things.1. For every position and every direction you can precalculate nearest position of sea. Now before than you do an instruction you should check that nearest position of sea further than position whereto you move after doing the instruction.2. Let sea cells have 1 and all other ones have 0. For every cell (i,j) you can calculate sum of all cells in the rectangle with angles in (1,1) and (i,j). It can be done by the operations like:sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + smthwhere smth is 0 or 1 according to type of according cell (i,j). Now you can determine sum of numbers for all rectangles of the map. Before you do instruction you should chech that sum of rectangle on which you will go has sum 0.Solution has complexity O(nm + kz), where z is number of local sights (this number no more than 26).E. (link) Author's solution is three ternary search for every demension that are nested within each other.It works because the function is convex. Maximum of convex functions also convex function. Author not very well imagine convex function in 3 dimrnsions, therefore you can read following proof that algorithm is correct:Let consider some straight line. Function of distance between points on this line and planet position will be convex (you can imagine it). If you get maximum of such functions it will be convex function too. Let's call this function f1.Now let's consider flat plane and choose one straight line in it. Set for every point of this line a minumum of function f1 of line that passes through this point and is perpendicular to choosen line. Let's call function on this choosen line f2.f2 is convex. It can be easily proved by contrary. If f2 is not convex, we can find at least two local minimums. Let's choose two neighbour of them. We can find this two minimums on the plane and drawn through them new line. f1 on this line will be not convex (you also can imagine it). Сontradiction.Now let's consider all space. Choose one line in it and define function f3 on it. Values of f3 will be minimums of functions f2 of planes that passes through the line and is perpendicular to it. f3 also is convex. Proof of it is analogically to that is written in the previous paragraph. []Now you can see that minimum can ge found by three ternary search over functions fi. You can add to these functions returning of value in which they reach a minimum.Also there are solutions that uses idea of Gradient descent or Hill climbing. Author was unable to write this solution (not enough precision), but some participants got AC with such solutions.There is exact solution O(n^4) (more exactly O(C_n^4)). This solution uses Helly's theorem and Jung's theorem that follows from the first one:http://en.wikipedia.org/wiki/Helly's_theoremIn this solution you should itarate over all pairs, triples and fours of points and for every of them build minimal ball that cover them. Answer is center of ball with maximum radius.Also you can google something like thathttp://www.inf.ethz.ch/personal/gaertner/miniball.htmlThere are code and article, but the author of contest is not particularly delved into them))",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2493",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4587
        },
        {
          "title": "Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "Good evening.Today's round is mine, as the previous one. This round will be for participants of the second division. Participants of the first division can take part in the round out of competition.RAD, Connector, it4.kp and MikeMirzayanov helped me to prepare this round. Delinur translated statements into English.Contest will be in the good old tradition of Codeforces. No any innovations, pretty short and clear statements.Points for problems are standard: 500-1000-1500-2000-2500.Good luck everyone!UPD. Round was ended, ratings was updated.Winners:1. tsundere2. jte3. abacadaea4. ltaravilse5. Billy_HerringtonEditorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2484",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 625
        },
        {
          "title": "Solutions for Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "A. (link) Solution of this problem is written in the fourth paragraph of the statements. You should carefully read and implement it. Only one difficult part is how to to determine which card has higher rank. You can for every card iterate over array [ '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' ] and determine numbers of ranks in this array. Finally, just compare them. B. (link) You can create array for all laptops where true for outdated laptop and false otherwise. Value of every cell of this array you can determine by iterating over all laptops and comparing all their parameters. At the end you should itarate over all laptops once again and choose cheapest one that is not outdated.C. (link) Let create array dp by size n x m. dp[i][j] means maximum number of tugriks that the baker can earn if he used i grams of dough and cook buns with stuffings of types 1..j.Initially dp[i][0] is 0 for all i.You can easily calculate this dp:dp[i][j] = max{ dp[i-c[j]*k][j-1] + d[j]*k } for every k from 0 to a[j]/b[j], for which i-c[j]*k>=0The answer will be max{ dp[k][m] + ((n-k)/c0)*d0 } for every k from 0 to n.Of course, all divisions in editorial of this problem are integer.Solution works in O(nma), where a is maximum a_i.D. (link) Solution is simulation of all insrtuctions from all of local sights. But naive solution doesn't fit into time limit. You should speed up this solution and do every instruction in O(1).You can use one of following things.1. For every position and every direction you can precalculate nearest position of sea. Now before than you do an instruction you should check that nearest position of sea further than position whereto you move after doing the instruction.2. Let sea cells have 1 and all other ones have 0. For every cell (i,j) you can calculate sum of all cells in the rectangle with angles in (1,1) and (i,j). It can be done by the operations like:sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + smthwhere smth is 0 or 1 according to type of according cell (i,j). Now you can determine sum of numbers for all rectangles of the map. Before you do instruction you should chech that sum of rectangle on which you will go has sum 0.Solution has complexity O(nm + kz), where z is number of local sights (this number no more than 26).E. (link) Author's solution is three ternary search for every demension that are nested within each other.It works because the function is convex. Maximum of convex functions also convex function. Author not very well imagine convex function in 3 dimrnsions, therefore you can read following proof that algorithm is correct:Let consider some straight line. Function of distance between points on this line and planet position will be convex (you can imagine it). If you get maximum of such functions it will be convex function too. Let's call this function f1.Now let's consider flat plane and choose one straight line in it. Set for every point of this line a minumum of function f1 of line that passes through this point and is perpendicular to choosen line. Let's call function on this choosen line f2.f2 is convex. It can be easily proved by contrary. If f2 is not convex, we can find at least two local minimums. Let's choose two neighbour of them. We can find this two minimums on the plane and drawn through them new line. f1 on this line will be not convex (you also can imagine it). Сontradiction.Now let's consider all space. Choose one line in it and define function f3 on it. Values of f3 will be minimums of functions f2 of planes that passes through the line and is perpendicular to it. f3 also is convex. Proof of it is analogically to that is written in the previous paragraph. []Now you can see that minimum can ge found by three ternary search over functions fi. You can add to these functions returning of value in which they reach a minimum.Also there are solutions that uses idea of Gradient descent or Hill climbing. Author was unable to write this solution (not enough precision), but some participants got AC with such solutions.There is exact solution O(n^4) (more exactly O(C_n^4)). This solution uses Helly's theorem and Jung's theorem that follows from the first one:http://en.wikipedia.org/wiki/Helly's_theoremIn this solution you should itarate over all pairs, triples and fours of points and for every of them build minimal ball that cover them. Answer is center of ball with maximum radius.Also you can google something like thathttp://www.inf.ethz.ch/personal/gaertner/miniball.htmlThere are code and article, but the author of contest is not particularly delved into them))",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2493",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4587
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string trump = inf.readLine(\"[SHDC]\", \"trump\");\n    ensuref(trump.length() == 1, \"Trump suit must be a single character\");\n\n    string card1 = inf.readToken(\"[6789TJQKA][SHDC]\", \"card1\");\n    inf.readSpace();\n    string card2 = inf.readToken(\"[6789TJQKA][SHDC]\", \"card2\");\n    inf.readEoln();\n\n    ensuref(card1 != card2, \"Cards must be different\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string trump = inf.readLine(\"[SHDC]\", \"trump\");\n    ensuref(trump.length() == 1, \"Trump suit must be a single character\");\n\n    string card1 = inf.readToken(\"[6789TJQKA][SHDC]\", \"card1\");\n    inf.readSpace();\n    string card2 = inf.readToken(\"[6789TJQKA][SHDC]\", \"card2\");\n    inf.readEoln();\n\n    ensuref(card1 != card2, \"Cards must be different\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string trump = inf.readLine(\"[SHDC]\", \"trump\");\n    ensuref(trump.length() == 1, \"Trump suit must be a single character\");\n\n    string card1 = inf.readToken(\"[6789TJQKA][SHDC]\", \"card1\");\n    inf.readSpace();\n    string card2 = inf.readToken(\"[6789TJQKA][SHDC]\", \"card2\");\n    inf.readEoln();\n\n    ensuref(card1 != card2, \"Cards must be different\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string trump_suit = opt<string>(\"trump\", \"\");\n    string type = opt<string>(\"type\");\n\n    vector<string> suits = {\"S\", \"H\", \"D\", \"C\"};\n    vector<string> ranks = {\"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\", \"A\"};\n    map<string, int> rank_value; // Map rank to value\n    for(int i = 0; i < (int)ranks.size(); ++i) {\n        rank_value[ranks[i]] = i;\n    }\n\n    // If trump_suit is empty, randomize it\n    if(trump_suit == \"\") {\n        trump_suit = suits[rnd.next(4)];\n    }\n\n    string card1_rank, card1_suit;\n    string card2_rank, card2_suit;\n\n    if(type == \"beat_same_suit_higher_rank\") {\n        // Both cards have same suit (non-trump or trump)\n        // First card has higher rank\n        // Let's choose a suit\n        string suit = suits[rnd.next(4)];\n        // Choose two different ranks, first higher than second\n        int r1 = rnd.next(1, (int)ranks.size()-1);\n        int r2 = rnd.next(r1);\n        card1_rank = ranks[r1];\n        card2_rank = ranks[r2];\n        card1_suit = suit;\n        card2_suit = suit;\n    } else if (type == \"beat_trump_vs_non_trump\") {\n        // First card is trump, second card is not trump\n        card1_suit = trump_suit;\n        // Choose any suit that is not trump\n        vector<string> non_trump_suits;\n        for(auto s: suits)\n            if(s != trump_suit)\n                non_trump_suits.push_back(s);\n        card2_suit = non_trump_suits[rnd.next((int)non_trump_suits.size())];\n        // Ranks can be any\n        card1_rank = ranks[rnd.next((int)ranks.size())];\n        card2_rank = ranks[rnd.next((int)ranks.size())];\n    } else if (type == \"not_beat_same_suit_lower_rank\") {\n        // Both cards have same suit\n        // First card has lower rank\n        // Choose a suit\n        string suit = suits[rnd.next(4)];\n        // Choose two different ranks, first lower than second\n        int r1 = rnd.next(0, (int)ranks.size() - 2);\n        int r2 = rnd.next(r1 + 1, (int)ranks.size() -1);\n        card1_rank = ranks[r1];\n        card2_rank = ranks[r2];\n        card1_suit = suit;\n        card2_suit = suit;\n    } else if (type == \"not_beat_different_suit\") {\n        // First card is not trump, and suits are different\n        // first card suit != trump_suit\n        vector<string> non_trump_suits;\n        for(auto s: suits)\n            if(s != trump_suit)\n                non_trump_suits.push_back(s);\n        card1_suit = non_trump_suits[rnd.next((int)non_trump_suits.size())];\n        card2_suit = non_trump_suits[rnd.next((int)non_trump_suits.size())];\n\n        // Ensure suits are different\n        while(card1_suit == card2_suit) {\n            card2_suit = non_trump_suits[rnd.next((int)non_trump_suits.size())];\n        }\n        card1_rank = ranks[rnd.next((int)ranks.size())];\n        card2_rank = ranks[rnd.next((int)ranks.size())];\n    } else if (type == \"beat_trump_vs_trump_higher_rank\") {\n        // Both cards are trump\n        card1_suit = trump_suit;\n        card2_suit = trump_suit;\n        // First card has higher rank\n        int r1 = rnd.next(1, (int)ranks.size()-1);\n        int r2 = rnd.next(r1);\n        card1_rank = ranks[r1];\n        card2_rank = ranks[r2];\n    } else if (type == \"not_beat_trump_vs_trump_lower_rank\") {\n        // Both cards are trump\n        card1_suit = trump_suit;\n        card2_suit = trump_suit;\n        // First card has lower rank\n        int r1 = rnd.next(0, (int)ranks.size()-2);\n        int r2 = rnd.next(r1 + 1, (int)ranks.size() -1);\n        card1_rank = ranks[r1];\n        card2_rank = ranks[r2];\n    } else if (type == \"edge_cases\") {\n        // Use highest and lowest ranks\n        // Make both possibilities\n        int edge_choice = rnd.next(2); // 0 or 1\n        if(edge_choice == 0) {\n            // First card has lowest rank, second card has highest rank, same suit\n            string suit = suits[rnd.next(4)];\n            card1_rank = ranks[0];\n            card1_suit = suit;\n            card2_rank = ranks.back();\n            card2_suit = suit;\n        } else {\n            // First card has highest rank, second card has lowest rank, same suit\n            string suit = suits[rnd.next(4)];\n            card1_rank = ranks.back();\n            card1_suit = suit;\n            card2_rank = ranks[0];\n            card2_suit = suit;\n        }\n    } else {\n        // Default random test case\n        // Generate random cards, making sure they are different\n        do {\n            card1_suit = suits[rnd.next(4)];\n            card1_rank = ranks[rnd.next(9)];\n            card2_suit = suits[rnd.next(4)];\n            card2_rank = ranks[rnd.next(9)];\n        } while(card1_suit == card2_suit && card1_rank == card2_rank);\n    }\n\n    // Ensure that the two cards are different\n    if(card1_suit == card2_suit && card1_rank == card2_rank) {\n        // Need to change the second card\n        do {\n            card2_suit = suits[rnd.next(4)];\n            card2_rank = ranks[rnd.next(9)];\n        } while(card1_suit == card2_suit && card1_rank == card2_rank);\n    }\n\n    // Output\n    printf(\"%s\\n\", trump_suit.c_str());\n    printf(\"%s%s %s%s\\n\", card1_rank.c_str(), card1_suit.c_str(),\n                          card2_rank.c_str(), card2_suit.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string trump_suit = opt<string>(\"trump\", \"\");\n    string type = opt<string>(\"type\");\n\n    vector<string> suits = {\"S\", \"H\", \"D\", \"C\"};\n    vector<string> ranks = {\"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\", \"A\"};\n    map<string, int> rank_value; // Map rank to value\n    for(int i = 0; i < (int)ranks.size(); ++i) {\n        rank_value[ranks[i]] = i;\n    }\n\n    // If trump_suit is empty, randomize it\n    if(trump_suit == \"\") {\n        trump_suit = suits[rnd.next(4)];\n    }\n\n    string card1_rank, card1_suit;\n    string card2_rank, card2_suit;\n\n    if(type == \"beat_same_suit_higher_rank\") {\n        // Both cards have same suit (non-trump or trump)\n        // First card has higher rank\n        // Let's choose a suit\n        string suit = suits[rnd.next(4)];\n        // Choose two different ranks, first higher than second\n        int r1 = rnd.next(1, (int)ranks.size()-1);\n        int r2 = rnd.next(r1);\n        card1_rank = ranks[r1];\n        card2_rank = ranks[r2];\n        card1_suit = suit;\n        card2_suit = suit;\n    } else if (type == \"beat_trump_vs_non_trump\") {\n        // First card is trump, second card is not trump\n        card1_suit = trump_suit;\n        // Choose any suit that is not trump\n        vector<string> non_trump_suits;\n        for(auto s: suits)\n            if(s != trump_suit)\n                non_trump_suits.push_back(s);\n        card2_suit = non_trump_suits[rnd.next((int)non_trump_suits.size())];\n        // Ranks can be any\n        card1_rank = ranks[rnd.next((int)ranks.size())];\n        card2_rank = ranks[rnd.next((int)ranks.size())];\n    } else if (type == \"not_beat_same_suit_lower_rank\") {\n        // Both cards have same suit\n        // First card has lower rank\n        // Choose a suit\n        string suit = suits[rnd.next(4)];\n        // Choose two different ranks, first lower than second\n        int r1 = rnd.next(0, (int)ranks.size() - 2);\n        int r2 = rnd.next(r1 + 1, (int)ranks.size() -1);\n        card1_rank = ranks[r1];\n        card2_rank = ranks[r2];\n        card1_suit = suit;\n        card2_suit = suit;\n    } else if (type == \"not_beat_different_suit\") {\n        // First card is not trump, and suits are different\n        // first card suit != trump_suit\n        vector<string> non_trump_suits;\n        for(auto s: suits)\n            if(s != trump_suit)\n                non_trump_suits.push_back(s);\n        card1_suit = non_trump_suits[rnd.next((int)non_trump_suits.size())];\n        card2_suit = non_trump_suits[rnd.next((int)non_trump_suits.size())];\n\n        // Ensure suits are different\n        while(card1_suit == card2_suit) {\n            card2_suit = non_trump_suits[rnd.next((int)non_trump_suits.size())];\n        }\n        card1_rank = ranks[rnd.next((int)ranks.size())];\n        card2_rank = ranks[rnd.next((int)ranks.size())];\n    } else if (type == \"beat_trump_vs_trump_higher_rank\") {\n        // Both cards are trump\n        card1_suit = trump_suit;\n        card2_suit = trump_suit;\n        // First card has higher rank\n        int r1 = rnd.next(1, (int)ranks.size()-1);\n        int r2 = rnd.next(r1);\n        card1_rank = ranks[r1];\n        card2_rank = ranks[r2];\n    } else if (type == \"not_beat_trump_vs_trump_lower_rank\") {\n        // Both cards are trump\n        card1_suit = trump_suit;\n        card2_suit = trump_suit;\n        // First card has lower rank\n        int r1 = rnd.next(0, (int)ranks.size()-2);\n        int r2 = rnd.next(r1 + 1, (int)ranks.size() -1);\n        card1_rank = ranks[r1];\n        card2_rank = ranks[r2];\n    } else if (type == \"edge_cases\") {\n        // Use highest and lowest ranks\n        // Make both possibilities\n        int edge_choice = rnd.next(2); // 0 or 1\n        if(edge_choice == 0) {\n            // First card has lowest rank, second card has highest rank, same suit\n            string suit = suits[rnd.next(4)];\n            card1_rank = ranks[0];\n            card1_suit = suit;\n            card2_rank = ranks.back();\n            card2_suit = suit;\n        } else {\n            // First card has highest rank, second card has lowest rank, same suit\n            string suit = suits[rnd.next(4)];\n            card1_rank = ranks.back();\n            card1_suit = suit;\n            card2_rank = ranks[0];\n            card2_suit = suit;\n        }\n    } else {\n        // Default random test case\n        // Generate random cards, making sure they are different\n        do {\n            card1_suit = suits[rnd.next(4)];\n            card1_rank = ranks[rnd.next(9)];\n            card2_suit = suits[rnd.next(4)];\n            card2_rank = ranks[rnd.next(9)];\n        } while(card1_suit == card2_suit && card1_rank == card2_rank);\n    }\n\n    // Ensure that the two cards are different\n    if(card1_suit == card2_suit && card1_rank == card2_rank) {\n        // Need to change the second card\n        do {\n            card2_suit = suits[rnd.next(4)];\n            card2_rank = ranks[rnd.next(9)];\n        } while(card1_suit == card2_suit && card1_rank == card2_rank);\n    }\n\n    // Output\n    printf(\"%s\\n\", trump_suit.c_str());\n    printf(\"%s%s %s%s\\n\", card1_rank.c_str(), card1_suit.c_str(),\n                          card2_rank.c_str(), card2_suit.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type beat_same_suit_higher_rank\n./gen -type beat_same_suit_higher_rank -trump H\n./gen -type beat_trump_vs_non_trump\n./gen -type beat_trump_vs_non_trump -trump D\n./gen -type not_beat_same_suit_lower_rank\n./gen -type not_beat_same_suit_lower_rank -trump S\n./gen -type not_beat_different_suit\n./gen -type not_beat_different_suit -trump C\n./gen -type beat_trump_vs_trump_higher_rank\n./gen -type beat_trump_vs_trump_higher_rank -trump H\n./gen -type not_beat_trump_vs_trump_lower_rank\n./gen -type not_beat_trump_vs_trump_lower_rank -trump D\n./gen -type edge_cases\n./gen -type edge_cases -trump S\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random -trump H\n./gen -type random -trump D\n./gen -type beat_same_suit_higher_rank\n./gen -type not_beat_same_suit_lower_rank\n./gen -type beat_trump_vs_non_trump\n./gen -type not_beat_different_suit\n./gen -type beat_trump_vs_trump_higher_rank\n./gen -type not_beat_trump_vs_trump_lower_rank\n./gen -type edge_cases\n./gen -type not_beat_trump_vs_trump_lower_rank -trump C\n./gen -type random\n./gen -type random -trump H\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:09.547905",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "106/B",
      "title": "B. Choosing Laptop",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number n (1 ≤ n ≤ 100).Then follow n lines. Each describes a laptop as speed ram hdd cost. Besides,   speed, ram, hdd and cost are integers  1000 ≤ speed ≤ 4200 is the processor's speed in megahertz  256 ≤ ram ≤ 4096 the RAM volume in megabytes  1 ≤ hdd ≤ 500 is the HDD in gigabytes  100 ≤ cost ≤ 1000 is price in tugriks All laptops have different prices.",
      "output_spec": "OutputPrint a single number — the number of a laptop Vasya will choose. The laptops are numbered with positive integers from 1 to n in the order in which they are given in the input data.",
      "sample_tests": "ExamplesInputCopy52100 512 150 2002000 2048 240 3502300 1024 200 3202500 2048 80 3002000 512 180 150OutputCopy4",
      "description": "B. Choosing Laptop\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains number n (1 ≤ n ≤ 100).Then follow n lines. Each describes a laptop as speed ram hdd cost. Besides,   speed, ram, hdd and cost are integers  1000 ≤ speed ≤ 4200 is the processor's speed in megahertz  256 ≤ ram ≤ 4096 the RAM volume in megabytes  1 ≤ hdd ≤ 500 is the HDD in gigabytes  100 ≤ cost ≤ 1000 is price in tugriks All laptops have different prices.\n\nOutputPrint a single number — the number of a laptop Vasya will choose. The laptops are numbered with positive integers from 1 to n in the order in which they are given in the input data.\n\nInputCopy52100 512 150 2002000 2048 240 3502300 1024 200 3202500 2048 80 3002000 512 180 150OutputCopy4\n\nInputCopy52100 512 150 2002000 2048 240 3502300 1024 200 3202500 2048 80 3002000 512 180 150\n\nOutputCopy4\n\nNoteIn the third sample Vasya considers the first and fifth laptops outdated as all of their properties cannot match those of the third laptop. The fourth one is the cheapest among the laptops that are left. Thus, Vasya chooses the fourth laptop.",
      "solutions": [
        {
          "title": "Solutions for Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "A. (link) Solution of this problem is written in the fourth paragraph of the statements. You should carefully read and implement it. Only one difficult part is how to to determine which card has higher rank. You can for every card iterate over array [ '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' ] and determine numbers of ranks in this array. Finally, just compare them. B. (link) You can create array for all laptops where true for outdated laptop and false otherwise. Value of every cell of this array you can determine by iterating over all laptops and comparing all their parameters. At the end you should itarate over all laptops once again and choose cheapest one that is not outdated.C. (link) Let create array dp by size n x m. dp[i][j] means maximum number of tugriks that the baker can earn if he used i grams of dough and cook buns with stuffings of types 1..j.Initially dp[i][0] is 0 for all i.You can easily calculate this dp:dp[i][j] = max{ dp[i-c[j]*k][j-1] + d[j]*k } for every k from 0 to a[j]/b[j], for which i-c[j]*k>=0The answer will be max{ dp[k][m] + ((n-k)/c0)*d0 } for every k from 0 to n.Of course, all divisions in editorial of this problem are integer.Solution works in O(nma), where a is maximum a_i.D. (link) Solution is simulation of all insrtuctions from all of local sights. But naive solution doesn't fit into time limit. You should speed up this solution and do every instruction in O(1).You can use one of following things.1. For every position and every direction you can precalculate nearest position of sea. Now before than you do an instruction you should check that nearest position of sea further than position whereto you move after doing the instruction.2. Let sea cells have 1 and all other ones have 0. For every cell (i,j) you can calculate sum of all cells in the rectangle with angles in (1,1) and (i,j). It can be done by the operations like:sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + smthwhere smth is 0 or 1 according to type of according cell (i,j). Now you can determine sum of numbers for all rectangles of the map. Before you do instruction you should chech that sum of rectangle on which you will go has sum 0.Solution has complexity O(nm + kz), where z is number of local sights (this number no more than 26).E. (link) Author's solution is three ternary search for every demension that are nested within each other.It works because the function is convex. Maximum of convex functions also convex function. Author not very well imagine convex function in 3 dimrnsions, therefore you can read following proof that algorithm is correct:Let consider some straight line. Function of distance between points on this line and planet position will be convex (you can imagine it). If you get maximum of such functions it will be convex function too. Let's call this function f1.Now let's consider flat plane and choose one straight line in it. Set for every point of this line a minumum of function f1 of line that passes through this point and is perpendicular to choosen line. Let's call function on this choosen line f2.f2 is convex. It can be easily proved by contrary. If f2 is not convex, we can find at least two local minimums. Let's choose two neighbour of them. We can find this two minimums on the plane and drawn through them new line. f1 on this line will be not convex (you also can imagine it). Сontradiction.Now let's consider all space. Choose one line in it and define function f3 on it. Values of f3 will be minimums of functions f2 of planes that passes through the line and is perpendicular to it. f3 also is convex. Proof of it is analogically to that is written in the previous paragraph. []Now you can see that minimum can ge found by three ternary search over functions fi. You can add to these functions returning of value in which they reach a minimum.Also there are solutions that uses idea of Gradient descent or Hill climbing. Author was unable to write this solution (not enough precision), but some participants got AC with such solutions.There is exact solution O(n^4) (more exactly O(C_n^4)). This solution uses Helly's theorem and Jung's theorem that follows from the first one:http://en.wikipedia.org/wiki/Helly's_theoremIn this solution you should itarate over all pairs, triples and fours of points and for every of them build minimal ball that cover them. Answer is center of ball with maximum radius.Also you can google something like thathttp://www.inf.ethz.ch/personal/gaertner/miniball.htmlThere are code and article, but the author of contest is not particularly delved into them))",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2493",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4587
        },
        {
          "title": "Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "Good evening.Today's round is mine, as the previous one. This round will be for participants of the second division. Participants of the first division can take part in the round out of competition.RAD, Connector, it4.kp and MikeMirzayanov helped me to prepare this round. Delinur translated statements into English.Contest will be in the good old tradition of Codeforces. No any innovations, pretty short and clear statements.Points for problems are standard: 500-1000-1500-2000-2500.Good luck everyone!UPD. Round was ended, ratings was updated.Winners:1. tsundere2. jte3. abacadaea4. ltaravilse5. Billy_HerringtonEditorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2484",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 625
        },
        {
          "title": "Solutions for Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "A. (link) Solution of this problem is written in the fourth paragraph of the statements. You should carefully read and implement it. Only one difficult part is how to to determine which card has higher rank. You can for every card iterate over array [ '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' ] and determine numbers of ranks in this array. Finally, just compare them. B. (link) You can create array for all laptops where true for outdated laptop and false otherwise. Value of every cell of this array you can determine by iterating over all laptops and comparing all their parameters. At the end you should itarate over all laptops once again and choose cheapest one that is not outdated.C. (link) Let create array dp by size n x m. dp[i][j] means maximum number of tugriks that the baker can earn if he used i grams of dough and cook buns with stuffings of types 1..j.Initially dp[i][0] is 0 for all i.You can easily calculate this dp:dp[i][j] = max{ dp[i-c[j]*k][j-1] + d[j]*k } for every k from 0 to a[j]/b[j], for which i-c[j]*k>=0The answer will be max{ dp[k][m] + ((n-k)/c0)*d0 } for every k from 0 to n.Of course, all divisions in editorial of this problem are integer.Solution works in O(nma), where a is maximum a_i.D. (link) Solution is simulation of all insrtuctions from all of local sights. But naive solution doesn't fit into time limit. You should speed up this solution and do every instruction in O(1).You can use one of following things.1. For every position and every direction you can precalculate nearest position of sea. Now before than you do an instruction you should check that nearest position of sea further than position whereto you move after doing the instruction.2. Let sea cells have 1 and all other ones have 0. For every cell (i,j) you can calculate sum of all cells in the rectangle with angles in (1,1) and (i,j). It can be done by the operations like:sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + smthwhere smth is 0 or 1 according to type of according cell (i,j). Now you can determine sum of numbers for all rectangles of the map. Before you do instruction you should chech that sum of rectangle on which you will go has sum 0.Solution has complexity O(nm + kz), where z is number of local sights (this number no more than 26).E. (link) Author's solution is three ternary search for every demension that are nested within each other.It works because the function is convex. Maximum of convex functions also convex function. Author not very well imagine convex function in 3 dimrnsions, therefore you can read following proof that algorithm is correct:Let consider some straight line. Function of distance between points on this line and planet position will be convex (you can imagine it). If you get maximum of such functions it will be convex function too. Let's call this function f1.Now let's consider flat plane and choose one straight line in it. Set for every point of this line a minumum of function f1 of line that passes through this point and is perpendicular to choosen line. Let's call function on this choosen line f2.f2 is convex. It can be easily proved by contrary. If f2 is not convex, we can find at least two local minimums. Let's choose two neighbour of them. We can find this two minimums on the plane and drawn through them new line. f1 on this line will be not convex (you also can imagine it). Сontradiction.Now let's consider all space. Choose one line in it and define function f3 on it. Values of f3 will be minimums of functions f2 of planes that passes through the line and is perpendicular to it. f3 also is convex. Proof of it is analogically to that is written in the previous paragraph. []Now you can see that minimum can ge found by three ternary search over functions fi. You can add to these functions returning of value in which they reach a minimum.Also there are solutions that uses idea of Gradient descent or Hill climbing. Author was unable to write this solution (not enough precision), but some participants got AC with such solutions.There is exact solution O(n^4) (more exactly O(C_n^4)). This solution uses Helly's theorem and Jung's theorem that follows from the first one:http://en.wikipedia.org/wiki/Helly's_theoremIn this solution you should itarate over all pairs, triples and fours of points and for every of them build minimal ball that cover them. Answer is center of ball with maximum radius.Also you can google something like thathttp://www.inf.ethz.ch/personal/gaertner/miniball.htmlThere are code and article, but the author of contest is not particularly delved into them))",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2493",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4587
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>  // Allowed to use this\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> costs;\n\n    // For each of the n laptops\n    for (int i = 0; i < n; ++i) {\n        int speed = inf.readInt(1000, 4200, \"speed\");\n        inf.readSpace();\n        int ram = inf.readInt(256, 4096, \"ram\");\n        inf.readSpace();\n        int hdd = inf.readInt(1, 500, \"hdd\");\n        inf.readSpace();\n        int cost = inf.readInt(100, 1000, \"cost\");\n        inf.readEoln();\n\n        ensuref(costs.count(cost) == 0, \"All laptops have different prices, duplicate cost %d\", cost);\n        costs.insert(cost);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>  // Allowed to use this\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> costs;\n\n    // For each of the n laptops\n    for (int i = 0; i < n; ++i) {\n        int speed = inf.readInt(1000, 4200, \"speed\");\n        inf.readSpace();\n        int ram = inf.readInt(256, 4096, \"ram\");\n        inf.readSpace();\n        int hdd = inf.readInt(1, 500, \"hdd\");\n        inf.readSpace();\n        int cost = inf.readInt(100, 1000, \"cost\");\n        inf.readEoln();\n\n        ensuref(costs.count(cost) == 0, \"All laptops have different prices, duplicate cost %d\", cost);\n        costs.insert(cost);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>  // Allowed to use this\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<int> costs;\n\n    // For each of the n laptops\n    for (int i = 0; i < n; ++i) {\n        int speed = inf.readInt(1000, 4200, \"speed\");\n        inf.readSpace();\n        int ram = inf.readInt(256, 4096, \"ram\");\n        inf.readSpace();\n        int hdd = inf.readInt(1, 500, \"hdd\");\n        inf.readSpace();\n        int cost = inf.readInt(100, 1000, \"cost\");\n        inf.readEoln();\n\n        ensuref(costs.count(cost) == 0, \"All laptops have different prices, duplicate cost %d\", cost);\n        costs.insert(cost);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Laptop {\n    int speed;\n    int ram;\n    int hdd;\n    int cost;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Laptop> laptops(n);\n    set<int> usedCosts;\n\n    if (type == \"random\") {\n        // Generate random laptops\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = rnd.next(1000, 4200);\n            laptops[i].ram = rnd.next(256, 4096);\n            laptops[i].hdd = rnd.next(1, 500);\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"one_outdated\") {\n        // Only one laptop is outdated\n        int high_speed = rnd.next(3500, 4200);\n        int high_ram = rnd.next(3072, 4096);\n        int high_hdd = rnd.next(400, 500);\n\n        // Generate n - 1 laptops with high properties\n        for (int i = 0; i < n - 1; ++i) {\n            laptops[i].speed = rnd.next(high_speed - 200, high_speed);\n            laptops[i].ram = rnd.next(high_ram - 500, high_ram);\n            laptops[i].hdd = rnd.next(high_hdd - 50, high_hdd);\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n\n        // One outdated laptop\n        laptops[n - 1].speed = rnd.next(1000, high_speed - 500);\n        laptops[n - 1].ram = rnd.next(256, high_ram - 1000);\n        laptops[n - 1].hdd = rnd.next(1, high_hdd - 100);\n        do {\n            laptops[n - 1].cost = rnd.next(100, 1000);\n        } while (usedCosts.count(laptops[n -1].cost));\n        usedCosts.insert(laptops[n -1].cost);\n    } else if (type == \"no_outdated\") {\n        // No laptop is outdated\n        for (int i = 0; i < n; ++i) {\n            if (i % 3 == 0) {\n                laptops[i].speed = 4200;\n                laptops[i].ram = rnd.next(256, 3000);\n                laptops[i].hdd = rnd.next(1, 200);\n            } else if (i % 3 == 1) {\n                laptops[i].speed = rnd.next(1000, 3000);\n                laptops[i].ram = 4096;\n                laptops[i].hdd = rnd.next(1, 200);\n            } else {\n                laptops[i].speed = rnd.next(1000, 3000);\n                laptops[i].ram = rnd.next(256, 3000);\n                laptops[i].hdd = 500;\n            }\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"same_props\") {\n        // All laptops have the same properties but different costs\n        int speed = rnd.next(1000, 4200);\n        int ram = rnd.next(256, 4096);\n        int hdd = rnd.next(1, 500);\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = speed;\n            laptops[i].ram = ram;\n            laptops[i].hdd = hdd;\n            do {\n                laptops[i].cost = 100 + rnd.next(0, 900);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"chain\") {\n        // Laptops form a chain where each next laptop dominates the previous\n        int speed = rnd.next(1000, 1200);\n        int ram = rnd.next(256, 512);\n        int hdd = rnd.next(1, 50);\n        int delta_speed = rnd.next(1, (4200 - speed) / n);\n        int delta_ram = rnd.next(1, (4096 - ram) / n);\n        int delta_hdd = rnd.next(1, (500 - hdd) / n);\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = speed + delta_speed * i;\n            laptops[i].ram = ram + delta_ram * i;\n            laptops[i].hdd = hdd + delta_hdd * i;\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"max_props\") {\n        // All laptops have maximum properties\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = 4200;\n            laptops[i].ram = 4096;\n            laptops[i].hdd = 500;\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"min_props\") {\n        // All laptops have minimum properties\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = 1000;\n            laptops[i].ram = 256;\n            laptops[i].hdd = 1;\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"equal_props\") {\n        // Laptops with some properties equal\n        int base_speed = rnd.next(1000, 4200);\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = base_speed;\n            laptops[i].ram = rnd.next(256, 4096);\n            laptops[i].hdd = rnd.next(1, 500);\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else {\n        // Default to random if type not recognized\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = rnd.next(1000, 4200);\n            laptops[i].ram = rnd.next(256, 4096);\n            laptops[i].hdd = rnd.next(1, 500);\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d\\n\", laptops[i].speed, laptops[i].ram, laptops[i].hdd, laptops[i].cost);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Laptop {\n    int speed;\n    int ram;\n    int hdd;\n    int cost;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Laptop> laptops(n);\n    set<int> usedCosts;\n\n    if (type == \"random\") {\n        // Generate random laptops\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = rnd.next(1000, 4200);\n            laptops[i].ram = rnd.next(256, 4096);\n            laptops[i].hdd = rnd.next(1, 500);\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"one_outdated\") {\n        // Only one laptop is outdated\n        int high_speed = rnd.next(3500, 4200);\n        int high_ram = rnd.next(3072, 4096);\n        int high_hdd = rnd.next(400, 500);\n\n        // Generate n - 1 laptops with high properties\n        for (int i = 0; i < n - 1; ++i) {\n            laptops[i].speed = rnd.next(high_speed - 200, high_speed);\n            laptops[i].ram = rnd.next(high_ram - 500, high_ram);\n            laptops[i].hdd = rnd.next(high_hdd - 50, high_hdd);\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n\n        // One outdated laptop\n        laptops[n - 1].speed = rnd.next(1000, high_speed - 500);\n        laptops[n - 1].ram = rnd.next(256, high_ram - 1000);\n        laptops[n - 1].hdd = rnd.next(1, high_hdd - 100);\n        do {\n            laptops[n - 1].cost = rnd.next(100, 1000);\n        } while (usedCosts.count(laptops[n -1].cost));\n        usedCosts.insert(laptops[n -1].cost);\n    } else if (type == \"no_outdated\") {\n        // No laptop is outdated\n        for (int i = 0; i < n; ++i) {\n            if (i % 3 == 0) {\n                laptops[i].speed = 4200;\n                laptops[i].ram = rnd.next(256, 3000);\n                laptops[i].hdd = rnd.next(1, 200);\n            } else if (i % 3 == 1) {\n                laptops[i].speed = rnd.next(1000, 3000);\n                laptops[i].ram = 4096;\n                laptops[i].hdd = rnd.next(1, 200);\n            } else {\n                laptops[i].speed = rnd.next(1000, 3000);\n                laptops[i].ram = rnd.next(256, 3000);\n                laptops[i].hdd = 500;\n            }\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"same_props\") {\n        // All laptops have the same properties but different costs\n        int speed = rnd.next(1000, 4200);\n        int ram = rnd.next(256, 4096);\n        int hdd = rnd.next(1, 500);\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = speed;\n            laptops[i].ram = ram;\n            laptops[i].hdd = hdd;\n            do {\n                laptops[i].cost = 100 + rnd.next(0, 900);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"chain\") {\n        // Laptops form a chain where each next laptop dominates the previous\n        int speed = rnd.next(1000, 1200);\n        int ram = rnd.next(256, 512);\n        int hdd = rnd.next(1, 50);\n        int delta_speed = rnd.next(1, (4200 - speed) / n);\n        int delta_ram = rnd.next(1, (4096 - ram) / n);\n        int delta_hdd = rnd.next(1, (500 - hdd) / n);\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = speed + delta_speed * i;\n            laptops[i].ram = ram + delta_ram * i;\n            laptops[i].hdd = hdd + delta_hdd * i;\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"max_props\") {\n        // All laptops have maximum properties\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = 4200;\n            laptops[i].ram = 4096;\n            laptops[i].hdd = 500;\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"min_props\") {\n        // All laptops have minimum properties\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = 1000;\n            laptops[i].ram = 256;\n            laptops[i].hdd = 1;\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else if (type == \"equal_props\") {\n        // Laptops with some properties equal\n        int base_speed = rnd.next(1000, 4200);\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = base_speed;\n            laptops[i].ram = rnd.next(256, 4096);\n            laptops[i].hdd = rnd.next(1, 500);\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    } else {\n        // Default to random if type not recognized\n        for (int i = 0; i < n; ++i) {\n            laptops[i].speed = rnd.next(1000, 4200);\n            laptops[i].ram = rnd.next(256, 4096);\n            laptops[i].hdd = rnd.next(1, 500);\n            do {\n                laptops[i].cost = rnd.next(100, 1000);\n            } while (usedCosts.count(laptops[i].cost));\n            usedCosts.insert(laptops[i].cost);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d\\n\", laptops[i].speed, laptops[i].ram, laptops[i].hdd, laptops[i].cost);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 20 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n\n./gen -n 5 -type one_outdated\n./gen -n 10 -type one_outdated\n./gen -n 20 -type one_outdated\n./gen -n 50 -type one_outdated\n./gen -n 100 -type one_outdated\n\n./gen -n 5 -type no_outdated\n./gen -n 10 -type no_outdated\n./gen -n 20 -type no_outdated\n./gen -n 50 -type no_outdated\n./gen -n 100 -type no_outdated\n\n./gen -n 5 -type same_props\n./gen -n 10 -type same_props\n./gen -n 20 -type same_props\n./gen -n 50 -type same_props\n./gen -n 100 -type same_props\n\n./gen -n 5 -type chain\n./gen -n 10 -type chain\n./gen -n 20 -type chain\n./gen -n 50 -type chain\n./gen -n 100 -type chain\n\n./gen -n 5 -type max_props\n./gen -n 10 -type max_props\n./gen -n 20 -type max_props\n./gen -n 50 -type max_props\n./gen -n 100 -type max_props\n\n./gen -n 5 -type min_props\n./gen -n 10 -type min_props\n./gen -n 20 -type min_props\n./gen -n 50 -type min_props\n./gen -n 100 -type min_props\n\n./gen -n 5 -type equal_props\n./gen -n 10 -type equal_props\n./gen -n 20 -type equal_props\n./gen -n 50 -type equal_props\n./gen -n 100 -type equal_props\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:11.441742",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "106/C",
      "title": "C. Buns",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains 4 integers n, m, c0 and d0 (1 ≤ n ≤ 1000, 1 ≤ m ≤ 10, 1 ≤ c0, d0 ≤ 100). Each of the following m lines contains 4 integers. The i-th line contains numbers ai, bi, ci and di (1 ≤ ai, bi, ci, di ≤ 100).",
      "output_spec": "OutputPrint the only number — the maximum number of tugriks Lavrenty can earn.",
      "sample_tests": "ExamplesInputCopy10 2 2 17 3 2 10012 3 1 10OutputCopy241InputCopy100 1 25 5015 5 20 10OutputCopy200",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains 4 integers n, m, c0 and d0 (1 ≤ n ≤ 1000, 1 ≤ m ≤ 10, 1 ≤ c0, d0 ≤ 100). Each of the following m lines contains 4 integers. The i-th line contains numbers ai, bi, ci and di (1 ≤ ai, bi, ci, di ≤ 100).\n\nOutputPrint the only number — the maximum number of tugriks Lavrenty can earn.\n\nInputCopy10 2 2 17 3 2 10012 3 1 10OutputCopy241InputCopy100 1 25 5015 5 20 10OutputCopy200\n\nInputCopy10 2 2 17 3 2 10012 3 1 10\n\nOutputCopy241\n\nInputCopy100 1 25 5015 5 20 10\n\nOutputCopy200\n\nNoteTo get the maximum number of tugriks in the first sample, you need to cook 2 buns with stuffing 1, 4 buns with stuffing 2 and a bun without any stuffing.In the second sample Lavrenty should cook 4 buns without stuffings.",
      "solutions": [
        {
          "title": "Solutions for Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "A. (link) Solution of this problem is written in the fourth paragraph of the statements. You should carefully read and implement it. Only one difficult part is how to to determine which card has higher rank. You can for every card iterate over array [ '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' ] and determine numbers of ranks in this array. Finally, just compare them. B. (link) You can create array for all laptops where true for outdated laptop and false otherwise. Value of every cell of this array you can determine by iterating over all laptops and comparing all their parameters. At the end you should itarate over all laptops once again and choose cheapest one that is not outdated.C. (link) Let create array dp by size n x m. dp[i][j] means maximum number of tugriks that the baker can earn if he used i grams of dough and cook buns with stuffings of types 1..j.Initially dp[i][0] is 0 for all i.You can easily calculate this dp:dp[i][j] = max{ dp[i-c[j]*k][j-1] + d[j]*k } for every k from 0 to a[j]/b[j], for which i-c[j]*k>=0The answer will be max{ dp[k][m] + ((n-k)/c0)*d0 } for every k from 0 to n.Of course, all divisions in editorial of this problem are integer.Solution works in O(nma), where a is maximum a_i.D. (link) Solution is simulation of all insrtuctions from all of local sights. But naive solution doesn't fit into time limit. You should speed up this solution and do every instruction in O(1).You can use one of following things.1. For every position and every direction you can precalculate nearest position of sea. Now before than you do an instruction you should check that nearest position of sea further than position whereto you move after doing the instruction.2. Let sea cells have 1 and all other ones have 0. For every cell (i,j) you can calculate sum of all cells in the rectangle with angles in (1,1) and (i,j). It can be done by the operations like:sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + smthwhere smth is 0 or 1 according to type of according cell (i,j). Now you can determine sum of numbers for all rectangles of the map. Before you do instruction you should chech that sum of rectangle on which you will go has sum 0.Solution has complexity O(nm + kz), where z is number of local sights (this number no more than 26).E. (link) Author's solution is three ternary search for every demension that are nested within each other.It works because the function is convex. Maximum of convex functions also convex function. Author not very well imagine convex function in 3 dimrnsions, therefore you can read following proof that algorithm is correct:Let consider some straight line. Function of distance between points on this line and planet position will be convex (you can imagine it). If you get maximum of such functions it will be convex function too. Let's call this function f1.Now let's consider flat plane and choose one straight line in it. Set for every point of this line a minumum of function f1 of line that passes through this point and is perpendicular to choosen line. Let's call function on this choosen line f2.f2 is convex. It can be easily proved by contrary. If f2 is not convex, we can find at least two local minimums. Let's choose two neighbour of them. We can find this two minimums on the plane and drawn through them new line. f1 on this line will be not convex (you also can imagine it). Сontradiction.Now let's consider all space. Choose one line in it and define function f3 on it. Values of f3 will be minimums of functions f2 of planes that passes through the line and is perpendicular to it. f3 also is convex. Proof of it is analogically to that is written in the previous paragraph. []Now you can see that minimum can ge found by three ternary search over functions fi. You can add to these functions returning of value in which they reach a minimum.Also there are solutions that uses idea of Gradient descent or Hill climbing. Author was unable to write this solution (not enough precision), but some participants got AC with such solutions.There is exact solution O(n^4) (more exactly O(C_n^4)). This solution uses Helly's theorem and Jung's theorem that follows from the first one:http://en.wikipedia.org/wiki/Helly's_theoremIn this solution you should itarate over all pairs, triples and fours of points and for every of them build minimal ball that cover them. Answer is center of ball with maximum radius.Also you can google something like thathttp://www.inf.ethz.ch/personal/gaertner/miniball.htmlThere are code and article, but the author of contest is not particularly delved into them))",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2493",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4587
        },
        {
          "title": "Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "Good evening.Today's round is mine, as the previous one. This round will be for participants of the second division. Participants of the first division can take part in the round out of competition.RAD, Connector, it4.kp and MikeMirzayanov helped me to prepare this round. Delinur translated statements into English.Contest will be in the good old tradition of Codeforces. No any innovations, pretty short and clear statements.Points for problems are standard: 500-1000-1500-2000-2500.Good luck everyone!UPD. Round was ended, ratings was updated.Winners:1. tsundere2. jte3. abacadaea4. ltaravilse5. Billy_HerringtonEditorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2484",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 625
        },
        {
          "title": "Solutions for Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "A. (link) Solution of this problem is written in the fourth paragraph of the statements. You should carefully read and implement it. Only one difficult part is how to to determine which card has higher rank. You can for every card iterate over array [ '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' ] and determine numbers of ranks in this array. Finally, just compare them. B. (link) You can create array for all laptops where true for outdated laptop and false otherwise. Value of every cell of this array you can determine by iterating over all laptops and comparing all their parameters. At the end you should itarate over all laptops once again and choose cheapest one that is not outdated.C. (link) Let create array dp by size n x m. dp[i][j] means maximum number of tugriks that the baker can earn if he used i grams of dough and cook buns with stuffings of types 1..j.Initially dp[i][0] is 0 for all i.You can easily calculate this dp:dp[i][j] = max{ dp[i-c[j]*k][j-1] + d[j]*k } for every k from 0 to a[j]/b[j], for which i-c[j]*k>=0The answer will be max{ dp[k][m] + ((n-k)/c0)*d0 } for every k from 0 to n.Of course, all divisions in editorial of this problem are integer.Solution works in O(nma), where a is maximum a_i.D. (link) Solution is simulation of all insrtuctions from all of local sights. But naive solution doesn't fit into time limit. You should speed up this solution and do every instruction in O(1).You can use one of following things.1. For every position and every direction you can precalculate nearest position of sea. Now before than you do an instruction you should check that nearest position of sea further than position whereto you move after doing the instruction.2. Let sea cells have 1 and all other ones have 0. For every cell (i,j) you can calculate sum of all cells in the rectangle with angles in (1,1) and (i,j). It can be done by the operations like:sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + smthwhere smth is 0 or 1 according to type of according cell (i,j). Now you can determine sum of numbers for all rectangles of the map. Before you do instruction you should chech that sum of rectangle on which you will go has sum 0.Solution has complexity O(nm + kz), where z is number of local sights (this number no more than 26).E. (link) Author's solution is three ternary search for every demension that are nested within each other.It works because the function is convex. Maximum of convex functions also convex function. Author not very well imagine convex function in 3 dimrnsions, therefore you can read following proof that algorithm is correct:Let consider some straight line. Function of distance between points on this line and planet position will be convex (you can imagine it). If you get maximum of such functions it will be convex function too. Let's call this function f1.Now let's consider flat plane and choose one straight line in it. Set for every point of this line a minumum of function f1 of line that passes through this point and is perpendicular to choosen line. Let's call function on this choosen line f2.f2 is convex. It can be easily proved by contrary. If f2 is not convex, we can find at least two local minimums. Let's choose two neighbour of them. We can find this two minimums on the plane and drawn through them new line. f1 on this line will be not convex (you also can imagine it). Сontradiction.Now let's consider all space. Choose one line in it and define function f3 on it. Values of f3 will be minimums of functions f2 of planes that passes through the line and is perpendicular to it. f3 also is convex. Proof of it is analogically to that is written in the previous paragraph. []Now you can see that minimum can ge found by three ternary search over functions fi. You can add to these functions returning of value in which they reach a minimum.Also there are solutions that uses idea of Gradient descent or Hill climbing. Author was unable to write this solution (not enough precision), but some participants got AC with such solutions.There is exact solution O(n^4) (more exactly O(C_n^4)). This solution uses Helly's theorem and Jung's theorem that follows from the first one:http://en.wikipedia.org/wiki/Helly's_theoremIn this solution you should itarate over all pairs, triples and fours of points and for every of them build minimal ball that cover them. Answer is center of ball with maximum radius.Also you can google something like thathttp://www.inf.ethz.ch/personal/gaertner/miniball.htmlThere are code and article, but the author of contest is not particularly delved into them))",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2493",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4587
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, c0, d0 from the first line\n    int n = inf.readInt(1, 1000, \"n\");  // 1 ≤ n ≤ 1000\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");    // 1 ≤ m ≤ 10\n    inf.readSpace();\n    int c0 = inf.readInt(1, 100, \"c0\"); // 1 ≤ c0 ≤ 100\n    inf.readSpace();\n    int d0 = inf.readInt(1, 100, \"d0\"); // 1 ≤ d0 ≤ 100\n    inf.readEoln();\n\n    // Read m lines, each containing ai, bi, ci, di\n    for(int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, 100);  // 1 ≤ ai ≤ 100\n        inf.readSpace();\n        int bi = inf.readInt(1, 100);  // 1 ≤ bi ≤ 100\n        inf.readSpace();\n        int ci = inf.readInt(1, 100);  // 1 ≤ ci ≤ 100\n        inf.readSpace();\n        int di = inf.readInt(1, 100);  // 1 ≤ di ≤ 100\n        inf.readEoln();\n    }\n    // Ensure the end of file is reached\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, c0, d0 from the first line\n    int n = inf.readInt(1, 1000, \"n\");  // 1 ≤ n ≤ 1000\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");    // 1 ≤ m ≤ 10\n    inf.readSpace();\n    int c0 = inf.readInt(1, 100, \"c0\"); // 1 ≤ c0 ≤ 100\n    inf.readSpace();\n    int d0 = inf.readInt(1, 100, \"d0\"); // 1 ≤ d0 ≤ 100\n    inf.readEoln();\n\n    // Read m lines, each containing ai, bi, ci, di\n    for(int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, 100);  // 1 ≤ ai ≤ 100\n        inf.readSpace();\n        int bi = inf.readInt(1, 100);  // 1 ≤ bi ≤ 100\n        inf.readSpace();\n        int ci = inf.readInt(1, 100);  // 1 ≤ ci ≤ 100\n        inf.readSpace();\n        int di = inf.readInt(1, 100);  // 1 ≤ di ≤ 100\n        inf.readEoln();\n    }\n    // Ensure the end of file is reached\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, c0, d0 from the first line\n    int n = inf.readInt(1, 1000, \"n\");  // 1 ≤ n ≤ 1000\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");    // 1 ≤ m ≤ 10\n    inf.readSpace();\n    int c0 = inf.readInt(1, 100, \"c0\"); // 1 ≤ c0 ≤ 100\n    inf.readSpace();\n    int d0 = inf.readInt(1, 100, \"d0\"); // 1 ≤ d0 ≤ 100\n    inf.readEoln();\n\n    // Read m lines, each containing ai, bi, ci, di\n    for(int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, 100);  // 1 ≤ ai ≤ 100\n        inf.readSpace();\n        int bi = inf.readInt(1, 100);  // 1 ≤ bi ≤ 100\n        inf.readSpace();\n        int ci = inf.readInt(1, 100);  // 1 ≤ ci ≤ 100\n        inf.readSpace();\n        int di = inf.readInt(1, 100);  // 1 ≤ di ≤ 100\n        inf.readEoln();\n    }\n    // Ensure the end of file is reached\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int c0, d0; // Plain bun dough and price\n    vector<int> ai(m), bi(m), ci(m), di(m);\n\n    if (type == \"zero_stuffings\") {\n        // Cannot make any stuffed buns\n        c0 = rnd.next(1, min(100, n));\n        d0 = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 50);\n            bi[i] = ai[i] + rnd.next(1, 50); // Ensure ai < bi\n            ci[i] = rnd.next(1, min(100, n));\n            di[i] = rnd.next(1, 100);\n        }\n    }\n    else if (type == \"plain_buns_better\") {\n        // Plain buns have better profit per dough unit\n        c0 = rnd.next(1, min(100, n));\n        d0 = rnd.next(50, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(50, 100);\n            bi[i] = rnd.next(1, min(ai[i], 50));\n            ci[i] = rnd.next(1, min(100, n));\n            di[i] = rnd.next(1, 49);\n        }\n    }\n    else if (type == \"stuffed_buns_better\") {\n        // Stuffed buns have better profit per dough unit\n        c0 = rnd.next(1, min(100, n));\n        d0 = rnd.next(1, 49);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(50, 100);\n            bi[i] = rnd.next(1, min(ai[i], 50));\n            ci[i] = rnd.next(1, min(100, n));\n            di[i] = rnd.next(50, 100);\n        }\n    }\n    else if (type == \"max_dough\") {\n        // Maximum dough\n        n = 1000;\n        c0 = rnd.next(1, 100);\n        d0 = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = rnd.next(1, min(ai[i], 100));\n            ci[i] = rnd.next(1, 100);\n            di[i] = rnd.next(1, 100);\n        }\n    }\n    else if (type == \"minimal_dough\") {\n        // Minimal dough\n        n = 1;\n        c0 = 1;\n        d0 = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = 1;\n            bi[i] = 1;\n            ci[i] = 1;\n            di[i] = rnd.next(1, 100);\n        }\n    }\n    else if (type == \"cannot_make_any_bun\") {\n        // Cannot make any buns\n        c0 = n + rnd.next(1, 10); // c0 > n\n        d0 = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 10);\n            bi[i] = rnd.next(1, min(ai[i], 10));\n            ci[i] = n + rnd.next(1, 10); // ci > n\n            di[i] = rnd.next(1, 100);\n        }\n    }\n    else {\n        // Random test case\n        c0 = rnd.next(1, min(100, n));\n        d0 = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = rnd.next(1, min(ai[i], 100));\n            ci[i] = rnd.next(1, min(100, n));\n            di[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, c0, d0);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d %d\\n\", ai[i], bi[i], ci[i], di[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int c0, d0; // Plain bun dough and price\n    vector<int> ai(m), bi(m), ci(m), di(m);\n\n    if (type == \"zero_stuffings\") {\n        // Cannot make any stuffed buns\n        c0 = rnd.next(1, min(100, n));\n        d0 = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 50);\n            bi[i] = ai[i] + rnd.next(1, 50); // Ensure ai < bi\n            ci[i] = rnd.next(1, min(100, n));\n            di[i] = rnd.next(1, 100);\n        }\n    }\n    else if (type == \"plain_buns_better\") {\n        // Plain buns have better profit per dough unit\n        c0 = rnd.next(1, min(100, n));\n        d0 = rnd.next(50, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(50, 100);\n            bi[i] = rnd.next(1, min(ai[i], 50));\n            ci[i] = rnd.next(1, min(100, n));\n            di[i] = rnd.next(1, 49);\n        }\n    }\n    else if (type == \"stuffed_buns_better\") {\n        // Stuffed buns have better profit per dough unit\n        c0 = rnd.next(1, min(100, n));\n        d0 = rnd.next(1, 49);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(50, 100);\n            bi[i] = rnd.next(1, min(ai[i], 50));\n            ci[i] = rnd.next(1, min(100, n));\n            di[i] = rnd.next(50, 100);\n        }\n    }\n    else if (type == \"max_dough\") {\n        // Maximum dough\n        n = 1000;\n        c0 = rnd.next(1, 100);\n        d0 = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = rnd.next(1, min(ai[i], 100));\n            ci[i] = rnd.next(1, 100);\n            di[i] = rnd.next(1, 100);\n        }\n    }\n    else if (type == \"minimal_dough\") {\n        // Minimal dough\n        n = 1;\n        c0 = 1;\n        d0 = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = 1;\n            bi[i] = 1;\n            ci[i] = 1;\n            di[i] = rnd.next(1, 100);\n        }\n    }\n    else if (type == \"cannot_make_any_bun\") {\n        // Cannot make any buns\n        c0 = n + rnd.next(1, 10); // c0 > n\n        d0 = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 10);\n            bi[i] = rnd.next(1, min(ai[i], 10));\n            ci[i] = n + rnd.next(1, 10); // ci > n\n            di[i] = rnd.next(1, 100);\n        }\n    }\n    else {\n        // Random test case\n        c0 = rnd.next(1, min(100, n));\n        d0 = rnd.next(1, 100);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = rnd.next(1, min(ai[i], 100));\n            ci[i] = rnd.next(1, min(100, n));\n            di[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, c0, d0);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d %d\\n\", ai[i], bi[i], ci[i], di[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -type random\n./gen -n 1 -m 3 -type minimal_dough\n./gen -n 1000 -m 10 -type max_dough\n./gen -n 500 -m 5 -type zero_stuffings\n./gen -n 100 -m 4 -type cannot_make_any_bun\n./gen -n 100 -m 4 -type plain_buns_better\n./gen -n 100 -m 4 -type stuffed_buns_better\n./gen -n 100 -m 10 -type zero_stuffings\n./gen -n 50 -m 10 -type random\n./gen -n 999 -m 7 -type random\n./gen -n 1000 -m 10 -type stuffed_buns_better\n./gen -n 1000 -m 10 -type plain_buns_better\n./gen -n 10 -m 2 -type cannot_make_any_bun\n./gen -n 10 -m 2 -type zero_stuffings\n./gen -n 1 -m 1 -type cannot_make_any_bun\n./gen -n 500 -m 5 -type random\n./gen -n 1000 -m 10 -type random\n./gen -n 1000 -m 1 -type random\n./gen -n 500 -m 10 -type max_dough\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 10 -type stuffed_buns_better\n./gen -n 1000 -m 10 -type cannot_make_any_bun\n./gen -n 1 -m 1 -type minimal_dough\n./gen -n 500 -m 10 -type zero_stuffings\n./gen -n 1000 -m 10 -type zero_stuffings\n./gen -n 100 -m 5 -type random\n./gen -n 100 -m 5 -type random\n./gen -n 200 -m 10 -type stuffed_buns_better\n./gen -n 300 -m 6 -type plain_buns_better\n./gen -n 400 -m 8 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:13.427718",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "106/D",
      "title": "D. Остров сокровищ",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке находятся два целых числа n и m (3 ≤ n, m ≤ 1000).Далее расположены n строк по m символов в каждой — описание карты острова. «#» означает море. Гарантируется, что все ячейки по периметру прямоугольника — море. «.» означает проходимую клетку без каких либо достопримечательностей, а достопримечательности обозначаются большими буквами латинского алфавита (от «A» до «Z»). Не все буквы алфавита могут быть использованы. Однако гарантируется, что хотя бы одна из них на карте присутствует. Все достопримечательности обозначены различными буквами.В следующей строке находится число k (1 ≤ k ≤ 105), после чего идут k строк, в каждой из которых описывается одна инструкция. Каждая из инструкций имеет вид «dir len», где dir — направление, а len — расстояние. dir может принимать значения «N», «S», «W» и «E» для севера, юга, запада и востока соответственно. При этом север находится наверху, юг внизу, запад слева, а восток справа. len — целое число от 1 до 1000.",
      "output_spec": "Выходные данныеВыведите все достопримечательности, удовлетворяющие инструкциям, в виде одной строки без каких либо разделителей в алфавитном порядке. Если ни одна из достопримечательностей не подходит, то выведите «no solution» без кавычек.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 10###########K#..######.#..##.###..L.#...####D###A.###########4N 2S 1E 1W 2Выходные данныеСкопироватьADВходные данныеСкопировать3 4#####.A#####2W 1N 2Выходные данныеСкопироватьno solution",
      "description": "D. Остров сокровищ\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке находятся два целых числа n и m (3 ≤ n, m ≤ 1000).Далее расположены n строк по m символов в каждой — описание карты острова. «#» означает море. Гарантируется, что все ячейки по периметру прямоугольника — море. «.» означает проходимую клетку без каких либо достопримечательностей, а достопримечательности обозначаются большими буквами латинского алфавита (от «A» до «Z»). Не все буквы алфавита могут быть использованы. Однако гарантируется, что хотя бы одна из них на карте присутствует. Все достопримечательности обозначены различными буквами.В следующей строке находится число k (1 ≤ k ≤ 105), после чего идут k строк, в каждой из которых описывается одна инструкция. Каждая из инструкций имеет вид «dir len», где dir — направление, а len — расстояние. dir может принимать значения «N», «S», «W» и «E» для севера, юга, запада и востока соответственно. При этом север находится наверху, юг внизу, запад слева, а восток справа. len — целое число от 1 до 1000.\n\nВходные данные\n\nВыходные данныеВыведите все достопримечательности, удовлетворяющие инструкциям, в виде одной строки без каких либо разделителей в алфавитном порядке. Если ни одна из достопримечательностей не подходит, то выведите «no solution» без кавычек.\n\nВыходные данные\n\nВходные данныеСкопировать6 10###########K#..######.#..##.###..L.#...####D###A.###########4N 2S 1E 1W 2Выходные данныеСкопироватьADВходные данныеСкопировать3 4#####.A#####2W 1N 2Выходные данныеСкопироватьno solution\n\nВходные данныеСкопировать6 10###########K#..######.#..##.###..L.#...####D###A.###########4N 2S 1E 1W 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьAD\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 4#####.A#####2W 1N 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьno solution\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Разбор задач Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "A. (ссылка) Решение этой задачи описано в четвертом абзаце условия. Его надо было внимательно прочитать и реализовать. Единственная сложность которая могла возникнуть - как опередить какое достоинство старше. Для этого можно было двумя проходами по массиву [ '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' ] определить номера достоинств карт в массиве, а полученные числа сравнить. B. (ссылка) Можно было использовать дополнительный массив, в котором true означает, что ноутбук устаревший, а false - что нет. Значение в каждой ячейке этого массива определяется проходом по всем ноутбукам и сравнения его параметров с параметрами текущего ноутбука. За еще один проход среди всех не устаревших ноутбуков нужно было выбрать самый дешевый.C. (ссылка) Создадим массив dp размера n на m. dp[i][j] будет означать максимальное количество денег, которое мы получим если используем i единиц теста и испечем булочки с начинками типов 1..j.Изначально dp[i][0] = 0 для всех i.Пересчитать данную динамику несложно:dp[i][j] = max{ dp[i-c[j]*k][j-1] + d[j]*k } по всем k от 0 до a[j]/b[j], для которых  i-c[j]*k>=0Ответом будет max{ dp[k][m] + ((n-k)/c0)*d0 } по всем k от 0 до n.Конечно же, в разборе данной задачи деление везде целочисленное.Полученное решение работает за O(nma), где a - максимум по a_i.D. (ссылка) Решение представляет собой симуляцию всех инструкций от всех достопримечательностей. Однако наивное решение не проходит по времени. Решение нужно ускорить, а именно: выполнение каждой инструкции должно быть выполнена за O(1).Это можно сделать одним из следующих способов.1. Для каждой позиции предпосчитать положение ближайшей клетки моря по всем четырем направлениям. Теперь перед каждым выполнением инструкции нужно смотреть попадем ли мы в клетку моря при выполнении.2. Для каждой клетки моря поставить в соответствие 1, а для всех остальных 0. После этого для каждой клетки (i,j) посчитать сумму чисел на прямоугольнике с углами в (1,1) и (i,j). Это можно сделать с помощью операций видаsum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + smthгде smth - это 0 или 1 в зависимости от текущей клетки. Похожим образом можно проверять есть ли клетки моря на любом прямоугольнике, например, на узком прямоугольнике ширины 1, по которому мы будем идти в процессе выполнения инструкции.Итоговое решение за время O(nm + kz), где z - количество достопримечательностей (это число не превосходит 26).E. (ссылка) Авторское решение - 3 вложенных друг в друга тернарных поиска по каждой из координат.Это работает, поскольку предложенная функция выпуклая - максимум выпуклых функций тоже выпуклая функция. Однако автор не совсем хорошо представляет себе выпуклую функцию в трехмерном пространстве, поэтому можно почитать следующее его доказательство корректности алгоритма:Рассмотрим какую либо прямую. Функция расстояния от точек на этой прямой до какой либо точки будет выпуклой вниз (ну, это несложно представить себе). Если теперь рассмотреть все точки, то у нас будет максимум от выпуклых вниз функций, что тоже есть выпуклая вниз функция. Назовем эту функцию f1. Еще надо отметить, что выпуклость тут строгая (т.е. константных кусков нет) (*).Теперь рассмотрим плоскость и выберем в ней прямую. Повесим на каждую точку этой прямой минимум из f1 от прямой, которая через эту точку проходит и перпендикулярна выбранной прямой. Назовем полученную функцию на выбранной прямой f2.Итак, f2 тоже выпукла вниз. Докажем это от противного - если это не так, то найдутся хотя бы два локальных минимума. Возьмем два соседних из них. Найдем точки где они находятся на плоскости и проведем через них прямую. И функция f1 на ней получится не выпуклая! (почему - несложно понять, если представить картинку и при этом учесть (*)). Противоречие.Теперь возьмем пространство. Проведем там прямую и заведем на ней функцию f3. Ее значениями будут минимумы f2 в плоскостях, перпендикулярных выбранной прямой. f3 тоже выпукла вниз - доказательство аналогично тому, что в предыдущем абзаце. []Итак, теперь несложно понять, что минимум найти несложно троичными поисками по fi. Если к этим функциям прикрепить еще возврат значения, где этот минимум достигается, то несложно получить и ответ.Также есть решения, которые используют идею градиентного спуска. Автору не удалось написать такое решения (не проходит по точности), но некоторые участники сдали такие решения.Еще есть точное решение за время O(n^4) (более точно - O(C_n^4)), использующее теорему Хелли и следующую из него теорему Юнга:http://ru.wikipedia.org/wiki/Теорема_Хеллиhttp://en.wikipedia.org/wiki/Helly's_theoremВ этом решении нужно перебрать все двойки, тройки и четверки точек и найти центр наименьшего шара, включающих их. После чего выбрать центр наибольшего из полученных шаров.Еще можно было нагуглить что то вродеhttp://www.inf.ethz.ch/personal/gaertner/miniball.htmlтам приложены статья и код, только автор контеста в них не особо вникал))",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2493",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4886
        },
        {
          "title": "Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "Добрый вечер.Сегодняшний раунд, как и прошлый, опять мой. Этот раунд будет для участников второго дивизиона, однако участники первого дивизиона тоже смогут принять участие вне конкурса.Раунд мне помогали готовить RAD, Connector, it4.kp, а также MikeMirzayanov. На английский язык условия перевела Delinur.На этот раз контест будет проходить в старых добрых традициях Codeforces. Никаких нововведений, в меру короткие и понятные условия.Разбалловка задач стандартная: 500-1000-1500-2000-2500.Всем удачи!UPD. Раунд завершен, рейтинги обновлены.Победители:1. tsundere2. jte3. abacadaea4. ltaravilse5. Billy_HerringtonРазбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2484",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 627
        },
        {
          "title": "Разбор задач Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "A. (ссылка) Решение этой задачи описано в четвертом абзаце условия. Его надо было внимательно прочитать и реализовать. Единственная сложность которая могла возникнуть - как опередить какое достоинство старше. Для этого можно было двумя проходами по массиву [ '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' ] определить номера достоинств карт в массиве, а полученные числа сравнить. B. (ссылка) Можно было использовать дополнительный массив, в котором true означает, что ноутбук устаревший, а false - что нет. Значение в каждой ячейке этого массива определяется проходом по всем ноутбукам и сравнения его параметров с параметрами текущего ноутбука. За еще один проход среди всех не устаревших ноутбуков нужно было выбрать самый дешевый.C. (ссылка) Создадим массив dp размера n на m. dp[i][j] будет означать максимальное количество денег, которое мы получим если используем i единиц теста и испечем булочки с начинками типов 1..j.Изначально dp[i][0] = 0 для всех i.Пересчитать данную динамику несложно:dp[i][j] = max{ dp[i-c[j]*k][j-1] + d[j]*k } по всем k от 0 до a[j]/b[j], для которых  i-c[j]*k>=0Ответом будет max{ dp[k][m] + ((n-k)/c0)*d0 } по всем k от 0 до n.Конечно же, в разборе данной задачи деление везде целочисленное.Полученное решение работает за O(nma), где a - максимум по a_i.D. (ссылка) Решение представляет собой симуляцию всех инструкций от всех достопримечательностей. Однако наивное решение не проходит по времени. Решение нужно ускорить, а именно: выполнение каждой инструкции должно быть выполнена за O(1).Это можно сделать одним из следующих способов.1. Для каждой позиции предпосчитать положение ближайшей клетки моря по всем четырем направлениям. Теперь перед каждым выполнением инструкции нужно смотреть попадем ли мы в клетку моря при выполнении.2. Для каждой клетки моря поставить в соответствие 1, а для всех остальных 0. После этого для каждой клетки (i,j) посчитать сумму чисел на прямоугольнике с углами в (1,1) и (i,j). Это можно сделать с помощью операций видаsum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + smthгде smth - это 0 или 1 в зависимости от текущей клетки. Похожим образом можно проверять есть ли клетки моря на любом прямоугольнике, например, на узком прямоугольнике ширины 1, по которому мы будем идти в процессе выполнения инструкции.Итоговое решение за время O(nm + kz), где z - количество достопримечательностей (это число не превосходит 26).E. (ссылка) Авторское решение - 3 вложенных друг в друга тернарных поиска по каждой из координат.Это работает, поскольку предложенная функция выпуклая - максимум выпуклых функций тоже выпуклая функция. Однако автор не совсем хорошо представляет себе выпуклую функцию в трехмерном пространстве, поэтому можно почитать следующее его доказательство корректности алгоритма:Рассмотрим какую либо прямую. Функция расстояния от точек на этой прямой до какой либо точки будет выпуклой вниз (ну, это несложно представить себе). Если теперь рассмотреть все точки, то у нас будет максимум от выпуклых вниз функций, что тоже есть выпуклая вниз функция. Назовем эту функцию f1. Еще надо отметить, что выпуклость тут строгая (т.е. константных кусков нет) (*).Теперь рассмотрим плоскость и выберем в ней прямую. Повесим на каждую точку этой прямой минимум из f1 от прямой, которая через эту точку проходит и перпендикулярна выбранной прямой. Назовем полученную функцию на выбранной прямой f2.Итак, f2 тоже выпукла вниз. Докажем это от противного - если это не так, то найдутся хотя бы два локальных минимума. Возьмем два соседних из них. Найдем точки где они находятся на плоскости и проведем через них прямую. И функция f1 на ней получится не выпуклая! (почему - несложно понять, если представить картинку и при этом учесть (*)). Противоречие.Теперь возьмем пространство. Проведем там прямую и заведем на ней функцию f3. Ее значениями будут минимумы f2 в плоскостях, перпендикулярных выбранной прямой. f3 тоже выпукла вниз - доказательство аналогично тому, что в предыдущем абзаце. []Итак, теперь несложно понять, что минимум найти несложно троичными поисками по fi. Если к этим функциям прикрепить еще возврат значения, где этот минимум достигается, то несложно получить и ответ.Также есть решения, которые используют идею градиентного спуска. Автору не удалось написать такое решения (не проходит по точности), но некоторые участники сдали такие решения.Еще есть точное решение за время O(n^4) (более точно - O(C_n^4)), использующее теорему Хелли и следующую из него теорему Юнга:http://ru.wikipedia.org/wiki/Теорема_Хеллиhttp://en.wikipedia.org/wiki/Helly's_theoremВ этом решении нужно перебрать все двойки, тройки и четверки точек и найти центр наименьшего шара, включающих их. После чего выбрать центр наибольшего из полученных шаров.Еще можно было нагуглить что то вродеhttp://www.inf.ethz.ch/personal/gaertner/miniball.htmlтам приложены статья и код, только автор контеста в них не особо вникал))",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2493",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4886
        }
      ],
      "code_examples": [
        {
          "title": "Разбор задач Codeforces Beta Round #82 (Div. 2) - Codeforces - Code 1",
          "code": "int main(){        scanf(\"%d\",&n);        for(int i = 0; i < n; i++)                scanf(\"%lf%lf%lf\",&x[i],&y[i],&z[i]);        double d = 1;        double xx=0,yy=0,zz=0;        for(int i = 0; i < 20000; i++)        {                double t=-1;int id = 0;                for(int j = 0; j < n; j++)                {                        double dis = sqr(x[j]-xx)+sqr(y[j]-yy)+sqr(z[j]-zz);                        if(dis>t)                        {                                t = dis;                                id = j;                        }                }                xx += (x[id]-xx)*d;                yy += (y[id]-yy)*d;                zz += (z[id]-zz)*d;                d *= 0.999;        }        printf(\"%.10f %.10f %.10f\\n\",xx,yy,zz);Почему данный алгоритм будет работать? В основном, большинство сдавших использовали именно эту идею, а не тройной поиск минимума функции одной переменной. То есть в данном алгоритме, мы просто итеративно со все уменьшаю-щимся шагом идем от исходной точки, до самой удаленной. Но почему, таким образом, мы с заданной точностью придем к единственной точкеминимума выпуклой функции.",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/2493",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Beta Round #82 (Div. 2) - Codeforces - Code 1",
          "code": "int main(){        scanf(\"%d\",&n);        for(int i = 0; i < n; i++)                scanf(\"%lf%lf%lf\",&x[i],&y[i],&z[i]);        double d = 1;        double xx=0,yy=0,zz=0;        for(int i = 0; i < 20000; i++)        {                double t=-1;int id = 0;                for(int j = 0; j < n; j++)                {                        double dis = sqr(x[j]-xx)+sqr(y[j]-yy)+sqr(z[j]-zz);                        if(dis>t)                        {                                t = dis;                                id = j;                        }                }                xx += (x[id]-xx)*d;                yy += (y[id]-yy)*d;                zz += (z[id]-zz)*d;                d *= 0.999;        }        printf(\"%.10f %.10f %.10f\\n\",xx,yy,zz);Почему данный алгоритм будет работать? В основном, большинство сдавших использовали именно эту идею, а не тройной поиск минимума функции одной переменной. То есть в данном алгоритме, мы просто итеративно со все уменьшаю-щимся шагом идем от исходной точки, до самой удаленной. Но почему, таким образом, мы с заданной точностью придем к единственной точкеминимума выпуклой функции.",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/2493",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    set<char> letters_found;\n    for(int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have exactly %d characters\", i+1, m);\n        for(int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.' || (c >= 'A' && c <= 'Z'), \n                    \"Invalid character '%c' at row %d, column %d\", c, i+1, j+1);\n            if(i == 0 || i == n - 1) {\n                ensuref(c == '#', \"Cell at row %d, column %d must be '#'\", i+1, j+1);\n            } else if(j == 0 || j == m - 1) {\n                ensuref(c == '#', \"Cell at row %d, column %d must be '#'\", i+1, j+1);\n            }\n            if(c >= 'A' && c <= 'Z') {\n                ensuref(letters_found.count(c) == 0, \"Letter '%c' occurs more than once\", c);\n                letters_found.insert(c);\n            }\n        }\n    }\n    ensuref(!letters_found.empty(), \"At least one sight must be present in the map\");\n\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    for(int i = 0; i < k; ++i) {\n        string dir = inf.readToken(\"^[NSEW]$\", \"dir\");\n        inf.readSpace();\n        int len = inf.readInt(1, 1000, \"len\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    set<char> letters_found;\n    for(int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have exactly %d characters\", i+1, m);\n        for(int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.' || (c >= 'A' && c <= 'Z'), \n                    \"Invalid character '%c' at row %d, column %d\", c, i+1, j+1);\n            if(i == 0 || i == n - 1) {\n                ensuref(c == '#', \"Cell at row %d, column %d must be '#'\", i+1, j+1);\n            } else if(j == 0 || j == m - 1) {\n                ensuref(c == '#', \"Cell at row %d, column %d must be '#'\", i+1, j+1);\n            }\n            if(c >= 'A' && c <= 'Z') {\n                ensuref(letters_found.count(c) == 0, \"Letter '%c' occurs more than once\", c);\n                letters_found.insert(c);\n            }\n        }\n    }\n    ensuref(!letters_found.empty(), \"At least one sight must be present in the map\");\n\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    for(int i = 0; i < k; ++i) {\n        string dir = inf.readToken(\"^[NSEW]$\", \"dir\");\n        inf.readSpace();\n        int len = inf.readInt(1, 1000, \"len\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    set<char> letters_found;\n    for(int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have exactly %d characters\", i+1, m);\n        for(int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.' || (c >= 'A' && c <= 'Z'), \n                    \"Invalid character '%c' at row %d, column %d\", c, i+1, j+1);\n            if(i == 0 || i == n - 1) {\n                ensuref(c == '#', \"Cell at row %d, column %d must be '#'\", i+1, j+1);\n            } else if(j == 0 || j == m - 1) {\n                ensuref(c == '#', \"Cell at row %d, column %d must be '#'\", i+1, j+1);\n            }\n            if(c >= 'A' && c <= 'Z') {\n                ensuref(letters_found.count(c) == 0, \"Letter '%c' occurs more than once\", c);\n                letters_found.insert(c);\n            }\n        }\n    }\n    ensuref(!letters_found.empty(), \"At least one sight must be present in the map\");\n\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    for(int i = 0; i < k; ++i) {\n        string dir = inf.readToken(\"^[NSEW]$\", \"dir\");\n        inf.readSpace();\n        int len = inf.readInt(1, 1000, \"len\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MIN_N = 3;\nconst int MAX_K = 100000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m within [MIN_N, MAX_N]\n    n = max(MIN_N, min(n, MAX_N));\n    m = max(MIN_N, min(m, MAX_N));\n    // Ensure k within [1, MAX_K]\n    k = max(1, min(k, MAX_K));\n\n    vector<string> grid(n, string(m, '#'));\n\n    // Generate the map\n    if (type == \"random\") {\n        // Random map\n        double p_land = 0.7; // probability of land\n        double p_sight = 0.02; // probability of sight\n        char current_sight = 'A';\n        int sight_count = 0;\n\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                if (rnd.next(0.0, 1.0) < p_land) {\n                    grid[i][j] = '.';\n                    if (rnd.next(0.0, 1.0) < p_sight && current_sight <= 'Z') {\n                        grid[i][j] = current_sight;\n                        current_sight++;\n                        sight_count++;\n                    }\n                } else {\n                    grid[i][j] = '#';\n                }\n            }\n        }\n        if(sight_count == 0) {\n            // Place at least one sight\n            for(int i = 1; i < n -1; i++) {\n                for(int j = 1; j < m -1; j++) {\n                    if(grid[i][j] == '.') {\n                        grid[i][j] = 'A';\n                        sight_count = 1;\n                        break;\n                    }\n                }\n                if(sight_count > 0) break;\n            }\n            // If still no sight, set one in the center\n            if(sight_count == 0) {\n                grid[n/2][m/2] = 'A';\n            }\n        }\n    } else if (type == \"dense\") {\n        // Map with mostly land\n        char current_sight = 'A';\n        int sight_count = 0;\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                grid[i][j] = '.';\n                if (rnd.next(10) == 0 && current_sight <= 'Z') {\n                    grid[i][j] = current_sight;\n                    current_sight++;\n                    sight_count++;\n                }\n            }\n        }\n        if(sight_count == 0) {\n            grid[n/2][m/2] = 'A';\n        }\n    } else if (type == \"sparse\") {\n        // Map with mostly sea\n        char current_sight = 'A';\n        int sight_count = 0;\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                if (rnd.next(10) == 0) {\n                    grid[i][j] = '.';\n                    if (rnd.next(10) == 0 && current_sight <= 'Z') {\n                        grid[i][j] = current_sight;\n                        current_sight++;\n                        sight_count++;\n                    }\n                } else {\n                    grid[i][j] = '#';\n                }\n            }\n        }\n        if(sight_count == 0) {\n            // Place at least one sight\n            for(int i = 1; i < n -1; i++) {\n                for(int j = 1; j < m -1; j++) {\n                    if(grid[i][j] == '.') {\n                        grid[i][j] = 'A';\n                        sight_count = 1;\n                        break;\n                    }\n                }\n                if(sight_count > 0) break;\n            }\n            if(sight_count == 0) {\n                grid[n/2][m/2] = 'A';\n            }\n        }\n    } else if (type == \"single_sight\") {\n        // Map with only one sight\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                grid[i][j] = '.';\n            }\n        }\n        grid[n/2][m/2] = 'A';\n    } else if (type == \"many_sights\") {\n        // Map with as many sights as possible\n        char current_sight = 'A';\n        for(int i = 1; i < n -1 && current_sight <= 'Z'; i++) {\n            for(int j = 1; j < m -1 && current_sight <= 'Z'; j++) {\n                grid[i][j] = current_sight;\n                current_sight++;\n            }\n        }\n        // Fill the rest with land\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                if(grid[i][j] == '#') {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Map where no starting point leads to a valid path\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                grid[i][j] = '#';\n            }\n        }\n        int i = n / 2;\n        int j = m / 2;\n        grid[i][j] = 'A'; // The sight is isolated\n        // Generate instructions that cannot be followed\n        k = 1;\n        vector<pair<string, int>> instructions;\n        instructions.push_back({\"N\", 1});\n\n        // Output the map\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n        // Output k\n        printf(\"%d\\n\", k);\n        printf(\"%s %d\\n\", instructions[0].first.c_str(), instructions[0].second);\n        return 0;\n    } else {\n        // Default to random\n        // Similar to \"random\" type\n        // (Implementation omitted for brevity)\n    }\n\n    // Generate instructions\n    vector<pair<string, int>> instructions;\n    for(int i = 0; i < k; ++i) {\n        int dir_choice = rnd.next(4);\n        string dir;\n        if(dir_choice == 0) dir = \"N\";\n        else if(dir_choice == 1) dir = \"S\";\n        else if(dir_choice == 2) dir = \"W\";\n        else dir = \"E\";\n\n        int len = rnd.next(1, 1000);\n        instructions.push_back({dir, len});\n    }\n\n    // Output the map\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    // Output k\n    printf(\"%d\\n\", k);\n    for(int i = 0; i < k; ++i) {\n        printf(\"%s %d\\n\", instructions[i].first.c_str(), instructions[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MIN_N = 3;\nconst int MAX_K = 100000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m within [MIN_N, MAX_N]\n    n = max(MIN_N, min(n, MAX_N));\n    m = max(MIN_N, min(m, MAX_N));\n    // Ensure k within [1, MAX_K]\n    k = max(1, min(k, MAX_K));\n\n    vector<string> grid(n, string(m, '#'));\n\n    // Generate the map\n    if (type == \"random\") {\n        // Random map\n        double p_land = 0.7; // probability of land\n        double p_sight = 0.02; // probability of sight\n        char current_sight = 'A';\n        int sight_count = 0;\n\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                if (rnd.next(0.0, 1.0) < p_land) {\n                    grid[i][j] = '.';\n                    if (rnd.next(0.0, 1.0) < p_sight && current_sight <= 'Z') {\n                        grid[i][j] = current_sight;\n                        current_sight++;\n                        sight_count++;\n                    }\n                } else {\n                    grid[i][j] = '#';\n                }\n            }\n        }\n        if(sight_count == 0) {\n            // Place at least one sight\n            for(int i = 1; i < n -1; i++) {\n                for(int j = 1; j < m -1; j++) {\n                    if(grid[i][j] == '.') {\n                        grid[i][j] = 'A';\n                        sight_count = 1;\n                        break;\n                    }\n                }\n                if(sight_count > 0) break;\n            }\n            // If still no sight, set one in the center\n            if(sight_count == 0) {\n                grid[n/2][m/2] = 'A';\n            }\n        }\n    } else if (type == \"dense\") {\n        // Map with mostly land\n        char current_sight = 'A';\n        int sight_count = 0;\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                grid[i][j] = '.';\n                if (rnd.next(10) == 0 && current_sight <= 'Z') {\n                    grid[i][j] = current_sight;\n                    current_sight++;\n                    sight_count++;\n                }\n            }\n        }\n        if(sight_count == 0) {\n            grid[n/2][m/2] = 'A';\n        }\n    } else if (type == \"sparse\") {\n        // Map with mostly sea\n        char current_sight = 'A';\n        int sight_count = 0;\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                if (rnd.next(10) == 0) {\n                    grid[i][j] = '.';\n                    if (rnd.next(10) == 0 && current_sight <= 'Z') {\n                        grid[i][j] = current_sight;\n                        current_sight++;\n                        sight_count++;\n                    }\n                } else {\n                    grid[i][j] = '#';\n                }\n            }\n        }\n        if(sight_count == 0) {\n            // Place at least one sight\n            for(int i = 1; i < n -1; i++) {\n                for(int j = 1; j < m -1; j++) {\n                    if(grid[i][j] == '.') {\n                        grid[i][j] = 'A';\n                        sight_count = 1;\n                        break;\n                    }\n                }\n                if(sight_count > 0) break;\n            }\n            if(sight_count == 0) {\n                grid[n/2][m/2] = 'A';\n            }\n        }\n    } else if (type == \"single_sight\") {\n        // Map with only one sight\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                grid[i][j] = '.';\n            }\n        }\n        grid[n/2][m/2] = 'A';\n    } else if (type == \"many_sights\") {\n        // Map with as many sights as possible\n        char current_sight = 'A';\n        for(int i = 1; i < n -1 && current_sight <= 'Z'; i++) {\n            for(int j = 1; j < m -1 && current_sight <= 'Z'; j++) {\n                grid[i][j] = current_sight;\n                current_sight++;\n            }\n        }\n        // Fill the rest with land\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                if(grid[i][j] == '#') {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Map where no starting point leads to a valid path\n        for(int i = 1; i < n -1; i++) {\n            for(int j = 1; j < m -1; j++) {\n                grid[i][j] = '#';\n            }\n        }\n        int i = n / 2;\n        int j = m / 2;\n        grid[i][j] = 'A'; // The sight is isolated\n        // Generate instructions that cannot be followed\n        k = 1;\n        vector<pair<string, int>> instructions;\n        instructions.push_back({\"N\", 1});\n\n        // Output the map\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", grid[i].c_str());\n        }\n        // Output k\n        printf(\"%d\\n\", k);\n        printf(\"%s %d\\n\", instructions[0].first.c_str(), instructions[0].second);\n        return 0;\n    } else {\n        // Default to random\n        // Similar to \"random\" type\n        // (Implementation omitted for brevity)\n    }\n\n    // Generate instructions\n    vector<pair<string, int>> instructions;\n    for(int i = 0; i < k; ++i) {\n        int dir_choice = rnd.next(4);\n        string dir;\n        if(dir_choice == 0) dir = \"N\";\n        else if(dir_choice == 1) dir = \"S\";\n        else if(dir_choice == 2) dir = \"W\";\n        else dir = \"E\";\n\n        int len = rnd.next(1, 1000);\n        instructions.push_back({dir, len});\n    }\n\n    // Output the map\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    // Output k\n    printf(\"%d\\n\", k);\n    for(int i = 0; i < k; ++i) {\n        printf(\"%s %d\\n\", instructions[i].first.c_str(), instructions[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 3 -k 1 -type impossible\n./gen -n 3 -m 3 -k 1 -type single_sight\n./gen -n 1000 -m 1000 -k 100000 -type random\n./gen -n 1000 -m 1000 -k 100000 -type dense\n./gen -n 1000 -m 1000 -k 100000 -type sparse\n./gen -n 500 -m 500 -k 50000 -type random\n./gen -n 500 -m 500 -k 50000 -type dense\n./gen -n 500 -m 500 -k 50000 -type sparse\n./gen -n 100 -m 100 -k 1000 -type random\n./gen -n 100 -m 100 -k 1000 -type single_sight\n./gen -n 100 -m 100 -k 1000 -type many_sights\n./gen -n 50 -m 50 -k 50000 -type random\n./gen -n 50 -m 50 -k 50000 -type dense\n./gen -n 50 -m 50 -k 50000 -type sparse\n./gen -n 3 -m 1000 -k 100000 -type random\n./gen -n 1000 -m 3 -k 100000 -type random\n./gen -n 500 -m 3 -k 50000 -type single_sight\n./gen -n 3 -m 500 -k 50000 -type single_sight\n./gen -n 3 -m 3 -k 1 -type random\n./gen -n 10 -m 15 -k 10 -type random\n./gen -n 10 -m 15 -k 10 -type dense\n./gen -n 10 -m 15 -k 10 -type sparse\n./gen -n 999 -m 999 -k 99999 -type random\n./gen -n 999 -m 999 -k 99999 -type many_sights\n./gen -n 300 -m 700 -k 70000 -type random\n./gen -n 300 -m 700 -k 70000 -type sparse\n./gen -n 100 -m 100 -k 1 -type dense\n./gen -n 1000 -m 1000 -k 100000 -type many_sights\n./gen -n 3 -m 3 -k 1 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:14.982666",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "106/E",
      "title": "E. Космические спасатели",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке входного файла содержится целое число n — количество планет (1 ≤ N ≤ 100). Каждая из последующих n строк содержит информация о планетах. i-я из этих строк содержит три целых числа xi, yi, zi — координаты i-й планеты ( - 104 ≤ xi, yi, zi ≤ 104, 1 ≤ i ≤ n). Никакие две планеты не совпадают.",
      "output_spec": "Выходные данныеВ первой строке выходного файла следует вывести три вещественных числа через пробел x0, y0, z0 — координаты будущей базы. Если существует несколько решений, то разрешается вывести любое. Ответ будет засчитан, если расстояние от данной точки до самой удаленной планеты будет отличаться от результата жюри не более чем на 10 - 6 по абсолютному или относительному значению.",
      "sample_tests": "ПримерыВходные данныеСкопировать55 0 0-5 0 00 3 44 -3 02 2 -2Выходные данныеСкопировать0.000 0.000 0.000",
      "description": "E. Космические спасатели\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входного файла содержится целое число n — количество планет (1 ≤ N ≤ 100). Каждая из последующих n строк содержит информация о планетах. i-я из этих строк содержит три целых числа xi, yi, zi — координаты i-й планеты ( - 104 ≤ xi, yi, zi ≤ 104, 1 ≤ i ≤ n). Никакие две планеты не совпадают.\n\nВходные данные\n\nВыходные данныеВ первой строке выходного файла следует вывести три вещественных числа через пробел x0, y0, z0 — координаты будущей базы. Если существует несколько решений, то разрешается вывести любое. Ответ будет засчитан, если расстояние от данной точки до самой удаленной планеты будет отличаться от результата жюри не более чем на 10 - 6 по абсолютному или относительному значению.\n\nВыходные данные\n\nВходные данныеСкопировать55 0 0-5 0 00 3 44 -3 02 2 -2Выходные данныеСкопировать0.000 0.000 0.000\n\nВходные данныеСкопировать55 0 0-5 0 00 3 44 -3 02 2 -2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.000 0.000 0.000\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Разбор задач Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "A. (ссылка) Решение этой задачи описано в четвертом абзаце условия. Его надо было внимательно прочитать и реализовать. Единственная сложность которая могла возникнуть - как опередить какое достоинство старше. Для этого можно было двумя проходами по массиву [ '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' ] определить номера достоинств карт в массиве, а полученные числа сравнить. B. (ссылка) Можно было использовать дополнительный массив, в котором true означает, что ноутбук устаревший, а false - что нет. Значение в каждой ячейке этого массива определяется проходом по всем ноутбукам и сравнения его параметров с параметрами текущего ноутбука. За еще один проход среди всех не устаревших ноутбуков нужно было выбрать самый дешевый.C. (ссылка) Создадим массив dp размера n на m. dp[i][j] будет означать максимальное количество денег, которое мы получим если используем i единиц теста и испечем булочки с начинками типов 1..j.Изначально dp[i][0] = 0 для всех i.Пересчитать данную динамику несложно:dp[i][j] = max{ dp[i-c[j]*k][j-1] + d[j]*k } по всем k от 0 до a[j]/b[j], для которых  i-c[j]*k>=0Ответом будет max{ dp[k][m] + ((n-k)/c0)*d0 } по всем k от 0 до n.Конечно же, в разборе данной задачи деление везде целочисленное.Полученное решение работает за O(nma), где a - максимум по a_i.D. (ссылка) Решение представляет собой симуляцию всех инструкций от всех достопримечательностей. Однако наивное решение не проходит по времени. Решение нужно ускорить, а именно: выполнение каждой инструкции должно быть выполнена за O(1).Это можно сделать одним из следующих способов.1. Для каждой позиции предпосчитать положение ближайшей клетки моря по всем четырем направлениям. Теперь перед каждым выполнением инструкции нужно смотреть попадем ли мы в клетку моря при выполнении.2. Для каждой клетки моря поставить в соответствие 1, а для всех остальных 0. После этого для каждой клетки (i,j) посчитать сумму чисел на прямоугольнике с углами в (1,1) и (i,j). Это можно сделать с помощью операций видаsum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + smthгде smth - это 0 или 1 в зависимости от текущей клетки. Похожим образом можно проверять есть ли клетки моря на любом прямоугольнике, например, на узком прямоугольнике ширины 1, по которому мы будем идти в процессе выполнения инструкции.Итоговое решение за время O(nm + kz), где z - количество достопримечательностей (это число не превосходит 26).E. (ссылка) Авторское решение - 3 вложенных друг в друга тернарных поиска по каждой из координат.Это работает, поскольку предложенная функция выпуклая - максимум выпуклых функций тоже выпуклая функция. Однако автор не совсем хорошо представляет себе выпуклую функцию в трехмерном пространстве, поэтому можно почитать следующее его доказательство корректности алгоритма:Рассмотрим какую либо прямую. Функция расстояния от точек на этой прямой до какой либо точки будет выпуклой вниз (ну, это несложно представить себе). Если теперь рассмотреть все точки, то у нас будет максимум от выпуклых вниз функций, что тоже есть выпуклая вниз функция. Назовем эту функцию f1. Еще надо отметить, что выпуклость тут строгая (т.е. константных кусков нет) (*).Теперь рассмотрим плоскость и выберем в ней прямую. Повесим на каждую точку этой прямой минимум из f1 от прямой, которая через эту точку проходит и перпендикулярна выбранной прямой. Назовем полученную функцию на выбранной прямой f2.Итак, f2 тоже выпукла вниз. Докажем это от противного - если это не так, то найдутся хотя бы два локальных минимума. Возьмем два соседних из них. Найдем точки где они находятся на плоскости и проведем через них прямую. И функция f1 на ней получится не выпуклая! (почему - несложно понять, если представить картинку и при этом учесть (*)). Противоречие.Теперь возьмем пространство. Проведем там прямую и заведем на ней функцию f3. Ее значениями будут минимумы f2 в плоскостях, перпендикулярных выбранной прямой. f3 тоже выпукла вниз - доказательство аналогично тому, что в предыдущем абзаце. []Итак, теперь несложно понять, что минимум найти несложно троичными поисками по fi. Если к этим функциям прикрепить еще возврат значения, где этот минимум достигается, то несложно получить и ответ.Также есть решения, которые используют идею градиентного спуска. Автору не удалось написать такое решения (не проходит по точности), но некоторые участники сдали такие решения.Еще есть точное решение за время O(n^4) (более точно - O(C_n^4)), использующее теорему Хелли и следующую из него теорему Юнга:http://ru.wikipedia.org/wiki/Теорема_Хеллиhttp://en.wikipedia.org/wiki/Helly's_theoremВ этом решении нужно перебрать все двойки, тройки и четверки точек и найти центр наименьшего шара, включающих их. После чего выбрать центр наибольшего из полученных шаров.Еще можно было нагуглить что то вродеhttp://www.inf.ethz.ch/personal/gaertner/miniball.htmlтам приложены статья и код, только автор контеста в них не особо вникал))",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2493",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4886
        },
        {
          "title": "Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "Добрый вечер.Сегодняшний раунд, как и прошлый, опять мой. Этот раунд будет для участников второго дивизиона, однако участники первого дивизиона тоже смогут принять участие вне конкурса.Раунд мне помогали готовить RAD, Connector, it4.kp, а также MikeMirzayanov. На английский язык условия перевела Delinur.На этот раз контест будет проходить в старых добрых традициях Codeforces. Никаких нововведений, в меру короткие и понятные условия.Разбалловка задач стандартная: 500-1000-1500-2000-2500.Всем удачи!UPD. Раунд завершен, рейтинги обновлены.Победители:1. tsundere2. jte3. abacadaea4. ltaravilse5. Billy_HerringtonРазбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2484",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 627
        },
        {
          "title": "Разбор задач Codeforces Beta Round #82 (Div. 2) - Codeforces",
          "content": "A. (ссылка) Решение этой задачи описано в четвертом абзаце условия. Его надо было внимательно прочитать и реализовать. Единственная сложность которая могла возникнуть - как опередить какое достоинство старше. Для этого можно было двумя проходами по массиву [ '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' ] определить номера достоинств карт в массиве, а полученные числа сравнить. B. (ссылка) Можно было использовать дополнительный массив, в котором true означает, что ноутбук устаревший, а false - что нет. Значение в каждой ячейке этого массива определяется проходом по всем ноутбукам и сравнения его параметров с параметрами текущего ноутбука. За еще один проход среди всех не устаревших ноутбуков нужно было выбрать самый дешевый.C. (ссылка) Создадим массив dp размера n на m. dp[i][j] будет означать максимальное количество денег, которое мы получим если используем i единиц теста и испечем булочки с начинками типов 1..j.Изначально dp[i][0] = 0 для всех i.Пересчитать данную динамику несложно:dp[i][j] = max{ dp[i-c[j]*k][j-1] + d[j]*k } по всем k от 0 до a[j]/b[j], для которых  i-c[j]*k>=0Ответом будет max{ dp[k][m] + ((n-k)/c0)*d0 } по всем k от 0 до n.Конечно же, в разборе данной задачи деление везде целочисленное.Полученное решение работает за O(nma), где a - максимум по a_i.D. (ссылка) Решение представляет собой симуляцию всех инструкций от всех достопримечательностей. Однако наивное решение не проходит по времени. Решение нужно ускорить, а именно: выполнение каждой инструкции должно быть выполнена за O(1).Это можно сделать одним из следующих способов.1. Для каждой позиции предпосчитать положение ближайшей клетки моря по всем четырем направлениям. Теперь перед каждым выполнением инструкции нужно смотреть попадем ли мы в клетку моря при выполнении.2. Для каждой клетки моря поставить в соответствие 1, а для всех остальных 0. После этого для каждой клетки (i,j) посчитать сумму чисел на прямоугольнике с углами в (1,1) и (i,j). Это можно сделать с помощью операций видаsum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + smthгде smth - это 0 или 1 в зависимости от текущей клетки. Похожим образом можно проверять есть ли клетки моря на любом прямоугольнике, например, на узком прямоугольнике ширины 1, по которому мы будем идти в процессе выполнения инструкции.Итоговое решение за время O(nm + kz), где z - количество достопримечательностей (это число не превосходит 26).E. (ссылка) Авторское решение - 3 вложенных друг в друга тернарных поиска по каждой из координат.Это работает, поскольку предложенная функция выпуклая - максимум выпуклых функций тоже выпуклая функция. Однако автор не совсем хорошо представляет себе выпуклую функцию в трехмерном пространстве, поэтому можно почитать следующее его доказательство корректности алгоритма:Рассмотрим какую либо прямую. Функция расстояния от точек на этой прямой до какой либо точки будет выпуклой вниз (ну, это несложно представить себе). Если теперь рассмотреть все точки, то у нас будет максимум от выпуклых вниз функций, что тоже есть выпуклая вниз функция. Назовем эту функцию f1. Еще надо отметить, что выпуклость тут строгая (т.е. константных кусков нет) (*).Теперь рассмотрим плоскость и выберем в ней прямую. Повесим на каждую точку этой прямой минимум из f1 от прямой, которая через эту точку проходит и перпендикулярна выбранной прямой. Назовем полученную функцию на выбранной прямой f2.Итак, f2 тоже выпукла вниз. Докажем это от противного - если это не так, то найдутся хотя бы два локальных минимума. Возьмем два соседних из них. Найдем точки где они находятся на плоскости и проведем через них прямую. И функция f1 на ней получится не выпуклая! (почему - несложно понять, если представить картинку и при этом учесть (*)). Противоречие.Теперь возьмем пространство. Проведем там прямую и заведем на ней функцию f3. Ее значениями будут минимумы f2 в плоскостях, перпендикулярных выбранной прямой. f3 тоже выпукла вниз - доказательство аналогично тому, что в предыдущем абзаце. []Итак, теперь несложно понять, что минимум найти несложно троичными поисками по fi. Если к этим функциям прикрепить еще возврат значения, где этот минимум достигается, то несложно получить и ответ.Также есть решения, которые используют идею градиентного спуска. Автору не удалось написать такое решения (не проходит по точности), но некоторые участники сдали такие решения.Еще есть точное решение за время O(n^4) (более точно - O(C_n^4)), использующее теорему Хелли и следующую из него теорему Юнга:http://ru.wikipedia.org/wiki/Теорема_Хеллиhttp://en.wikipedia.org/wiki/Helly's_theoremВ этом решении нужно перебрать все двойки, тройки и четверки точек и найти центр наименьшего шара, включающих их. После чего выбрать центр наибольшего из полученных шаров.Еще можно было нагуглить что то вродеhttp://www.inf.ethz.ch/personal/gaertner/miniball.htmlтам приложены статья и код, только автор контеста в них не особо вникал))",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2493",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4886
        }
      ],
      "code_examples": [
        {
          "title": "Разбор задач Codeforces Beta Round #82 (Div. 2) - Codeforces - Code 1",
          "code": "int main(){        scanf(\"%d\",&n);        for(int i = 0; i < n; i++)                scanf(\"%lf%lf%lf\",&x[i],&y[i],&z[i]);        double d = 1;        double xx=0,yy=0,zz=0;        for(int i = 0; i < 20000; i++)        {                double t=-1;int id = 0;                for(int j = 0; j < n; j++)                {                        double dis = sqr(x[j]-xx)+sqr(y[j]-yy)+sqr(z[j]-zz);                        if(dis>t)                        {                                t = dis;                                id = j;                        }                }                xx += (x[id]-xx)*d;                yy += (y[id]-yy)*d;                zz += (z[id]-zz)*d;                d *= 0.999;        }        printf(\"%.10f %.10f %.10f\\n\",xx,yy,zz);Почему данный алгоритм будет работать? В основном, большинство сдавших использовали именно эту идею, а не тройной поиск минимума функции одной переменной. То есть в данном алгоритме, мы просто итеративно со все уменьшаю-щимся шагом идем от исходной точки, до самой удаленной. Но почему, таким образом, мы с заданной точностью придем к единственной точкеминимума выпуклой функции.",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/2493",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Beta Round #82 (Div. 2) - Codeforces - Code 1",
          "code": "int main(){        scanf(\"%d\",&n);        for(int i = 0; i < n; i++)                scanf(\"%lf%lf%lf\",&x[i],&y[i],&z[i]);        double d = 1;        double xx=0,yy=0,zz=0;        for(int i = 0; i < 20000; i++)        {                double t=-1;int id = 0;                for(int j = 0; j < n; j++)                {                        double dis = sqr(x[j]-xx)+sqr(y[j]-yy)+sqr(z[j]-zz);                        if(dis>t)                        {                                t = dis;                                id = j;                        }                }                xx += (x[id]-xx)*d;                yy += (y[id]-yy)*d;                zz += (z[id]-zz)*d;                d *= 0.999;        }        printf(\"%.10f %.10f %.10f\\n\",xx,yy,zz);Почему данный алгоритм будет работать? В основном, большинство сдавших использовали именно эту идею, а не тройной поиск минимума функции одной переменной. То есть в данном алгоритме, мы просто итеративно со все уменьшаю-щимся шагом идем от исходной точки, до самой удаленной. Но почему, таким образом, мы с заданной точностью придем к единственной точкеминимума выпуклой функции.",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/2493",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    \n    set<tuple<int, int, int>> points;\n    \n    for (int i = 1; i <= n; ++i) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readSpace();\n        int zi = inf.readInt(-10000, 10000, \"zi\");\n        inf.readEoln();\n        \n        auto point_t = make_tuple(xi, yi, zi);\n        ensuref(points.count(point_t) == 0, \"Point #%d (%d, %d, %d) is duplicated\", i, xi, yi, zi);\n        points.insert(point_t);\n    }\n    \n    inf.readEof();\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    \n    set<tuple<int, int, int>> points;\n    \n    for (int i = 1; i <= n; ++i) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readSpace();\n        int zi = inf.readInt(-10000, 10000, \"zi\");\n        inf.readEoln();\n        \n        auto point_t = make_tuple(xi, yi, zi);\n        ensuref(points.count(point_t) == 0, \"Point #%d (%d, %d, %d) is duplicated\", i, xi, yi, zi);\n        points.insert(point_t);\n    }\n    \n    inf.readEof();\n    \n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    \n    set<tuple<int, int, int>> points;\n    \n    for (int i = 1; i <= n; ++i) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readSpace();\n        int zi = inf.readInt(-10000, 10000, \"zi\");\n        inf.readEoln();\n        \n        auto point_t = make_tuple(xi, yi, zi);\n        ensuref(points.count(point_t) == 0, \"Point #%d (%d, %d, %d) is duplicated\", i, xi, yi, zi);\n        points.insert(point_t);\n    }\n    \n    inf.readEof();\n    \n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-6;\n\nint n;\nvector<tuple<double, double, double>> planets;\n\ndouble compute_max_distance(double x0, double y0, double z0) {\n    double max_dist = 0.0;\n    for (auto& planet : planets) {\n        double xi, yi, zi;\n        tie(xi, yi, zi) = planet;\n        double dx = xi - x0;\n        double dy = yi - y0;\n        double dz = zi - z0;\n        double dist = sqrt(dx * dx + dy * dy + dz * dz);\n        max_dist = max(max_dist, dist);\n    }\n    return max_dist;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 100);\n    planets.resize(n);\n    for (int i = 0; i < n; i++) {\n        double xi = inf.readDouble(-1e4, 1e4);\n        double yi = inf.readDouble(-1e4, 1e4);\n        double zi = inf.readDouble(-1e4, 1e4);\n        planets[i] = make_tuple(xi, yi, zi);\n    }\n\n    // Read jury's answer\n    double x_jury = ans.readDouble();\n    double y_jury = ans.readDouble();\n    double z_jury = ans.readDouble();\n    double d_max_jury = compute_max_distance(x_jury, y_jury, z_jury);\n\n    // Read participant's answer\n    double x_participant = ouf.readDouble();\n    double y_participant = ouf.readDouble();\n    double z_participant = ouf.readDouble();\n    double d_max_participant = compute_max_distance(x_participant, y_participant, z_participant);\n\n    // Check the distance\n    double abs_error = fabs(d_max_participant - d_max_jury);\n    double rel_error = abs_error / max(1.0, fabs(d_max_jury));\n\n    if (abs_error <= EPS || rel_error <= EPS) {\n        quitf(_ok, \"Accepted: participant's maximal distance %.10f, jury's maximal distance %.10f\", d_max_participant, d_max_jury);\n    } else {\n        quitf(_wa, \"Wrong answer: participant's maximal distance %.10f differs from jury's maximal distance %.10f more than %.10f\", d_max_participant, d_max_jury, EPS);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Planets: vector of (x, y, z)\n    vector<tuple<int,int,int>> planets;\n\n    if(type == \"random\") {\n        // Generate random planets ensuring no duplicates\n        set<tuple<int,int,int>> used;\n        while(planets.size() < n) {\n            int x = rnd.next(-10000, 10000);\n            int y = rnd.next(-10000, 10000);\n            int z = rnd.next(-10000, 10000);\n            tuple<int,int,int> point = make_tuple(x, y, z);\n            if(used.count(point) == 0) {\n                used.insert(point);\n                planets.push_back(point);\n            }\n        }\n    } else if (type == \"colinear\") {\n        // All planets in a straight line\n        int dx = rnd.next(1, 10);\n        int dy = rnd.next(1, 10);\n        int dz = rnd.next(1, 10);\n        int x0 = rnd.next(-10000, 10000);\n        int y0 = rnd.next(-10000, 10000);\n        int z0 = rnd.next(-10000, 10000);\n        for(int i = 0; i < n; ++i) {\n            int x = x0 + dx * i;\n            int y = y0 + dy * i;\n            int z = z0 + dz * i;\n            planets.push_back(make_tuple(x % 20001 - 10000, y % 20001 - 10000, z % 20001 - 10000));\n        }\n    } else if (type == \"coplanar\") {\n        // All planets in the z = 0 plane\n        set<pair<int,int>> used;\n        while(planets.size() < n) {\n            int x = rnd.next(-10000, 10000);\n            int y = rnd.next(-10000, 10000);\n            int z = 0;\n            pair<int,int> point2d = make_pair(x, y);\n            if(used.count(point2d) == 0) {\n                used.insert(point2d);\n                planets.push_back(make_tuple(x, y, z));\n            }\n        }\n    } else if (type == \"sphere\") {\n        // Planets on the surface of a sphere\n        int x0 = rnd.next(-5000, 5000);\n        int y0 = rnd.next(-5000, 5000);\n        int z0 = rnd.next(-5000, 5000);\n        int r = rnd.next(1, 10000);\n        set<tuple<int,int,int>> used;\n        while(planets.size() < n) {\n            double theta = rnd.next(0.0, 2.0 * M_PI);\n            double phi = acos(1.0 - 2.0 * rnd.next(0.0, 1.0));\n            double x = x0 + r * sin(phi) * cos(theta);\n            double y = y0 + r * sin(phi) * sin(theta);\n            double z = z0 + r * cos(phi);\n            int ix = (int)round(x);\n            int iy = (int)round(y);\n            int iz = (int)round(z);\n            if(abs(ix) > 10000 || abs(iy) > 10000 || abs(iz) > 10000) continue;\n            tuple<int,int,int> point = make_tuple(ix, iy, iz);\n            if(used.count(point) == 0) {\n                used.insert(point);\n                planets.push_back(point);\n            }\n        }\n    } else if (type == \"cube\") {\n        // Planets at the vertices of a cube\n        int x0 = rnd.next(-5000, 5000);\n        int y0 = rnd.next(-5000, 5000);\n        int z0 = rnd.next(-5000, 5000);\n        int d = rnd.next(1, 5000);\n        set<tuple<int,int,int>> used;\n        for(int dx = 0; dx <= 1; dx++)\n            for(int dy = 0; dy <= 1; dy++)\n                for(int dz = 0; dz <= 1; dz++) {\n                    int x = x0 + dx * d;\n                    int y = y0 + dy * d;\n                    int z = z0 + dz * d;\n                    if(abs(x) <= 10000 && abs(y) <= 10000 && abs(z) <= 10000) {\n                        tuple<int,int,int> point = make_tuple(x, y, z);\n                        if(used.count(point) == 0 && planets.size() < n) {\n                            used.insert(point);\n                            planets.push_back(point);\n                        }\n                    }\n                }\n        // Fill up with random points if needed\n        while(planets.size() < n) {\n            int x = rnd.next(-10000, 10000);\n            int y = rnd.next(-10000, 10000);\n            int z = rnd.next(-10000, 10000);\n            tuple<int,int,int> point = make_tuple(x, y, z);\n            if(used.count(point) == 0) {\n                used.insert(point);\n                planets.push_back(point);\n            }\n        }\n    } else if (type == \"one_cluster\") {\n        // All planets at one point except one far away\n        int x0 = rnd.next(-5000, 5000);\n        int y0 = rnd.next(-5000, 5000);\n        int z0 = rnd.next(-5000, 5000);\n\n        for(int i = 0; i < n -1; ++i) {\n            planets.push_back(make_tuple(x0, y0, z0));\n        }\n\n        int x1 = x0 + rnd.next(9000, 10000);\n        int y1 = y0 + rnd.next(9000, 10000);\n        int z1 = z0 + rnd.next(9000, 10000);\n        if(abs(x1) > 10000) x1 = x0 + 10000;\n        if(abs(y1) > 10000) y1 = y0 + 10000;\n        if(abs(z1) > 10000) z1 = z0 + 10000;\n\n        planets.push_back(make_tuple(x1, y1, z1));\n    } else if (type == \"two_clusters\") {\n        // Planets in two clusters far from each other\n        int x0 = rnd.next(-5000, 5000);\n        int y0 = rnd.next(-5000, 5000);\n        int z0 = rnd.next(-5000, 5000);\n\n        int x1 = x0 + rnd.next(9000, 10000);\n        int y1 = y0 + rnd.next(9000, 10000);\n        int z1 = z0 + rnd.next(9000, 10000);\n        if(abs(x1) > 10000) x1 = x0 + 10000;\n        if(abs(y1) > 10000) y1 = y0 + 10000;\n        if(abs(z1) > 10000) z1 = z0 + 10000;\n\n        for(int i = 0; i < n / 2; ++i) {\n            planets.push_back(make_tuple(x0, y0, z0));\n        }\n        while(planets.size() < n) {\n            planets.push_back(make_tuple(x1, y1, z1));\n        }\n    } else if (type == \"small_random\") {\n        // Random coordinates in smaller range\n        set<tuple<int,int,int>> used;\n        while(planets.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            int z = rnd.next(-100, 100);\n            tuple<int,int,int> point = make_tuple(x, y, z);\n            if(used.count(point) == 0) {\n                used.insert(point);\n                planets.push_back(point);\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the planets\n    printf(\"%d\\n\", n);\n    for(auto &p : planets) {\n        int x, y, z;\n        tie(x, y, z) = p;\n        printf(\"%d %d %d\\n\", x, y, z);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Planets: vector of (x, y, z)\n    vector<tuple<int,int,int>> planets;\n\n    if(type == \"random\") {\n        // Generate random planets ensuring no duplicates\n        set<tuple<int,int,int>> used;\n        while(planets.size() < n) {\n            int x = rnd.next(-10000, 10000);\n            int y = rnd.next(-10000, 10000);\n            int z = rnd.next(-10000, 10000);\n            tuple<int,int,int> point = make_tuple(x, y, z);\n            if(used.count(point) == 0) {\n                used.insert(point);\n                planets.push_back(point);\n            }\n        }\n    } else if (type == \"colinear\") {\n        // All planets in a straight line\n        int dx = rnd.next(1, 10);\n        int dy = rnd.next(1, 10);\n        int dz = rnd.next(1, 10);\n        int x0 = rnd.next(-10000, 10000);\n        int y0 = rnd.next(-10000, 10000);\n        int z0 = rnd.next(-10000, 10000);\n        for(int i = 0; i < n; ++i) {\n            int x = x0 + dx * i;\n            int y = y0 + dy * i;\n            int z = z0 + dz * i;\n            planets.push_back(make_tuple(x % 20001 - 10000, y % 20001 - 10000, z % 20001 - 10000));\n        }\n    } else if (type == \"coplanar\") {\n        // All planets in the z = 0 plane\n        set<pair<int,int>> used;\n        while(planets.size() < n) {\n            int x = rnd.next(-10000, 10000);\n            int y = rnd.next(-10000, 10000);\n            int z = 0;\n            pair<int,int> point2d = make_pair(x, y);\n            if(used.count(point2d) == 0) {\n                used.insert(point2d);\n                planets.push_back(make_tuple(x, y, z));\n            }\n        }\n    } else if (type == \"sphere\") {\n        // Planets on the surface of a sphere\n        int x0 = rnd.next(-5000, 5000);\n        int y0 = rnd.next(-5000, 5000);\n        int z0 = rnd.next(-5000, 5000);\n        int r = rnd.next(1, 10000);\n        set<tuple<int,int,int>> used;\n        while(planets.size() < n) {\n            double theta = rnd.next(0.0, 2.0 * M_PI);\n            double phi = acos(1.0 - 2.0 * rnd.next(0.0, 1.0));\n            double x = x0 + r * sin(phi) * cos(theta);\n            double y = y0 + r * sin(phi) * sin(theta);\n            double z = z0 + r * cos(phi);\n            int ix = (int)round(x);\n            int iy = (int)round(y);\n            int iz = (int)round(z);\n            if(abs(ix) > 10000 || abs(iy) > 10000 || abs(iz) > 10000) continue;\n            tuple<int,int,int> point = make_tuple(ix, iy, iz);\n            if(used.count(point) == 0) {\n                used.insert(point);\n                planets.push_back(point);\n            }\n        }\n    } else if (type == \"cube\") {\n        // Planets at the vertices of a cube\n        int x0 = rnd.next(-5000, 5000);\n        int y0 = rnd.next(-5000, 5000);\n        int z0 = rnd.next(-5000, 5000);\n        int d = rnd.next(1, 5000);\n        set<tuple<int,int,int>> used;\n        for(int dx = 0; dx <= 1; dx++)\n            for(int dy = 0; dy <= 1; dy++)\n                for(int dz = 0; dz <= 1; dz++) {\n                    int x = x0 + dx * d;\n                    int y = y0 + dy * d;\n                    int z = z0 + dz * d;\n                    if(abs(x) <= 10000 && abs(y) <= 10000 && abs(z) <= 10000) {\n                        tuple<int,int,int> point = make_tuple(x, y, z);\n                        if(used.count(point) == 0 && planets.size() < n) {\n                            used.insert(point);\n                            planets.push_back(point);\n                        }\n                    }\n                }\n        // Fill up with random points if needed\n        while(planets.size() < n) {\n            int x = rnd.next(-10000, 10000);\n            int y = rnd.next(-10000, 10000);\n            int z = rnd.next(-10000, 10000);\n            tuple<int,int,int> point = make_tuple(x, y, z);\n            if(used.count(point) == 0) {\n                used.insert(point);\n                planets.push_back(point);\n            }\n        }\n    } else if (type == \"one_cluster\") {\n        // All planets at one point except one far away\n        int x0 = rnd.next(-5000, 5000);\n        int y0 = rnd.next(-5000, 5000);\n        int z0 = rnd.next(-5000, 5000);\n\n        for(int i = 0; i < n -1; ++i) {\n            planets.push_back(make_tuple(x0, y0, z0));\n        }\n\n        int x1 = x0 + rnd.next(9000, 10000);\n        int y1 = y0 + rnd.next(9000, 10000);\n        int z1 = z0 + rnd.next(9000, 10000);\n        if(abs(x1) > 10000) x1 = x0 + 10000;\n        if(abs(y1) > 10000) y1 = y0 + 10000;\n        if(abs(z1) > 10000) z1 = z0 + 10000;\n\n        planets.push_back(make_tuple(x1, y1, z1));\n    } else if (type == \"two_clusters\") {\n        // Planets in two clusters far from each other\n        int x0 = rnd.next(-5000, 5000);\n        int y0 = rnd.next(-5000, 5000);\n        int z0 = rnd.next(-5000, 5000);\n\n        int x1 = x0 + rnd.next(9000, 10000);\n        int y1 = y0 + rnd.next(9000, 10000);\n        int z1 = z0 + rnd.next(9000, 10000);\n        if(abs(x1) > 10000) x1 = x0 + 10000;\n        if(abs(y1) > 10000) y1 = y0 + 10000;\n        if(abs(z1) > 10000) z1 = z0 + 10000;\n\n        for(int i = 0; i < n / 2; ++i) {\n            planets.push_back(make_tuple(x0, y0, z0));\n        }\n        while(planets.size() < n) {\n            planets.push_back(make_tuple(x1, y1, z1));\n        }\n    } else if (type == \"small_random\") {\n        // Random coordinates in smaller range\n        set<tuple<int,int,int>> used;\n        while(planets.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            int z = rnd.next(-100, 100);\n            tuple<int,int,int> point = make_tuple(x, y, z);\n            if(used.count(point) == 0) {\n                used.insert(point);\n                planets.push_back(point);\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the planets\n    printf(\"%d\\n\", n);\n    for(auto &p : planets) {\n        int x, y, z;\n        tie(x, y, z) = p;\n        printf(\"%d %d %d\\n\", x, y, z);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type colinear\n./gen -n 1 -type coplanar\n\n./gen -n 2 -type random\n./gen -n 2 -type colinear\n./gen -n 2 -type coplanar\n\n./gen -n 3 -type random\n./gen -n 3 -type sphere\n./gen -n 3 -type cube\n\n./gen -n 5 -type random\n./gen -n 5 -type cube\n\n./gen -n 10 -type random\n./gen -n 10 -type colinear\n./gen -n 10 -type coplanar\n./gen -n 10 -type sphere\n./gen -n 10 -type cube\n./gen -n 10 -type one_cluster\n./gen -n 10 -type two_clusters\n\n./gen -n 50 -type random\n./gen -n 50 -type colinear\n./gen -n 50 -type coplanar\n./gen -n 50 -type sphere\n./gen -n 50 -type cube\n./gen -n 50 -type one_cluster\n./gen -n 50 -type two_clusters\n\n./gen -n 100 -type random\n./gen -n 100 -type colinear\n./gen -n 100 -type coplanar\n./gen -n 100 -type sphere\n./gen -n 100 -type cube\n./gen -n 100 -type one_cluster\n./gen -n 100 -type two_clusters\n./gen -n 100 -type small_random\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:16.788342",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1060/A",
      "title": "A. Phone Numbers",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains an integer nn — the number of cards with digits that you have (1≤n≤1001≤n≤100).The second line contains a string of nn digits (characters \"0\", \"1\", ..., \"9\") s1,s2,…,sns1,s2,…,sn. The string will not contain any other characters, such as leading or trailing spaces.",
      "output_spec": "OutputIf at least one phone number can be made from these cards, output the maximum number of phone numbers that can be made. Otherwise, output 0.",
      "sample_tests": "ExamplesInputCopy1100000000008OutputCopy1InputCopy220011223344556677889988OutputCopy2InputCopy1131415926535OutputCopy0",
      "description": "A. Phone Numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains an integer nn — the number of cards with digits that you have (1≤n≤1001≤n≤100).The second line contains a string of nn digits (characters \"0\", \"1\", ..., \"9\") s1,s2,…,sns1,s2,…,sn. The string will not contain any other characters, such as leading or trailing spaces.\n\nOutputIf at least one phone number can be made from these cards, output the maximum number of phone numbers that can be made. Otherwise, output 0.\n\nInputCopy1100000000008OutputCopy1InputCopy220011223344556677889988OutputCopy2InputCopy1131415926535OutputCopy0\n\nInputCopy1100000000008\n\nOutputCopy1\n\nInputCopy220011223344556677889988\n\nOutputCopy2\n\nInputCopy1131415926535\n\nOutputCopy0\n\nNoteIn the first example, one phone number, \"8000000000\", can be made from these cards.In the second example, you can make two phone numbers from the cards, for example, \"80123456789\" and \"80123456789\".In the third example you can't make any phone number from the given cards.",
      "solutions": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On Thursday, October 4, 2018 at 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On Thursday, October 4, 2018 at 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/113725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref((int)s.length() == n, \"Length of s should be %d, but it is %d\", n, (int)s.length());\n    for (int i = 0; i < n; ++i) {\n        ensuref('0' <= s[i] && s[i] <= '9', \"All characters in s should be digits, but s[%d] = '%c'\", i, s[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref((int)s.length() == n, \"Length of s should be %d, but it is %d\", n, (int)s.length());\n    for (int i = 0; i < n; ++i) {\n        ensuref('0' <= s[i] && s[i] <= '9', \"All characters in s should be digits, but s[%d] = '%c'\", i, s[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref((int)s.length() == n, \"Length of s should be %d, but it is %d\", n, (int)s.length());\n    for (int i = 0; i < n; ++i) {\n        ensuref('0' <= s[i] && s[i] <= '9', \"All characters in s should be digits, but s[%d] = '%c'\", i, s[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int num_eights = opt<int>(\"num_eights\", -1);\n\n    string s(n, '0');  // Initialize s with '0's\n\n    if (type == \"random\") {\n        // Fill s with random digits\n        for(int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(10); // Digit from '0' to '9'\n        }\n    } else if (type == \"no_eights\") {\n        // Fill s with digits '0'-'9', but without '8's\n        for(int i = 0; i < n; ++i) {\n            int d = rnd.next(9); // 0 to 8 (excluding 9)\n            if (d >= 8) d++; // Adjust to skip '8'\n            s[i] = '0' + d;\n        }\n    } else if (type == \"all_eights\") {\n        // Fill s with '8's\n        s = string(n, '8');\n    } else if (type == \"max_phone_numbers\") {\n        // Fill s to maximize number of phone numbers\n        int max_phone_numbers = n / 11;\n        int num_eights_in_s = min(max_phone_numbers, n);\n        int remaining_digits = n - num_eights_in_s;\n        vector<char> digits;\n\n        for (int i = 0; i < num_eights_in_s; ++i)\n            digits.push_back('8');\n        for (int i = 0; i < remaining_digits; ++i)\n            digits.push_back('0' + rnd.next(10)); // Digit from '0' to '9'\n\n        shuffle(digits.begin(), digits.end());\n        s.assign(digits.begin(), digits.end());\n    } else if (type == \"specified_eights\") {\n        // Ensure num_eights is specified\n        if (num_eights == -1) {\n            fprintf(stderr, \"Error: type specified_eights requires -num_eights parameter\\n\");\n            return 1;\n        }\n        if (num_eights > n) num_eights = n;\n        // Fill num_eights '8's and other digits randomly\n        vector<char> digits;\n        for (int i = 0; i < num_eights; ++i)\n            digits.push_back('8');\n        for (int i = num_eights; i < n; ++i)\n            digits.push_back('0' + rnd.next(10)); // Digit from '0' to '9'\n        shuffle(digits.begin(), digits.end());\n        s.assign(digits.begin(), digits.end());\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int num_eights = opt<int>(\"num_eights\", -1);\n\n    string s(n, '0');  // Initialize s with '0's\n\n    if (type == \"random\") {\n        // Fill s with random digits\n        for(int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(10); // Digit from '0' to '9'\n        }\n    } else if (type == \"no_eights\") {\n        // Fill s with digits '0'-'9', but without '8's\n        for(int i = 0; i < n; ++i) {\n            int d = rnd.next(9); // 0 to 8 (excluding 9)\n            if (d >= 8) d++; // Adjust to skip '8'\n            s[i] = '0' + d;\n        }\n    } else if (type == \"all_eights\") {\n        // Fill s with '8's\n        s = string(n, '8');\n    } else if (type == \"max_phone_numbers\") {\n        // Fill s to maximize number of phone numbers\n        int max_phone_numbers = n / 11;\n        int num_eights_in_s = min(max_phone_numbers, n);\n        int remaining_digits = n - num_eights_in_s;\n        vector<char> digits;\n\n        for (int i = 0; i < num_eights_in_s; ++i)\n            digits.push_back('8');\n        for (int i = 0; i < remaining_digits; ++i)\n            digits.push_back('0' + rnd.next(10)); // Digit from '0' to '9'\n\n        shuffle(digits.begin(), digits.end());\n        s.assign(digits.begin(), digits.end());\n    } else if (type == \"specified_eights\") {\n        // Ensure num_eights is specified\n        if (num_eights == -1) {\n            fprintf(stderr, \"Error: type specified_eights requires -num_eights parameter\\n\");\n            return 1;\n        }\n        if (num_eights > n) num_eights = n;\n        // Fill num_eights '8's and other digits randomly\n        vector<char> digits;\n        for (int i = 0; i < num_eights; ++i)\n            digits.push_back('8');\n        for (int i = num_eights; i < n; ++i)\n            digits.push_back('0' + rnd.next(10)); // Digit from '0' to '9'\n        shuffle(digits.begin(), digits.end());\n        s.assign(digits.begin(), digits.end());\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_eights\n./gen -n 1 -type no_eights\n\n./gen -n 11 -type random\n./gen -n 11 -type all_eights\n./gen -n 11 -type no_eights\n\n./gen -n 22 -type random\n./gen -n 22 -type max_phone_numbers\n\n./gen -n 50 -type random\n./gen -n 50 -type max_phone_numbers\n\n./gen -n 50 -type specified_eights -num_eights 5\n\n./gen -n 55 -type specified_eights -num_eights 5\n\n./gen -n 55 -type specified_eights -num_eights 10\n\n./gen -n 55 -type specified_eights -num_eights 0\n\n./gen -n 50 -type no_eights\n\n./gen -n 100 -type random\n\n./gen -n 99 -type random\n\n./gen -n 100 -type specified_eights -num_eights 9\n\n./gen -n 11 -type specified_eights -num_eights 1\n\n./gen -n 11 -type specified_eights -num_eights 0\n\n./gen -n 100 -type max_phone_numbers\n\n./gen -n 100 -type specified_eights -num_eights 100\n\n./gen -n 99 -type specified_eights -num_eights 9\n\n./gen -n 99 -type specified_eights -num_eights 90\n\n./gen -n 15 -type max_phone_numbers\n\n./gen -n 15 -type no_eights\n\n./gen -n 23 -type random\n\n./gen -n 38 -type random\n\n./gen -n 100 -type no_eights\n\n./gen -n 100 -type all_eights\n\n./gen -n 1 -type specified_eights -num_eights 1\n\n./gen -n 1 -type specified_eights -num_eights 0\n\n./gen -n 100 -type specified_eights -num_eights 50\n\n./gen -n 100 -type random\n\n./gen -n 5 -type no_eights\n\n./gen -n 105 -type random  # Note: This will produce an error because n is out of bounds\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:18.558511",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1060/B",
      "title": "B. Максимальная сумма цифр",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано целое число nn (1≤n≤1012)(1≤n≤1012).",
      "output_spec": "Выходные данныеВыведите максимальное S(a)+S(b)S(a)+S(b) среди всех пар целых чисел a,ba,b, таких, что 0≤a,b≤n0≤a,b≤n и a+b=na+b=n.",
      "sample_tests": "ПримерыВходные данныеСкопировать35Выходные данныеСкопировать17Входные данныеСкопировать10000000000Выходные данныеСкопировать91",
      "description": "B. Максимальная сумма цифр\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке записано целое число nn (1≤n≤1012)(1≤n≤1012).\n\nВходные данные\n\nВыходные данныеВыведите максимальное S(a)+S(b)S(a)+S(b) среди всех пар целых чисел a,ba,b, таких, что 0≤a,b≤n0≤a,b≤n и a+b=na+b=n.\n\nВыходные данные\n\nВходные данныеСкопировать35Выходные данныеСкопировать17Входные данныеСкопировать10000000000Выходные данныеСкопировать91\n\nВходные данныеСкопировать35\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать17\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10000000000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать91\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере можно выбрать, например, a=17a=17 и b=18b=18, получив S(17)+S(18)=1+7+1+8=17S(17)+S(18)=1+7+1+8=17. Можно показать, что больший ответ получить нельзя.Во втором тестовом примере можно выбрать, например, a=5000000001a=5000000001, b=4999999999b=4999999999, получив S(5000000001)+S(4999999999)=91S(5000000001)+S(4999999999)=91. Можно показать, что ответ больше получить нельзя.",
      "solutions": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On четверг, 4 октября 2018 г. в 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On четверг, 4 октября 2018 г. в 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/113725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long n;\n    if (type == \"small\") {\n        /* Small n between 1 and 10 */\n        n = rnd.next(1LL, 10LL);\n    } else if (type == \"power10\") {\n        /* n is a power of 10 */\n        int exp = rnd.next(0, 12);\n        n = 1LL;\n        for (int i = 0; i < exp; ++i)\n            n *= 10LL;\n    } else if (type == \"justbelow10power\") {\n        /* n is just below a power of 10 */\n        int exp = rnd.next(1, 12);\n        n = 1LL;\n        for (int i = 0; i < exp; ++i)\n            n *= 10LL;\n        n -= 1LL;\n    } else if (type == \"justabove10power\") {\n        /* n is just above a power of 10 */\n        int exp = rnd.next(0, 11);\n        n = 1LL;\n        for (int i = 0; i < exp; ++i)\n            n *= 10LL;\n        n += 1LL;\n    } else if (type == \"max\") {\n        /* Maximum n */\n        n = 1000000000000LL;\n    } else if (type == \"random\") {\n        /* Random n in range [1, 1e12] */\n        n = rnd.next(1LL, 1000000000000LL);\n    } else if (type == \"custom\") {\n        /* Custom n provided as parameter */\n        n = opt<long long>(\"n\");\n    } else {\n        /* Default random n */\n        n = rnd.next(1LL, 1000000000000LL);\n    }\n    printf(\"%lld\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long n;\n    if (type == \"small\") {\n        /* Small n between 1 and 10 */\n        n = rnd.next(1LL, 10LL);\n    } else if (type == \"power10\") {\n        /* n is a power of 10 */\n        int exp = rnd.next(0, 12);\n        n = 1LL;\n        for (int i = 0; i < exp; ++i)\n            n *= 10LL;\n    } else if (type == \"justbelow10power\") {\n        /* n is just below a power of 10 */\n        int exp = rnd.next(1, 12);\n        n = 1LL;\n        for (int i = 0; i < exp; ++i)\n            n *= 10LL;\n        n -= 1LL;\n    } else if (type == \"justabove10power\") {\n        /* n is just above a power of 10 */\n        int exp = rnd.next(0, 11);\n        n = 1LL;\n        for (int i = 0; i < exp; ++i)\n            n *= 10LL;\n        n += 1LL;\n    } else if (type == \"max\") {\n        /* Maximum n */\n        n = 1000000000000LL;\n    } else if (type == \"random\") {\n        /* Random n in range [1, 1e12] */\n        n = rnd.next(1LL, 1000000000000LL);\n    } else if (type == \"custom\") {\n        /* Custom n provided as parameter */\n        n = opt<long long>(\"n\");\n    } else {\n        /* Default random n */\n        n = rnd.next(1LL, 1000000000000LL);\n    }\n    printf(\"%lld\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small values\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Powers of 10\n./gen -type power10\n./gen -type power10\n./gen -type power10\n\n# Just below powers of 10\n./gen -type justbelow10power\n./gen -type justbelow10power\n./gen -type justbelow10power\n\n# Just above powers of 10\n./gen -type justabove10power\n./gen -type justabove10power\n./gen -type justabove10power\n\n# Maximum value\n./gen -type max\n\n# Random large values\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Custom specific values\n./gen -type custom -n 1\n./gen -type custom -n 9\n./gen -type custom -n 10\n./gen -type custom -n 99\n./gen -type custom -n 100\n./gen -type custom -n 999\n./gen -type custom -n 1000\n./gen -type custom -n 9999\n./gen -type custom -n 10000\n./gen -type custom -n 987654321098\n\n# Edge cases near the maximum\n./gen -type custom -n 999999999999\n./gen -type custom -n 1000000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:20.772416",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1060/C",
      "title": "C. Maximum Subrectangle",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two integers nn and mm (1≤n,m≤20001≤n,m≤2000).The second line contains nn integers a1,a2,…,ana1,a2,…,an (1≤ai≤20001≤ai≤2000).The third line contains mm integers b1,b2,…,bmb1,b2,…,bm (1≤bi≤20001≤bi≤2000).The fourth line contains a single integer xx (1≤x≤2⋅1091≤x≤2⋅109).",
      "output_spec": "OutputIf it is possible to choose four integers x1,x2,y1,y2x1,x2,y1,y2 such that 1≤x1≤x2≤n1≤x1≤x2≤n, 1≤y1≤y2≤m1≤y1≤y2≤m, and ∑x2i=x1∑y2j=y1ci,j≤x∑i=x1x2∑j=y1y2ci,j≤x, output the largest value of (x2−x1+1)×(y2−y1+1)(x2−x1+1)×(y2−y1+1) among all such quadruplets, otherwise output 00.",
      "sample_tests": "ExamplesInputCopy3 31 2 31 2 39OutputCopy4InputCopy5 15 4 2 4 525OutputCopy1",
      "description": "C. Maximum Subrectangle\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\n∑i=x1x2∑j=y1y2ci,j≤x.∑i=x1x2∑j=y1y2ci,j≤x.\n\nInputThe first line contains two integers nn and mm (1≤n,m≤20001≤n,m≤2000).The second line contains nn integers a1,a2,…,ana1,a2,…,an (1≤ai≤20001≤ai≤2000).The third line contains mm integers b1,b2,…,bmb1,b2,…,bm (1≤bi≤20001≤bi≤2000).The fourth line contains a single integer xx (1≤x≤2⋅1091≤x≤2⋅109).\n\nOutputIf it is possible to choose four integers x1,x2,y1,y2x1,x2,y1,y2 such that 1≤x1≤x2≤n1≤x1≤x2≤n, 1≤y1≤y2≤m1≤y1≤y2≤m, and ∑x2i=x1∑y2j=y1ci,j≤x∑i=x1x2∑j=y1y2ci,j≤x, output the largest value of (x2−x1+1)×(y2−y1+1)(x2−x1+1)×(y2−y1+1) among all such quadruplets, otherwise output 00.\n\nInputCopy3 31 2 31 2 39OutputCopy4InputCopy5 15 4 2 4 525OutputCopy1\n\nInputCopy3 31 2 31 2 39\n\nOutputCopy4\n\nInputCopy5 15 4 2 4 525\n\nOutputCopy1\n\nNoteMatrix from the first sample and the chosen subrectangle (of blue color):  Matrix from the second sample and the chosen subrectangle (of blue color):",
      "solutions": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On Thursday, October 4, 2018 at 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On Thursday, October 4, 2018 at 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/113725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 2000);\n    inf.readEoln();\n\n    inf.readInts(m, 1, 2000);\n    inf.readEoln();\n\n    int x = inf.readInt(1, 2000000000, \"x\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 2000);\n    inf.readEoln();\n\n    inf.readInts(m, 1, 2000);\n    inf.readEoln();\n\n    int x = inf.readInt(1, 2000000000, \"x\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 2000);\n    inf.readEoln();\n\n    inf.readInts(m, 1, 2000);\n    inf.readEoln();\n\n    int x = inf.readInt(1, 2000000000, \"x\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int x_value = opt<int>(\"x\", -1);\n\n    vector<int> a;\n    vector<int> b;\n    int x;\n    if(type == \"small_random\") {\n        n = min(n, 10);\n        m = min(m, 10);\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 10));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 10));\n        if(x_value == -1)\n            x = rnd.next(1, 1000);\n        else\n            x = x_value;\n    } else if(type == \"large_random\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    } else if(type == \"max_a_b\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(2000);\n        for(int i=0; i<m; ++i)\n            b.push_back(2000);\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    } else if(type == \"min_a_b\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(1);\n        for(int i=0; i<m; ++i)\n            b.push_back(1);\n        if(x_value == -1)\n            x = rnd.next(1, n * m);\n        else\n            x = x_value;\n    } else if(type == \"mixed_a_b\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    } else if(type == \"single_row\") {\n        n = 1;\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    } else if(type == \"single_column\") {\n        m = 1;\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    } else if(type == \"x_small\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        x = 1;\n    } else if(type == \"x_large\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        x = 2000000000;\n    } else {\n        // default random\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    }\n    x = max(1, min(x, 2000000000));\n    \n    printf(\"%d %d\\n\", n, m);\n    for(int i=0; i<n; ++i) {\n        printf(\"%d%c\", a[i], i==n-1?'\\n':' ');\n    }\n    for(int i=0; i<m; ++i) {\n        printf(\"%d%c\", b[i], i==m-1?'\\n':' ');\n    }\n    printf(\"%d\\n\", x);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int x_value = opt<int>(\"x\", -1);\n\n    vector<int> a;\n    vector<int> b;\n    int x;\n    if(type == \"small_random\") {\n        n = min(n, 10);\n        m = min(m, 10);\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 10));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 10));\n        if(x_value == -1)\n            x = rnd.next(1, 1000);\n        else\n            x = x_value;\n    } else if(type == \"large_random\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    } else if(type == \"max_a_b\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(2000);\n        for(int i=0; i<m; ++i)\n            b.push_back(2000);\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    } else if(type == \"min_a_b\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(1);\n        for(int i=0; i<m; ++i)\n            b.push_back(1);\n        if(x_value == -1)\n            x = rnd.next(1, n * m);\n        else\n            x = x_value;\n    } else if(type == \"mixed_a_b\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    } else if(type == \"single_row\") {\n        n = 1;\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    } else if(type == \"single_column\") {\n        m = 1;\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    } else if(type == \"x_small\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        x = 1;\n    } else if(type == \"x_large\") {\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        x = 2000000000;\n    } else {\n        // default random\n        for(int i=0; i<n; ++i)\n            a.push_back(rnd.next(1, 2000));\n        for(int i=0; i<m; ++i)\n            b.push_back(rnd.next(1, 2000));\n        if(x_value == -1)\n            x = rnd.next(1, 2000000000);\n        else\n            x = x_value;\n    }\n    x = max(1, min(x, 2000000000));\n    \n    printf(\"%d %d\\n\", n, m);\n    for(int i=0; i<n; ++i) {\n        printf(\"%d%c\", a[i], i==n-1?'\\n':' ');\n    }\n    for(int i=0; i<m; ++i) {\n        printf(\"%d%c\", b[i], i==m-1?'\\n':' ');\n    }\n    printf(\"%d\\n\", x);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type small_random\n./gen -n 10 -m 10 -type small_random\n./gen -n 2000 -m 2000 -type large_random\n./gen -n 2000 -m 2000 -type max_a_b\n./gen -n 2000 -m 2000 -type min_a_b\n./gen -n 2000 -m 2000 -type mixed_a_b\n./gen -n 1 -m 2000 -type single_row\n./gen -n 2000 -m 1 -type single_column\n./gen -n 2000 -m 2000 -type x_small\n./gen -n 2000 -m 2000 -type x_large\n./gen -n 1 -m 1 -type min_a_b -x 1\n./gen -n 1 -m 1 -type max_a_b -x 1\n./gen -n 2000 -m 2000 -type max_a_b -x 1\n./gen -n 2000 -m 2000 -type min_a_b -x 2000000000\n./gen -n 2000 -m 2000 -type max_a_b -x 2000000000\n./gen -n 2000 -m 2000 -type mixed_a_b -x 1\n./gen -n 1 -m 2000 -type single_row -x 1\n./gen -n 2000 -m 1 -type single_column -x 1\n./gen -n 2000 -m 2000 -type large_random -x 100000\n./gen -n 100 -m 100 -type small_random -x 50\n./gen -n 50 -m 50 -type small_random -x 1\n./gen -n 50 -m 50 -type small_random -x 2000000000\n./gen -n 2000 -m 2000 -type min_a_b -x 1\n./gen -n 2000 -m 2000 -type min_a_b -x 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:22.582116",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1060/D",
      "title": "D. Social Circles",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputFirst line contains one integer nn  — number of guests, (1⩽n⩽1051⩽n⩽105). Next nn lines contain nn pairs of space-separated integers lili and riri (0⩽li,ri⩽1090⩽li,ri⩽109).",
      "output_spec": "OutputOutput a single integer — the smallest number of chairs you have to use.",
      "sample_tests": "ExamplesInputCopy31 11 11 1OutputCopy6InputCopy41 22 13 55 3OutputCopy15InputCopy15 6OutputCopy7",
      "description": "D. Social Circles\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line contains one integer nn  — number of guests, (1⩽n⩽1051⩽n⩽105). Next nn lines contain nn pairs of space-separated integers lili and riri (0⩽li,ri⩽1090⩽li,ri⩽109).\n\nOutputOutput a single integer — the smallest number of chairs you have to use.\n\nInputCopy31 11 11 1OutputCopy6InputCopy41 22 13 55 3OutputCopy15InputCopy15 6OutputCopy7\n\nInputCopy31 11 11 1\n\nOutputCopy6\n\nInputCopy41 22 13 55 3\n\nOutputCopy15\n\nInputCopy15 6\n\nOutputCopy7\n\nNoteIn the second sample the only optimal answer is to use two circles: a circle with 55 chairs accomodating guests 11 and 22, and another one with 1010 chairs accomodationg guests 33 and 44.In the third sample, you have only one circle with one person. The guest should have at least five free chairs to his left, and at least six free chairs to his right to the next person, which is in this case the guest herself. So, overall number of chairs should be at least 6+1=7.",
      "solutions": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On Thursday, October 4, 2018 at 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On Thursday, October 4, 2018 at 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/113725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int l_i = inf.readInt(0, 1000000000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(0, 1000000000, \"r_i\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int l_i = inf.readInt(0, 1000000000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(0, 1000000000, \"r_i\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int l_i = inf.readInt(0, 1000000000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(0, 1000000000, \"r_i\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> l, r;\n\n    if (type == \"min\") {\n        // All l_i = r_i = 0\n        l.assign(n, 0);\n        r.assign(n, 0);\n    } else if (type == \"max\") {\n        // All l_i = r_i = 1e9\n        l.assign(n, 1000000000);\n        r.assign(n, 1000000000);\n    } else if (type == \"random\") {\n        // l_i and r_i are random integers between 0 and maxValue\n        int maxValue = opt<int>(\"maxValue\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            l.push_back(rnd.next(0, maxValue));\n            r.push_back(rnd.next(0, maxValue));\n        }\n    } else if (type == \"half_zero\") {\n        // Half of l_i and r_i are zero\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                l.push_back(0);\n                r.push_back(rnd.next(0, 1000000000));\n            } else {\n                l.push_back(rnd.next(0, 1000000000));\n                r.push_back(0);\n            }\n        }\n    } else if (type == \"alternating_max_zero\") {\n        // Alternating l_i = 0, r_i = max and l_i = max, r_i = 0\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                l.push_back(0);\n                r.push_back(1000000000);\n            } else {\n                l.push_back(1000000000);\n                r.push_back(0);\n            }\n        }\n    } else if (type == \"single_guest_min\") {\n        // For n = 1, l_i = r_i = 0\n        ensure(n == 1);\n        l.push_back(0);\n        r.push_back(0);\n    } else if (type == \"single_guest_max\") {\n        // For n = 1, l_i = r_i = 1e9\n        ensure(n == 1);\n        l.push_back(1000000000);\n        r.push_back(1000000000);\n    } else if (type == \"staircase_increase\") {\n        // l_i and r_i increase from 0 to maxValue\n        int maxValue = opt<int>(\"maxValue\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int val = (long long)i * maxValue / max(n - 1, 1);\n            l.push_back(val);\n            r.push_back(val);\n        }\n    } else if (type == \"staircase_decrease\") {\n        // l_i and r_i decrease from maxValue to 0\n        int maxValue = opt<int>(\"maxValue\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int val = (long long)(n - i - 1) * maxValue / max(n - 1, 1);\n            l.push_back(val);\n            r.push_back(val);\n        }\n    } else if (type == \"same_value\") {\n        // All l_i and r_i are the same specified value\n        int value = opt<int>(\"value\", 0);\n        l.assign(n, value);\n        r.assign(n, value);\n    } else if (type == \"extreme_diff\") {\n        // l_i = 0, r_i = max or l_i = max, r_i = 0 randomly\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                l.push_back(0);\n                r.push_back(1000000000);\n            } else {\n                l.push_back(1000000000);\n                r.push_back(0);\n            }\n        }\n    } else {\n        // Default to random values\n        int maxValue = opt<int>(\"maxValue\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            l.push_back(rnd.next(0, maxValue));\n            r.push_back(rnd.next(0, maxValue));\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", l[i], r[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> l, r;\n\n    if (type == \"min\") {\n        // All l_i = r_i = 0\n        l.assign(n, 0);\n        r.assign(n, 0);\n    } else if (type == \"max\") {\n        // All l_i = r_i = 1e9\n        l.assign(n, 1000000000);\n        r.assign(n, 1000000000);\n    } else if (type == \"random\") {\n        // l_i and r_i are random integers between 0 and maxValue\n        int maxValue = opt<int>(\"maxValue\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            l.push_back(rnd.next(0, maxValue));\n            r.push_back(rnd.next(0, maxValue));\n        }\n    } else if (type == \"half_zero\") {\n        // Half of l_i and r_i are zero\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                l.push_back(0);\n                r.push_back(rnd.next(0, 1000000000));\n            } else {\n                l.push_back(rnd.next(0, 1000000000));\n                r.push_back(0);\n            }\n        }\n    } else if (type == \"alternating_max_zero\") {\n        // Alternating l_i = 0, r_i = max and l_i = max, r_i = 0\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                l.push_back(0);\n                r.push_back(1000000000);\n            } else {\n                l.push_back(1000000000);\n                r.push_back(0);\n            }\n        }\n    } else if (type == \"single_guest_min\") {\n        // For n = 1, l_i = r_i = 0\n        ensure(n == 1);\n        l.push_back(0);\n        r.push_back(0);\n    } else if (type == \"single_guest_max\") {\n        // For n = 1, l_i = r_i = 1e9\n        ensure(n == 1);\n        l.push_back(1000000000);\n        r.push_back(1000000000);\n    } else if (type == \"staircase_increase\") {\n        // l_i and r_i increase from 0 to maxValue\n        int maxValue = opt<int>(\"maxValue\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int val = (long long)i * maxValue / max(n - 1, 1);\n            l.push_back(val);\n            r.push_back(val);\n        }\n    } else if (type == \"staircase_decrease\") {\n        // l_i and r_i decrease from maxValue to 0\n        int maxValue = opt<int>(\"maxValue\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int val = (long long)(n - i - 1) * maxValue / max(n - 1, 1);\n            l.push_back(val);\n            r.push_back(val);\n        }\n    } else if (type == \"same_value\") {\n        // All l_i and r_i are the same specified value\n        int value = opt<int>(\"value\", 0);\n        l.assign(n, value);\n        r.assign(n, value);\n    } else if (type == \"extreme_diff\") {\n        // l_i = 0, r_i = max or l_i = max, r_i = 0 randomly\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                l.push_back(0);\n                r.push_back(1000000000);\n            } else {\n                l.push_back(1000000000);\n                r.push_back(0);\n            }\n        }\n    } else {\n        // Default to random values\n        int maxValue = opt<int>(\"maxValue\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            l.push_back(rnd.next(0, maxValue));\n            r.push_back(rnd.next(0, maxValue));\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", l[i], r[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type single_guest_min\n./gen -n 1 -type single_guest_max\n./gen -n 1 -type random\n\n./gen -n 2 -type min\n./gen -n 2 -type max\n\n./gen -n 10 -type random -maxValue 100\n./gen -n 10 -type half_zero\n./gen -n 10 -type alternating_max_zero\n\n./gen -n 100 -type random\n./gen -n 100 -type staircase_increase\n./gen -n 100 -type staircase_decrease\n\n./gen -n 1000 -type random\n./gen -n 1000 -type staircase_increase -maxValue 1000000000\n./gen -n 1000 -type same_value -value 123456789\n\n./gen -n 10000 -type random\n./gen -n 10000 -type extreme_diff\n\n./gen -n 100000 -type random\n./gen -n 100000 -type min\n./gen -n 100000 -type max\n./gen -n 100000 -type half_zero\n./gen -n 100000 -type alternating_max_zero\n\n./gen -n 100000 -type staircase_increase\n./gen -n 100000 -type staircase_decrease\n\n./gen -n 100000 -type same_value -value 0\n./gen -n 100000 -type same_value -value 1000000000\n\n./gen -n 99999 -type random\n\n./gen -n 99998 -type random -maxValue 0\n\n./gen -n 100000 -type random -maxValue 1\n\n./gen -n 100000 -type random -maxValue 100000000\n\n./gen -n 50000 -type random\n\n./gen -n 1 -type same_value -value 999999999\n\n./gen -n 3 -type random\n\n./gen -n 100000 -type same_value -value 1\n\n./gen -n 100000 -type extreme_diff\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:24.456249",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1060/E",
      "title": "E. Sergey and Subway",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer nn (2≤n≤2000002≤n≤200000) — the number of subway stations in the imaginary city drawn by mayor's assistants. Each of the following n−1n−1 lines contains two integers uiui and vivi (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi), meaning the station with these indices are connected with a direct tunnel.It is guaranteed that these nn stations and n−1n−1 tunnels form a tree.",
      "output_spec": "OutputPrint one integer that is equal to the sum of distances between all pairs of stations after Sergey Semyonovich draws new tunnels between all pairs of stations that share a common neighbor in the original map.",
      "sample_tests": "ExamplesInputCopy41 21 31 4OutputCopy6InputCopy41 22 33 4OutputCopy7",
      "description": "E. Sergey and Subway\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single integer nn (2≤n≤2000002≤n≤200000) — the number of subway stations in the imaginary city drawn by mayor's assistants. Each of the following n−1n−1 lines contains two integers uiui and vivi (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi), meaning the station with these indices are connected with a direct tunnel.It is guaranteed that these nn stations and n−1n−1 tunnels form a tree.\n\nOutputPrint one integer that is equal to the sum of distances between all pairs of stations after Sergey Semyonovich draws new tunnels between all pairs of stations that share a common neighbor in the original map.\n\nInputCopy41 21 31 4OutputCopy6InputCopy41 22 33 4OutputCopy7\n\nInputCopy41 21 31 4\n\nOutputCopy6\n\nInputCopy41 22 33 4\n\nOutputCopy7\n\nNoteIn the first sample, in the new map all pairs of stations share a direct connection, so the sum of distances is 66.In the second sample, the new map has a direct tunnel between all pairs of stations except for the pair (1,4)(1,4). For these two stations the distance is 22.",
      "solutions": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On Thursday, October 4, 2018 at 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On Thursday, October 4, 2018 at 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/113725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000 + 1;\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(!visited[v]) {\n            dfs(v, u);\n        } else if(v != parent) {\n            ensuref(false, \"Graph contains a cycle involving edge between %d and %d\", u, v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n-1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Self-loops are not allowed: edge from %d to %d\", u, v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    memset(visited, 0, sizeof(bool)*(n+1));\n    dfs(1, -1);\n    for(int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected: node %d is unreachable\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000 + 1;\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(!visited[v]) {\n            dfs(v, u);\n        } else if(v != parent) {\n            ensuref(false, \"Graph contains a cycle involving edge between %d and %d\", u, v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n-1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Self-loops are not allowed: edge from %d to %d\", u, v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    memset(visited, 0, sizeof(bool)*(n+1));\n    dfs(1, -1);\n    for(int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected: node %d is unreachable\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000 + 1;\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(!visited[v]) {\n            dfs(v, u);\n        } else if(v != parent) {\n            ensuref(false, \"Graph contains a cycle involving edge between %d and %d\", u, v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n-1; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Self-loops are not allowed: edge from %d to %d\", u, v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    memset(visited, 0, sizeof(bool)*(n+1));\n    dfs(1, -1);\n    for(int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected: node %d is unreachable\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        /* A tree that has degenerated into a chain */\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        /* A tree that has degenerated into a star */\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        /* A complete binary tree */\n        queue<int> q;\n        q.push(1);\n        int cnt = 2;\n        while (cnt <= n) {\n            int u = q.front(); q.pop();\n            int left = cnt++;\n            edges.push_back({u, left});\n            q.push(left);\n            if (cnt <= n) {\n                int right = cnt++;\n                edges.push_back({u, right});\n                q.push(right);\n            }\n        }\n    } else if (type == \"random\") {\n        /* Random tree */\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (type == \"skewed\") {\n        /* Skewed tree */\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n        reverse(edges.begin(), edges.end());\n    } else {\n        /* Unknown type */\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output edges */\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        /* A tree that has degenerated into a chain */\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        /* A tree that has degenerated into a star */\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        /* A complete binary tree */\n        queue<int> q;\n        q.push(1);\n        int cnt = 2;\n        while (cnt <= n) {\n            int u = q.front(); q.pop();\n            int left = cnt++;\n            edges.push_back({u, left});\n            q.push(left);\n            if (cnt <= n) {\n                int right = cnt++;\n                edges.push_back({u, right});\n                q.push(right);\n            }\n        }\n    } else if (type == \"random\") {\n        /* Random tree */\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (type == \"skewed\") {\n        /* Skewed tree */\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n        reverse(edges.begin(), edges.end());\n    } else {\n        /* Unknown type */\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output edges */\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type random\n\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type binary\n./gen -n 3 -type random\n./gen -n 3 -type skewed\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type binary\n./gen -n 10 -type random\n./gen -n 10 -type skewed\n\n./gen -n 50 -type chain\n./gen -n 50 -type star\n./gen -n 50 -type binary\n./gen -n 50 -type random\n./gen -n 50 -type skewed\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type binary\n./gen -n 100 -type random\n./gen -n 100 -type skewed\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type binary\n./gen -n 1000 -type random\n./gen -n 1000 -type skewed\n\n./gen -n 10000 -type chain\n./gen -n 10000 -type star\n./gen -n 10000 -type binary\n./gen -n 10000 -type random\n./gen -n 10000 -type skewed\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type binary\n./gen -n 100000 -type random\n./gen -n 100000 -type skewed\n\n./gen -n 200000 -type chain\n./gen -n 200000 -type star\n./gen -n 200000 -type binary\n./gen -n 200000 -type random\n./gen -n 200000 -type skewed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:26.602830",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1060/F",
      "title": "F. Сжимающееся дерево",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке входного файла записано целое число nn (1≤n≤501≤n≤50).Следующие n−1n−1 строк описывают ребра дерева. Каждая из этих строк содержит два целых числа ui,viui,vi — номера вершин, соединенных соответствующим ребром (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi). Гарантируется, что данный граф является деревом.",
      "output_spec": "Выходные данныеВыведите nn вещественных чисел — описанные вероятности для номеров 1,…,n1,…,n, соответственно. Все числа должны быть правильными с точностью до абсолютной или относительной погрешности 10−610−6.",
      "sample_tests": "ПримерыВходные данныеСкопировать41 21 31 4Выходные данныеСкопировать0.12500000000.29166666670.29166666670.2916666667Входные данныеСкопировать71 21 32 42 53 63 7Выходные данныеСкопировать0.08506944440.06640625000.06640625000.19552951390.19552951390.19552951390.1955295139",
      "description": "F. Сжимающееся дерево\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входного файла записано целое число nn (1≤n≤501≤n≤50).Следующие n−1n−1 строк описывают ребра дерева. Каждая из этих строк содержит два целых числа ui,viui,vi — номера вершин, соединенных соответствующим ребром (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi). Гарантируется, что данный граф является деревом.\n\nВходные данные\n\nВыходные данныеВыведите nn вещественных чисел — описанные вероятности для номеров 1,…,n1,…,n, соответственно. Все числа должны быть правильными с точностью до абсолютной или относительной погрешности 10−610−6.\n\nВыходные данные\n\nВходные данныеСкопировать41 21 31 4Выходные данныеСкопировать0.12500000000.29166666670.29166666670.2916666667Входные данныеСкопировать71 21 32 42 53 63 7Выходные данныеСкопировать0.08506944440.06640625000.06640625000.19552951390.19552951390.19552951390.1955295139\n\nВходные данныеСкопировать41 21 31 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.12500000000.29166666670.29166666670.2916666667\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать71 21 32 42 53 63 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.08506944440.06640625000.06640625000.19552951390.19552951390.19552951390.1955295139\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере, получившаяся вершина будет иметь номер 1 тогда и только тогда, когда для всех ребер вершина 1 выживет, соответственно вероятность равна 1/23=1/81/23=1/8. Все остальные числа имеют равную вероятность из-за симметрии, таким образом, каждое из них имеет вероятность (1−1/8)/3=7/24(1−1/8)/3=7/24.",
      "solutions": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On четверг, 4 октября 2018 г. в 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On четверг, 4 октября 2018 г. в 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/113725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nbool hasCycle = false;\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, u);\n        } else if (v != parent) {\n            hasCycle = true;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    adj.resize(n + 1); // Nodes are labeled from 1 to n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge from %d to %d is a self-loop\", u, v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    visited.resize(n + 1, false);\n    dfs(1, -1); // Start DFS from node 1\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected, node %d is unreachable\", i);\n    }\n    ensuref(!hasCycle, \"Graph contains a cycle\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nbool hasCycle = false;\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, u);\n        } else if (v != parent) {\n            hasCycle = true;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    adj.resize(n + 1); // Nodes are labeled from 1 to n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge from %d to %d is a self-loop\", u, v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    visited.resize(n + 1, false);\n    dfs(1, -1); // Start DFS from node 1\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected, node %d is unreachable\", i);\n    }\n    ensuref(!hasCycle, \"Graph contains a cycle\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nbool hasCycle = false;\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, u);\n        } else if (v != parent) {\n            hasCycle = true;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    adj.resize(n + 1); // Nodes are labeled from 1 to n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge from %d to %d is a self-loop\", u, v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    visited.resize(n + 1, false);\n    dfs(1, -1); // Start DFS from node 1\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected, node %d is unreachable\", i);\n    }\n    ensuref(!hasCycle, \"Graph contains a cycle\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"star\" || type == \"flower\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"random\") {\n        // generate random tree\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) {\n            nodes[i] = i+1;\n        }\n        shuffle(nodes.begin(), nodes.end());\n        // use random parents\n        for (int i = 1; i < n; ++i) {\n            int u = nodes[i];\n            int v = nodes[rnd.next(0, i-1)];\n            edges.push_back({u, v});\n        }\n    } else if (type == \"bamboo\") {\n        // Skewed tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n            // Then connect i to i+1 if possible\n            if (i + 1 <= n) {\n                edges.push_back({i, i+1});\n                ++i;\n            }\n        }\n        // Adjust n in case we added extra nodes\n        n = max(n, (int)edges.size() + 1);\n    } else if (type == \"complete_binary_tree\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i/2, i});\n        }\n    } else if (type == \"caterpillar\") {\n        // A path with leaves\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        for (int i = 1; i <= n && edges.size() < n - 1; i += 5) {\n            edges.push_back({i, n + 1});\n            n++;\n        }\n    } else if (type == \"prufer\") {\n        // Use Prüfer sequence to generate random tree\n        vector<int> prufer_code(n - 2);\n        for (auto &x : prufer_code) x = rnd.next(1, n);\n        vector<int> degree(n + 1, 1);\n        for (auto x : prufer_code) degree[x]++;\n        set<int> leaves;\n        for (int i = 1; i <= n; ++i)\n            if (degree[i] == 1)\n                leaves.insert(i);\n\n        for (auto x : prufer_code) {\n            int y = *leaves.begin();\n            leaves.erase(leaves.begin());\n            edges.push_back({x, y});\n            if (--degree[x] == 1)\n                leaves.insert(x);\n        }\n        int u = *leaves.begin();\n        int v = *leaves.rbegin();\n        edges.push_back({u, v});\n    } else if (type == \"bushy_tree\") {\n        // Generate a balanced tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({(i + 1) / 2 - 1, i});\n        }\n    } else if (type == \"skewed_tree\") {\n        // Generate a skewed tree\n        edges.push_back({1, 2});\n        for (int i = 3; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        // Default random tree\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n    }\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"star\" || type == \"flower\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"random\") {\n        // generate random tree\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) {\n            nodes[i] = i+1;\n        }\n        shuffle(nodes.begin(), nodes.end());\n        // use random parents\n        for (int i = 1; i < n; ++i) {\n            int u = nodes[i];\n            int v = nodes[rnd.next(0, i-1)];\n            edges.push_back({u, v});\n        }\n    } else if (type == \"bamboo\") {\n        // Skewed tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n            // Then connect i to i+1 if possible\n            if (i + 1 <= n) {\n                edges.push_back({i, i+1});\n                ++i;\n            }\n        }\n        // Adjust n in case we added extra nodes\n        n = max(n, (int)edges.size() + 1);\n    } else if (type == \"complete_binary_tree\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i/2, i});\n        }\n    } else if (type == \"caterpillar\") {\n        // A path with leaves\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        for (int i = 1; i <= n && edges.size() < n - 1; i += 5) {\n            edges.push_back({i, n + 1});\n            n++;\n        }\n    } else if (type == \"prufer\") {\n        // Use Prüfer sequence to generate random tree\n        vector<int> prufer_code(n - 2);\n        for (auto &x : prufer_code) x = rnd.next(1, n);\n        vector<int> degree(n + 1, 1);\n        for (auto x : prufer_code) degree[x]++;\n        set<int> leaves;\n        for (int i = 1; i <= n; ++i)\n            if (degree[i] == 1)\n                leaves.insert(i);\n\n        for (auto x : prufer_code) {\n            int y = *leaves.begin();\n            leaves.erase(leaves.begin());\n            edges.push_back({x, y});\n            if (--degree[x] == 1)\n                leaves.insert(x);\n        }\n        int u = *leaves.begin();\n        int v = *leaves.rbegin();\n        edges.push_back({u, v});\n    } else if (type == \"bushy_tree\") {\n        // Generate a balanced tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({(i + 1) / 2 - 1, i});\n        }\n    } else if (type == \"skewed_tree\") {\n        // Generate a skewed tree\n        edges.push_back({1, 2});\n        for (int i = 3; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        // Default random tree\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n    }\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# n = 1\n./gen -n 1 -type chain\n./gen -n 1 -type star\n./gen -n 1 -type random\n\n# n = 2\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type random\n\n# n = 3\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type random\n\n# n = 4\n./gen -n 4 -type chain\n./gen -n 4 -type star\n./gen -n 4 -type random\n\n# n = 5\n./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type random\n\n# n = 10\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type random\n./gen -n 10 -type complete_binary_tree\n./gen -n 10 -type skewed_tree\n./gen -n 10 -type bushy_tree\n\n# n = 25\n./gen -n 25 -type chain\n./gen -n 25 -type star\n./gen -n 25 -type random\n./gen -n 25 -type complete_binary_tree\n./gen -n 25 -type skewed_tree\n./gen -n 25 -type bushy_tree\n./gen -n 25 -type prufer\n\n# n = 50\n./gen -n 50 -type chain\n./gen -n 50 -type star\n./gen -n 50 -type random\n./gen -n 50 -type complete_binary_tree\n./gen -n 50 -type skewed_tree\n./gen -n 50 -type bushy_tree\n./gen -n 50 -type prufer\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:28.569730",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1060/G",
      "title": "G. Шары и лузы",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа nn и mm — количество луз и количество вопросов соответственно (1≤n,m≤1051≤n,m≤105).В следующей строке записано nn целых чисел a1,…,ana1,…,an — номера клеток с лузами (0≤a1<…<an≤1090≤a1<…<an≤109).Следующие mm строк описывают вопросы. ii-я из этих строк содержит два целых числа xixi и kiki (0≤xi,ki≤1090≤xi,ki≤109).",
      "output_spec": "Выходные данныеВыведите mm чисел — ответы на вопросы в том же порядке, в котором они заданы на входе.",
      "sample_tests": "ПримерВходные данныеСкопировать3 151 3 40 01 02 03 04 00 11 12 13 14 10 21 22 23 24 2Выходные данныеСкопировать0123402567058910",
      "description": "G. Шары и лузы\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записано два целых числа nn и mm — количество луз и количество вопросов соответственно (1≤n,m≤1051≤n,m≤105).В следующей строке записано nn целых чисел a1,…,ana1,…,an — номера клеток с лузами (0≤a1<…<an≤1090≤a1<…<an≤109).Следующие mm строк описывают вопросы. ii-я из этих строк содержит два целых числа xixi и kiki (0≤xi,ki≤1090≤xi,ki≤109).\n\nВходные данные\n\nВыходные данныеВыведите mm чисел — ответы на вопросы в том же порядке, в котором они заданы на входе.\n\nВыходные данные\n\nВходные данныеСкопировать3 151 3 40 01 02 03 04 00 11 12 13 14 10 21 22 23 24 2Выходные данныеСкопировать0123402567058910\n\nВходные данныеСкопировать3 151 3 40 01 02 03 04 00 11 12 13 14 10 21 22 23 24 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0123402567058910\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On четверг, 4 октября 2018 г. в 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On четверг, 4 октября 2018 г. в 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/113725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1], \"a_i should be strictly increasing, but a[%d]=%d, a[%d]=%d\", i, a[i], i+1, a[i+1]);\n    }\n\n    for(int i = 0; i < m; ++i) {\n        int x_i = inf.readInt(0, 1000000000, \"x_i\");\n        inf.readSpace();\n        int k_i = inf.readInt(0, 1000000000, \"k_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1], \"a_i should be strictly increasing, but a[%d]=%d, a[%d]=%d\", i, a[i], i+1, a[i+1]);\n    }\n\n    for(int i = 0; i < m; ++i) {\n        int x_i = inf.readInt(0, 1000000000, \"x_i\");\n        inf.readSpace();\n        int k_i = inf.readInt(0, 1000000000, \"k_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1], \"a_i should be strictly increasing, but a[%d]=%d, a[%d]=%d\", i, a[i], i+1, a[i+1]);\n    }\n\n    for(int i = 0; i < m; ++i) {\n        int x_i = inf.readInt(0, 1000000000, \"x_i\");\n        inf.readSpace();\n        int k_i = inf.readInt(0, 1000000000, \"k_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int maxAi = opt<int>(\"maxAi\", (int)1e9);\n    int maxXi = opt<int>(\"maxXi\", (int)1e9);\n    int maxKi = opt<int>(\"maxKi\", (int)1e9);\n    string pocketsType = opt<string>(\"pocketsType\", \"random\");\n    string queriesType = opt<string>(\"queriesType\", \"random\");\n\n    // Generate pockets positions a_1 to a_n\n    vector<int> a;\n\n    if (pocketsType == \"none\") {\n        // No pockets\n        n = 0;\n    } else if (pocketsType == \"all\") {\n        // Pockets at positions 0 to n-1\n        for (int i = 0; i < n; ++i) {\n            a.push_back(i);\n        }\n    } else if (pocketsType == \"clustered\") {\n        // Pockets clustered together\n        int startPos = rnd.next(0, max(0, maxAi - n + 1));\n        for (int i = 0; i < n; ++i) {\n            a.push_back(startPos + i);\n        }\n    } else if (pocketsType == \"spaced\") {\n        // Pockets evenly spaced\n        int spacing = maxAi / max(1, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a.push_back(i * spacing);\n        }\n    } else {\n        // Random pockets\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            int val = rnd.next(0, maxAi);\n            positions.insert(val);\n        }\n        a.assign(positions.begin(), positions.end());\n    }\n\n    // Ensure a_i are sorted and unique\n    sort(a.begin(), a.end());\n    n = a.size();\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    // Generate m queries\n    for (int i = 0; i < m; ++i) {\n        int x_i, k_i;\n        if (queriesType == \"zeroK\") {\n            k_i = 0;\n            x_i = rnd.next(0, maxXi);\n        } else if (queriesType == \"maxKi\") {\n            k_i = maxKi;\n            x_i = rnd.next(0, maxXi);\n        } else if (queriesType == \"xAtPockets\") {\n            // x_i is always at positions where pockets are\n            x_i = a[rnd.next(0, n - 1)];\n            k_i = rnd.next(0, maxKi);\n        } else {\n            // Random queries\n            x_i = rnd.next(0, maxXi);\n            k_i = rnd.next(0, maxKi);\n        }\n        printf(\"%d %d\\n\", x_i, k_i);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int maxAi = opt<int>(\"maxAi\", (int)1e9);\n    int maxXi = opt<int>(\"maxXi\", (int)1e9);\n    int maxKi = opt<int>(\"maxKi\", (int)1e9);\n    string pocketsType = opt<string>(\"pocketsType\", \"random\");\n    string queriesType = opt<string>(\"queriesType\", \"random\");\n\n    // Generate pockets positions a_1 to a_n\n    vector<int> a;\n\n    if (pocketsType == \"none\") {\n        // No pockets\n        n = 0;\n    } else if (pocketsType == \"all\") {\n        // Pockets at positions 0 to n-1\n        for (int i = 0; i < n; ++i) {\n            a.push_back(i);\n        }\n    } else if (pocketsType == \"clustered\") {\n        // Pockets clustered together\n        int startPos = rnd.next(0, max(0, maxAi - n + 1));\n        for (int i = 0; i < n; ++i) {\n            a.push_back(startPos + i);\n        }\n    } else if (pocketsType == \"spaced\") {\n        // Pockets evenly spaced\n        int spacing = maxAi / max(1, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a.push_back(i * spacing);\n        }\n    } else {\n        // Random pockets\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            int val = rnd.next(0, maxAi);\n            positions.insert(val);\n        }\n        a.assign(positions.begin(), positions.end());\n    }\n\n    // Ensure a_i are sorted and unique\n    sort(a.begin(), a.end());\n    n = a.size();\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    // Generate m queries\n    for (int i = 0; i < m; ++i) {\n        int x_i, k_i;\n        if (queriesType == \"zeroK\") {\n            k_i = 0;\n            x_i = rnd.next(0, maxXi);\n        } else if (queriesType == \"maxKi\") {\n            k_i = maxKi;\n            x_i = rnd.next(0, maxXi);\n        } else if (queriesType == \"xAtPockets\") {\n            // x_i is always at positions where pockets are\n            x_i = a[rnd.next(0, n - 1)];\n            k_i = rnd.next(0, maxKi);\n        } else {\n            // Random queries\n            x_i = rnd.next(0, maxXi);\n            k_i = rnd.next(0, maxKi);\n        }\n        printf(\"%d %d\\n\", x_i, k_i);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m, random pockets and queries\n./gen -n 5 -m 5 -maxAi 10 -maxXi 10 -maxKi 10 -pocketsType random -queriesType random\n./gen -n 0 -m 5 -maxAi 10 -maxXi 10 -maxKi 10 -pocketsType none -queriesType random\n./gen -n 5 -m 5 -maxAi 10 -maxXi 10 -maxKi 10 -pocketsType all -queriesType random\n\n# Pockets at every position\n./gen -n 100000 -m 100000 -maxAi 99999999 -pocketsType all -queriesType random\n\n# No pockets\n./gen -n 0 -m 100000 -maxXi 1000000000 -maxKi 1000000000 -pocketsType none -queriesType random\n\n# Pockets clustered together at the beginning\n./gen -n 10000 -m 10000 -maxAi 1000000 -pocketsType clustered -queriesType random\n\n# Pockets clustered together at the end\n./gen -n 10000 -m 10000 -maxAi 1000000 -pocketsType clustered -queriesType random\n\n# Pockets spaced apart\n./gen -n 1000 -m 1000 -maxAi 1000000000 -pocketsType spaced -queriesType random\n\n# Random pockets\n./gen -n 100000 -m 100000 -maxAi 1000000000 -pocketsType random -queriesType random\n\n# Max k_i\n./gen -n 100000 -m 100000 -maxAi 1000000000 -maxKi 1000000000 -pocketsType random -queriesType maxKi\n\n# Zero k_i\n./gen -n 100000 -m 100000 -maxAi 1000000000 -pocketsType random -queriesType zeroK\n\n# x_i at pockets positions\n./gen -n 100000 -m 100000 -maxAi 1000000000 -pocketsType random -queriesType xAtPockets\n\n# All pockets at position zero\n./gen -n 1 -m 5 -maxAi 0 -pocketsType all -queriesType random\n\n# Maximum n and m\n./gen -n 100000 -m 100000 -maxAi 1000000000 -maxXi 1000000000 -maxKi 1000000000 -pocketsType random -queriesType random\n\n# Pockets at every even position\n./gen -n 50000 -m 100000 -maxAi 99999999 -pocketsType spaced -queriesType random\n\n# Pockets at random positions, queries at high x_i\n./gen -n 100000 -m 100000 -maxAi 1000000000 -maxXi 1000000000 -pocketsType random -queriesType random\n\n# All queries have x_i = 0, varying k_i\n./gen -n 100000 -m 100000 -maxAi 1000000000 -pocketsType random -queriesType random\n\n# All k_i = 1\n./gen -n 100000 -m 100000 -maxAi 1000000000 -maxKi 1 -pocketsType random -queriesType random\n\n# Edge test: n = m = 1, minimal input\n./gen -n 1 -m 1 -maxAi 0 -maxXi 0 -maxKi 0 -pocketsType random -queriesType random\n\n# Repeated queries\n./gen -n 100000 -m 100000 -maxAi 1000000000 -pocketsType random -queriesType random\n\n# All queries ask for x_i at positions with no pockets\n./gen -n 100000 -m 100000 -maxAi 1000000000 -pocketsType random -queriesType random\n\n# No pockets, maximum x_i and k_i\n./gen -n 0 -m 100000 -maxXi 1000000000 -maxKi 1000000000 -pocketsType none -queriesType random\n\n# Pockets only at high positions\n./gen -n 100000 -m 100000 -maxAi 1000000000 -pocketsType spaced -queriesType random\n\n# All x_i are the same\n./gen -n 100000 -m 100000 -maxAi 1000000000 -pocketsType random -queriesType random\n\n# Pockets at same position\n./gen -n 1 -m 5 -maxAi 0 -pocketsType all -queriesType random\n\n# All k_i are the same\n./gen -n 100000 -m 100000 -maxAi 1000000000 -maxKi 1000 -pocketsType random -queriesType random\n\n# Pockets cover all possible positions up to maxAi\n./gen -n 100000 -m 100000 -maxAi 100000 -pocketsType all -queriesType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:30.435379",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1060/H",
      "title": "H. Sophisticated Device",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains space-separated integers dd and pp (2⩽d⩽102⩽d⩽10, d<pd<p, 3⩽p⩽109+93⩽p⩽109+9, pp is prime).",
      "output_spec": "OutputOutput instructions, one instruction per line in the above format. There should be no more than 50005000 lines, and the last line should be the return instruction.",
      "sample_tests": "",
      "description": "H. Sophisticated Device\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains space-separated integers dd and pp (2⩽d⩽102⩽d⩽10, d<pd<p, 3⩽p⩽109+93⩽p⩽109+9, pp is prime).\n\nOutputOutput instructions, one instruction per line in the above format. There should be no more than 50005000 lines, and the last line should be the return instruction.\n\nNoteThis problem has no sample tests. A sample output is shown below. Note that this output is not supposed to be a solution to any testcase, and is there purely to illustrate the output format.+ 1 1 3^ 3 3+ 3 2 2+ 3 2 3^ 3 1f 1+ 1 1 3^ 3 3+ 3 2 2+ 3 2 3^ 3 1f 1Here's a step-by-step runtime illustration:initially+ 1 1 3^ 3 3+ 3 2 2+ 3 2 3^ 3 1cell 1xxxxx(y+2⋅(2x)d)dcell 2yyyy+(2x)dy+(2x)dy+(2x)dcell 312x(2x)d(2x)dy+2⋅(2x)dy+2⋅(2x)dcell 1cell 2cell 3initiallyxy1+ 1 1 3xy2x^ 3 3xy(2x)d+ 3 2 2xy+(2x)d(2x)d+ 3 2 3xy+(2x)dy+2⋅(2x)d^ 3 1(y+2⋅(2x)d)dy+(2x)dy+2⋅(2x)dSuppose that d=2d=2 and p=3p=3. Since for x=0x=0 and y=1y=1 the returned result is 1≠0⋅1mod31≠0⋅1mod3, this program would be judged as incorrect.",
      "solutions": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On Thursday, October 4, 2018 at 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces",
          "content": "On Thursday, October 4, 2018 at 15:05UTC+8, the Codeforces Round 513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) will start. This is a special round for the Hello Barcelona Programming Bootcamp, in collaboration with Moscow Workshops ICPC. It is rated for all participants, everybody can register on it regardless of a rating.Hello Barcelona Programming Bootcamp is sponsored by VTB and Indeed Tokyo, with the addition of team sponsors Phaze Ventures, Spark Labs and REMY Robotics. VTB, the largest international bank based in Eastern Europe, continues to be an official partner of the Hello Programming Bootcamp series, adding further quality to the 3rd edition of the Hello Barcelona Programming Bootcamp by bringing their own participants, as well as by supporting top teams from around the world.Indeed Tokyo is Japan's branch of the #1 employment website in the world, giving job seekers free access to millions of jobs from thousands of company websites and job boards. As they sponsor for the second year in a row, Indeed continues to offer the best job opportunities to the boot camp participants.Wish good luck to all the participants!There will be 8 problems, common for both division. Score distribution: 500 750 1250 1500 1750 2250 2750 3000.The problems are prepared by me, Arterm and GlebsHP, with assistance from 300iq, ifsmirnov and vintage_Vlad_Makeev. Have fun!",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/113725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1382
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62199",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 1",
          "code": "500 750 1250 1500 1750 2250 2750 3000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 2",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        },
        {
          "title": "Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2) - Codeforces - Code 3",
          "code": "if (ppl._2 == ppl._2) {\n\tstl.erase(stl.begin());\n\tstr.erase(str.begin());\n} else {\n\t// manipulate with sets\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/113725",
          "author": "awoo"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int64;\n\nint64 powmod(int64 a, int64 b, int64 mod) {\n    int64 res = 1 % mod;\n    a %= mod;\n    while(b > 0) {\n        if (b & 1)\n            res = (res * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\nbool isComposite(int64 n, int64 a, int64 d, int s) {\n    int64 x = powmod(a, d, n);\n    if (x == 1 || x == n - 1) return false;\n    for (int r = 1; r < s; ++r) {\n        x = (x * x) % n;\n        if (x == n - 1) return false;\n    }\n    return true;\n}\n\nbool isPrime(int64 n) {\n    if (n < 2) return false;\n    int64 r = 0, d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        ++r;\n    }\n    int64 bases[] = {2, 3, 5, 7, 11};\n    for (int64 a : bases) {\n        if (a >= n) break;\n        if (isComposite(n, a, d, r)) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(2,10,\"d\");\n    inf.readSpace();\n    long long p = inf.readLong(3LL,1000000009LL,\"p\");\n    inf.readEoln();\n\n    ensuref(d < p, \"d (%d) must be less than p (%lld)\", d, p);\n    ensuref(isPrime(p), \"p (%lld) must be prime\", p);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int64;\n\nint64 powmod(int64 a, int64 b, int64 mod) {\n    int64 res = 1 % mod;\n    a %= mod;\n    while(b > 0) {\n        if (b & 1)\n            res = (res * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\nbool isComposite(int64 n, int64 a, int64 d, int s) {\n    int64 x = powmod(a, d, n);\n    if (x == 1 || x == n - 1) return false;\n    for (int r = 1; r < s; ++r) {\n        x = (x * x) % n;\n        if (x == n - 1) return false;\n    }\n    return true;\n}\n\nbool isPrime(int64 n) {\n    if (n < 2) return false;\n    int64 r = 0, d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        ++r;\n    }\n    int64 bases[] = {2, 3, 5, 7, 11};\n    for (int64 a : bases) {\n        if (a >= n) break;\n        if (isComposite(n, a, d, r)) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(2,10,\"d\");\n    inf.readSpace();\n    long long p = inf.readLong(3LL,1000000009LL,\"p\");\n    inf.readEoln();\n\n    ensuref(d < p, \"d (%d) must be less than p (%lld)\", d, p);\n    ensuref(isPrime(p), \"p (%lld) must be prime\", p);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int64;\n\nint64 powmod(int64 a, int64 b, int64 mod) {\n    int64 res = 1 % mod;\n    a %= mod;\n    while(b > 0) {\n        if (b & 1)\n            res = (res * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\nbool isComposite(int64 n, int64 a, int64 d, int s) {\n    int64 x = powmod(a, d, n);\n    if (x == 1 || x == n - 1) return false;\n    for (int r = 1; r < s; ++r) {\n        x = (x * x) % n;\n        if (x == n - 1) return false;\n    }\n    return true;\n}\n\nbool isPrime(int64 n) {\n    if (n < 2) return false;\n    int64 r = 0, d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        ++r;\n    }\n    int64 bases[] = {2, 3, 5, 7, 11};\n    for (int64 a : bases) {\n        if (a >= n) break;\n        if (isComposite(n, a, d, r)) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(2,10,\"d\");\n    inf.readSpace();\n    long long p = inf.readLong(3LL,1000000009LL,\"p\");\n    inf.readEoln();\n\n    ensuref(d < p, \"d (%d) must be less than p (%lld)\", d, p);\n    ensuref(isPrime(p), \"p (%lld) must be prime\", p);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This problem clearly has multiple valid solutions (many possible programs can\n  produce x*y mod p for all x,y). Hence we need a custom checker.\n\n  We do the following:\n    1) Read d, p from the input file (inf).\n    2) Read up to 5000 instructions from the contestant output (ouf) until we\n       see a line that starts with 'f'.\n         - Each line must be in one of the following forms:\n           \"+ e1 e2 to\"\n           \"^ e to\"\n           \"f target\"\n         - We stop reading as soon as we see \"f\".\n         - We ensure the total number of lines (instructions) is ≤ 5000.\n    3) We then test the correctness of the contestant’s program on a handful of\n       (x, y) pairs. Each pair is used to simulate the instructions:\n         - memory[1] = x, memory[2] = y, memory[3..5000] = 1.\n         - Apply each instruction modulo p.\n         - When we reach \"f target\", we check memory[target] == (x * y) mod p.\n           If not, we report _wa.\n    4) If all tested pairs pass, we accept (_ok).\n*/\n\nstruct Instruction {\n    char type;  // '+' or '^' or 'f'\n    int e1, e2, to; // for '+': e1,e2,to; for '^': e1->to; for 'f': e1 is target\n};\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // 1) read d, p from input\n    long long d = inf.readLong(2, 10, \"d\"); // though in problem: 2 <= d <= 10\n    long long p = inf.readLong(3, 1000000009 + 9, \"p\"); \n    // (the problem says p up to 10^9+9, p prime, but we won't enforce primality here)\n    if (d >= p)\n        quitf(_fail, \"Problem statement says d < p, but input has d >= p\");\n\n    // 2) read instructions from ouf\n    vector<Instruction> prog;\n    const int MAX_LINES = 5000;\n    bool finished = false;\n    for (int i = 0; i < MAX_LINES; i++) {\n        if (ouf.eof())\n            break; // no more lines\n        string cmd = ouf.readToken(); // read the first token of a line\n\n        Instruction ins;\n        if (cmd == \"+\") {\n            // must read three integers e1,e2,to\n            ins.type = '+';\n            ins.e1 = ouf.readInt(1, 5000, \"e1\");\n            ins.e2 = ouf.readInt(1, 5000, \"e2\");\n            ins.to  = ouf.readInt(1, 5000, \"to\");\n            prog.push_back(ins);\n        }\n        else if (cmd == \"^\") {\n            // must read two integers e, to\n            ins.type = '^';\n            ins.e1 = ouf.readInt(1, 5000, \"e\");\n            ins.to = ouf.readInt(1, 5000, \"to\");\n            prog.push_back(ins);\n        }\n        else if (cmd == \"f\") {\n            // must read target\n            ins.type = 'f';\n            ins.e1 = ouf.readInt(1, 5000, \"target\");\n            prog.push_back(ins);\n            finished = true;\n            break; // no more instructions should be processed\n        }\n        else {\n            // invalid command\n            quitf(_wa, \"Invalid instruction command '%s'. Expected '+', '^', or 'f'.\", cmd.c_str());\n        }\n    }\n\n    if (!finished) {\n        // if we haven't seen an 'f' instruction after reading up to 5000 lines\n        quitf(_wa, \"No 'f' instruction found or instructions exceed 5000 lines\");\n    }\n\n    // If there are extra lines after 'f', that's invalid:\n    if (!ouf.eof()) {\n        // read possibly next token to see if there's more data\n        // if there's more data, that's a WA\n        string extra;\n        if (!ouf.seekEof()) {\n            extra = ouf.readToken();\n            quitf(_wa, \"Extra data found after final 'f' instruction, token: %s\", extra.c_str());\n        }\n    }\n\n    // 3) We'll test several (x, y) pairs. We do a small set of deterministic plus random checks.\n    //    Because p can be large, we can't exhaust all x,y. We'll test a few edge and random cases.\n    //    If it passes them all, we accept. If any fails, we _wa.\n\n    // We create a small set of x,y pairs (including 0, 1, small random, etc.).\n    vector<pair<long long, long long>> tests;\n    // Edge cases\n    tests.push_back({0, 0});\n    tests.push_back({0, 1});\n    tests.push_back({1, 0});\n    tests.push_back({1, 1});\n    tests.push_back({2, 2});\n    // Some random pairs (up to 5 random checks)\n    const int RANDOM_TESTS = 5;\n    // We'll keep random values in [0, min(p-1, 20)] for safety\n    // (No need for large random if p is huge; just partial check.)\n    for (int i = 0; i < RANDOM_TESTS; i++) {\n        long long rx = rnd.next(0LL, min(p-1, 20LL));\n        long long ry = rnd.next(0LL, min(p-1, 20LL));\n        tests.push_back({rx, ry});\n    }\n\n    // For each test pair (x,y), simulate the program:\n    for (auto &pr : tests) {\n        long long x = pr.first;\n        long long y = pr.second;\n\n        // Initialize memory\n        static long long mem[5001]; // 1-based indexing\n        for (int i = 3; i <= 5000; i++) {\n            mem[i] = 1 % p; \n        }\n        mem[1] = x % p;\n        mem[2] = y % p;\n\n        // run the program\n        bool haveFinal = false;\n        long long finalVal = -1;\n        for (auto &ins : prog) {\n            if (ins.type == '+') {\n                // mem[to] = (mem[e1] + mem[e2]) mod p\n                long long val = (mem[ins.e1] + mem[ins.e2]) % p;\n                mem[ins.to] = val;\n            }\n            else if (ins.type == '^') {\n                // mem[to] = (mem[e1]^d) mod p\n                // do fast exponent\n                long long base = mem[ins.e1] % p;\n                long long power = 1 % p;\n                long long dd = d;\n                // fast exponentiation\n                while (dd > 0) {\n                    if (dd & 1) {\n                        // multiply by base\n                        __int128 tmp = (__int128)power * base;\n                        power = (long long)(tmp % p);\n                    }\n                    __int128 tmp = (__int128)base * base;\n                    base = (long long)(tmp % p);\n                    dd >>= 1;\n                }\n                mem[ins.to] = power % p;\n            }\n            else { // 'f'\n                haveFinal = true;\n                finalVal = mem[ins.e1];\n                break; \n            }\n        }\n\n        if (!haveFinal) {\n            quitf(_wa, \"No final instruction was found for test pair (x=%lld, y=%lld).\", x, y);\n        }\n\n        // check the result\n        long long shouldBe = (x % p) * (y % p) % p;\n        if (finalVal != shouldBe) {\n            quitf(_wa, \"Wrong result for x=%lld, y=%lld. Expected %lld, got %lld.\",\n                  x, y, shouldBe, finalVal);\n        }\n    }\n\n    // 4) If all tests pass:\n    quitf(_ok, \"All tested pairs OK. Solution accepted.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int p) {\n    if (p < 2) return false;\n    if (p == 2 || p == 3) return true;\n    if (p % 2 == 0) return false;\n    for (int i = 3; i * i <= p; i += 2) {\n        if (p % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int d = opt<int>(\"d\", rnd.next(2, 10));\n    string type = opt<string>(\"type\", \"random\");\n\n    int p = 0;\n\n    if (type == \"small_prime\") {\n        // Generate a small prime p greater than d\n        vector<int> primes = {3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\n        for (int prime : primes) {\n            if (prime > d) {\n                p = prime;\n                break;\n            }\n        }\n        if (p == 0) {\n            // If no small prime found, use the next prime after d\n            p = d + 1;\n            while (!isPrime(p)) p++;\n        }\n    } else if (type == \"large_prime\") {\n        // Use a large prime, such as 1e9+7 or 1e9+9\n        if (d < 1000000007)\n            p = 1000000007;\n        else\n            p = 1000000009;\n    } else if (type == \"p_equal_d_plus_one\") {\n        // p is the next prime after d\n        p = d + 1;\n        while (!isPrime(p)) p++;\n    } else if (type == \"random_prime\") {\n        // Generate a random prime p greater than d\n        int min_p = d + 1;\n        int max_p = min_p + 1000; // Limit to avoid too large numbers\n        vector<int> candidates;\n        for (int i = min_p; i <= max_p; ++i) {\n            if (isPrime(i)) candidates.push_back(i);\n        }\n        if (!candidates.empty()) {\n            p = rnd.any(candidates);\n        } else {\n            // If no prime found in range, use the next prime after max_p\n            p = max_p + 1;\n            while (!isPrime(p)) p++;\n        }\n    } else {\n        // Default to p being the next prime after d\n        p = d + 1;\n        while (!isPrime(p)) p++;\n    }\n\n    // Ensure p satisfies the constraints\n    ensure(3 <= p && p <= 1000000009 && isPrime(p) && d < p);\n\n    printf(\"%d %d\\n\", d, p);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int p) {\n    if (p < 2) return false;\n    if (p == 2 || p == 3) return true;\n    if (p % 2 == 0) return false;\n    for (int i = 3; i * i <= p; i += 2) {\n        if (p % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int d = opt<int>(\"d\", rnd.next(2, 10));\n    string type = opt<string>(\"type\", \"random\");\n\n    int p = 0;\n\n    if (type == \"small_prime\") {\n        // Generate a small prime p greater than d\n        vector<int> primes = {3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\n        for (int prime : primes) {\n            if (prime > d) {\n                p = prime;\n                break;\n            }\n        }\n        if (p == 0) {\n            // If no small prime found, use the next prime after d\n            p = d + 1;\n            while (!isPrime(p)) p++;\n        }\n    } else if (type == \"large_prime\") {\n        // Use a large prime, such as 1e9+7 or 1e9+9\n        if (d < 1000000007)\n            p = 1000000007;\n        else\n            p = 1000000009;\n    } else if (type == \"p_equal_d_plus_one\") {\n        // p is the next prime after d\n        p = d + 1;\n        while (!isPrime(p)) p++;\n    } else if (type == \"random_prime\") {\n        // Generate a random prime p greater than d\n        int min_p = d + 1;\n        int max_p = min_p + 1000; // Limit to avoid too large numbers\n        vector<int> candidates;\n        for (int i = min_p; i <= max_p; ++i) {\n            if (isPrime(i)) candidates.push_back(i);\n        }\n        if (!candidates.empty()) {\n            p = rnd.any(candidates);\n        } else {\n            // If no prime found in range, use the next prime after max_p\n            p = max_p + 1;\n            while (!isPrime(p)) p++;\n        }\n    } else {\n        // Default to p being the next prime after d\n        p = d + 1;\n        while (!isPrime(p)) p++;\n    }\n\n    // Ensure p satisfies the constraints\n    ensure(3 <= p && p <= 1000000009 && isPrime(p) && d < p);\n\n    printf(\"%d %d\\n\", d, p);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -d 2 -type small_prime\n./gen -d 2 -type large_prime\n./gen -d 2 -type p_equal_d_plus_one\n./gen -d 2 -type random_prime\n\n./gen -d 3 -type small_prime\n./gen -d 3 -type large_prime\n./gen -d 3 -type p_equal_d_plus_one\n./gen -d 3 -type random_prime\n\n./gen -d 5 -type small_prime\n./gen -d 5 -type large_prime\n./gen -d 5 -type p_equal_d_plus_one\n./gen -d 5 -type random_prime\n\n./gen -d 7 -type small_prime\n./gen -d 7 -type large_prime\n./gen -d 7 -type p_equal_d_plus_one\n./gen -d 7 -type random_prime\n\n./gen -d 10 -type small_prime\n./gen -d 10 -type large_prime\n./gen -d 10 -type p_equal_d_plus_one\n./gen -d 10 -type random_prime\n\n# Generating test cases with random d\n./gen -d 2 -type random_prime\n./gen -d 4 -type random_prime\n./gen -d 6 -type random_prime\n./gen -d 8 -type random_prime\n./gen -d 9 -type random_prime\n\n# Generating test cases with maximum p\n./gen -d 2 -type large_prime\n./gen -d 5 -type large_prime\n./gen -d 8 -type large_prime\n\n# Additional test cases with p just greater than d\n./gen -d 2 -type p_equal_d_plus_one\n./gen -d 3 -type p_equal_d_plus_one\n./gen -d 4 -type p_equal_d_plus_one\n./gen -d 5 -type p_equal_d_plus_one\n./gen -d 6 -type p_equal_d_plus_one\n\n# Random test cases without specifying type\n./gen -d 2\n./gen -d 5\n./gen -d 8\n./gen -d 10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:32.428639",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1061/A",
      "title": "A. Coins",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of the input contains two integers nn and SS (1≤n≤1000001≤n≤100000, 1≤S≤1091≤S≤109)",
      "output_spec": "OutputPrint exactly one integer — the minimum number of coins required to obtain sum SS.",
      "sample_tests": "ExamplesInputCopy5 11OutputCopy3InputCopy6 16OutputCopy3",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line of the input contains two integers nn and SS (1≤n≤1000001≤n≤100000, 1≤S≤1091≤S≤109)\n\nOutputPrint exactly one integer — the minimum number of coins required to obtain sum SS.\n\nInputCopy5 11OutputCopy3InputCopy6 16OutputCopy3\n\nInputCopy5 11\n\nOutputCopy3\n\nInputCopy6 16\n\nOutputCopy3\n\nNoteIn the first example, some of the possible ways to get sum 1111 with 33 coins are:   (3,4,4)(3,4,4) (2,4,5)(2,4,5) (1,5,5)(1,5,5) (3,3,5)(3,3,5) It is impossible to get sum 1111 with less than 33 coins.In the second example, some of the possible ways to get sum 1616 with 33 coins are:   (5,5,6)(5,5,6) (4,6,6)(4,6,6) It is impossible to get sum 1616 with less than 33 coins.",
      "solutions": [
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces",
          "content": "Hi everyone!I would like to invite you to my second Codeforces Round, which I have made with my friend and Snackdown partner Jeel_Vaishnav.With that said, I bring to your attention our new Codeforces Round 523 (Div. 2) that will take place on Thursday, November 22, 2018 at 23:45UTC+8. If your rating is less than 2100, this round will be rated for you; otherwise, you can participate out of competition.I would really like to thank Jeel_Vaishnav for his help with preparing problems, cdkrot for coordinating our round and Um_nik, vintage_Vlad_Makeev, Aleks5d, KeyurJain & Mahir83 for testing the problems. I would also like to thank MikeMirzayanov for Codeforces and Polygon platforms.You will be given 6 problems and 2 hours to solve them. Scoring distribution will be announced later.Link to My Coding Library for those interested :)Good luck! :DUPD: Scoring Distribution: 500-1000-1500-2000-2500-2750UPD2: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63352",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 919
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces",
          "content": "I hope you guys enjoyed the contest and we hope to host another one soon :)With that said, here are the tutorials: 1061A - CoinsNotice that using maximum value coin whenever possible will be always optimal. Hence, we can use floor(S/n)floor(S/n) coins of value nn. Now, if SmodnSmodn is not equal to 00, then we need to use one more coin of valuation SmodnSmodn. Hence, our answer can be written as ceil(S/n)ceil(S/n).Overall Complexity: O(1)O(1)Author: AshishgupC++ Code: 46095081 Java Code: 46095332 1061B - Views MatterLet's sort the array in increasing order and find the minimum number of blocks XX required to retain the same top and right views. Then, the answer would be ∑ni=1Ai−X∑i=1nAi−X.For every ii from 11 to NN, we need to keep at least 11 block for this stack to retain the top view. Thus, X=X+1X=X+1 for every ii. However, we also need to maintain the maximum height we can cover till now, by keeping 11 block in this stack. Let the previous best height we had be YY.Then, if A[i]>YA[i]>Y, then we managed to increase the height YY by 11, by keeping the block at Y+1Y+1. However, if A[i]=YA[i]=Y, then we cannot increase the number of blocks in the right view, since we are only allowed to keep the current block in range [1,Y][1,Y]. In the end, when we finish processing all the stacks, we also need to keep max(Ai)−Ymax(Ai)−Y blocks in the longest stack, to retain the right view as it was originally.Overall complexity: O(nlogn)O(nlog⁡n)Refer to solution code for clarity.Author: Jeel_VaishnavC++ Code: 46095083 Java Code: 46095337 1061C - MultiplicityLet's introduce the following dynamic programming approach, dp[n][n]dp[n][n], where dp[i][j]dp[i][j] indicates the number of ways to select a good subsequence of size jj from elements a1,a2,...,aia1,a2,...,ai. Our final answer will be ∑ni=1dp[n][i]∑i=1ndp[n][i].dp[i][j]={dp[i−1][j]+dp[i−1][j−1]dp[i−1][j]if a[i] is a multiple of jotherwisedp[i][j]={dp[i−1][j]+dp[i−1][j−1]if a[i] is a multiple of jdp[i−1][j]otherwiseNow, maintaining a 2-D dp will exceed memory limit, however notice that dp[i]dp[i] is calculated only on the basis of dp[i−1]dp[i−1], hence mainitaining a 1-D dp will work. Also, now dp[j]dp[j] is updated if and only if jj is a divisor of a[i]a[i]. We can find divisors of a number xx in O(x−−√)O(x).Overall Complexity : O(n⋅(maxD+maxA−−−−−√))O(n⋅(maxD+maxA)). Here, maxDmaxD indicates maximum number of divisors possible and maxAmaxA indicates maximum value of aiai possible.Also, we can use sieve to compute divisors of each number and achieve complexity of O(maxA⋅log(maxA)+n⋅maxD)O(maxA⋅log(maxA)+n⋅maxD).Authors: Jeel_Vaishnav, AshishgupC++ Code: 46095097 Java Code: 46095342 1061D - TV ShowsSolution: Sort the TV shows on the basis of their starting time. Now, we start allocating TVs greedily to the shows. For any show ii, we allocate a new TV only if there is no old TV where the show ends at roro, such that ro<liro<li and (li−ro)⋅y<=x(li−ro)⋅y<=x. Also, if there are many such old TVs, then we use the TV where roro is maximum.Proof: Notice that there is a minimal cost of ∑ni=1(ri−li)⋅y∑i=1n(ri−li)⋅y, which will always be added. Hence, the optimal solution completely depends on the rent of new TV and the time wasted on old TVs. Now, lets try to prove that allocating an old TV with maximum roro is optimal. Suppose we are allocating a TV to show ii. Let's consider two old TVs o1o1 and o2o2, such that ro1<ro2<liro1<ro2<li and (li−ro1)⋅y<=x(li−ro1)⋅y<=x. In such a case, it is possible to allocate both the TVs to this show. For choosing which TV to be allocated let's consider the three possible cases:Case I: There is no show j(j>i)j(j>i), such that (lj−ro2)⋅y<=x(lj−ro2)⋅y<=x. In this case, it would be better to allocate TV o2o2 to show ii, since (li−ro2)⋅y<(li−ro1)⋅y(li−ro2)⋅y<(li−ro1)⋅y. Hence, allocating TV o2o2 to show ii is optimal in this case.Case II: There are shows j(j>i)j(j>i), such that (lj−ro2)⋅y<=x(lj−ro2)⋅y<=x; but there is no show j(j>i)j(j>i), such that (lj−ro1)⋅y<=x(lj−ro1)⋅y<=x. In this case, if we allocate TV o1o1 to show ii and TV o2o2 to show jj, then the cost will be (lj−ro2)⋅y+(li−ro1)⋅y(lj−ro2)⋅y+(li−ro1)⋅y. And, if we allocate TV o2o2 to show ii, then we need to buy a new TV for show jj and our cost will be x+(li−ro2)⋅yx+(li−ro2)⋅y. Now, as (lj−ro1)⋅y>x(lj−ro1)⋅y>x, (lj−ro2)⋅y+(li−ro1)⋅y>x+(li−ro2)⋅y(lj−ro2)⋅y+(li−ro1)⋅y>x+(li−ro2)⋅y. Hence, allocating TV o2o2 instead of TV o1o1 to show ii is optimal in this case.Case III: There are shows j(j>i)j(j>i), such that (lj−ro1)⋅y<=x(lj−ro1)⋅y<=x. In this case, if we allocate TV o1o1 to show ii, cost will be (li−ro1)⋅y+(lj−ro2)⋅y(li−ro1)⋅y+(lj−ro2)⋅y. If we allocate TV o2o2 to show ii, cost will be (li−ro2)⋅y+(lj−ro1)⋅y(li−ro2)⋅y+(lj−ro1)⋅y. Here, we can see that in both of the allocations, the cost is (li+lj−ro1−ro2)⋅y(li+lj−ro1−ro2)⋅y and so any allocation is optimal here. Hence, we can see that if more than one old TVs are available, allocating the one with maximum roro is always optimal. Overall Complexity: O(n⋅logn)O(n⋅log⁡n)Authors: Jeel_Vaishnav, AshishgupC++ Code: 46095154 Java Code: 46095344 1061E - PoliticsLet's create a graph with a source, sink and two layers. Let the left layer denote the nodes of tree 11 and right layer denote the nodes of tree 22. Let's denote xixi as the demand of the ithith node. For a demand (k,x)(k,x) in tree 1, we add an edge from source to node kk in the left layer with cost=0cost=0 and capacity=x−∑xjcapacity=x−∑xj, such that jj is not equal to ii and jj belongs to the subtree of ii. Similarly for a demand (k,x)(k,x) in tree 2, we add an edge from node kk in the right layer to sink with cost=0cost=0 and capacity=x−∑xjcapacity=x−∑xj, such that jj is not equal to ii and jj belongs to the subtree of ii. Now, for every node ii, let col1icol1i be the closest node to ii, such that ii belongs to subtree of col1icol1i and the demand of col1icol1i in tree 11 has been provided. Similarly col2icol2i be the closest node to ii, such that ii belongs to subtree of col2icol2i and the demand of col2icol2i in tree 22 has been provided.For every node ii, we add an edge from col1icol1i in left layer to col2icol2i in right layer with capacity=1capacity=1 and cost=−aicost=−ai.Now, when we run min cost max flow on this graph, our answer will be negative of the minimum cost obtained.Overall Complexity: O(n3)O(n3) using MCMF with bellman ford; O(n2⋅logn)O(n2⋅log⁡n) using MCMF with Dijkstra.Author: Jeel_VaishnavJava Code: 46095349A nice explanation of Problem E by Kognition in the comment section: https://codeforces.com/blog/entry/63352?#comment-473028 1061F - Lost RootThis solution had many randomized approaches, some with higher probability of passing and some with lower probability of passing.The author's solution (there exist better solutions with even lower probability of failure - comment yours below) is as follows:Part 1: Checking if a node is a leaf node:It can be done in O(n)O(n) queries.Suppose candidate node is XXGenerate a random node Y(!=X)Y(!=X)For all ZZ, if YY XX ZZ is falsefalse, then XX is a leaf node, otherwise is not. Part 2: Finding a leaf node: Generate a random node and check if it is a leaf node. Probability of getting a lead node is >=0.5>=0.5. Higher the KK, higher the probability.So we can find a leaf node in O(20⋅n)O(20⋅n) queries with failure probability (1/2)20(1/2)20Part 3: Generating a leaf node in other subtree of the actual root:Fix a random node (that is not the same as the leaf node, L1L1, that we found), check if it is a leaf node, and if it is a leaf node and check if 2h−12h−1 nodes separate Leaf 11 and this current leaf. If yes, we have found two separate leaf nodes and the 2h−12h−1 candidate nodes for the root. We can use  O(40⋅n)O(40⋅n) queries to ensure a failure probability of (1/2)20(1/2)20Finally: Instead of checking all of them separately in 2H⋅N2H⋅N, we can fix their order in O(H2)O(H2) by finding each node's appropriate position by placing them incrementally. Let the initial path be L1L1 L2L2, then we add XX to get L1L1 XX L2L2. Now to find YY's appropriate position, we check if it lies between L1L1, XX or XX, L2L2. And so on. In the final order, the middle node would be the root.Author: AshishgupC++ Code: 46095066 Java Code: 46095373",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63384",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1061\\s*A"
          },
          "content_length": 8256
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 1",
          "code": "502 Bad Gateway",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 2",
          "code": "auto it=lower_bound(s.begin(), s.end(), v[i].fs);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 3",
          "code": "auto it=lower_bound(s.begin(), s.end(), v[i].fs);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 4",
          "code": "st.lower_bound(val)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 5",
          "code": "for (int divisor = 1; divisor <= n; divisor++) {\n    int v = divisor\n    while (v <= 1000000) {\n        if (v exists in original input) then (add divisor to list of v's divisors)\n        v += divisor\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 6",
          "code": "for (int divisor = 1; divisor <= n; divisor++) {\n    int v = divisor\n    while (v <= 1000000) {\n        if (v exists in original input) then (add divisor to list of v's divisors)\n        v += divisor\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 7",
          "code": "highly likely",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 8",
          "code": "Highest = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 9",
          "code": "min(Highest+1, Height[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 10",
          "code": "Max - Highest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 11",
          "code": "dp[f[i]]+=ans[f[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 12",
          "code": "auto nxt = next(it);\nerase(it); \nit = nxt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 13",
          "code": "auto nxt = next(it);\nerase(it); \nit = nxt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 14",
          "code": "(int)(ceil(1.0*n/k)+1e-9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 1",
          "code": "std::sort(path.begin(), path.end(), \n  [&](int u, int v) {\n    if (u == v) return false; \n    return Query(leftmost, u, v);\n  }\n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 2",
          "code": "std::sort(path.begin(), path.end(), \n  [&](int u, int v) {\n    if (u == v) return false; \n    return Query(leftmost, u, v);\n  }\n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 3",
          "code": "*\n  *\n    *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 4",
          "code": "*\n  *\n    *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 5",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l))%mod;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 6",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l))%mod;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 7",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 8",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 9",
          "code": "int find_leaf()\n{\n    u=rand(),v=rand()\n    for i=1 to n \n        if query(u,v,i) \n            v=i; \n    return v; \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 10",
          "code": "int find_leaf()\n{\n    u=rand(),v=rand()\n    for i=1 to n \n        if query(u,v,i) \n            v=i; \n    return v; \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int S = inf.readInt(1, 1000000000, \"S\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int S = inf.readInt(1, 1000000000, \"S\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int S = inf.readInt(1, 1000000000, \"S\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int S = opt<int>(\"S\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (S == 0) S = rnd.next(1, 1000000000);\n        // else use S as provided\n    } else if (type == \"max\") {\n        n = 100000;\n        S = 1000000000;\n    } else if (type == \"min\") {\n        n = 1;\n        S = 1;\n    } else if (type == \"n_equals_S\") {\n        S = n;\n    } else if (type == \"S_multiple_of_n\") {\n        int k = opt<int>(\"k\", rnd.next(1, 10000));\n        S = n * k;\n        if (S > 1000000000) S = 1000000000;\n    } else if (type == \"S_just_less_than_multiple_of_n\") {\n        int k = opt<int>(\"k\", rnd.next(1, 10000));\n        S = n * k - 1;\n        if (S < 1) S = 1;\n    } else if (type == \"S_just_more_than_multiple_of_n\") {\n        int k = opt<int>(\"k\", rnd.next(1, 10000));\n        S = n * k + 1;\n        if (S > 1000000000) S = 1000000000;\n    } else if (type == \"S_equals_1\") {\n        S = 1;\n    } else if (type == \"S_equals_max\") {\n        S = 1000000000;\n    } else if (type == \"S_equals_n_minus_1\") {\n        S = n - 1;\n        if (S < 1) S = 1;\n    } else if (type == \"S_equals_n_plus_1\") {\n        S = n + 1;\n        if (S > 1000000000) S = 1000000000;\n    } else if (type == \"n_equals_1\") {\n        n = 1;\n        if (S == 0) S = rnd.next(1, 1000000000);\n    } else if (type == \"n_equals_max\") {\n        n = 100000;\n        if (S == 0) S = rnd.next(1, 1000000000);\n    } else if (type == \"n_small_S_large\") {\n        n = rnd.next(1, 10);\n        S = 1000000000;\n    } else if (type == \"n_large_S_small\") {\n        n = 100000;\n        S = rnd.next(1, 100);\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure n and S within constraints\n    if (n < 1) n = 1;\n    if (n > 100000) n = 100000;\n    if (S < 1) S = 1;\n    if (S > 1000000000) S = 1000000000;\n\n    printf(\"%d %d\\n\", n, S);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int S = opt<int>(\"S\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (S == 0) S = rnd.next(1, 1000000000);\n        // else use S as provided\n    } else if (type == \"max\") {\n        n = 100000;\n        S = 1000000000;\n    } else if (type == \"min\") {\n        n = 1;\n        S = 1;\n    } else if (type == \"n_equals_S\") {\n        S = n;\n    } else if (type == \"S_multiple_of_n\") {\n        int k = opt<int>(\"k\", rnd.next(1, 10000));\n        S = n * k;\n        if (S > 1000000000) S = 1000000000;\n    } else if (type == \"S_just_less_than_multiple_of_n\") {\n        int k = opt<int>(\"k\", rnd.next(1, 10000));\n        S = n * k - 1;\n        if (S < 1) S = 1;\n    } else if (type == \"S_just_more_than_multiple_of_n\") {\n        int k = opt<int>(\"k\", rnd.next(1, 10000));\n        S = n * k + 1;\n        if (S > 1000000000) S = 1000000000;\n    } else if (type == \"S_equals_1\") {\n        S = 1;\n    } else if (type == \"S_equals_max\") {\n        S = 1000000000;\n    } else if (type == \"S_equals_n_minus_1\") {\n        S = n - 1;\n        if (S < 1) S = 1;\n    } else if (type == \"S_equals_n_plus_1\") {\n        S = n + 1;\n        if (S > 1000000000) S = 1000000000;\n    } else if (type == \"n_equals_1\") {\n        n = 1;\n        if (S == 0) S = rnd.next(1, 1000000000);\n    } else if (type == \"n_equals_max\") {\n        n = 100000;\n        if (S == 0) S = rnd.next(1, 1000000000);\n    } else if (type == \"n_small_S_large\") {\n        n = rnd.next(1, 10);\n        S = 1000000000;\n    } else if (type == \"n_large_S_small\") {\n        n = 100000;\n        S = rnd.next(1, 100);\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure n and S within constraints\n    if (n < 1) n = 1;\n    if (n > 100000) n = 100000;\n    if (S < 1) S = 1;\n    if (S > 1000000000) S = 1000000000;\n\n    printf(\"%d %d\\n\", n, S);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input\n./gen -n 1 -S 1 -type min\n\n# Maximal input\n./gen -n 100000 -S 1000000000 -type max\n\n# n equals 1, various S\n./gen -n 1 -S 1 -type n_equals_1\n./gen -n 1 -S 500000000 -type n_equals_1\n./gen -n 1 -S 1000000000 -type n_equals_1\n\n# S equals 1, various n\n./gen -n 100000 -S 1 -type S_equals_1\n./gen -n 50000 -S 1 -type S_equals_1\n\n# S equals n\n./gen -n 99999 -type n_equals_S\n\n# S equals n - 1\n./gen -n 99999 -type S_equals_n_minus_1\n\n# S equals n + 1\n./gen -n 99999 -type S_equals_n_plus_1\n\n# S is a multiple of n\n./gen -n 99999 -type S_multiple_of_n -k 10001\n\n# S just less than a multiple of n\n./gen -n 99999 -type S_just_less_than_multiple_of_n -k 10001\n\n# S just more than a multiple of n\n./gen -n 99999 -type S_just_more_than_multiple_of_n -k 10001\n\n# Small n, large S\n./gen -n 2 -type n_small_S_large\n\n# Large n, small S\n./gen -n 100000 -type n_large_S_small\n\n# Random cases\n./gen -n 12345 -type random\n./gen -n 67890 -type random\n./gen -n 100000 -type random\n./gen -n 1 -type random\n./gen -n 50000 -type random\n\n# Test with S equals maximum\n./gen -n 99999 -type S_equals_max\n\n# Test with S equals n\n./gen -n 100000 -type n_equals_S\n\n# Edge cases with n equals 1 and large S\n./gen -n 1 -S 1000000000 -type n_equals_1\n\n# Edge cases with large n and small S\n./gen -n 100000 -S 1 -type n_large_S_small\n\n# All types with medium n\n./gen -n 50000 -type S_equals_n_minus_1\n./gen -n 50000 -type S_equals_n_plus_1\n./gen -n 50000 -type S_multiple_of_n -k 20000\n./gen -n 50000 -type S_just_less_than_multiple_of_n -k 20000\n./gen -n 50000 -type S_just_more_than_multiple_of_n -k 20000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:34.615134",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1061/B",
      "title": "B. Views Matter",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and mm (1≤n≤1000001≤n≤100000, 1≤m≤1091≤m≤109) — the number of stacks and the height of the exhibit.The second line contains nn integers a1,a2,…,ana1,a2,…,an (1≤ai≤m1≤ai≤m) — the number of blocks in each stack from left to right.",
      "output_spec": "OutputPrint exactly one integer — the maximum number of blocks that can be removed.",
      "sample_tests": "ExamplesInputCopy5 63 3 3 3 3OutputCopy10InputCopy3 51 2 4OutputCopy3InputCopy5 52 3 1 4 4OutputCopy9InputCopy1 1000548OutputCopy0InputCopy3 33 1 1OutputCopy1",
      "description": "B. Views Matter\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and mm (1≤n≤1000001≤n≤100000, 1≤m≤1091≤m≤109) — the number of stacks and the height of the exhibit.The second line contains nn integers a1,a2,…,ana1,a2,…,an (1≤ai≤m1≤ai≤m) — the number of blocks in each stack from left to right.\n\nOutputPrint exactly one integer — the maximum number of blocks that can be removed.\n\nInputCopy5 63 3 3 3 3OutputCopy10InputCopy3 51 2 4OutputCopy3InputCopy5 52 3 1 4 4OutputCopy9InputCopy1 1000548OutputCopy0InputCopy3 33 1 1OutputCopy1\n\nInputCopy5 63 3 3 3 3\n\nOutputCopy10\n\nInputCopy3 51 2 4\n\nOutputCopy3\n\nInputCopy5 52 3 1 4 4\n\nOutputCopy9\n\nInputCopy1 1000548\n\nOutputCopy0\n\nInputCopy3 33 1 1\n\nOutputCopy1\n\nNoteThe following pictures illustrate the first example and its possible solution.Blue cells indicate removed blocks. There are 1010 blue cells, so the answer is 1010.",
      "solutions": [
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces",
          "content": "Hi everyone!I would like to invite you to my second Codeforces Round, which I have made with my friend and Snackdown partner Jeel_Vaishnav.With that said, I bring to your attention our new Codeforces Round 523 (Div. 2) that will take place on Thursday, November 22, 2018 at 23:45UTC+8. If your rating is less than 2100, this round will be rated for you; otherwise, you can participate out of competition.I would really like to thank Jeel_Vaishnav for his help with preparing problems, cdkrot for coordinating our round and Um_nik, vintage_Vlad_Makeev, Aleks5d, KeyurJain & Mahir83 for testing the problems. I would also like to thank MikeMirzayanov for Codeforces and Polygon platforms.You will be given 6 problems and 2 hours to solve them. Scoring distribution will be announced later.Link to My Coding Library for those interested :)Good luck! :DUPD: Scoring Distribution: 500-1000-1500-2000-2500-2750UPD2: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63352",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 919
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces",
          "content": "I hope you guys enjoyed the contest and we hope to host another one soon :)With that said, here are the tutorials: 1061A - CoinsNotice that using maximum value coin whenever possible will be always optimal. Hence, we can use floor(S/n)floor(S/n) coins of value nn. Now, if SmodnSmodn is not equal to 00, then we need to use one more coin of valuation SmodnSmodn. Hence, our answer can be written as ceil(S/n)ceil(S/n).Overall Complexity: O(1)O(1)Author: AshishgupC++ Code: 46095081 Java Code: 46095332 1061B - Views MatterLet's sort the array in increasing order and find the minimum number of blocks XX required to retain the same top and right views. Then, the answer would be ∑ni=1Ai−X∑i=1nAi−X.For every ii from 11 to NN, we need to keep at least 11 block for this stack to retain the top view. Thus, X=X+1X=X+1 for every ii. However, we also need to maintain the maximum height we can cover till now, by keeping 11 block in this stack. Let the previous best height we had be YY.Then, if A[i]>YA[i]>Y, then we managed to increase the height YY by 11, by keeping the block at Y+1Y+1. However, if A[i]=YA[i]=Y, then we cannot increase the number of blocks in the right view, since we are only allowed to keep the current block in range [1,Y][1,Y]. In the end, when we finish processing all the stacks, we also need to keep max(Ai)−Ymax(Ai)−Y blocks in the longest stack, to retain the right view as it was originally.Overall complexity: O(nlogn)O(nlog⁡n)Refer to solution code for clarity.Author: Jeel_VaishnavC++ Code: 46095083 Java Code: 46095337 1061C - MultiplicityLet's introduce the following dynamic programming approach, dp[n][n]dp[n][n], where dp[i][j]dp[i][j] indicates the number of ways to select a good subsequence of size jj from elements a1,a2,...,aia1,a2,...,ai. Our final answer will be ∑ni=1dp[n][i]∑i=1ndp[n][i].dp[i][j]={dp[i−1][j]+dp[i−1][j−1]dp[i−1][j]if a[i] is a multiple of jotherwisedp[i][j]={dp[i−1][j]+dp[i−1][j−1]if a[i] is a multiple of jdp[i−1][j]otherwiseNow, maintaining a 2-D dp will exceed memory limit, however notice that dp[i]dp[i] is calculated only on the basis of dp[i−1]dp[i−1], hence mainitaining a 1-D dp will work. Also, now dp[j]dp[j] is updated if and only if jj is a divisor of a[i]a[i]. We can find divisors of a number xx in O(x−−√)O(x).Overall Complexity : O(n⋅(maxD+maxA−−−−−√))O(n⋅(maxD+maxA)). Here, maxDmaxD indicates maximum number of divisors possible and maxAmaxA indicates maximum value of aiai possible.Also, we can use sieve to compute divisors of each number and achieve complexity of O(maxA⋅log(maxA)+n⋅maxD)O(maxA⋅log(maxA)+n⋅maxD).Authors: Jeel_Vaishnav, AshishgupC++ Code: 46095097 Java Code: 46095342 1061D - TV ShowsSolution: Sort the TV shows on the basis of their starting time. Now, we start allocating TVs greedily to the shows. For any show ii, we allocate a new TV only if there is no old TV where the show ends at roro, such that ro<liro<li and (li−ro)⋅y<=x(li−ro)⋅y<=x. Also, if there are many such old TVs, then we use the TV where roro is maximum.Proof: Notice that there is a minimal cost of ∑ni=1(ri−li)⋅y∑i=1n(ri−li)⋅y, which will always be added. Hence, the optimal solution completely depends on the rent of new TV and the time wasted on old TVs. Now, lets try to prove that allocating an old TV with maximum roro is optimal. Suppose we are allocating a TV to show ii. Let's consider two old TVs o1o1 and o2o2, such that ro1<ro2<liro1<ro2<li and (li−ro1)⋅y<=x(li−ro1)⋅y<=x. In such a case, it is possible to allocate both the TVs to this show. For choosing which TV to be allocated let's consider the three possible cases:Case I: There is no show j(j>i)j(j>i), such that (lj−ro2)⋅y<=x(lj−ro2)⋅y<=x. In this case, it would be better to allocate TV o2o2 to show ii, since (li−ro2)⋅y<(li−ro1)⋅y(li−ro2)⋅y<(li−ro1)⋅y. Hence, allocating TV o2o2 to show ii is optimal in this case.Case II: There are shows j(j>i)j(j>i), such that (lj−ro2)⋅y<=x(lj−ro2)⋅y<=x; but there is no show j(j>i)j(j>i), such that (lj−ro1)⋅y<=x(lj−ro1)⋅y<=x. In this case, if we allocate TV o1o1 to show ii and TV o2o2 to show jj, then the cost will be (lj−ro2)⋅y+(li−ro1)⋅y(lj−ro2)⋅y+(li−ro1)⋅y. And, if we allocate TV o2o2 to show ii, then we need to buy a new TV for show jj and our cost will be x+(li−ro2)⋅yx+(li−ro2)⋅y. Now, as (lj−ro1)⋅y>x(lj−ro1)⋅y>x, (lj−ro2)⋅y+(li−ro1)⋅y>x+(li−ro2)⋅y(lj−ro2)⋅y+(li−ro1)⋅y>x+(li−ro2)⋅y. Hence, allocating TV o2o2 instead of TV o1o1 to show ii is optimal in this case.Case III: There are shows j(j>i)j(j>i), such that (lj−ro1)⋅y<=x(lj−ro1)⋅y<=x. In this case, if we allocate TV o1o1 to show ii, cost will be (li−ro1)⋅y+(lj−ro2)⋅y(li−ro1)⋅y+(lj−ro2)⋅y. If we allocate TV o2o2 to show ii, cost will be (li−ro2)⋅y+(lj−ro1)⋅y(li−ro2)⋅y+(lj−ro1)⋅y. Here, we can see that in both of the allocations, the cost is (li+lj−ro1−ro2)⋅y(li+lj−ro1−ro2)⋅y and so any allocation is optimal here. Hence, we can see that if more than one old TVs are available, allocating the one with maximum roro is always optimal. Overall Complexity: O(n⋅logn)O(n⋅log⁡n)Authors: Jeel_Vaishnav, AshishgupC++ Code: 46095154 Java Code: 46095344 1061E - PoliticsLet's create a graph with a source, sink and two layers. Let the left layer denote the nodes of tree 11 and right layer denote the nodes of tree 22. Let's denote xixi as the demand of the ithith node. For a demand (k,x)(k,x) in tree 1, we add an edge from source to node kk in the left layer with cost=0cost=0 and capacity=x−∑xjcapacity=x−∑xj, such that jj is not equal to ii and jj belongs to the subtree of ii. Similarly for a demand (k,x)(k,x) in tree 2, we add an edge from node kk in the right layer to sink with cost=0cost=0 and capacity=x−∑xjcapacity=x−∑xj, such that jj is not equal to ii and jj belongs to the subtree of ii. Now, for every node ii, let col1icol1i be the closest node to ii, such that ii belongs to subtree of col1icol1i and the demand of col1icol1i in tree 11 has been provided. Similarly col2icol2i be the closest node to ii, such that ii belongs to subtree of col2icol2i and the demand of col2icol2i in tree 22 has been provided.For every node ii, we add an edge from col1icol1i in left layer to col2icol2i in right layer with capacity=1capacity=1 and cost=−aicost=−ai.Now, when we run min cost max flow on this graph, our answer will be negative of the minimum cost obtained.Overall Complexity: O(n3)O(n3) using MCMF with bellman ford; O(n2⋅logn)O(n2⋅log⁡n) using MCMF with Dijkstra.Author: Jeel_VaishnavJava Code: 46095349A nice explanation of Problem E by Kognition in the comment section: https://codeforces.com/blog/entry/63352?#comment-473028 1061F - Lost RootThis solution had many randomized approaches, some with higher probability of passing and some with lower probability of passing.The author's solution (there exist better solutions with even lower probability of failure - comment yours below) is as follows:Part 1: Checking if a node is a leaf node:It can be done in O(n)O(n) queries.Suppose candidate node is XXGenerate a random node Y(!=X)Y(!=X)For all ZZ, if YY XX ZZ is falsefalse, then XX is a leaf node, otherwise is not. Part 2: Finding a leaf node: Generate a random node and check if it is a leaf node. Probability of getting a lead node is >=0.5>=0.5. Higher the KK, higher the probability.So we can find a leaf node in O(20⋅n)O(20⋅n) queries with failure probability (1/2)20(1/2)20Part 3: Generating a leaf node in other subtree of the actual root:Fix a random node (that is not the same as the leaf node, L1L1, that we found), check if it is a leaf node, and if it is a leaf node and check if 2h−12h−1 nodes separate Leaf 11 and this current leaf. If yes, we have found two separate leaf nodes and the 2h−12h−1 candidate nodes for the root. We can use  O(40⋅n)O(40⋅n) queries to ensure a failure probability of (1/2)20(1/2)20Finally: Instead of checking all of them separately in 2H⋅N2H⋅N, we can fix their order in O(H2)O(H2) by finding each node's appropriate position by placing them incrementally. Let the initial path be L1L1 L2L2, then we add XX to get L1L1 XX L2L2. Now to find YY's appropriate position, we check if it lies between L1L1, XX or XX, L2L2. And so on. In the final order, the middle node would be the root.Author: AshishgupC++ Code: 46095066 Java Code: 46095373",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63384",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1061\\s*B"
          },
          "content_length": 8256
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 1",
          "code": "502 Bad Gateway",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 2",
          "code": "auto it=lower_bound(s.begin(), s.end(), v[i].fs);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 3",
          "code": "auto it=lower_bound(s.begin(), s.end(), v[i].fs);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 4",
          "code": "st.lower_bound(val)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 5",
          "code": "for (int divisor = 1; divisor <= n; divisor++) {\n    int v = divisor\n    while (v <= 1000000) {\n        if (v exists in original input) then (add divisor to list of v's divisors)\n        v += divisor\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 6",
          "code": "for (int divisor = 1; divisor <= n; divisor++) {\n    int v = divisor\n    while (v <= 1000000) {\n        if (v exists in original input) then (add divisor to list of v's divisors)\n        v += divisor\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 7",
          "code": "highly likely",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 8",
          "code": "Highest = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 9",
          "code": "min(Highest+1, Height[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 10",
          "code": "Max - Highest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 11",
          "code": "dp[f[i]]+=ans[f[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 12",
          "code": "auto nxt = next(it);\nerase(it); \nit = nxt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 13",
          "code": "auto nxt = next(it);\nerase(it); \nit = nxt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 14",
          "code": "(int)(ceil(1.0*n/k)+1e-9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 1",
          "code": "std::sort(path.begin(), path.end(), \n  [&](int u, int v) {\n    if (u == v) return false; \n    return Query(leftmost, u, v);\n  }\n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 2",
          "code": "std::sort(path.begin(), path.end(), \n  [&](int u, int v) {\n    if (u == v) return false; \n    return Query(leftmost, u, v);\n  }\n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 3",
          "code": "*\n  *\n    *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 4",
          "code": "*\n  *\n    *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 5",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l))%mod;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 6",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l))%mod;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 7",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 8",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 9",
          "code": "int find_leaf()\n{\n    u=rand(),v=rand()\n    for i=1 to n \n        if query(u,v,i) \n            v=i; \n    return v; \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 10",
          "code": "int find_leaf()\n{\n    u=rand(),v=rand()\n    for i=1 to n \n        if query(u,v,i) \n            v=i; \n    return v; \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, m, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, m, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, m, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, m);\n        }\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, m);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"maxes\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = m;\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = min(m, i + 1);\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = max(1, m - i);\n        }\n    } else if (type == \"max_min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? m : 1;\n        }\n    } else if (type == \"staircase\") {\n        int s = rnd.next(1, m / n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = min(m, s + i);\n        }\n    } else if (type == \"spikes\") {\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(1, 10) == 1) { // 10% chance\n                a[i] = m;\n            } else {\n                a[i] = rnd.next(1, min(m / 10, (int)1e8) + 1);\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, m);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, m);\n        }\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, m);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"maxes\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = m;\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = min(m, i + 1);\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = max(1, m - i);\n        }\n    } else if (type == \"max_min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? m : 1;\n        }\n    } else if (type == \"staircase\") {\n        int s = rnd.next(1, m / n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = min(m, s + i);\n        }\n    } else if (type == \"spikes\") {\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(1, 10) == 1) { // 10% chance\n                a[i] = m;\n            } else {\n                a[i] = rnd.next(1, min(m / 10, (int)1e8) + 1);\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, m);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type ones\n./gen -n 1 -m 1000000000 -type maxes\n./gen -n 2 -m 1000 -type increasing\n./gen -n 5 -m 10 -type decreasing\n./gen -n 10 -m 5 -type random\n./gen -n 100 -m 1 -type ones\n./gen -n 1000 -m 1000000000 -type maxes\n./gen -n 100000 -m 1000000000 -type random\n./gen -n 100000 -m 1 -type ones\n\n# Edge cases\n./gen -n 100000 -m 1 -type ones\n./gen -n 100000 -m 1000000000 -type maxes\n./gen -n 100000 -m 1000000000 -type increasing\n./gen -n 100000 -m 1000000000 -type decreasing\n./gen -n 100000 -m 1000000000 -type max_min\n./gen -n 100000 -m 1000000000 -type spikes\n\n# Small m\n./gen -n 100000 -m 2 -type max_min\n./gen -n 100000 -m 10 -type spikes\n\n# Staircase test case\n./gen -n 100000 -m 1000000000 -type staircase\n\n# Random test cases with various n and m\n./gen -n 12345 -m 67890 -type random\n./gen -n 99999 -m 1000000000 -type random\n./gen -n 54321 -m 1000000000 -type random\n\n# Small n tests\n./gen -n 3 -m 5 -type random\n./gen -n 2 -m 1000000000 -type max_min\n\n# Max n and min m\n./gen -n 100000 -m 1 -type ones\n\n# Min n and max m\n./gen -n 1 -m 1000000000 -type maxes\n./gen -n 1 -m 500000000 -type maxes\n\n# Max n and various m\n./gen -n 100000 -m 500000000 -type increasing\n./gen -n 100000 -m 500000000 -type decreasing\n./gen -n 100000 -m 500000000 -type max_min\n./gen -n 100000 -m 500000000 -type spikes\n\n# All_same type\n./gen -n 100000 -m 1000000000 -type all_same\n./gen -n 100000 -m 1 -type all_same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:36.558665",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1061/C",
      "title": "C. Multiplicity",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer nn (1≤n≤1000001≤n≤100000) — the length of the array aa.The next line contains integers a1,a2,…,ana1,a2,…,an (1≤ai≤1061≤ai≤106).",
      "output_spec": "OutputPrint exactly one integer — the number of good subsequences taken modulo 109+7109+7.",
      "sample_tests": "ExamplesInputCopy21 2OutputCopy3InputCopy52 2 1 22 14OutputCopy13",
      "description": "C. Multiplicity\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains an integer nn (1≤n≤1000001≤n≤100000) — the length of the array aa.The next line contains integers a1,a2,…,ana1,a2,…,an (1≤ai≤1061≤ai≤106).\n\nOutputPrint exactly one integer — the number of good subsequences taken modulo 109+7109+7.\n\nInputCopy21 2OutputCopy3InputCopy52 2 1 22 14OutputCopy13\n\nInputCopy21 2\n\nOutputCopy3\n\nInputCopy52 2 1 22 14\n\nOutputCopy13\n\nNoteIn the first example, all three non-empty possible subsequences are good: {1}{1}, {1,2}{1,2}, {2}{2}In the second example, the possible good subsequences are: {2}{2}, {2,2}{2,2}, {2,22}{2,22}, {2,14}{2,14}, {2}{2}, {2,22}{2,22}, {2,14}{2,14}, {1}{1}, {1,22}{1,22}, {1,14}{1,14}, {22}{22}, {22,14}{22,14}, {14}{14}.Note, that some subsequences are listed more than once, since they occur in the original array multiple times.",
      "solutions": [
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces",
          "content": "Hi everyone!I would like to invite you to my second Codeforces Round, which I have made with my friend and Snackdown partner Jeel_Vaishnav.With that said, I bring to your attention our new Codeforces Round 523 (Div. 2) that will take place on Thursday, November 22, 2018 at 23:45UTC+8. If your rating is less than 2100, this round will be rated for you; otherwise, you can participate out of competition.I would really like to thank Jeel_Vaishnav for his help with preparing problems, cdkrot for coordinating our round and Um_nik, vintage_Vlad_Makeev, Aleks5d, KeyurJain & Mahir83 for testing the problems. I would also like to thank MikeMirzayanov for Codeforces and Polygon platforms.You will be given 6 problems and 2 hours to solve them. Scoring distribution will be announced later.Link to My Coding Library for those interested :)Good luck! :DUPD: Scoring Distribution: 500-1000-1500-2000-2500-2750UPD2: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63352",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 919
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces",
          "content": "I hope you guys enjoyed the contest and we hope to host another one soon :)With that said, here are the tutorials: 1061A - CoinsNotice that using maximum value coin whenever possible will be always optimal. Hence, we can use floor(S/n)floor(S/n) coins of value nn. Now, if SmodnSmodn is not equal to 00, then we need to use one more coin of valuation SmodnSmodn. Hence, our answer can be written as ceil(S/n)ceil(S/n).Overall Complexity: O(1)O(1)Author: AshishgupC++ Code: 46095081 Java Code: 46095332 1061B - Views MatterLet's sort the array in increasing order and find the minimum number of blocks XX required to retain the same top and right views. Then, the answer would be ∑ni=1Ai−X∑i=1nAi−X.For every ii from 11 to NN, we need to keep at least 11 block for this stack to retain the top view. Thus, X=X+1X=X+1 for every ii. However, we also need to maintain the maximum height we can cover till now, by keeping 11 block in this stack. Let the previous best height we had be YY.Then, if A[i]>YA[i]>Y, then we managed to increase the height YY by 11, by keeping the block at Y+1Y+1. However, if A[i]=YA[i]=Y, then we cannot increase the number of blocks in the right view, since we are only allowed to keep the current block in range [1,Y][1,Y]. In the end, when we finish processing all the stacks, we also need to keep max(Ai)−Ymax(Ai)−Y blocks in the longest stack, to retain the right view as it was originally.Overall complexity: O(nlogn)O(nlog⁡n)Refer to solution code for clarity.Author: Jeel_VaishnavC++ Code: 46095083 Java Code: 46095337 1061C - MultiplicityLet's introduce the following dynamic programming approach, dp[n][n]dp[n][n], where dp[i][j]dp[i][j] indicates the number of ways to select a good subsequence of size jj from elements a1,a2,...,aia1,a2,...,ai. Our final answer will be ∑ni=1dp[n][i]∑i=1ndp[n][i].dp[i][j]={dp[i−1][j]+dp[i−1][j−1]dp[i−1][j]if a[i] is a multiple of jotherwisedp[i][j]={dp[i−1][j]+dp[i−1][j−1]if a[i] is a multiple of jdp[i−1][j]otherwiseNow, maintaining a 2-D dp will exceed memory limit, however notice that dp[i]dp[i] is calculated only on the basis of dp[i−1]dp[i−1], hence mainitaining a 1-D dp will work. Also, now dp[j]dp[j] is updated if and only if jj is a divisor of a[i]a[i]. We can find divisors of a number xx in O(x−−√)O(x).Overall Complexity : O(n⋅(maxD+maxA−−−−−√))O(n⋅(maxD+maxA)). Here, maxDmaxD indicates maximum number of divisors possible and maxAmaxA indicates maximum value of aiai possible.Also, we can use sieve to compute divisors of each number and achieve complexity of O(maxA⋅log(maxA)+n⋅maxD)O(maxA⋅log(maxA)+n⋅maxD).Authors: Jeel_Vaishnav, AshishgupC++ Code: 46095097 Java Code: 46095342 1061D - TV ShowsSolution: Sort the TV shows on the basis of their starting time. Now, we start allocating TVs greedily to the shows. For any show ii, we allocate a new TV only if there is no old TV where the show ends at roro, such that ro<liro<li and (li−ro)⋅y<=x(li−ro)⋅y<=x. Also, if there are many such old TVs, then we use the TV where roro is maximum.Proof: Notice that there is a minimal cost of ∑ni=1(ri−li)⋅y∑i=1n(ri−li)⋅y, which will always be added. Hence, the optimal solution completely depends on the rent of new TV and the time wasted on old TVs. Now, lets try to prove that allocating an old TV with maximum roro is optimal. Suppose we are allocating a TV to show ii. Let's consider two old TVs o1o1 and o2o2, such that ro1<ro2<liro1<ro2<li and (li−ro1)⋅y<=x(li−ro1)⋅y<=x. In such a case, it is possible to allocate both the TVs to this show. For choosing which TV to be allocated let's consider the three possible cases:Case I: There is no show j(j>i)j(j>i), such that (lj−ro2)⋅y<=x(lj−ro2)⋅y<=x. In this case, it would be better to allocate TV o2o2 to show ii, since (li−ro2)⋅y<(li−ro1)⋅y(li−ro2)⋅y<(li−ro1)⋅y. Hence, allocating TV o2o2 to show ii is optimal in this case.Case II: There are shows j(j>i)j(j>i), such that (lj−ro2)⋅y<=x(lj−ro2)⋅y<=x; but there is no show j(j>i)j(j>i), such that (lj−ro1)⋅y<=x(lj−ro1)⋅y<=x. In this case, if we allocate TV o1o1 to show ii and TV o2o2 to show jj, then the cost will be (lj−ro2)⋅y+(li−ro1)⋅y(lj−ro2)⋅y+(li−ro1)⋅y. And, if we allocate TV o2o2 to show ii, then we need to buy a new TV for show jj and our cost will be x+(li−ro2)⋅yx+(li−ro2)⋅y. Now, as (lj−ro1)⋅y>x(lj−ro1)⋅y>x, (lj−ro2)⋅y+(li−ro1)⋅y>x+(li−ro2)⋅y(lj−ro2)⋅y+(li−ro1)⋅y>x+(li−ro2)⋅y. Hence, allocating TV o2o2 instead of TV o1o1 to show ii is optimal in this case.Case III: There are shows j(j>i)j(j>i), such that (lj−ro1)⋅y<=x(lj−ro1)⋅y<=x. In this case, if we allocate TV o1o1 to show ii, cost will be (li−ro1)⋅y+(lj−ro2)⋅y(li−ro1)⋅y+(lj−ro2)⋅y. If we allocate TV o2o2 to show ii, cost will be (li−ro2)⋅y+(lj−ro1)⋅y(li−ro2)⋅y+(lj−ro1)⋅y. Here, we can see that in both of the allocations, the cost is (li+lj−ro1−ro2)⋅y(li+lj−ro1−ro2)⋅y and so any allocation is optimal here. Hence, we can see that if more than one old TVs are available, allocating the one with maximum roro is always optimal. Overall Complexity: O(n⋅logn)O(n⋅log⁡n)Authors: Jeel_Vaishnav, AshishgupC++ Code: 46095154 Java Code: 46095344 1061E - PoliticsLet's create a graph with a source, sink and two layers. Let the left layer denote the nodes of tree 11 and right layer denote the nodes of tree 22. Let's denote xixi as the demand of the ithith node. For a demand (k,x)(k,x) in tree 1, we add an edge from source to node kk in the left layer with cost=0cost=0 and capacity=x−∑xjcapacity=x−∑xj, such that jj is not equal to ii and jj belongs to the subtree of ii. Similarly for a demand (k,x)(k,x) in tree 2, we add an edge from node kk in the right layer to sink with cost=0cost=0 and capacity=x−∑xjcapacity=x−∑xj, such that jj is not equal to ii and jj belongs to the subtree of ii. Now, for every node ii, let col1icol1i be the closest node to ii, such that ii belongs to subtree of col1icol1i and the demand of col1icol1i in tree 11 has been provided. Similarly col2icol2i be the closest node to ii, such that ii belongs to subtree of col2icol2i and the demand of col2icol2i in tree 22 has been provided.For every node ii, we add an edge from col1icol1i in left layer to col2icol2i in right layer with capacity=1capacity=1 and cost=−aicost=−ai.Now, when we run min cost max flow on this graph, our answer will be negative of the minimum cost obtained.Overall Complexity: O(n3)O(n3) using MCMF with bellman ford; O(n2⋅logn)O(n2⋅log⁡n) using MCMF with Dijkstra.Author: Jeel_VaishnavJava Code: 46095349A nice explanation of Problem E by Kognition in the comment section: https://codeforces.com/blog/entry/63352?#comment-473028 1061F - Lost RootThis solution had many randomized approaches, some with higher probability of passing and some with lower probability of passing.The author's solution (there exist better solutions with even lower probability of failure - comment yours below) is as follows:Part 1: Checking if a node is a leaf node:It can be done in O(n)O(n) queries.Suppose candidate node is XXGenerate a random node Y(!=X)Y(!=X)For all ZZ, if YY XX ZZ is falsefalse, then XX is a leaf node, otherwise is not. Part 2: Finding a leaf node: Generate a random node and check if it is a leaf node. Probability of getting a lead node is >=0.5>=0.5. Higher the KK, higher the probability.So we can find a leaf node in O(20⋅n)O(20⋅n) queries with failure probability (1/2)20(1/2)20Part 3: Generating a leaf node in other subtree of the actual root:Fix a random node (that is not the same as the leaf node, L1L1, that we found), check if it is a leaf node, and if it is a leaf node and check if 2h−12h−1 nodes separate Leaf 11 and this current leaf. If yes, we have found two separate leaf nodes and the 2h−12h−1 candidate nodes for the root. We can use  O(40⋅n)O(40⋅n) queries to ensure a failure probability of (1/2)20(1/2)20Finally: Instead of checking all of them separately in 2H⋅N2H⋅N, we can fix their order in O(H2)O(H2) by finding each node's appropriate position by placing them incrementally. Let the initial path be L1L1 L2L2, then we add XX to get L1L1 XX L2L2. Now to find YY's appropriate position, we check if it lies between L1L1, XX or XX, L2L2. And so on. In the final order, the middle node would be the root.Author: AshishgupC++ Code: 46095066 Java Code: 46095373",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63384",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1061\\s*C"
          },
          "content_length": 8256
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 1",
          "code": "502 Bad Gateway",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 2",
          "code": "auto it=lower_bound(s.begin(), s.end(), v[i].fs);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 3",
          "code": "auto it=lower_bound(s.begin(), s.end(), v[i].fs);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 4",
          "code": "st.lower_bound(val)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 5",
          "code": "for (int divisor = 1; divisor <= n; divisor++) {\n    int v = divisor\n    while (v <= 1000000) {\n        if (v exists in original input) then (add divisor to list of v's divisors)\n        v += divisor\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 6",
          "code": "for (int divisor = 1; divisor <= n; divisor++) {\n    int v = divisor\n    while (v <= 1000000) {\n        if (v exists in original input) then (add divisor to list of v's divisors)\n        v += divisor\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 7",
          "code": "highly likely",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 8",
          "code": "Highest = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 9",
          "code": "min(Highest+1, Height[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 10",
          "code": "Max - Highest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 11",
          "code": "dp[f[i]]+=ans[f[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 12",
          "code": "auto nxt = next(it);\nerase(it); \nit = nxt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 13",
          "code": "auto nxt = next(it);\nerase(it); \nit = nxt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 14",
          "code": "(int)(ceil(1.0*n/k)+1e-9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 1",
          "code": "std::sort(path.begin(), path.end(), \n  [&](int u, int v) {\n    if (u == v) return false; \n    return Query(leftmost, u, v);\n  }\n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 2",
          "code": "std::sort(path.begin(), path.end(), \n  [&](int u, int v) {\n    if (u == v) return false; \n    return Query(leftmost, u, v);\n  }\n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 3",
          "code": "*\n  *\n    *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 4",
          "code": "*\n  *\n    *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 5",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l))%mod;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 6",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l))%mod;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 7",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 8",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 9",
          "code": "int find_leaf()\n{\n    u=rand(),v=rand()\n    for i=1 to n \n        if query(u,v,i) \n            v=i; \n    return v; \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 10",
          "code": "int find_leaf()\n{\n    u=rand(),v=rand()\n    for i=1 to n \n        if query(u,v,i) \n            v=i; \n    return v; \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"all_max\") {\n        fill(a.begin(), a.end(), 1000000);  // 1e6\n    } else if (type == \"multiples_of_i\") {\n        for (int i = 1; i <= n; ++i) {\n            int max_k = 1000000 / i; // k = a_i / i\n            if (max_k == 0) max_k = 1; // Ensure at least k=1\n            int k = rnd.next(1, max_k);\n            a[i - 1] = i * k;\n        }\n    } else if (type == \"not_multiples_of_i\") {\n        for (int i = 1; i <= n; ++i) {\n            int ai;\n            int attempts = 0;\n            do {\n                ai = rnd.next(1, 1000000);\n                attempts++;\n                if (attempts > 1000) {\n                    // If we can't find such a number, set ai to i+1 or 1\n                    if (i + 1 <= 1000000)\n                        ai = i + 1;\n                    else\n                        ai = 1;\n                    break;\n                }\n            } while (ai % i == 0);\n            a[i - 1] = ai;\n        }\n    } else if (type == \"alternating_multiples\") {\n        for (int i = 1; i <= n; ++i) {\n            if (i % 2 == 0) { // multiples of i\n                int max_k = 1000000 / i; // a_i = k * i\n                if (max_k == 0) max_k = 1;\n                int k = rnd.next(1, max_k);\n                a[i - 1] = i * k;\n            } else { // not multiples of i\n                int ai;\n                int attempts = 0;\n                do {\n                    ai = rnd.next(1, 1000000);\n                    attempts++;\n                    if (attempts > 1000) {\n                        if (i + 1 <= 1000000)\n                            ai = i + 1;\n                        else\n                            ai = 1;\n                        break;\n                    }\n                } while (ai % i == 0);\n                a[i - 1] = ai;\n            }\n        }\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"all_max\") {\n        fill(a.begin(), a.end(), 1000000);  // 1e6\n    } else if (type == \"multiples_of_i\") {\n        for (int i = 1; i <= n; ++i) {\n            int max_k = 1000000 / i; // k = a_i / i\n            if (max_k == 0) max_k = 1; // Ensure at least k=1\n            int k = rnd.next(1, max_k);\n            a[i - 1] = i * k;\n        }\n    } else if (type == \"not_multiples_of_i\") {\n        for (int i = 1; i <= n; ++i) {\n            int ai;\n            int attempts = 0;\n            do {\n                ai = rnd.next(1, 1000000);\n                attempts++;\n                if (attempts > 1000) {\n                    // If we can't find such a number, set ai to i+1 or 1\n                    if (i + 1 <= 1000000)\n                        ai = i + 1;\n                    else\n                        ai = 1;\n                    break;\n                }\n            } while (ai % i == 0);\n            a[i - 1] = ai;\n        }\n    } else if (type == \"alternating_multiples\") {\n        for (int i = 1; i <= n; ++i) {\n            if (i % 2 == 0) { // multiples of i\n                int max_k = 1000000 / i; // a_i = k * i\n                if (max_k == 0) max_k = 1;\n                int k = rnd.next(1, max_k);\n                a[i - 1] = i * k;\n            } else { // not multiples of i\n                int ai;\n                int attempts = 0;\n                do {\n                    ai = rnd.next(1, 1000000);\n                    attempts++;\n                    if (attempts > 1000) {\n                        if (i + 1 <= 1000000)\n                            ai = i + 1;\n                        else\n                            ai = 1;\n                        break;\n                    }\n                } while (ai % i == 0);\n                a[i - 1] = ai;\n            }\n        }\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_ones\n./gen -n 1 -type all_max\n\n./gen -n 2 -type multiples_of_i\n./gen -n 2 -type not_multiples_of_i\n\n./gen -n 10 -type alternating_multiples\n./gen -n 10 -type random\n\n./gen -n 1000 -type all_ones\n./gen -n 1000 -type all_max\n./gen -n 1000 -type multiples_of_i\n./gen -n 1000 -type not_multiples_of_i\n./gen -n 1000 -type alternating_multiples\n./gen -n 1000 -type random\n\n./gen -n 10000 -type all_ones\n./gen -n 10000 -type all_max\n./gen -n 10000 -type multiples_of_i\n./gen -n 10000 -type not_multiples_of_i\n./gen -n 10000 -type alternating_multiples\n./gen -n 10000 -type random\n\n./gen -n 50000 -type all_ones\n./gen -n 50000 -type all_max\n./gen -n 50000 -type multiples_of_i\n./gen -n 50000 -type not_multiples_of_i\n./gen -n 50000 -type alternating_multiples\n./gen -n 50000 -type random\n\n./gen -n 99999 -type all_ones\n./gen -n 99999 -type all_max\n./gen -n 99999 -type multiples_of_i\n./gen -n 99999 -type not_multiples_of_i\n./gen -n 99999 -type alternating_multiples\n./gen -n 99999 -type random\n\n./gen -n 100000 -type all_ones\n./gen -n 100000 -type all_max\n./gen -n 100000 -type multiples_of_i\n./gen -n 100000 -type not_multiples_of_i\n./gen -n 100000 -type alternating_multiples\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:38.419050",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1061/D",
      "title": "D. Телепередачи",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит три целых числа nn, xx и yy (1≤n≤1051≤n≤105, 1≤y<x≤1091≤y<x≤109) — количество телепередач, стоимость аренды телевизора в первую минуту и cтоимость аренды телевизора в каждую последующую минуту.Каждая из следующих nn строк содержит два целых числа lili и riri (1≤li≤ri≤1091≤li≤ri≤109), обозначающие начальную и конечную минуту ii-й телепередачи.",
      "output_spec": "Выходные данныеВыведите одно целое число — минимальную стоимость просмотра всех телепередач, взятую по модулю 109+7109+7.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 4 31 24 102 410 115 9Выходные данныеСкопировать60Входные данныеСкопировать6 3 28 206 224 1520 2817 2520 27Выходные данныеСкопировать142Входные данныеСкопировать2 1000000000 21 22 3Выходные данныеСкопировать999999997",
      "description": "D. Телепередачи\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит три целых числа nn, xx и yy (1≤n≤1051≤n≤105, 1≤y<x≤1091≤y<x≤109) — количество телепередач, стоимость аренды телевизора в первую минуту и cтоимость аренды телевизора в каждую последующую минуту.Каждая из следующих nn строк содержит два целых числа lili и riri (1≤li≤ri≤1091≤li≤ri≤109), обозначающие начальную и конечную минуту ii-й телепередачи.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — минимальную стоимость просмотра всех телепередач, взятую по модулю 109+7109+7.\n\nВыходные данные\n\nВходные данныеСкопировать5 4 31 24 102 410 115 9Выходные данныеСкопировать60Входные данныеСкопировать6 3 28 206 224 1520 2817 2520 27Выходные данныеСкопировать142Входные данныеСкопировать2 1000000000 21 22 3Выходные данныеСкопировать999999997\n\nВходные данныеСкопировать5 4 31 24 102 410 115 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать60\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 3 28 206 224 1520 2817 2520 27\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать142\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1000000000 21 22 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать999999997\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере оптимально арендовать 33 телевизора и посмотреть:  Телепередачу [1,2][1,2] на первом телевизоре, Телепередачу [4,10][4,10] на втором телевизоре, Тепередачи [2,4],[5,9],[10,11][2,4],[5,9],[10,11] на третьем телевизоре. Таким образом, стоимость аренды первого телевизора равна 4+3⋅(2−1)=74+3⋅(2−1)=7, второго 4+3⋅(10−4)=224+3⋅(10−4)=22 и треьего 4+3⋅(11−2)=314+3⋅(11−2)=31, что в сумме составляет 6060 рупий.Во втором примере оптимально посмотреть каждую телепередачу на отдельном телевизоре.В третьем примере тоже оптимально посмотреть каждую телепередачу на отдельном телевизоре. Обратите внимание, что ответ нужно вывести по модулю 109+7109+7.",
      "solutions": [
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces",
          "content": "Hi everyone!I would like to invite you to my second Codeforces Round, which I have made with my friend and Snackdown partner Jeel_Vaishnav.With that said, I bring to your attention our new Codeforces Round 523 (Div. 2) that will take place on четверг, 22 ноября 2018 г. в 23:45UTC+8. If your rating is less than 2100, this round will be rated for you; otherwise, you can participate out of competition.I would really like to thank Jeel_Vaishnav for his help with preparing problems, cdkrot for coordinating our round and Um_nik, vintage_Vlad_Makeev, Aleks5d, KeyurJain & Mahir83 for testing the problems. I would also like to thank MikeMirzayanov for Codeforces and Polygon platforms.You will be given 6 problems and 2 hours to solve them. Scoring distribution will be announced later.Link to My Coding Library for those interested :)Good luck! :DUPD: Scoring Distribution: 500-1000-1500-2000-2500-2750UPD2: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63352",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 917
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces",
          "content": "I hope you guys enjoyed the contest and we hope to host another one soon :)With that said, here are the tutorials: 1061A - CoinsNotice that using maximum value coin whenever possible will be always optimal. Hence, we can use floor(S/n)floor(S/n) coins of value nn. Now, if SmodnSmodn is not equal to 00, then we need to use one more coin of valuation SmodnSmodn. Hence, our answer can be written as ceil(S/n)ceil(S/n).Overall Complexity: O(1)O(1)Author: AshishgupC++ Code: 46095081 Java Code: 46095332 1061B - Views MatterLet's sort the array in increasing order and find the minimum number of blocks XX required to retain the same top and right views. Then, the answer would be ∑ni=1Ai−X∑i=1nAi−X.For every ii from 11 to NN, we need to keep at least 11 block for this stack to retain the top view. Thus, X=X+1X=X+1 for every ii. However, we also need to maintain the maximum height we can cover till now, by keeping 11 block in this stack. Let the previous best height we had be YY.Then, if A[i]>YA[i]>Y, then we managed to increase the height YY by 11, by keeping the block at Y+1Y+1. However, if A[i]=YA[i]=Y, then we cannot increase the number of blocks in the right view, since we are only allowed to keep the current block in range [1,Y][1,Y]. In the end, when we finish processing all the stacks, we also need to keep max(Ai)−Ymax(Ai)−Y blocks in the longest stack, to retain the right view as it was originally.Overall complexity: O(nlogn)O(nlog⁡n)Refer to solution code for clarity.Author: Jeel_VaishnavC++ Code: 46095083 Java Code: 46095337 1061C - MultiplicityLet's introduce the following dynamic programming approach, dp[n][n]dp[n][n], where dp[i][j]dp[i][j] indicates the number of ways to select a good subsequence of size jj from elements a1,a2,...,aia1,a2,...,ai. Our final answer will be ∑ni=1dp[n][i]∑i=1ndp[n][i].dp[i][j]={dp[i−1][j]+dp[i−1][j−1]dp[i−1][j]if a[i] is a multiple of jotherwisedp[i][j]={dp[i−1][j]+dp[i−1][j−1]if a[i] is a multiple of jdp[i−1][j]otherwiseNow, maintaining a 2-D dp will exceed memory limit, however notice that dp[i]dp[i] is calculated only on the basis of dp[i−1]dp[i−1], hence mainitaining a 1-D dp will work. Also, now dp[j]dp[j] is updated if and only if jj is a divisor of a[i]a[i]. We can find divisors of a number xx in O(x−−√)O(x).Overall Complexity : O(n⋅(maxD+maxA−−−−−√))O(n⋅(maxD+maxA)). Here, maxDmaxD indicates maximum number of divisors possible and maxAmaxA indicates maximum value of aiai possible.Also, we can use sieve to compute divisors of each number and achieve complexity of O(maxA⋅log(maxA)+n⋅maxD)O(maxA⋅log(maxA)+n⋅maxD).Authors: Jeel_Vaishnav, AshishgupC++ Code: 46095097 Java Code: 46095342 1061D - TV ShowsSolution: Sort the TV shows on the basis of their starting time. Now, we start allocating TVs greedily to the shows. For any show ii, we allocate a new TV only if there is no old TV where the show ends at roro, such that ro<liro<li and (li−ro)⋅y<=x(li−ro)⋅y<=x. Also, if there are many such old TVs, then we use the TV where roro is maximum.Proof: Notice that there is a minimal cost of ∑ni=1(ri−li)⋅y∑i=1n(ri−li)⋅y, which will always be added. Hence, the optimal solution completely depends on the rent of new TV and the time wasted on old TVs. Now, lets try to prove that allocating an old TV with maximum roro is optimal. Suppose we are allocating a TV to show ii. Let's consider two old TVs o1o1 and o2o2, such that ro1<ro2<liro1<ro2<li and (li−ro1)⋅y<=x(li−ro1)⋅y<=x. In such a case, it is possible to allocate both the TVs to this show. For choosing which TV to be allocated let's consider the three possible cases:Case I: There is no show j(j>i)j(j>i), such that (lj−ro2)⋅y<=x(lj−ro2)⋅y<=x. In this case, it would be better to allocate TV o2o2 to show ii, since (li−ro2)⋅y<(li−ro1)⋅y(li−ro2)⋅y<(li−ro1)⋅y. Hence, allocating TV o2o2 to show ii is optimal in this case.Case II: There are shows j(j>i)j(j>i), such that (lj−ro2)⋅y<=x(lj−ro2)⋅y<=x; but there is no show j(j>i)j(j>i), such that (lj−ro1)⋅y<=x(lj−ro1)⋅y<=x. In this case, if we allocate TV o1o1 to show ii and TV o2o2 to show jj, then the cost will be (lj−ro2)⋅y+(li−ro1)⋅y(lj−ro2)⋅y+(li−ro1)⋅y. And, if we allocate TV o2o2 to show ii, then we need to buy a new TV for show jj and our cost will be x+(li−ro2)⋅yx+(li−ro2)⋅y. Now, as (lj−ro1)⋅y>x(lj−ro1)⋅y>x, (lj−ro2)⋅y+(li−ro1)⋅y>x+(li−ro2)⋅y(lj−ro2)⋅y+(li−ro1)⋅y>x+(li−ro2)⋅y. Hence, allocating TV o2o2 instead of TV o1o1 to show ii is optimal in this case.Case III: There are shows j(j>i)j(j>i), such that (lj−ro1)⋅y<=x(lj−ro1)⋅y<=x. In this case, if we allocate TV o1o1 to show ii, cost will be (li−ro1)⋅y+(lj−ro2)⋅y(li−ro1)⋅y+(lj−ro2)⋅y. If we allocate TV o2o2 to show ii, cost will be (li−ro2)⋅y+(lj−ro1)⋅y(li−ro2)⋅y+(lj−ro1)⋅y. Here, we can see that in both of the allocations, the cost is (li+lj−ro1−ro2)⋅y(li+lj−ro1−ro2)⋅y and so any allocation is optimal here. Hence, we can see that if more than one old TVs are available, allocating the one with maximum roro is always optimal. Overall Complexity: O(n⋅logn)O(n⋅log⁡n)Authors: Jeel_Vaishnav, AshishgupC++ Code: 46095154 Java Code: 46095344 1061E - PoliticsLet's create a graph with a source, sink and two layers. Let the left layer denote the nodes of tree 11 and right layer denote the nodes of tree 22. Let's denote xixi as the demand of the ithith node. For a demand (k,x)(k,x) in tree 1, we add an edge from source to node kk in the left layer with cost=0cost=0 and capacity=x−∑xjcapacity=x−∑xj, such that jj is not equal to ii and jj belongs to the subtree of ii. Similarly for a demand (k,x)(k,x) in tree 2, we add an edge from node kk in the right layer to sink with cost=0cost=0 and capacity=x−∑xjcapacity=x−∑xj, such that jj is not equal to ii and jj belongs to the subtree of ii. Now, for every node ii, let col1icol1i be the closest node to ii, such that ii belongs to subtree of col1icol1i and the demand of col1icol1i in tree 11 has been provided. Similarly col2icol2i be the closest node to ii, such that ii belongs to subtree of col2icol2i and the demand of col2icol2i in tree 22 has been provided.For every node ii, we add an edge from col1icol1i in left layer to col2icol2i in right layer with capacity=1capacity=1 and cost=−aicost=−ai.Now, when we run min cost max flow on this graph, our answer will be negative of the minimum cost obtained.Overall Complexity: O(n3)O(n3) using MCMF with bellman ford; O(n2⋅logn)O(n2⋅log⁡n) using MCMF with Dijkstra.Author: Jeel_VaishnavJava Code: 46095349A nice explanation of Problem E by Kognition in the comment section: https://codeforces.com/blog/entry/63352?#comment-473028 1061F - Lost RootThis solution had many randomized approaches, some with higher probability of passing and some with lower probability of passing.The author's solution (there exist better solutions with even lower probability of failure - comment yours below) is as follows:Part 1: Checking if a node is a leaf node:It can be done in O(n)O(n) queries.Suppose candidate node is XXGenerate a random node Y(!=X)Y(!=X)For all ZZ, if YY XX ZZ is falsefalse, then XX is a leaf node, otherwise is not. Part 2: Finding a leaf node: Generate a random node and check if it is a leaf node. Probability of getting a lead node is >=0.5>=0.5. Higher the KK, higher the probability.So we can find a leaf node in O(20⋅n)O(20⋅n) queries with failure probability (1/2)20(1/2)20Part 3: Generating a leaf node in other subtree of the actual root:Fix a random node (that is not the same as the leaf node, L1L1, that we found), check if it is a leaf node, and if it is a leaf node and check if 2h−12h−1 nodes separate Leaf 11 and this current leaf. If yes, we have found two separate leaf nodes and the 2h−12h−1 candidate nodes for the root. We can use  O(40⋅n)O(40⋅n) queries to ensure a failure probability of (1/2)20(1/2)20Finally: Instead of checking all of them separately in 2H⋅N2H⋅N, we can fix their order in O(H2)O(H2) by finding each node's appropriate position by placing them incrementally. Let the initial path be L1L1 L2L2, then we add XX to get L1L1 XX L2L2. Now to find YY's appropriate position, we check if it lies between L1L1, XX or XX, L2L2. And so on. In the final order, the middle node would be the root.Author: AshishgupC++ Code: 46095066 Java Code: 46095373",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63384",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1061\\s*D"
          },
          "content_length": 8256
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 1",
          "code": "502 Bad Gateway",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 2",
          "code": "auto it=lower_bound(s.begin(), s.end(), v[i].fs);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 3",
          "code": "auto it=lower_bound(s.begin(), s.end(), v[i].fs);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 4",
          "code": "st.lower_bound(val)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 5",
          "code": "for (int divisor = 1; divisor <= n; divisor++) {\n    int v = divisor\n    while (v <= 1000000) {\n        if (v exists in original input) then (add divisor to list of v's divisors)\n        v += divisor\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 6",
          "code": "for (int divisor = 1; divisor <= n; divisor++) {\n    int v = divisor\n    while (v <= 1000000) {\n        if (v exists in original input) then (add divisor to list of v's divisors)\n        v += divisor\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 7",
          "code": "highly likely",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 8",
          "code": "Highest = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 9",
          "code": "min(Highest+1, Height[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 10",
          "code": "Max - Highest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 11",
          "code": "dp[f[i]]+=ans[f[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 12",
          "code": "auto nxt = next(it);\nerase(it); \nit = nxt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 13",
          "code": "auto nxt = next(it);\nerase(it); \nit = nxt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 14",
          "code": "(int)(ceil(1.0*n/k)+1e-9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 1",
          "code": "std::sort(path.begin(), path.end(), \n  [&](int u, int v) {\n    if (u == v) return false; \n    return Query(leftmost, u, v);\n  }\n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 2",
          "code": "std::sort(path.begin(), path.end(), \n  [&](int u, int v) {\n    if (u == v) return false; \n    return Query(leftmost, u, v);\n  }\n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 3",
          "code": "*\n  *\n    *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 4",
          "code": "*\n  *\n    *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 5",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l))%mod;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 6",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l))%mod;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 7",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 8",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 9",
          "code": "int find_leaf()\n{\n    u=rand(),v=rand()\n    for i=1 to n \n        if query(u,v,i) \n            v=i; \n    return v; \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 10",
          "code": "int find_leaf()\n{\n    u=rand(),v=rand()\n    for i=1 to n \n        if query(u,v,i) \n            v=i; \n    return v; \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n    ensuref(1 <= y && y < x, \"y must satisfy 1 ≤ y < x, but y=%d, x=%d\", y, x);\n    for (int i = 0; i < n; ++i) {\n        int l_i = inf.readInt(1, 1000000000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, 1000000000, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n    ensuref(1 <= y && y < x, \"y must satisfy 1 ≤ y < x, but y=%d, x=%d\", y, x);\n    for (int i = 0; i < n; ++i) {\n        int l_i = inf.readInt(1, 1000000000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, 1000000000, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000000000, \"y\");\n    inf.readEoln();\n    ensuref(1 <= y && y < x, \"y must satisfy 1 ≤ y < x, but y=%d, x=%d\", y, x);\n    for (int i = 0; i < n; ++i) {\n        int l_i = inf.readInt(1, 1000000000, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, 1000000000, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    ll x = opt<ll>(\"x\");\n    ll y = opt<ll>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<ll, ll>> intervals;\n\n    if (type == \"random\") {\n        /* Generate random intervals */\n        for(int i = 0; i < n; i++) {\n            ll l = rnd.next(1LL, 1000000000LL);\n            ll r = rnd.next(l, 1000000000LL);\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"overlapping\") {\n        /* All intervals are the same */\n        ll l = rnd.next(1LL, 1000000000LL);\n        ll r = rnd.next(l, 1000000000LL);\n        for(int i = 0; i < n; i++) {\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"nonoverlapping\") {\n        /* Intervals do not overlap */\n        ll current_time = 1;\n        ll max_time = 1000000000LL;\n        ll interval_duration = max(1LL, (max_time - current_time + 1) / n);\n        for(int i = 0; i < n; i++) {\n            ll l = current_time;\n            ll r = l + interval_duration - 1;\n            if (r > max_time) r = max_time;\n            intervals.push_back({l, r});\n            current_time = r + 1;\n            if (current_time > max_time) break;\n        }\n        n = intervals.size();\n    } else if (type == \"single\") {\n        /* Intervals of length 1 */\n        for(int i = 0; i < n; i++) {\n            ll l = rnd.next(1LL, 1000000000LL);\n            intervals.push_back({l, l});\n        }\n    } else if (type == \"maxduration\") {\n        /* Intervals from 1 to 1e9 */\n        for(int i = 0; i < n; i++) {\n            intervals.push_back({1LL, 1000000000LL});\n        }\n    } else if (type == \"sequential\") {\n        /* Intervals are sequential */\n        ll current_time = 1;\n        for(int i = 0; i < n; i++) {\n            ll duration = rnd.next(1LL, 10000LL);\n            ll l = current_time;\n            ll r = l + duration - 1;\n            if (r > 1000000000LL) r = 1000000000LL;\n            intervals.push_back({l, r});\n            current_time = r + 1;\n            if (current_time > 1000000000LL) break;\n        }\n        n = intervals.size();\n    } else if (type == \"staggered\") {\n        /* Partially overlapping intervals */\n        ll start_time = 1;\n        for (int i = 0; i < n; ++i) {\n            ll l = start_time + i;\n            ll r = l + rnd.next(1LL, 1000000LL);\n            if (r > 1000000000LL) r = 1000000000LL;\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"longshort\") {\n        /* Mix of long and short intervals */\n        for(int i = 0; i < n; i++) {\n            if(i % 2 == 0) {\n                intervals.push_back({1LL, 1000000000LL});\n            } else {\n                ll l = rnd.next(1LL, 1000000000LL);\n                intervals.push_back({l, l});\n            }\n        }\n    } else if (type == \"edgecase\") {\n        /* Intervals at the boundaries */\n        intervals.push_back({1LL, 1LL});\n        intervals.push_back({1000000000LL, 1000000000LL});\n        for(int i = 2; i < n; i++) {\n            ll l = rnd.next(1LL, 1000000000LL);\n            intervals.push_back({l, l});\n        }\n    } else {\n        /* Default to random intervals */\n        for(int i = 0; i < n; i++) {\n            ll l = rnd.next(1LL, 1000000000LL);\n            ll r = rnd.next(l, 1000000000LL);\n            intervals.push_back({l, r});\n        }\n    }\n\n    /* Output the data */\n    printf(\"%d %lld %lld\\n\", n, x, y);\n    for(int i = 0; i < n; i++) {\n        printf(\"%lld %lld\\n\", intervals[i].first, intervals[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    ll x = opt<ll>(\"x\");\n    ll y = opt<ll>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<ll, ll>> intervals;\n\n    if (type == \"random\") {\n        /* Generate random intervals */\n        for(int i = 0; i < n; i++) {\n            ll l = rnd.next(1LL, 1000000000LL);\n            ll r = rnd.next(l, 1000000000LL);\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"overlapping\") {\n        /* All intervals are the same */\n        ll l = rnd.next(1LL, 1000000000LL);\n        ll r = rnd.next(l, 1000000000LL);\n        for(int i = 0; i < n; i++) {\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"nonoverlapping\") {\n        /* Intervals do not overlap */\n        ll current_time = 1;\n        ll max_time = 1000000000LL;\n        ll interval_duration = max(1LL, (max_time - current_time + 1) / n);\n        for(int i = 0; i < n; i++) {\n            ll l = current_time;\n            ll r = l + interval_duration - 1;\n            if (r > max_time) r = max_time;\n            intervals.push_back({l, r});\n            current_time = r + 1;\n            if (current_time > max_time) break;\n        }\n        n = intervals.size();\n    } else if (type == \"single\") {\n        /* Intervals of length 1 */\n        for(int i = 0; i < n; i++) {\n            ll l = rnd.next(1LL, 1000000000LL);\n            intervals.push_back({l, l});\n        }\n    } else if (type == \"maxduration\") {\n        /* Intervals from 1 to 1e9 */\n        for(int i = 0; i < n; i++) {\n            intervals.push_back({1LL, 1000000000LL});\n        }\n    } else if (type == \"sequential\") {\n        /* Intervals are sequential */\n        ll current_time = 1;\n        for(int i = 0; i < n; i++) {\n            ll duration = rnd.next(1LL, 10000LL);\n            ll l = current_time;\n            ll r = l + duration - 1;\n            if (r > 1000000000LL) r = 1000000000LL;\n            intervals.push_back({l, r});\n            current_time = r + 1;\n            if (current_time > 1000000000LL) break;\n        }\n        n = intervals.size();\n    } else if (type == \"staggered\") {\n        /* Partially overlapping intervals */\n        ll start_time = 1;\n        for (int i = 0; i < n; ++i) {\n            ll l = start_time + i;\n            ll r = l + rnd.next(1LL, 1000000LL);\n            if (r > 1000000000LL) r = 1000000000LL;\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"longshort\") {\n        /* Mix of long and short intervals */\n        for(int i = 0; i < n; i++) {\n            if(i % 2 == 0) {\n                intervals.push_back({1LL, 1000000000LL});\n            } else {\n                ll l = rnd.next(1LL, 1000000000LL);\n                intervals.push_back({l, l});\n            }\n        }\n    } else if (type == \"edgecase\") {\n        /* Intervals at the boundaries */\n        intervals.push_back({1LL, 1LL});\n        intervals.push_back({1000000000LL, 1000000000LL});\n        for(int i = 2; i < n; i++) {\n            ll l = rnd.next(1LL, 1000000000LL);\n            intervals.push_back({l, l});\n        }\n    } else {\n        /* Default to random intervals */\n        for(int i = 0; i < n; i++) {\n            ll l = rnd.next(1LL, 1000000000LL);\n            ll r = rnd.next(l, 1000000000LL);\n            intervals.push_back({l, r});\n        }\n    }\n\n    /* Output the data */\n    printf(\"%d %lld %lld\\n\", n, x, y);\n    for(int i = 0; i < n; i++) {\n        printf(\"%lld %lld\\n\", intervals[i].first, intervals[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random intervals with small n\n./gen -n 10 -x 5 -y 3 -type random\n./gen -n 100 -x 50 -y 30 -type random\n\n# Random intervals with maximum n\n./gen -n 100000 -x 1000000000 -y 1 -type random\n\n# Overlapping intervals\n./gen -n 10 -x 5 -y 3 -type overlapping\n./gen -n 100 -x 10 -y 9 -type overlapping\n./gen -n 1000 -x 100 -y 1 -type overlapping\n./gen -n 100000 -x 2 -y 1 -type overlapping\n\n# Non-overlapping intervals\n./gen -n 10 -x 5 -y 3 -type nonoverlapping\n./gen -n 100 -x 10 -y 9 -type nonoverlapping\n./gen -n 1000 -x 100 -y 50 -type nonoverlapping\n./gen -n 100000 -x 1000000000 -y 999999999 -type nonoverlapping\n\n# Intervals of length 1\n./gen -n 10 -x 5 -y 3 -type single\n./gen -n 100 -x 10 -y 9 -type single\n./gen -n 1000 -x 100 -y 99 -type single\n./gen -n 100000 -x 1000000000 -y 999999999 -type single\n\n# Max duration intervals\n./gen -n 10 -x 5 -y 3 -type maxduration\n./gen -n 100 -x 10 -y 9 -type maxduration\n./gen -n 1000 -x 100 -y 99 -type maxduration\n./gen -n 100000 -x 1000000000 -y 1 -type maxduration\n\n# Sequential intervals\n./gen -n 100 -x 10 -y 9 -type sequential\n./gen -n 1000 -x 100 -y 1 -type sequential\n./gen -n 10000 -x 1000 -y 999 -type sequential\n./gen -n 50000 -x 1000000000 -y 1 -type sequential\n\n# Staggered intervals\n./gen -n 10 -x 5 -y 3 -type staggered\n./gen -n 1000 -x 100 -y 50 -type staggered\n./gen -n 100000 -x 1000000000 -y 1 -type staggered\n\n# Mix of long and short intervals\n./gen -n 100000 -x 1000000000 -y 999999999 -type longshort\n\n# Edge case intervals at boundaries\n./gen -n 2 -x 1000000000 -y 999999999 -type edgecase\n./gen -n 100000 -x 1000000000 -y 999999999 -type edgecase\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:40.042460",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1061/E",
      "title": "E. Politics",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers nn, xx and yy (1≤n≤5001≤n≤500, 1≤x,y≤n1≤x,y≤n) — the number of cities, the capital of the first candidate and the capital of the second candidate respectively.Next line contains integers a1,a2,…,ana1,a2,…,an (1≤ai≤1000001≤ai≤100000) — the revenue gained if the port is constructed in the corresponding city.Each of the next n−1n−1 lines contains integers uiui and vivi (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi), denoting edges between cities in the tree of the first candidate.Each of the next n−1n−1 lines contains integers u′iui′ and v′ivi′ (1≤u′i,v′i≤n1≤ui′,vi′≤n, u′i≠v′iui′≠vi′), denoting edges between cities in the tree of the second candidate.Next line contains an integer q1q1 (1≤q1≤n1≤q1≤n), denoting the number of demands of the first candidate.Each of the next q1q1 lines contains two integers kk and xx (1≤k≤n1≤k≤n, 1≤x≤n1≤x≤n) — the city number and the number of ports in its subtree.Next line contains an integer q2q2 (1≤q2≤n1≤q2≤n), denoting the number of demands of the second candidate.Each of the next q2q2 lines contain two integers kk and xx (1≤k≤n1≤k≤n, 1≤x≤n1≤x≤n) — the city number and the number of ports in its subtree.It is guaranteed, that given edges correspond to valid trees, each candidate has given demand about each city at most once and that each candidate has specified the port demands for the capital of his choice. That is, the city xx is always given in demands of the first candidate and city yy is always given in the demands of the second candidate.",
      "output_spec": "OutputPrint exactly one integer — the maximum possible revenue that can be gained, while satisfying demands of both candidates, or -1 if it is not possible to satisfy all of the demands.",
      "sample_tests": "ExamplesInputCopy4 1 21 2 3 41 21 33 41 22 31 421 34 112 3OutputCopy9InputCopy5 1 13 99 99 100 21 21 33 43 51 31 22 42 521 23 121 22 1OutputCopy198InputCopy4 1 21 2 3 41 21 33 42 12 44 311 424 12 4OutputCopy-1",
      "description": "E. Politics\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integers nn, xx and yy (1≤n≤5001≤n≤500, 1≤x,y≤n1≤x,y≤n) — the number of cities, the capital of the first candidate and the capital of the second candidate respectively.Next line contains integers a1,a2,…,ana1,a2,…,an (1≤ai≤1000001≤ai≤100000) — the revenue gained if the port is constructed in the corresponding city.Each of the next n−1n−1 lines contains integers uiui and vivi (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi), denoting edges between cities in the tree of the first candidate.Each of the next n−1n−1 lines contains integers u′iui′ and v′ivi′ (1≤u′i,v′i≤n1≤ui′,vi′≤n, u′i≠v′iui′≠vi′), denoting edges between cities in the tree of the second candidate.Next line contains an integer q1q1 (1≤q1≤n1≤q1≤n), denoting the number of demands of the first candidate.Each of the next q1q1 lines contains two integers kk and xx (1≤k≤n1≤k≤n, 1≤x≤n1≤x≤n) — the city number and the number of ports in its subtree.Next line contains an integer q2q2 (1≤q2≤n1≤q2≤n), denoting the number of demands of the second candidate.Each of the next q2q2 lines contain two integers kk and xx (1≤k≤n1≤k≤n, 1≤x≤n1≤x≤n) — the city number and the number of ports in its subtree.It is guaranteed, that given edges correspond to valid trees, each candidate has given demand about each city at most once and that each candidate has specified the port demands for the capital of his choice. That is, the city xx is always given in demands of the first candidate and city yy is always given in the demands of the second candidate.\n\nOutputPrint exactly one integer — the maximum possible revenue that can be gained, while satisfying demands of both candidates, or -1 if it is not possible to satisfy all of the demands.\n\nInputCopy4 1 21 2 3 41 21 33 41 22 31 421 34 112 3OutputCopy9InputCopy5 1 13 99 99 100 21 21 33 43 51 31 22 42 521 23 121 22 1OutputCopy198InputCopy4 1 21 2 3 41 21 33 42 12 44 311 424 12 4OutputCopy-1\n\nInputCopy4 1 21 2 3 41 21 33 41 22 31 421 34 112 3\n\nOutputCopy9\n\nInputCopy5 1 13 99 99 100 21 21 33 43 51 31 22 42 521 23 121 22 1\n\nOutputCopy198\n\nInputCopy4 1 21 2 3 41 21 33 42 12 44 311 424 12 4\n\nOutputCopy-1\n\nNoteIn the first example, it is optimal to build ports in cities 22, 33 and 44, which fulfills all demands of both candidates and gives revenue equal to 2+3+4=92+3+4=9.In the second example, it is optimal to build ports in cities 22 and 33, which fulfills all demands of both candidates and gives revenue equal to 99+99=19899+99=198. In the third example, it is not possible to build ports in such way, that all demands of both candidates are specified, hence the answer is -1.",
      "solutions": [
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces",
          "content": "Hi everyone!I would like to invite you to my second Codeforces Round, which I have made with my friend and Snackdown partner Jeel_Vaishnav.With that said, I bring to your attention our new Codeforces Round 523 (Div. 2) that will take place on Thursday, November 22, 2018 at 23:45UTC+8. If your rating is less than 2100, this round will be rated for you; otherwise, you can participate out of competition.I would really like to thank Jeel_Vaishnav for his help with preparing problems, cdkrot for coordinating our round and Um_nik, vintage_Vlad_Makeev, Aleks5d, KeyurJain & Mahir83 for testing the problems. I would also like to thank MikeMirzayanov for Codeforces and Polygon platforms.You will be given 6 problems and 2 hours to solve them. Scoring distribution will be announced later.Link to My Coding Library for those interested :)Good luck! :DUPD: Scoring Distribution: 500-1000-1500-2000-2500-2750UPD2: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63352",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 919
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces",
          "content": "I hope you guys enjoyed the contest and we hope to host another one soon :)With that said, here are the tutorials: 1061A - CoinsNotice that using maximum value coin whenever possible will be always optimal. Hence, we can use floor(S/n)floor(S/n) coins of value nn. Now, if SmodnSmodn is not equal to 00, then we need to use one more coin of valuation SmodnSmodn. Hence, our answer can be written as ceil(S/n)ceil(S/n).Overall Complexity: O(1)O(1)Author: AshishgupC++ Code: 46095081 Java Code: 46095332 1061B - Views MatterLet's sort the array in increasing order and find the minimum number of blocks XX required to retain the same top and right views. Then, the answer would be ∑ni=1Ai−X∑i=1nAi−X.For every ii from 11 to NN, we need to keep at least 11 block for this stack to retain the top view. Thus, X=X+1X=X+1 for every ii. However, we also need to maintain the maximum height we can cover till now, by keeping 11 block in this stack. Let the previous best height we had be YY.Then, if A[i]>YA[i]>Y, then we managed to increase the height YY by 11, by keeping the block at Y+1Y+1. However, if A[i]=YA[i]=Y, then we cannot increase the number of blocks in the right view, since we are only allowed to keep the current block in range [1,Y][1,Y]. In the end, when we finish processing all the stacks, we also need to keep max(Ai)−Ymax(Ai)−Y blocks in the longest stack, to retain the right view as it was originally.Overall complexity: O(nlogn)O(nlog⁡n)Refer to solution code for clarity.Author: Jeel_VaishnavC++ Code: 46095083 Java Code: 46095337 1061C - MultiplicityLet's introduce the following dynamic programming approach, dp[n][n]dp[n][n], where dp[i][j]dp[i][j] indicates the number of ways to select a good subsequence of size jj from elements a1,a2,...,aia1,a2,...,ai. Our final answer will be ∑ni=1dp[n][i]∑i=1ndp[n][i].dp[i][j]={dp[i−1][j]+dp[i−1][j−1]dp[i−1][j]if a[i] is a multiple of jotherwisedp[i][j]={dp[i−1][j]+dp[i−1][j−1]if a[i] is a multiple of jdp[i−1][j]otherwiseNow, maintaining a 2-D dp will exceed memory limit, however notice that dp[i]dp[i] is calculated only on the basis of dp[i−1]dp[i−1], hence mainitaining a 1-D dp will work. Also, now dp[j]dp[j] is updated if and only if jj is a divisor of a[i]a[i]. We can find divisors of a number xx in O(x−−√)O(x).Overall Complexity : O(n⋅(maxD+maxA−−−−−√))O(n⋅(maxD+maxA)). Here, maxDmaxD indicates maximum number of divisors possible and maxAmaxA indicates maximum value of aiai possible.Also, we can use sieve to compute divisors of each number and achieve complexity of O(maxA⋅log(maxA)+n⋅maxD)O(maxA⋅log(maxA)+n⋅maxD).Authors: Jeel_Vaishnav, AshishgupC++ Code: 46095097 Java Code: 46095342 1061D - TV ShowsSolution: Sort the TV shows on the basis of their starting time. Now, we start allocating TVs greedily to the shows. For any show ii, we allocate a new TV only if there is no old TV where the show ends at roro, such that ro<liro<li and (li−ro)⋅y<=x(li−ro)⋅y<=x. Also, if there are many such old TVs, then we use the TV where roro is maximum.Proof: Notice that there is a minimal cost of ∑ni=1(ri−li)⋅y∑i=1n(ri−li)⋅y, which will always be added. Hence, the optimal solution completely depends on the rent of new TV and the time wasted on old TVs. Now, lets try to prove that allocating an old TV with maximum roro is optimal. Suppose we are allocating a TV to show ii. Let's consider two old TVs o1o1 and o2o2, such that ro1<ro2<liro1<ro2<li and (li−ro1)⋅y<=x(li−ro1)⋅y<=x. In such a case, it is possible to allocate both the TVs to this show. For choosing which TV to be allocated let's consider the three possible cases:Case I: There is no show j(j>i)j(j>i), such that (lj−ro2)⋅y<=x(lj−ro2)⋅y<=x. In this case, it would be better to allocate TV o2o2 to show ii, since (li−ro2)⋅y<(li−ro1)⋅y(li−ro2)⋅y<(li−ro1)⋅y. Hence, allocating TV o2o2 to show ii is optimal in this case.Case II: There are shows j(j>i)j(j>i), such that (lj−ro2)⋅y<=x(lj−ro2)⋅y<=x; but there is no show j(j>i)j(j>i), such that (lj−ro1)⋅y<=x(lj−ro1)⋅y<=x. In this case, if we allocate TV o1o1 to show ii and TV o2o2 to show jj, then the cost will be (lj−ro2)⋅y+(li−ro1)⋅y(lj−ro2)⋅y+(li−ro1)⋅y. And, if we allocate TV o2o2 to show ii, then we need to buy a new TV for show jj and our cost will be x+(li−ro2)⋅yx+(li−ro2)⋅y. Now, as (lj−ro1)⋅y>x(lj−ro1)⋅y>x, (lj−ro2)⋅y+(li−ro1)⋅y>x+(li−ro2)⋅y(lj−ro2)⋅y+(li−ro1)⋅y>x+(li−ro2)⋅y. Hence, allocating TV o2o2 instead of TV o1o1 to show ii is optimal in this case.Case III: There are shows j(j>i)j(j>i), such that (lj−ro1)⋅y<=x(lj−ro1)⋅y<=x. In this case, if we allocate TV o1o1 to show ii, cost will be (li−ro1)⋅y+(lj−ro2)⋅y(li−ro1)⋅y+(lj−ro2)⋅y. If we allocate TV o2o2 to show ii, cost will be (li−ro2)⋅y+(lj−ro1)⋅y(li−ro2)⋅y+(lj−ro1)⋅y. Here, we can see that in both of the allocations, the cost is (li+lj−ro1−ro2)⋅y(li+lj−ro1−ro2)⋅y and so any allocation is optimal here. Hence, we can see that if more than one old TVs are available, allocating the one with maximum roro is always optimal. Overall Complexity: O(n⋅logn)O(n⋅log⁡n)Authors: Jeel_Vaishnav, AshishgupC++ Code: 46095154 Java Code: 46095344 1061E - PoliticsLet's create a graph with a source, sink and two layers. Let the left layer denote the nodes of tree 11 and right layer denote the nodes of tree 22. Let's denote xixi as the demand of the ithith node. For a demand (k,x)(k,x) in tree 1, we add an edge from source to node kk in the left layer with cost=0cost=0 and capacity=x−∑xjcapacity=x−∑xj, such that jj is not equal to ii and jj belongs to the subtree of ii. Similarly for a demand (k,x)(k,x) in tree 2, we add an edge from node kk in the right layer to sink with cost=0cost=0 and capacity=x−∑xjcapacity=x−∑xj, such that jj is not equal to ii and jj belongs to the subtree of ii. Now, for every node ii, let col1icol1i be the closest node to ii, such that ii belongs to subtree of col1icol1i and the demand of col1icol1i in tree 11 has been provided. Similarly col2icol2i be the closest node to ii, such that ii belongs to subtree of col2icol2i and the demand of col2icol2i in tree 22 has been provided.For every node ii, we add an edge from col1icol1i in left layer to col2icol2i in right layer with capacity=1capacity=1 and cost=−aicost=−ai.Now, when we run min cost max flow on this graph, our answer will be negative of the minimum cost obtained.Overall Complexity: O(n3)O(n3) using MCMF with bellman ford; O(n2⋅logn)O(n2⋅log⁡n) using MCMF with Dijkstra.Author: Jeel_VaishnavJava Code: 46095349A nice explanation of Problem E by Kognition in the comment section: https://codeforces.com/blog/entry/63352?#comment-473028 1061F - Lost RootThis solution had many randomized approaches, some with higher probability of passing and some with lower probability of passing.The author's solution (there exist better solutions with even lower probability of failure - comment yours below) is as follows:Part 1: Checking if a node is a leaf node:It can be done in O(n)O(n) queries.Suppose candidate node is XXGenerate a random node Y(!=X)Y(!=X)For all ZZ, if YY XX ZZ is falsefalse, then XX is a leaf node, otherwise is not. Part 2: Finding a leaf node: Generate a random node and check if it is a leaf node. Probability of getting a lead node is >=0.5>=0.5. Higher the KK, higher the probability.So we can find a leaf node in O(20⋅n)O(20⋅n) queries with failure probability (1/2)20(1/2)20Part 3: Generating a leaf node in other subtree of the actual root:Fix a random node (that is not the same as the leaf node, L1L1, that we found), check if it is a leaf node, and if it is a leaf node and check if 2h−12h−1 nodes separate Leaf 11 and this current leaf. If yes, we have found two separate leaf nodes and the 2h−12h−1 candidate nodes for the root. We can use  O(40⋅n)O(40⋅n) queries to ensure a failure probability of (1/2)20(1/2)20Finally: Instead of checking all of them separately in 2H⋅N2H⋅N, we can fix their order in O(H2)O(H2) by finding each node's appropriate position by placing them incrementally. Let the initial path be L1L1 L2L2, then we add XX to get L1L1 XX L2L2. Now to find YY's appropriate position, we check if it lies between L1L1, XX or XX, L2L2. And so on. In the final order, the middle node would be the root.Author: AshishgupC++ Code: 46095066 Java Code: 46095373",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63384",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1061\\s*E"
          },
          "content_length": 8256
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 1",
          "code": "502 Bad Gateway",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 2",
          "code": "auto it=lower_bound(s.begin(), s.end(), v[i].fs);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 3",
          "code": "auto it=lower_bound(s.begin(), s.end(), v[i].fs);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 4",
          "code": "st.lower_bound(val)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 5",
          "code": "for (int divisor = 1; divisor <= n; divisor++) {\n    int v = divisor\n    while (v <= 1000000) {\n        if (v exists in original input) then (add divisor to list of v's divisors)\n        v += divisor\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 6",
          "code": "for (int divisor = 1; divisor <= n; divisor++) {\n    int v = divisor\n    while (v <= 1000000) {\n        if (v exists in original input) then (add divisor to list of v's divisors)\n        v += divisor\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 7",
          "code": "highly likely",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 8",
          "code": "Highest = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 9",
          "code": "min(Highest+1, Height[i])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 10",
          "code": "Max - Highest",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 11",
          "code": "dp[f[i]]+=ans[f[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 12",
          "code": "auto nxt = next(it);\nerase(it); \nit = nxt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 13",
          "code": "auto nxt = next(it);\nerase(it); \nit = nxt;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 (Div. 2) - Codeforces - Code 14",
          "code": "(int)(ceil(1.0*n/k)+1e-9)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63352",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 1",
          "code": "std::sort(path.begin(), path.end(), \n  [&](int u, int v) {\n    if (u == v) return false; \n    return Query(leftmost, u, v);\n  }\n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 2",
          "code": "std::sort(path.begin(), path.end(), \n  [&](int u, int v) {\n    if (u == v) return false; \n    return Query(leftmost, u, v);\n  }\n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 3",
          "code": "*\n  *\n    *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 4",
          "code": "*\n  *\n    *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 5",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l))%mod;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 6",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l))%mod;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 7",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 8",
          "code": "ll f(ll l, ll r){\n\treturn (y * (r - l));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 9",
          "code": "int find_leaf()\n{\n    u=rand(),v=rand()\n    for i=1 to n \n        if query(u,v,i) \n            v=i; \n    return v; \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #523 Editorial - Codeforces - Code 10",
          "code": "int find_leaf()\n{\n    u=rand(),v=rand()\n    for i=1 to n \n        if query(u,v,i) \n            v=i; \n    return v; \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63384",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n, x, y\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, n, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, n, \"y\");\n    inf.readEoln();\n\n    // Read a_1 to a_n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    // Read first tree's edges\n    vector<pair<int, int>> edges1;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge connects a node to itself in first tree on edge %d\", i+1);\n        edges1.emplace_back(u, v);\n    }\n    // Check that edges1 forms a valid tree\n    {\n        vector<int> parent(n + 1);\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n        for (auto& edge : edges1) {\n            int u = edge.first;\n            int v = edge.second;\n            int pu = find(u);\n            int pv = find(v);\n            ensuref(pu != pv, \"First tree contains a cycle between nodes %d and %d\", u, v);\n            parent[pu] = pv;\n        }\n        // Ensure connected\n        int root = find(1);\n        for (int i = 2; i <= n; ++i) {\n            ensuref(find(i) == root, \"First tree is not connected at node %d\", i);\n        }\n    }\n\n    // Read second tree's edges\n    vector<pair<int, int>> edges2;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u'_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v'_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge connects a node to itself in second tree on edge %d\", i+1);\n        edges2.emplace_back(u, v);\n    }\n    // Check that edges2 forms a valid tree\n    {\n        vector<int> parent(n + 1);\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n        for (auto& edge : edges2) {\n            int u = edge.first;\n            int v = edge.second;\n            int pu = find(u);\n            int pv = find(v);\n            ensuref(pu != pv, \"Second tree contains a cycle between nodes %d and %d\", u, v);\n            parent[pu] = pv;\n        }\n        // Ensure connected\n        int root = find(1);\n        for (int i = 2; i <= n; ++i) {\n            ensuref(find(i) == root, \"Second tree is not connected at node %d\", i);\n        }\n    }\n\n    // Read q1\n    int q1 = inf.readInt(1, n, \"q1\");\n    inf.readEoln();\n\n    // Read q1 demands\n    set<int> k_set1;\n    bool capital1_found = false;\n    for (int i = 0; i < q1; ++i) {\n        int k = inf.readInt(1, n, \"k1_i\");\n        inf.readSpace();\n        int x_demand = inf.readInt(1, n, \"x_demand1_i\");\n        inf.readEoln();\n        ensuref(k_set1.insert(k).second, \"Duplicate demand for city %d in first candidate's demands\", k);\n        if (k == x) capital1_found = true;\n    }\n    ensuref(capital1_found, \"First candidate's demands do not include the capital city %d\", x);\n\n    // Read q2\n    int q2 = inf.readInt(1, n, \"q2\");\n    inf.readEoln();\n\n    // Read q2 demands\n    set<int> k_set2;\n    bool capital2_found = false;\n    for (int i = 0; i < q2; ++i) {\n        int k = inf.readInt(1, n, \"k2_i\");\n        inf.readSpace();\n        int x_demand = inf.readInt(1, n, \"x_demand2_i\");\n        inf.readEoln();\n        ensuref(k_set2.insert(k).second, \"Duplicate demand for city %d in second candidate's demands\", k);\n        if (k == y) capital2_found = true;\n    }\n    ensuref(capital2_found, \"Second candidate's demands do not include the capital city %d\", y);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n, x, y\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, n, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, n, \"y\");\n    inf.readEoln();\n\n    // Read a_1 to a_n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    // Read first tree's edges\n    vector<pair<int, int>> edges1;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge connects a node to itself in first tree on edge %d\", i+1);\n        edges1.emplace_back(u, v);\n    }\n    // Check that edges1 forms a valid tree\n    {\n        vector<int> parent(n + 1);\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n        for (auto& edge : edges1) {\n            int u = edge.first;\n            int v = edge.second;\n            int pu = find(u);\n            int pv = find(v);\n            ensuref(pu != pv, \"First tree contains a cycle between nodes %d and %d\", u, v);\n            parent[pu] = pv;\n        }\n        // Ensure connected\n        int root = find(1);\n        for (int i = 2; i <= n; ++i) {\n            ensuref(find(i) == root, \"First tree is not connected at node %d\", i);\n        }\n    }\n\n    // Read second tree's edges\n    vector<pair<int, int>> edges2;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u'_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v'_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge connects a node to itself in second tree on edge %d\", i+1);\n        edges2.emplace_back(u, v);\n    }\n    // Check that edges2 forms a valid tree\n    {\n        vector<int> parent(n + 1);\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n        for (auto& edge : edges2) {\n            int u = edge.first;\n            int v = edge.second;\n            int pu = find(u);\n            int pv = find(v);\n            ensuref(pu != pv, \"Second tree contains a cycle between nodes %d and %d\", u, v);\n            parent[pu] = pv;\n        }\n        // Ensure connected\n        int root = find(1);\n        for (int i = 2; i <= n; ++i) {\n            ensuref(find(i) == root, \"Second tree is not connected at node %d\", i);\n        }\n    }\n\n    // Read q1\n    int q1 = inf.readInt(1, n, \"q1\");\n    inf.readEoln();\n\n    // Read q1 demands\n    set<int> k_set1;\n    bool capital1_found = false;\n    for (int i = 0; i < q1; ++i) {\n        int k = inf.readInt(1, n, \"k1_i\");\n        inf.readSpace();\n        int x_demand = inf.readInt(1, n, \"x_demand1_i\");\n        inf.readEoln();\n        ensuref(k_set1.insert(k).second, \"Duplicate demand for city %d in first candidate's demands\", k);\n        if (k == x) capital1_found = true;\n    }\n    ensuref(capital1_found, \"First candidate's demands do not include the capital city %d\", x);\n\n    // Read q2\n    int q2 = inf.readInt(1, n, \"q2\");\n    inf.readEoln();\n\n    // Read q2 demands\n    set<int> k_set2;\n    bool capital2_found = false;\n    for (int i = 0; i < q2; ++i) {\n        int k = inf.readInt(1, n, \"k2_i\");\n        inf.readSpace();\n        int x_demand = inf.readInt(1, n, \"x_demand2_i\");\n        inf.readEoln();\n        ensuref(k_set2.insert(k).second, \"Duplicate demand for city %d in second candidate's demands\", k);\n        if (k == y) capital2_found = true;\n    }\n    ensuref(capital2_found, \"Second candidate's demands do not include the capital city %d\", y);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n, x, y\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, n, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, n, \"y\");\n    inf.readEoln();\n\n    // Read a_1 to a_n\n    vector<int> a = inf.readInts(n, 1, 100000, \"a\");\n    inf.readEoln();\n\n    // Read first tree's edges\n    vector<pair<int, int>> edges1;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge connects a node to itself in first tree on edge %d\", i+1);\n        edges1.emplace_back(u, v);\n    }\n    // Check that edges1 forms a valid tree\n    {\n        vector<int> parent(n + 1);\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n        for (auto& edge : edges1) {\n            int u = edge.first;\n            int v = edge.second;\n            int pu = find(u);\n            int pv = find(v);\n            ensuref(pu != pv, \"First tree contains a cycle between nodes %d and %d\", u, v);\n            parent[pu] = pv;\n        }\n        // Ensure connected\n        int root = find(1);\n        for (int i = 2; i <= n; ++i) {\n            ensuref(find(i) == root, \"First tree is not connected at node %d\", i);\n        }\n    }\n\n    // Read second tree's edges\n    vector<pair<int, int>> edges2;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u'_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v'_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge connects a node to itself in second tree on edge %d\", i+1);\n        edges2.emplace_back(u, v);\n    }\n    // Check that edges2 forms a valid tree\n    {\n        vector<int> parent(n + 1);\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n        for (auto& edge : edges2) {\n            int u = edge.first;\n            int v = edge.second;\n            int pu = find(u);\n            int pv = find(v);\n            ensuref(pu != pv, \"Second tree contains a cycle between nodes %d and %d\", u, v);\n            parent[pu] = pv;\n        }\n        // Ensure connected\n        int root = find(1);\n        for (int i = 2; i <= n; ++i) {\n            ensuref(find(i) == root, \"Second tree is not connected at node %d\", i);\n        }\n    }\n\n    // Read q1\n    int q1 = inf.readInt(1, n, \"q1\");\n    inf.readEoln();\n\n    // Read q1 demands\n    set<int> k_set1;\n    bool capital1_found = false;\n    for (int i = 0; i < q1; ++i) {\n        int k = inf.readInt(1, n, \"k1_i\");\n        inf.readSpace();\n        int x_demand = inf.readInt(1, n, \"x_demand1_i\");\n        inf.readEoln();\n        ensuref(k_set1.insert(k).second, \"Duplicate demand for city %d in first candidate's demands\", k);\n        if (k == x) capital1_found = true;\n    }\n    ensuref(capital1_found, \"First candidate's demands do not include the capital city %d\", x);\n\n    // Read q2\n    int q2 = inf.readInt(1, n, \"q2\");\n    inf.readEoln();\n\n    // Read q2 demands\n    set<int> k_set2;\n    bool capital2_found = false;\n    for (int i = 0; i < q2; ++i) {\n        int k = inf.readInt(1, n, \"k2_i\");\n        inf.readSpace();\n        int x_demand = inf.readInt(1, n, \"x_demand2_i\");\n        inf.readEoln();\n        ensuref(k_set2.insert(k).second, \"Duplicate demand for city %d in second candidate's demands\", k);\n        if (k == y) capital2_found = true;\n    }\n    ensuref(capital2_found, \"Second candidate's demands do not include the capital city %d\", y);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int>> generate_tree(int n, string type) {\n    vector<int> p(n);\n    if (type == \"chain\") {\n        for(int i = 1; i < n; ++i)\n            p[i] = i - 1;\n    } else if (type == \"star\") {\n        for(int i = 1; i < n; ++i)\n            p[i] = 0;\n    } else {\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(i);\n    }\n\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    vector<pair<int,int>> edges;\n    for (int i = 1; i < n; ++i) {\n        int u = perm[i], v = perm[p[i]];\n        if (rnd.next(2))\n            edges.emplace_back(u, v);\n        else\n            edges.emplace_back(v, u);\n    }\n    shuffle(edges.begin(), edges.end());\n    return edges;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree1_type = opt<string>(\"tree1\", \"random\");\n    string tree2_type = opt<string>(\"tree2\", \"random\");\n    string demands1_type = opt<string>(\"demands1\", \"random\");\n    string demands2_type = opt<string>(\"demands2\", \"random\");\n    string ai_type = opt<string>(\"ai\", \"random\");\n    int cap1 = opt<int>(\"cap1\", rnd.next(1, n));\n    int cap2 = opt<int>(\"cap2\", rnd.next(1, n));\n\n    vector<pair<int,int>> tree1 = generate_tree(n, tree1_type);\n    vector<pair<int,int>> tree2 = generate_tree(n, tree2_type);\n\n    vector<int> a(n);\n    if (ai_type == \"max\") {\n        fill(a.begin(), a.end(), 100000);\n    } else if (ai_type == \"min\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (ai_type == \"allSame\") {\n        int val = rnd.next(1, 100000);\n        fill(a.begin(), a.end(), val);\n    } else {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    }\n\n    vector<pair<int, int>> demands1;\n    set<int> demandedCities1;\n    int cap1_demand = rnd.next(1, n);\n    demands1.emplace_back(cap1, cap1_demand);\n    demandedCities1.insert(cap1);\n\n    if (demands1_type == \"empty\") {\n        // Only capital demand\n    } else if (demands1_type == \"full\") {\n        for(int i = 1; i <= n; ++i) {\n            if (i == cap1) continue;\n            int x = rnd.next(1, n);\n            demands1.emplace_back(i, x);\n        }\n    } else if (demands1_type == \"random\") {\n        int q1 = rnd.next(1, n);\n        for(int i = 1; i < q1; ++i) {\n            int k;\n            do {\n                k = rnd.next(1, n);\n            } while(demandedCities1.count(k));\n            demandedCities1.insert(k);\n            int x = rnd.next(1, n);\n            demands1.emplace_back(k, x);\n        }\n    } else if (demands1_type == \"conflict\") {\n        demands1.clear();\n        demands1.emplace_back(cap1, 0);\n        demandedCities1.insert(cap1);\n        int k;\n        do {\n            k = rnd.next(1, n);\n        } while(k == cap1);\n        int x = rnd.next(1, n);\n        demands1.emplace_back(k, x);\n    }\n\n    vector<pair<int, int>> demands2;\n    set<int> demandedCities2;\n    int cap2_demand = rnd.next(1, n);\n    demands2.emplace_back(cap2, cap2_demand);\n    demandedCities2.insert(cap2);\n\n    if (demands2_type == \"empty\") {\n        // Only capital demand\n    } else if (demands2_type == \"full\") {\n        for(int i = 1; i <= n; ++i) {\n            if (i == cap2) continue;\n            int x = rnd.next(1, n);\n            demands2.emplace_back(i, x);\n        }\n    } else if (demands2_type == \"random\") {\n        int q2 = rnd.next(1, n);\n        for(int i = 1; i < q2; ++i) {\n            int k;\n            do {\n                k = rnd.next(1, n);\n            } while(demandedCities2.count(k));\n            demandedCities2.insert(k);\n            int x = rnd.next(1, n);\n            demands2.emplace_back(k, x);\n        }\n    } else if (demands2_type == \"conflict\") {\n        demands2.clear();\n        demands2.emplace_back(cap2, 0);\n        demandedCities2.insert(cap2);\n        int k;\n        do {\n            k = rnd.next(1, n);\n        } while(k == cap2);\n        int x = rnd.next(1, n);\n        demands2.emplace_back(k, x);\n    }\n\n    printf(\"%d %d %d\\n\", n, cap1, cap2);\n\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n\n    for(auto edge : tree1) {\n        printf(\"%d %d\\n\", edge.first + 1, edge.second + 1);\n    }\n\n    for(auto edge : tree2) {\n        printf(\"%d %d\\n\", edge.first + 1, edge.second + 1);\n    }\n\n    printf(\"%d\\n\", (int)demands1.size());\n    for(auto demand : demands1) {\n        printf(\"%d %d\\n\", demand.first, demand.second);\n    }\n\n    printf(\"%d\\n\", (int)demands2.size());\n    for(auto demand : demands2) {\n        printf(\"%d %d\\n\", demand.first, demand.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int>> generate_tree(int n, string type) {\n    vector<int> p(n);\n    if (type == \"chain\") {\n        for(int i = 1; i < n; ++i)\n            p[i] = i - 1;\n    } else if (type == \"star\") {\n        for(int i = 1; i < n; ++i)\n            p[i] = 0;\n    } else {\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(i);\n    }\n\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    vector<pair<int,int>> edges;\n    for (int i = 1; i < n; ++i) {\n        int u = perm[i], v = perm[p[i]];\n        if (rnd.next(2))\n            edges.emplace_back(u, v);\n        else\n            edges.emplace_back(v, u);\n    }\n    shuffle(edges.begin(), edges.end());\n    return edges;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree1_type = opt<string>(\"tree1\", \"random\");\n    string tree2_type = opt<string>(\"tree2\", \"random\");\n    string demands1_type = opt<string>(\"demands1\", \"random\");\n    string demands2_type = opt<string>(\"demands2\", \"random\");\n    string ai_type = opt<string>(\"ai\", \"random\");\n    int cap1 = opt<int>(\"cap1\", rnd.next(1, n));\n    int cap2 = opt<int>(\"cap2\", rnd.next(1, n));\n\n    vector<pair<int,int>> tree1 = generate_tree(n, tree1_type);\n    vector<pair<int,int>> tree2 = generate_tree(n, tree2_type);\n\n    vector<int> a(n);\n    if (ai_type == \"max\") {\n        fill(a.begin(), a.end(), 100000);\n    } else if (ai_type == \"min\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (ai_type == \"allSame\") {\n        int val = rnd.next(1, 100000);\n        fill(a.begin(), a.end(), val);\n    } else {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n    }\n\n    vector<pair<int, int>> demands1;\n    set<int> demandedCities1;\n    int cap1_demand = rnd.next(1, n);\n    demands1.emplace_back(cap1, cap1_demand);\n    demandedCities1.insert(cap1);\n\n    if (demands1_type == \"empty\") {\n        // Only capital demand\n    } else if (demands1_type == \"full\") {\n        for(int i = 1; i <= n; ++i) {\n            if (i == cap1) continue;\n            int x = rnd.next(1, n);\n            demands1.emplace_back(i, x);\n        }\n    } else if (demands1_type == \"random\") {\n        int q1 = rnd.next(1, n);\n        for(int i = 1; i < q1; ++i) {\n            int k;\n            do {\n                k = rnd.next(1, n);\n            } while(demandedCities1.count(k));\n            demandedCities1.insert(k);\n            int x = rnd.next(1, n);\n            demands1.emplace_back(k, x);\n        }\n    } else if (demands1_type == \"conflict\") {\n        demands1.clear();\n        demands1.emplace_back(cap1, 0);\n        demandedCities1.insert(cap1);\n        int k;\n        do {\n            k = rnd.next(1, n);\n        } while(k == cap1);\n        int x = rnd.next(1, n);\n        demands1.emplace_back(k, x);\n    }\n\n    vector<pair<int, int>> demands2;\n    set<int> demandedCities2;\n    int cap2_demand = rnd.next(1, n);\n    demands2.emplace_back(cap2, cap2_demand);\n    demandedCities2.insert(cap2);\n\n    if (demands2_type == \"empty\") {\n        // Only capital demand\n    } else if (demands2_type == \"full\") {\n        for(int i = 1; i <= n; ++i) {\n            if (i == cap2) continue;\n            int x = rnd.next(1, n);\n            demands2.emplace_back(i, x);\n        }\n    } else if (demands2_type == \"random\") {\n        int q2 = rnd.next(1, n);\n        for(int i = 1; i < q2; ++i) {\n            int k;\n            do {\n                k = rnd.next(1, n);\n            } while(demandedCities2.count(k));\n            demandedCities2.insert(k);\n            int x = rnd.next(1, n);\n            demands2.emplace_back(k, x);\n        }\n    } else if (demands2_type == \"conflict\") {\n        demands2.clear();\n        demands2.emplace_back(cap2, 0);\n        demandedCities2.insert(cap2);\n        int k;\n        do {\n            k = rnd.next(1, n);\n        } while(k == cap2);\n        int x = rnd.next(1, n);\n        demands2.emplace_back(k, x);\n    }\n\n    printf(\"%d %d %d\\n\", n, cap1, cap2);\n\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n\n    for(auto edge : tree1) {\n        printf(\"%d %d\\n\", edge.first + 1, edge.second + 1);\n    }\n\n    for(auto edge : tree2) {\n        printf(\"%d %d\\n\", edge.first + 1, edge.second + 1);\n    }\n\n    printf(\"%d\\n\", (int)demands1.size());\n    for(auto demand : demands1) {\n        printf(\"%d %d\\n\", demand.first, demand.second);\n    }\n\n    printf(\"%d\\n\", (int)demands2.size());\n    for(auto demand : demands2) {\n        printf(\"%d %d\\n\", demand.first, demand.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -tree1 chain -tree2 chain -demands1 empty -demands2 empty -ai min\n./gen -n 2 -tree1 chain -tree2 star -demands1 full -demands2 full -ai max\n./gen -n 3 -tree1 random -tree2 random -demands1 conflict -demands2 conflict -ai random -cap1 1 -cap2 1\n./gen -n 10 -tree1 random -tree2 random -demands1 random -demands2 random -ai random\n./gen -n 10 -tree1 chain -tree2 chain -demands1 empty -demands2 empty -ai allSame\n./gen -n 10 -tree1 star -tree2 star -demands1 full -demands2 full -ai random\n./gen -n 20 -tree1 random -tree2 chain -demands1 conflict -demands2 random -ai random\n./gen -n 50 -tree1 chain -tree2 random -demands1 random -demands2 conflict -ai random\n./gen -n 100 -tree1 random -tree2 random -demands1 random -demands2 random -ai min\n./gen -n 150 -tree1 star -tree2 chain -demands1 random -demands2 empty -ai max\n./gen -n 200 -tree1 random -tree2 random -demands1 full -demands2 full -ai random\n./gen -n 250 -tree1 random -tree2 random -demands1 empty -demands2 random -ai random\n./gen -n 300 -tree1 chain -tree2 star -demands1 random -demands2 random -ai max\n./gen -n 350 -tree1 random -tree2 chain -demands1 conflict -demands2 random -ai random\n./gen -n 400 -tree1 random -tree2 star -demands1 random -demands2 conflict -ai random\n./gen -n 450 -tree1 star -tree2 random -demands1 random -demands2 random -ai min\n./gen -n 500 -tree1 random -tree2 random -demands1 random -demands2 random -ai random\n./gen -n 500 -tree1 chain -tree2 chain -demands1 conflict -demands2 conflict -ai random\n./gen -n 500 -tree1 star -tree2 star -demands1 full -demands2 empty -ai allSame\n./gen -n 500 -tree1 random -tree2 random -demands1 empty -demands2 full -ai random -cap1 1 -cap2 1\n./gen -n 500 -tree1 random -tree2 random -demands1 random -demands2 random -ai random\n./gen -n 500 -tree1 random -tree2 random -demands1 full -demands2 full -ai max\n./gen -n 500 -tree1 random -tree2 random -demands1 conflict -demands2 random -ai min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:41.689568",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1062/A",
      "title": "A. Пранк",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка входных данных содержит одно целое число nn (1≤n≤1001≤n≤100) — количество элементов в массиве.Вторая строка входных данных содержит nn целых чисел aiai (1≤a1<a2<⋯<an≤1031≤a1<a2<⋯<an≤103) — массив, который написал Giraffe.",
      "output_spec": "Выходные данныеВыведите одно целое число — наибольшее количество последовательных элементов, которые JATC может удалить.Если нельзя удалить даже один элемент, выведите 00.",
      "sample_tests": "ПримерыВходные данныеСкопировать61 3 4 5 6 9Выходные данныеСкопировать2Входные данныеСкопировать3998 999 1000Выходные данныеСкопировать2Входные данныеСкопировать51 2 3 4 5Выходные данныеСкопировать4",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка входных данных содержит одно целое число nn (1≤n≤1001≤n≤100) — количество элементов в массиве.Вторая строка входных данных содержит nn целых чисел aiai (1≤a1<a2<⋯<an≤1031≤a1<a2<⋯<an≤103) — массив, который написал Giraffe.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — наибольшее количество последовательных элементов, которые JATC может удалить.Если нельзя удалить даже один элемент, выведите 00.\n\nВыходные данные\n\nВходные данныеСкопировать61 3 4 5 6 9Выходные данныеСкопировать2Входные данныеСкопировать3998 999 1000Выходные данныеСкопировать2Входные данныеСкопировать51 2 3 4 5Выходные данныеСкопировать4\n\nВходные данныеСкопировать61 3 4 5 6 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3998 999 1000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 2 3 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере JATC может удалить третий и четвёртый элемент, превратив массив в [1,3,_,_,6,9][1,3,_,_,6,9]. Как можно заметить, есть только один способ заполнить пустоты.Во втором примере JATC может удалить второй и третий элемент. Массив тем самым превратится в [998,_,_][998,_,_]. Так как все элементы должны быть меньше или равны 10001000, то массив всё равно может быть одозначно восстановлен. Заметим, что удалить первые 22 элемента нельзя.В третьем примере JATC может удалить первые 44 элемента. Так как все элементы больше или равны 11, то Giraffe всё равно может восстановить массив. Заметим, что удалить последние 44 элемента нельзя.",
      "solutions": [
        {
          "title": "Codeforces Round #520 - Codeforces",
          "content": "Hi everyone. I'm glad to announce that the Codeforces Round 520 (Div. 2) will be held on среда, 14 ноября 2018 г. в 23:35UTC+8.The round will be rated for Div 2 participants (whose ratings are lower than 2100). However, all the other participants can compete as well, without worrying about ratings being changed.You will be given 2 hours to solve 6 problems. It's better to read all the problems. The scoring distribution will be announced soon before the contest starts.All the problems were prepared by myself, with some help from my friend GiraffeCoder. I want to thank cdkrot for coordinating me in preparing the problems, vintage_Vlad_Makeev, isaf27, demon1999 and Arpa for testing my solutions. I also want to thank csacademy for their graph editor tool. You can check it out at this link.This is the first round I propose. I put a lot of work into it so I hope that you will enjoy it (smiley face).Wish you do your best and get a high rating!Update 1: If you want to discuss about the problems after the contest, here is the link to the CP Community on Discord. Please make sure that you don't give the solutions to other participants during the contest.Update 2: The score distribution will be the standard one: 500 1000 1500 2000 2500 3000.Update 3: Congrats to the winnerOfficial participants: Kataoka_Yuuki Dark_Warlock wcysai coriander fcwww Unofficial participants: budalnik HIR180 KrK ayaze Anadi Tutorial UPDATED",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63136",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1428
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces",
          "content": "1062A - A PrankSince 1≤ai≤1031≤ai≤103 for all ii, let set a0=0a0=0 and an+1=1001an+1=1001. For every i,ji,j such that 0≤i<j≤n+10≤i<j≤n+1, if aj−j=ai−iaj−j=ai−i then we can erase all the elements between ii and jj (not inclusive). So just check for all the valid pairs and maximize the answer. Time complexity: O(n2)O(n2). 1062B - MathBy factorizing nn we get n=p1a1p2a2…pkakn=p1a1p2a2…pkak (kk is the number of prime factors). Because we can't get rid of those prime factors then the smallest nn is p1p2…pkp1p2…pk. For each aiai, let uiui be the positive integer so that 2ui≥ai>2ui−12ui≥ai>2ui−1. Let UU be max(ui)max(ui). It's clear that we have to apply the \"sqrtsqrt\" operation at least UU times, since each time we apply it, aiai is divided by 22 for all ii. If for all ii, ai=2Uai=2U then the answer is UU, obviously. Otherwise, we need to use the operation \"mulmul\" 11 time to make all the aiai equal 2U2U and by now the answer is U+1U+1.Complexity: O(sqrt(N))O(sqrt(N)) 1062C - Banh-miFor each part that we choose, we need to calculate how many times that element is added to our score. You can see that, the first element that we choose is added 2k−12k−1 times in our score (k=r−l+1k=r−l+1), the second element is added 2k−22k−2 times and so on. Therefore, we just need to choose all the 1s1s first and then all the remaining parts. The final score is (2x−1)⋅2y(2x−1)⋅2y, where xx is the number of 1s1s and yy is the number of 0s0s. Complexity: O(n+Q)O(n+Q). 1062D - Fun with IntegersFor every integer xx (1≤x≤n)(1≤x≤n), let's call DD the set of integers that are able to be transformed into xx. As you can see, if aa could be transformed into bb then −a−a could also be transformed into bb. Therefore |D||D| is always even. Let's build a graph consists of 2n−22n−2 nodes, numbered −n−n through nn (except for −1−1, 00, and 11). There is an weighted undirected edge between node uu and vv if and only if uu can be transformed into vv. The weight of the edge is the score of the transformation. Every node in the graph has an even degree so you can split the graph into some connected components so that each components is an Euler circuit (a circuit that contains all the edges). Therefore you just need to find all those Euler circuits and maximize your score. Moreover, you can see that, if an integer aa can be transformed into bb then xx and 22 are in the same component. Proof: Suppose a<ba<b, there exists an integer x=b/ax=b/a. If x=2x=2 then it is proved, otherwise there exists an integer c=2x<b≤nc=2x<b≤n. cc and 22 are in the same component so xx and 22 are also in the same component. Therefore, if we ignore all the nodes that have no edges attached to it, the graph will be connected. So you need to simply get the sum of all the weights of the edges.The complexity is O(n+nlog(n))O(n+nlog(n)) since the number of edges can go up to nlog(n)nlog(n). 1062E - CompanyLet's call inuinu the time that we reach the node uu in depth first search and outu=max(inv1,inv2,⋯,invk)outu=max(inv1,inv2,⋯,invk) where vivi is a child of uu. If node uu is in charge of node vv (uu is an ancestor of vv) then inu≤inv≤outuinu≤inv≤outu. Suppose we don't have to ignore any node then the answer to each query is the LCA of two nodes uu and vv (l≤u,v≤rl≤u,v≤r), where uu and vv are chosen so that inu=max(inl,inl+1,…,inr)inu=max(inl,inl+1,…,inr) and inv=min(inl,inl+1,…,inr)inv=min(inl,inl+1,…,inr). Proof: Let rr be the LCA of uu and vv, then inr≤inv≤inu≤outrinr≤inv≤inu≤outr. For every node w∈[l,r]w∈[l,r], inv≤inw≤inu⇒inr≤inw≤outr⇒rinv≤inw≤inu⇒inr≤inw≤outr⇒r is an ancestor of ww. Therefore, the node that needs to be ignored is either uu or vv. Suppose we ignore uu, the query splits into two halves [l,u−1]∪[u+1,r][l,u−1]∪[u+1,r]. We find the LCA to each half and get the LCA of them. We do similarly for vv and optimize the answer.Complexity: O(Nlog(N)+Qlog(N))O(Nlog(N)+Qlog(N)). 1062F - Upgrading CitiesThe main idea of this problem is to calculate inuinu and outuoutu for every node uu, where inuinu denotes the number of nodes that can reach uu and outuoutu denotes the number of nodes that can be reached by uu. If inu+outu=N+1inu+outu=N+1 then uu is important or NN if uu is semi-important.However, it may not possible to calculate inuinu and outuoutu for every node uu in given time (please tell me if it's possible) so we have to do some tricks.First of all, we need to find an arbitrary longest path (PP)=s1→s2→...→sk=s1→s2→...→sk on the graph (kk is the number of nodes on this path). If a node is important then it must lie on this path (11). Proof: Assume there is a node uu that is important and doesn't lie on (PP). Let sisi be the rightmost node on (PP) and can reach uu. It's true that i<ki<k, because if i=ki=k then we have a longer path than the one we found so it's not possible. By definition of ii, si+1si+1 cannot reach uu. Therefore uu must be able to reach si+1si+1 (because uu is important). This leads to a conflict: We have a path that is longer than the one we found: s1→s2→⋯→si→u→si+1→⋯→sks1→s2→⋯→si→u→si+1→⋯→sk. Therefore statement (11) is proved. It takes O(N+M)O(N+M) to find (PP).Let's deal with important nodes first. Because all important nodes lie on the path (PP) so it makes no sense to calculate inin and outout for those nodes that don't belong to (PP). We can calculate outout by iterate through PP from sksk to s1s1. At each node sisi, we just need to use bfs or dfs to search for the nodes that can be reached by sisi. Because we visit each node 11 time then it takes O(N+M)O(N+M) to do this. To calculate inin we just need to reverse the direction of the edges and do similarly.Now we need to find the semi nodes. There are two types of semi nodes: those belong to (PP) and those don't. For the ones belong to (PP), we just need to check if inu+outu=Ninu+outu=N. For the ones don't belong to (PP), suppose we are dealing with node uu. Let sisi be the rightmost node on (PP) that can reach uu and sjsj be the leftmost node on (PP) that can be reached by uu. It's obvious that i<j−1i<j−1. Let Lu=iLu=i and Ru=jRu=j, let lengleng equal j−i−1j−i−1. If leng>1leng>1 then u is not a semi node (because we have to delete all nodes between i and j not inclusive), or else we must erase si+1si+1 to make uu a semi important node. We can see that the path from sisi to uu contains only sisi and uu, and the path from uu to sjsj contains only uu and sjsj, because otherwise there exists a longer path than (PP), which is false. So we consider uu as a candidate. Moreover, if exists a node vv that is a candidate and Lu=LvLu=Lv (also leads to Ru=RvRu=Rv) then both uu and vv are not semi important nodes. Proof: After we delete si+1si+1, for uu, exists a path that is as long as (PP) and does not go through uu (it goes through vv) so uu is not a important node, based on statement (11). Same for vv. Briefly, at this point we have the path (PP) and a list of nodes u1,u2,...,utu1,u2,...,ut. For every ii, uiui is a candidate and Lui+1=Rui−1Lui+1=Rui−1. For every ii, jj, Lui!=LujLui!=Luj.So now we are going to calculate inin and outout for those candidate nodes. We can do this similarly as when we find the important nodes. To calculate outout, iterate through sksk to s1s1. At each node sisi, bfs or dfs to search for nodes that can be reached by sisi. Additionally, if there is a candidate node vv that Rv=i−1Rv=i−1, we start a search from vv to find those nodes that can be reached by vv, we have outv=outsi+outv=outsi+ the number of nodes we just found. After that we pop those nodes from the stack (or whatever), mark them as not visited and continue to iterate to si−1si−1. To calculate inin we reverse the directs of the edges and do the same. Because each node is visited 11 time by nodes on (PP) and at most 22 times by candidate nodes so it takes O(3(N+M))O(3(N+M)).The total complexity is O(N+M)O(N+M).Sorry if the tutorial for F is too long.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1062\\s*A"
          },
          "content_length": 7894
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #520 - Codeforces - Code 1",
          "code": "2^(num zeroes + num ones) - 2^(num zeroes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63136",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 1",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 2",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(a[i] < a[i + 1],\n                \"Array elements must be strictly increasing, but a[%d]=%d is not less than a[%d]=%d\",\n                i + 1, a[i], i + 2, a[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(a[i] < a[i + 1],\n                \"Array elements must be strictly increasing, but a[%d]=%d is not less than a[%d]=%d\",\n                i + 1, a[i], i + 2, a[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(a[i] < a[i + 1],\n                \"Array elements must be strictly increasing, but a[%d]=%d is not less than a[%d]=%d\",\n                i + 1, a[i], i + 2, a[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_minimal_diff(int n, vector<int> &a) {\n    for (int i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n}\n\nvoid generate_maximal_gap(int n, vector<int> &a) {\n    set<int> s;\n    s.insert(1);\n    s.insert(1000);\n    while ((int)s.size() < n) {\n        s.insert(rnd.next(2, 999));\n    }\n    vector<int> temp(s.begin(), s.end());\n    sort(temp.begin(), temp.end());\n    for (int i = 0; i < n; i++) {\n        a[i] = temp[i];\n    }\n}\n\nvoid generate_extremes_low(int n, vector<int> &a) {\n    for (int i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n}\n\nvoid generate_extremes_high(int n, vector<int> &a) {\n    for (int i = 0; i < n; i++) {\n        a[i] = 1000 - n + i + 1;\n    }\n}\n\nvoid generate_random(int n, vector<int> &a) {\n    set<int> s;\n    while ((int)s.size() < n) {\n        s.insert(rnd.next(1, 1000));\n    }\n    vector<int> temp(s.begin(), s.end());\n    sort(temp.begin(), temp.end());\n    for (int i = 0; i < n; i++) {\n        a[i] = temp[i];\n    }\n}\n\nvoid generate_single_element(int &n, vector<int> &a) {\n    n = 1;\n    a.resize(n);\n    a[0] = rnd.next(1, 1000);\n}\n\nvoid generate_cannot_erase(int &n, vector<int> &a) {\n    n = 2;\n    a.resize(n);\n    a[0] = rnd.next(1, 500);\n    a[1] = a[0] + rnd.next(500, min(1000 - a[0], 500));\n}\n\nvoid generate_full_range(int &n, vector<int> &a) {\n    n = 100;\n    a.resize(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n}\n\nvoid generate_large_narrow(int &n, vector<int> &a) {\n    n = 100;\n    a.resize(n);\n    int start = rnd.next(1, 1000 - n + 1);\n    for (int i = 0; i < n; i++) {\n        a[i] = start + i;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\", 10);\n    string type = opt<string>(\"type\", \"minimal_diff\");\n    \n    vector<int> a(n);\n    \n    if (type == \"minimal_diff\") {\n        generate_minimal_diff(n, a);\n    } else if (type == \"maximal_gap\") {\n        generate_maximal_gap(n, a);\n    } else if (type == \"extremes_low\") {\n        generate_extremes_low(n, a);\n    } else if (type == \"extremes_high\") {\n        generate_extremes_high(n, a);\n    } else if (type == \"random\") {\n        generate_random(n, a);\n    } else if (type == \"single_element\") {\n        generate_single_element(n, a);\n    } else if (type == \"cannot_erase\") {\n        generate_cannot_erase(n, a);\n    } else if (type == \"full_range\") {\n        generate_full_range(n, a);\n    } else if (type == \"large_narrow\") {\n        generate_large_narrow(n, a);\n    } else {\n        // default\n        generate_minimal_diff(n, a);\n    }\n    \n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the array\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_minimal_diff(int n, vector<int> &a) {\n    for (int i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n}\n\nvoid generate_maximal_gap(int n, vector<int> &a) {\n    set<int> s;\n    s.insert(1);\n    s.insert(1000);\n    while ((int)s.size() < n) {\n        s.insert(rnd.next(2, 999));\n    }\n    vector<int> temp(s.begin(), s.end());\n    sort(temp.begin(), temp.end());\n    for (int i = 0; i < n; i++) {\n        a[i] = temp[i];\n    }\n}\n\nvoid generate_extremes_low(int n, vector<int> &a) {\n    for (int i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n}\n\nvoid generate_extremes_high(int n, vector<int> &a) {\n    for (int i = 0; i < n; i++) {\n        a[i] = 1000 - n + i + 1;\n    }\n}\n\nvoid generate_random(int n, vector<int> &a) {\n    set<int> s;\n    while ((int)s.size() < n) {\n        s.insert(rnd.next(1, 1000));\n    }\n    vector<int> temp(s.begin(), s.end());\n    sort(temp.begin(), temp.end());\n    for (int i = 0; i < n; i++) {\n        a[i] = temp[i];\n    }\n}\n\nvoid generate_single_element(int &n, vector<int> &a) {\n    n = 1;\n    a.resize(n);\n    a[0] = rnd.next(1, 1000);\n}\n\nvoid generate_cannot_erase(int &n, vector<int> &a) {\n    n = 2;\n    a.resize(n);\n    a[0] = rnd.next(1, 500);\n    a[1] = a[0] + rnd.next(500, min(1000 - a[0], 500));\n}\n\nvoid generate_full_range(int &n, vector<int> &a) {\n    n = 100;\n    a.resize(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n}\n\nvoid generate_large_narrow(int &n, vector<int> &a) {\n    n = 100;\n    a.resize(n);\n    int start = rnd.next(1, 1000 - n + 1);\n    for (int i = 0; i < n; i++) {\n        a[i] = start + i;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\", 10);\n    string type = opt<string>(\"type\", \"minimal_diff\");\n    \n    vector<int> a(n);\n    \n    if (type == \"minimal_diff\") {\n        generate_minimal_diff(n, a);\n    } else if (type == \"maximal_gap\") {\n        generate_maximal_gap(n, a);\n    } else if (type == \"extremes_low\") {\n        generate_extremes_low(n, a);\n    } else if (type == \"extremes_high\") {\n        generate_extremes_high(n, a);\n    } else if (type == \"random\") {\n        generate_random(n, a);\n    } else if (type == \"single_element\") {\n        generate_single_element(n, a);\n    } else if (type == \"cannot_erase\") {\n        generate_cannot_erase(n, a);\n    } else if (type == \"full_range\") {\n        generate_full_range(n, a);\n    } else if (type == \"large_narrow\") {\n        generate_large_narrow(n, a);\n    } else {\n        // default\n        generate_minimal_diff(n, a);\n    }\n    \n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the array\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# minimal_diff with small n\n./gen -n 5 -type minimal_diff\n./gen -n 10 -type minimal_diff\n./gen -n 20 -type minimal_diff\n./gen -n 50 -type minimal_diff\n./gen -n 100 -type minimal_diff\n\n# maximal_gap with small n\n./gen -n 5 -type maximal_gap\n./gen -n 10 -type maximal_gap\n./gen -n 20 -type maximal_gap\n./gen -n 50 -type maximal_gap\n./gen -n 100 -type maximal_gap\n\n# extremes_low with various n\n./gen -n 1 -type extremes_low\n./gen -n 50 -type extremes_low\n./gen -n 100 -type extremes_low\n\n# extremes_high with various n\n./gen -n 1 -type extremes_high\n./gen -n 50 -type extremes_high\n./gen -n 100 -type extremes_high\n\n# random arrays with n from 1 to 100\n./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n\n# single_element\n./gen -type single_element\n\n# cannot_erase\n./gen -type cannot_erase\n\n# full_range\n./gen -type full_range\n\n# large_narrow\n./gen -type large_narrow\n\n# random arrays multiple times to generate different data\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n\n# generate more 'cannot_erase' test cases\n./gen -type cannot_erase\n./gen -type cannot_erase\n./gen -type cannot_erase\n\n# generate 'large_narrow' with varying starting points\n./gen -type large_narrow\n./gen -type large_narrow\n./gen -type large_narrow\n\n# generate 'maximal_gap' multiple times\n./gen -n 100 -type maximal_gap\n./gen -n 100 -type maximal_gap\n./gen -n 100 -type maximal_gap\n\n# generate 'minimal_diff' with n=100\n./gen -n 100 -type minimal_diff\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:43.517965",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1062/B",
      "title": "B. Math",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of the input contains a single integer nn (1≤n≤1061≤n≤106) — the initial number.",
      "output_spec": "OutputPrint two integers: the minimum integer nn that can be achieved using the described operations and the minimum number of operations required.",
      "sample_tests": "ExamplesInputCopy20OutputCopy10 2InputCopy5184OutputCopy6 4",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line of the input contains a single integer nn (1≤n≤1061≤n≤106) — the initial number.\n\nOutputPrint two integers: the minimum integer nn that can be achieved using the described operations and the minimum number of operations required.\n\nInputCopy20OutputCopy10 2InputCopy5184OutputCopy6 4\n\nInputCopy20\n\nOutputCopy10 2\n\nInputCopy5184\n\nOutputCopy6 4\n\nNoteIn the first example, you can apply the operation mul 55 to get 100100 and then sqrt to get 1010.In the second example, you can first apply sqrt to get 7272, then mul 1818 to get 12961296 and finally two more sqrt and you get 66.Note, that even if the initial value of nn is less or equal 106106, it can still become greater than 106106 after applying one or more operations.",
      "solutions": [
        {
          "title": "Codeforces Round #520 - Codeforces",
          "content": "Hi everyone. I'm glad to announce that the Codeforces Round 520 (Div. 2) will be held on Wednesday, November 14, 2018 at 23:35UTC+8.The round will be rated for Div 2 participants (whose ratings are lower than 2100). However, all the other participants can compete as well, without worrying about ratings being changed.You will be given 2 hours to solve 6 problems. It's better to read all the problems. The scoring distribution will be announced soon before the contest starts.All the problems were prepared by myself, with some help from my friend GiraffeCoder. I want to thank cdkrot for coordinating me in preparing the problems, vintage_Vlad_Makeev, isaf27, demon1999 and Arpa for testing my solutions. I also want to thank csacademy for their graph editor tool. You can check it out at this link.This is the first round I propose. I put a lot of work into it so I hope that you will enjoy it (smiley face).Wish you do your best and get a high rating!Update 1: If you want to discuss about the problems after the contest, here is the link to the CP Community on Discord. Please make sure that you don't give the solutions to other participants during the contest.Update 2: The score distribution will be the standard one: 500 1000 1500 2000 2500 3000.Update 3: Congrats to the winnerOfficial participants: Kataoka_Yuuki Dark_Warlock wcysai coriander fcwww Unofficial participants: budalnik HIR180 KrK ayaze Anadi Tutorial UPDATED",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63136",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1433
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces",
          "content": "1062A - A PrankSince 1≤ai≤1031≤ai≤103 for all ii, let set a0=0a0=0 and an+1=1001an+1=1001. For every i,ji,j such that 0≤i<j≤n+10≤i<j≤n+1, if aj−j=ai−iaj−j=ai−i then we can erase all the elements between ii and jj (not inclusive). So just check for all the valid pairs and maximize the answer. Time complexity: O(n2)O(n2). 1062B - MathBy factorizing nn we get n=p1a1p2a2…pkakn=p1a1p2a2…pkak (kk is the number of prime factors). Because we can't get rid of those prime factors then the smallest nn is p1p2…pkp1p2…pk. For each aiai, let uiui be the positive integer so that 2ui≥ai>2ui−12ui≥ai>2ui−1. Let UU be max(ui)max(ui). It's clear that we have to apply the \"sqrtsqrt\" operation at least UU times, since each time we apply it, aiai is divided by 22 for all ii. If for all ii, ai=2Uai=2U then the answer is UU, obviously. Otherwise, we need to use the operation \"mulmul\" 11 time to make all the aiai equal 2U2U and by now the answer is U+1U+1.Complexity: O(sqrt(N))O(sqrt(N)) 1062C - Banh-miFor each part that we choose, we need to calculate how many times that element is added to our score. You can see that, the first element that we choose is added 2k−12k−1 times in our score (k=r−l+1k=r−l+1), the second element is added 2k−22k−2 times and so on. Therefore, we just need to choose all the 1s1s first and then all the remaining parts. The final score is (2x−1)⋅2y(2x−1)⋅2y, where xx is the number of 1s1s and yy is the number of 0s0s. Complexity: O(n+Q)O(n+Q). 1062D - Fun with IntegersFor every integer xx (1≤x≤n)(1≤x≤n), let's call DD the set of integers that are able to be transformed into xx. As you can see, if aa could be transformed into bb then −a−a could also be transformed into bb. Therefore |D||D| is always even. Let's build a graph consists of 2n−22n−2 nodes, numbered −n−n through nn (except for −1−1, 00, and 11). There is an weighted undirected edge between node uu and vv if and only if uu can be transformed into vv. The weight of the edge is the score of the transformation. Every node in the graph has an even degree so you can split the graph into some connected components so that each components is an Euler circuit (a circuit that contains all the edges). Therefore you just need to find all those Euler circuits and maximize your score. Moreover, you can see that, if an integer aa can be transformed into bb then xx and 22 are in the same component. Proof: Suppose a<ba<b, there exists an integer x=b/ax=b/a. If x=2x=2 then it is proved, otherwise there exists an integer c=2x<b≤nc=2x<b≤n. cc and 22 are in the same component so xx and 22 are also in the same component. Therefore, if we ignore all the nodes that have no edges attached to it, the graph will be connected. So you need to simply get the sum of all the weights of the edges.The complexity is O(n+nlog(n))O(n+nlog(n)) since the number of edges can go up to nlog(n)nlog(n). 1062E - CompanyLet's call inuinu the time that we reach the node uu in depth first search and outu=max(inv1,inv2,⋯,invk)outu=max(inv1,inv2,⋯,invk) where vivi is a child of uu. If node uu is in charge of node vv (uu is an ancestor of vv) then inu≤inv≤outuinu≤inv≤outu. Suppose we don't have to ignore any node then the answer to each query is the LCA of two nodes uu and vv (l≤u,v≤rl≤u,v≤r), where uu and vv are chosen so that inu=max(inl,inl+1,…,inr)inu=max(inl,inl+1,…,inr) and inv=min(inl,inl+1,…,inr)inv=min(inl,inl+1,…,inr). Proof: Let rr be the LCA of uu and vv, then inr≤inv≤inu≤outrinr≤inv≤inu≤outr. For every node w∈[l,r]w∈[l,r], inv≤inw≤inu⇒inr≤inw≤outr⇒rinv≤inw≤inu⇒inr≤inw≤outr⇒r is an ancestor of ww. Therefore, the node that needs to be ignored is either uu or vv. Suppose we ignore uu, the query splits into two halves [l,u−1]∪[u+1,r][l,u−1]∪[u+1,r]. We find the LCA to each half and get the LCA of them. We do similarly for vv and optimize the answer.Complexity: O(Nlog(N)+Qlog(N))O(Nlog(N)+Qlog(N)). 1062F - Upgrading CitiesThe main idea of this problem is to calculate inuinu and outuoutu for every node uu, where inuinu denotes the number of nodes that can reach uu and outuoutu denotes the number of nodes that can be reached by uu. If inu+outu=N+1inu+outu=N+1 then uu is important or NN if uu is semi-important.However, it may not possible to calculate inuinu and outuoutu for every node uu in given time (please tell me if it's possible) so we have to do some tricks.First of all, we need to find an arbitrary longest path (PP)=s1→s2→...→sk=s1→s2→...→sk on the graph (kk is the number of nodes on this path). If a node is important then it must lie on this path (11). Proof: Assume there is a node uu that is important and doesn't lie on (PP). Let sisi be the rightmost node on (PP) and can reach uu. It's true that i<ki<k, because if i=ki=k then we have a longer path than the one we found so it's not possible. By definition of ii, si+1si+1 cannot reach uu. Therefore uu must be able to reach si+1si+1 (because uu is important). This leads to a conflict: We have a path that is longer than the one we found: s1→s2→⋯→si→u→si+1→⋯→sks1→s2→⋯→si→u→si+1→⋯→sk. Therefore statement (11) is proved. It takes O(N+M)O(N+M) to find (PP).Let's deal with important nodes first. Because all important nodes lie on the path (PP) so it makes no sense to calculate inin and outout for those nodes that don't belong to (PP). We can calculate outout by iterate through PP from sksk to s1s1. At each node sisi, we just need to use bfs or dfs to search for the nodes that can be reached by sisi. Because we visit each node 11 time then it takes O(N+M)O(N+M) to do this. To calculate inin we just need to reverse the direction of the edges and do similarly.Now we need to find the semi nodes. There are two types of semi nodes: those belong to (PP) and those don't. For the ones belong to (PP), we just need to check if inu+outu=Ninu+outu=N. For the ones don't belong to (PP), suppose we are dealing with node uu. Let sisi be the rightmost node on (PP) that can reach uu and sjsj be the leftmost node on (PP) that can be reached by uu. It's obvious that i<j−1i<j−1. Let Lu=iLu=i and Ru=jRu=j, let lengleng equal j−i−1j−i−1. If leng>1leng>1 then u is not a semi node (because we have to delete all nodes between i and j not inclusive), or else we must erase si+1si+1 to make uu a semi important node. We can see that the path from sisi to uu contains only sisi and uu, and the path from uu to sjsj contains only uu and sjsj, because otherwise there exists a longer path than (PP), which is false. So we consider uu as a candidate. Moreover, if exists a node vv that is a candidate and Lu=LvLu=Lv (also leads to Ru=RvRu=Rv) then both uu and vv are not semi important nodes. Proof: After we delete si+1si+1, for uu, exists a path that is as long as (PP) and does not go through uu (it goes through vv) so uu is not a important node, based on statement (11). Same for vv. Briefly, at this point we have the path (PP) and a list of nodes u1,u2,...,utu1,u2,...,ut. For every ii, uiui is a candidate and Lui+1=Rui−1Lui+1=Rui−1. For every ii, jj, Lui!=LujLui!=Luj.So now we are going to calculate inin and outout for those candidate nodes. We can do this similarly as when we find the important nodes. To calculate outout, iterate through sksk to s1s1. At each node sisi, bfs or dfs to search for nodes that can be reached by sisi. Additionally, if there is a candidate node vv that Rv=i−1Rv=i−1, we start a search from vv to find those nodes that can be reached by vv, we have outv=outsi+outv=outsi+ the number of nodes we just found. After that we pop those nodes from the stack (or whatever), mark them as not visited and continue to iterate to si−1si−1. To calculate inin we reverse the directs of the edges and do the same. Because each node is visited 11 time by nodes on (PP) and at most 22 times by candidate nodes so it takes O(3(N+M))O(3(N+M)).The total complexity is O(N+M)O(N+M).Sorry if the tutorial for F is too long.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1062\\s*B"
          },
          "content_length": 7894
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #520 - Codeforces - Code 1",
          "code": "2^(num zeroes + num ones) - 2^(num zeroes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63136",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 1",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 2",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int minN = opt<int>(\"minN\", 1);\n    int maxN = opt<int>(\"maxN\", 1e6);\n    string type = opt<string>(\"type\", \"random\");\n    int n;\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000000;\n    } else if (type == \"small\") {\n        n = rnd.next(minN, min(maxN, 100));\n    } else if (type == \"large\") {\n        n = rnd.next(max(minN, 900000), maxN);\n    } else if (type == \"square\") {\n        int minSq = ceil(sqrt(minN));\n        int maxSq = floor(sqrt(maxN));\n        if (minSq > maxSq) {\n            cerr << \"No squares in the given range!\" << endl;\n            exit(1);\n        }\n        int s = rnd.next(minSq, maxSq);\n        n = s * s;\n    } else if (type == \"non-square\") {\n        n = rnd.next(minN, maxN);\n        int s = sqrt(n);\n        if (s * s == n) {\n            if (n + 1 <= maxN)\n                n++;\n            else if (n -1 >= minN)\n                n--;\n            else\n                n = minN; // Make sure it's not a square\n        }\n    } else if (type == \"multiple_sqrt\") {\n        // Generate n = 2^(2*k) where k >= 2\n        int maxK = log2(sqrt(maxN));\n        int minK = max(2, (int)(log2(sqrt(minN))));\n        if (minK > maxK) {\n            cerr << \"No suitable n for multiple sqrt in the given range!\" << endl;\n            exit(1);\n        }\n        int k = rnd.next(minK, maxK);\n        n = 1 << (2*k); // n = 2^(2k)\n    } else if (type == \"max_mul\") {\n        // Generate n where minimal n is achieved by multiplying to get n > 1e6\n        // For this test, we pick n such that it's a large non-square number\n        n = rnd.next(100000, 999999);\n        // Ensure n is not a perfect square\n        int s = sqrt(n);\n        if (s * s == n)\n            n += (n + 1 <= maxN) ? 1 : -1;\n    } else { // random\n        n = rnd.next(minN, maxN);\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int minN = opt<int>(\"minN\", 1);\n    int maxN = opt<int>(\"maxN\", 1e6);\n    string type = opt<string>(\"type\", \"random\");\n    int n;\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000000;\n    } else if (type == \"small\") {\n        n = rnd.next(minN, min(maxN, 100));\n    } else if (type == \"large\") {\n        n = rnd.next(max(minN, 900000), maxN);\n    } else if (type == \"square\") {\n        int minSq = ceil(sqrt(minN));\n        int maxSq = floor(sqrt(maxN));\n        if (minSq > maxSq) {\n            cerr << \"No squares in the given range!\" << endl;\n            exit(1);\n        }\n        int s = rnd.next(minSq, maxSq);\n        n = s * s;\n    } else if (type == \"non-square\") {\n        n = rnd.next(minN, maxN);\n        int s = sqrt(n);\n        if (s * s == n) {\n            if (n + 1 <= maxN)\n                n++;\n            else if (n -1 >= minN)\n                n--;\n            else\n                n = minN; // Make sure it's not a square\n        }\n    } else if (type == \"multiple_sqrt\") {\n        // Generate n = 2^(2*k) where k >= 2\n        int maxK = log2(sqrt(maxN));\n        int minK = max(2, (int)(log2(sqrt(minN))));\n        if (minK > maxK) {\n            cerr << \"No suitable n for multiple sqrt in the given range!\" << endl;\n            exit(1);\n        }\n        int k = rnd.next(minK, maxK);\n        n = 1 << (2*k); // n = 2^(2k)\n    } else if (type == \"max_mul\") {\n        // Generate n where minimal n is achieved by multiplying to get n > 1e6\n        // For this test, we pick n such that it's a large non-square number\n        n = rnd.next(100000, 999999);\n        // Ensure n is not a perfect square\n        int s = sqrt(n);\n        if (s * s == n)\n            n += (n + 1 <= maxN) ? 1 : -1;\n    } else { // random\n        n = rnd.next(minN, maxN);\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type small\n./gen -type small\n./gen -type small\n./gen -type large\n./gen -type large\n./gen -type large\n./gen -type square\n./gen -type square\n./gen -type square -minN 999000 -maxN 1000000\n./gen -type square -minN 1 -maxN 1\n./gen -type non-square\n./gen -type non-square\n./gen -type non-square -minN 999000 -maxN 1000000\n./gen -type multiple_sqrt\n./gen -type multiple_sqrt\n./gen -type multiple_sqrt -minN 1 -maxN 256\n./gen -type max_mul\n./gen -type max_mul\n./gen -type random\n./gen -type random\n./gen -type random -minN 1 -maxN 1000000\n./gen -type random -minN 500000 -maxN 500000\n./gen -type random -minN 1000000 -maxN 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:45.231178",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1062/C",
      "title": "C. Banh-mi",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and qq (1≤n,q≤1000001≤n,q≤100000).The second line contains a string of nn characters, each character is either '0' or '1'. The ii-th character defines the deliciousness of the ii-th part.Each of the following qq lines contains two integers lili and riri (1≤li≤ri≤n1≤li≤ri≤n) — the segment of the corresponding query.",
      "output_spec": "OutputPrint qq lines, where ii-th of them contains a single integer — the answer to the ii-th query modulo 109+7109+7.",
      "sample_tests": "ExamplesInputCopy4 210111 43 4OutputCopy143InputCopy3 21111 23 3OutputCopy31",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and qq (1≤n,q≤1000001≤n,q≤100000).The second line contains a string of nn characters, each character is either '0' or '1'. The ii-th character defines the deliciousness of the ii-th part.Each of the following qq lines contains two integers lili and riri (1≤li≤ri≤n1≤li≤ri≤n) — the segment of the corresponding query.\n\nOutputPrint qq lines, where ii-th of them contains a single integer — the answer to the ii-th query modulo 109+7109+7.\n\nInputCopy4 210111 43 4OutputCopy143InputCopy3 21111 23 3OutputCopy31\n\nInputCopy4 210111 43 4\n\nOutputCopy143\n\nInputCopy3 21111 23 3\n\nOutputCopy31\n\nNoteIn the first example:   For query 11: One of the best ways for JATC to eats those parts is in this order: 11, 44, 33, 22.  For query 22: Both 33, 44 and 44, 33 ordering give the same answer. In the second example, any order of eating parts leads to the same answer.",
      "solutions": [
        {
          "title": "Codeforces Round #520 - Codeforces",
          "content": "Hi everyone. I'm glad to announce that the Codeforces Round 520 (Div. 2) will be held on Wednesday, November 14, 2018 at 23:35UTC+8.The round will be rated for Div 2 participants (whose ratings are lower than 2100). However, all the other participants can compete as well, without worrying about ratings being changed.You will be given 2 hours to solve 6 problems. It's better to read all the problems. The scoring distribution will be announced soon before the contest starts.All the problems were prepared by myself, with some help from my friend GiraffeCoder. I want to thank cdkrot for coordinating me in preparing the problems, vintage_Vlad_Makeev, isaf27, demon1999 and Arpa for testing my solutions. I also want to thank csacademy for their graph editor tool. You can check it out at this link.This is the first round I propose. I put a lot of work into it so I hope that you will enjoy it (smiley face).Wish you do your best and get a high rating!Update 1: If you want to discuss about the problems after the contest, here is the link to the CP Community on Discord. Please make sure that you don't give the solutions to other participants during the contest.Update 2: The score distribution will be the standard one: 500 1000 1500 2000 2500 3000.Update 3: Congrats to the winnerOfficial participants: Kataoka_Yuuki Dark_Warlock wcysai coriander fcwww Unofficial participants: budalnik HIR180 KrK ayaze Anadi Tutorial UPDATED",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63136",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1433
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces",
          "content": "1062A - A PrankSince 1≤ai≤1031≤ai≤103 for all ii, let set a0=0a0=0 and an+1=1001an+1=1001. For every i,ji,j such that 0≤i<j≤n+10≤i<j≤n+1, if aj−j=ai−iaj−j=ai−i then we can erase all the elements between ii and jj (not inclusive). So just check for all the valid pairs and maximize the answer. Time complexity: O(n2)O(n2). 1062B - MathBy factorizing nn we get n=p1a1p2a2…pkakn=p1a1p2a2…pkak (kk is the number of prime factors). Because we can't get rid of those prime factors then the smallest nn is p1p2…pkp1p2…pk. For each aiai, let uiui be the positive integer so that 2ui≥ai>2ui−12ui≥ai>2ui−1. Let UU be max(ui)max(ui). It's clear that we have to apply the \"sqrtsqrt\" operation at least UU times, since each time we apply it, aiai is divided by 22 for all ii. If for all ii, ai=2Uai=2U then the answer is UU, obviously. Otherwise, we need to use the operation \"mulmul\" 11 time to make all the aiai equal 2U2U and by now the answer is U+1U+1.Complexity: O(sqrt(N))O(sqrt(N)) 1062C - Banh-miFor each part that we choose, we need to calculate how many times that element is added to our score. You can see that, the first element that we choose is added 2k−12k−1 times in our score (k=r−l+1k=r−l+1), the second element is added 2k−22k−2 times and so on. Therefore, we just need to choose all the 1s1s first and then all the remaining parts. The final score is (2x−1)⋅2y(2x−1)⋅2y, where xx is the number of 1s1s and yy is the number of 0s0s. Complexity: O(n+Q)O(n+Q). 1062D - Fun with IntegersFor every integer xx (1≤x≤n)(1≤x≤n), let's call DD the set of integers that are able to be transformed into xx. As you can see, if aa could be transformed into bb then −a−a could also be transformed into bb. Therefore |D||D| is always even. Let's build a graph consists of 2n−22n−2 nodes, numbered −n−n through nn (except for −1−1, 00, and 11). There is an weighted undirected edge between node uu and vv if and only if uu can be transformed into vv. The weight of the edge is the score of the transformation. Every node in the graph has an even degree so you can split the graph into some connected components so that each components is an Euler circuit (a circuit that contains all the edges). Therefore you just need to find all those Euler circuits and maximize your score. Moreover, you can see that, if an integer aa can be transformed into bb then xx and 22 are in the same component. Proof: Suppose a<ba<b, there exists an integer x=b/ax=b/a. If x=2x=2 then it is proved, otherwise there exists an integer c=2x<b≤nc=2x<b≤n. cc and 22 are in the same component so xx and 22 are also in the same component. Therefore, if we ignore all the nodes that have no edges attached to it, the graph will be connected. So you need to simply get the sum of all the weights of the edges.The complexity is O(n+nlog(n))O(n+nlog(n)) since the number of edges can go up to nlog(n)nlog(n). 1062E - CompanyLet's call inuinu the time that we reach the node uu in depth first search and outu=max(inv1,inv2,⋯,invk)outu=max(inv1,inv2,⋯,invk) where vivi is a child of uu. If node uu is in charge of node vv (uu is an ancestor of vv) then inu≤inv≤outuinu≤inv≤outu. Suppose we don't have to ignore any node then the answer to each query is the LCA of two nodes uu and vv (l≤u,v≤rl≤u,v≤r), where uu and vv are chosen so that inu=max(inl,inl+1,…,inr)inu=max(inl,inl+1,…,inr) and inv=min(inl,inl+1,…,inr)inv=min(inl,inl+1,…,inr). Proof: Let rr be the LCA of uu and vv, then inr≤inv≤inu≤outrinr≤inv≤inu≤outr. For every node w∈[l,r]w∈[l,r], inv≤inw≤inu⇒inr≤inw≤outr⇒rinv≤inw≤inu⇒inr≤inw≤outr⇒r is an ancestor of ww. Therefore, the node that needs to be ignored is either uu or vv. Suppose we ignore uu, the query splits into two halves [l,u−1]∪[u+1,r][l,u−1]∪[u+1,r]. We find the LCA to each half and get the LCA of them. We do similarly for vv and optimize the answer.Complexity: O(Nlog(N)+Qlog(N))O(Nlog(N)+Qlog(N)). 1062F - Upgrading CitiesThe main idea of this problem is to calculate inuinu and outuoutu for every node uu, where inuinu denotes the number of nodes that can reach uu and outuoutu denotes the number of nodes that can be reached by uu. If inu+outu=N+1inu+outu=N+1 then uu is important or NN if uu is semi-important.However, it may not possible to calculate inuinu and outuoutu for every node uu in given time (please tell me if it's possible) so we have to do some tricks.First of all, we need to find an arbitrary longest path (PP)=s1→s2→...→sk=s1→s2→...→sk on the graph (kk is the number of nodes on this path). If a node is important then it must lie on this path (11). Proof: Assume there is a node uu that is important and doesn't lie on (PP). Let sisi be the rightmost node on (PP) and can reach uu. It's true that i<ki<k, because if i=ki=k then we have a longer path than the one we found so it's not possible. By definition of ii, si+1si+1 cannot reach uu. Therefore uu must be able to reach si+1si+1 (because uu is important). This leads to a conflict: We have a path that is longer than the one we found: s1→s2→⋯→si→u→si+1→⋯→sks1→s2→⋯→si→u→si+1→⋯→sk. Therefore statement (11) is proved. It takes O(N+M)O(N+M) to find (PP).Let's deal with important nodes first. Because all important nodes lie on the path (PP) so it makes no sense to calculate inin and outout for those nodes that don't belong to (PP). We can calculate outout by iterate through PP from sksk to s1s1. At each node sisi, we just need to use bfs or dfs to search for the nodes that can be reached by sisi. Because we visit each node 11 time then it takes O(N+M)O(N+M) to do this. To calculate inin we just need to reverse the direction of the edges and do similarly.Now we need to find the semi nodes. There are two types of semi nodes: those belong to (PP) and those don't. For the ones belong to (PP), we just need to check if inu+outu=Ninu+outu=N. For the ones don't belong to (PP), suppose we are dealing with node uu. Let sisi be the rightmost node on (PP) that can reach uu and sjsj be the leftmost node on (PP) that can be reached by uu. It's obvious that i<j−1i<j−1. Let Lu=iLu=i and Ru=jRu=j, let lengleng equal j−i−1j−i−1. If leng>1leng>1 then u is not a semi node (because we have to delete all nodes between i and j not inclusive), or else we must erase si+1si+1 to make uu a semi important node. We can see that the path from sisi to uu contains only sisi and uu, and the path from uu to sjsj contains only uu and sjsj, because otherwise there exists a longer path than (PP), which is false. So we consider uu as a candidate. Moreover, if exists a node vv that is a candidate and Lu=LvLu=Lv (also leads to Ru=RvRu=Rv) then both uu and vv are not semi important nodes. Proof: After we delete si+1si+1, for uu, exists a path that is as long as (PP) and does not go through uu (it goes through vv) so uu is not a important node, based on statement (11). Same for vv. Briefly, at this point we have the path (PP) and a list of nodes u1,u2,...,utu1,u2,...,ut. For every ii, uiui is a candidate and Lui+1=Rui−1Lui+1=Rui−1. For every ii, jj, Lui!=LujLui!=Luj.So now we are going to calculate inin and outout for those candidate nodes. We can do this similarly as when we find the important nodes. To calculate outout, iterate through sksk to s1s1. At each node sisi, bfs or dfs to search for nodes that can be reached by sisi. Additionally, if there is a candidate node vv that Rv=i−1Rv=i−1, we start a search from vv to find those nodes that can be reached by vv, we have outv=outsi+outv=outsi+ the number of nodes we just found. After that we pop those nodes from the stack (or whatever), mark them as not visited and continue to iterate to si−1si−1. To calculate inin we reverse the directs of the edges and do the same. Because each node is visited 11 time by nodes on (PP) and at most 22 times by candidate nodes so it takes O(3(N+M))O(3(N+M)).The total complexity is O(N+M)O(N+M).Sorry if the tutorial for F is too long.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1062\\s*C"
          },
          "content_length": 7894
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #520 - Codeforces - Code 1",
          "code": "2^(num zeroes + num ones) - 2^(num zeroes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63136",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 1",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 2",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    string s = inf.readLine(\"[01]{\" + to_string(n) + \"}\", \"s\");\n    for (int i = 0; i < q; i++) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    string s = inf.readLine(\"[01]{\" + to_string(n) + \"}\", \"s\");\n    for (int i = 0; i < q; i++) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    string s = inf.readLine(\"[01]{\" + to_string(n) + \"}\", \"s\");\n    for (int i = 0; i < q; i++) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string xi_type = opt<string>(\"xi_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate xi\n    string xi(n, '0');\n    if (xi_type == \"all_zeros\") {\n        // xi is already all '0's\n    } else if (xi_type == \"all_ones\") {\n        xi.assign(n, '1');\n    } else if (xi_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(2) ? '1' : '0';\n        }\n    } else if (xi_type == \"one_one\") {\n        xi.assign(n, '0');\n        int pos = rnd.next(0, n - 1);\n        xi[pos] = '1';\n    } else if (xi_type == \"one_zero\") {\n        xi.assign(n, '1');\n        int pos = rnd.next(0, n - 1);\n        xi[pos] = '0';\n    } else if (xi_type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = (i % 2 == 0) ? '0' : '1';\n        }\n    } else if (xi_type == \"long_runs\") {\n        int i = 0;\n        while (i < n) {\n            char curr_char = rnd.next(2) ? '1' : '0';\n            int run_length = rnd.next(1, min(n - i, max(1, n / 10)));\n            for (int j = 0; j < run_length && i < n; ++j, ++i) {\n                xi[i] = curr_char;\n            }\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n    // Output xi\n    printf(\"%s\\n\", xi.c_str());\n\n    // Generate queries\n    vector<pair<int, int> > queries;\n    if (query_type == \"full_range\") {\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(make_pair(1, n));\n        }\n    } else if (query_type == \"single_point\") {\n        for (int i = 0; i < q; ++i) {\n            int pos = rnd.next(1, n);\n            queries.push_back(make_pair(pos, pos));\n        }\n    } else if (query_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back(make_pair(l, r));\n        }\n    } else if (query_type == \"prefixes\") {\n        for (int i = 0; i < q; ++i) {\n            int k = rnd.next(1, n);\n            queries.push_back(make_pair(1, k));\n        }\n    } else if (query_type == \"suffixes\") {\n        for (int i = 0; i < q; ++i) {\n            int k = rnd.next(1, n);\n            queries.push_back(make_pair(k, n));\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string xi_type = opt<string>(\"xi_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate xi\n    string xi(n, '0');\n    if (xi_type == \"all_zeros\") {\n        // xi is already all '0's\n    } else if (xi_type == \"all_ones\") {\n        xi.assign(n, '1');\n    } else if (xi_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(2) ? '1' : '0';\n        }\n    } else if (xi_type == \"one_one\") {\n        xi.assign(n, '0');\n        int pos = rnd.next(0, n - 1);\n        xi[pos] = '1';\n    } else if (xi_type == \"one_zero\") {\n        xi.assign(n, '1');\n        int pos = rnd.next(0, n - 1);\n        xi[pos] = '0';\n    } else if (xi_type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = (i % 2 == 0) ? '0' : '1';\n        }\n    } else if (xi_type == \"long_runs\") {\n        int i = 0;\n        while (i < n) {\n            char curr_char = rnd.next(2) ? '1' : '0';\n            int run_length = rnd.next(1, min(n - i, max(1, n / 10)));\n            for (int j = 0; j < run_length && i < n; ++j, ++i) {\n                xi[i] = curr_char;\n            }\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n    // Output xi\n    printf(\"%s\\n\", xi.c_str());\n\n    // Generate queries\n    vector<pair<int, int> > queries;\n    if (query_type == \"full_range\") {\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(make_pair(1, n));\n        }\n    } else if (query_type == \"single_point\") {\n        for (int i = 0; i < q; ++i) {\n            int pos = rnd.next(1, n);\n            queries.push_back(make_pair(pos, pos));\n        }\n    } else if (query_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back(make_pair(l, r));\n        }\n    } else if (query_type == \"prefixes\") {\n        for (int i = 0; i < q; ++i) {\n            int k = rnd.next(1, n);\n            queries.push_back(make_pair(1, k));\n        }\n    } else if (query_type == \"suffixes\") {\n        for (int i = 0; i < q; ++i) {\n            int k = rnd.next(1, n);\n            queries.push_back(make_pair(k, n));\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -xi_type all_zeros -query_type full_range\n./gen -n 1 -q 1 -xi_type all_ones -query_type full_range\n./gen -n 2 -q 1 -xi_type alternate -query_type full_range\n./gen -n 10 -q 5 -xi_type random -query_type random\n./gen -n 100 -q 50 -xi_type random -query_type random\n./gen -n 1000 -q 1000 -xi_type one_one -query_type single_point\n./gen -n 1000 -q 1000 -xi_type one_zero -query_type single_point\n./gen -n 10000 -q 10000 -xi_type all_ones -query_type prefixes\n./gen -n 10000 -q 10000 -xi_type all_zeros -query_type suffixes\n./gen -n 50000 -q 50000 -xi_type long_runs -query_type random\n./gen -n 100000 -q 100000 -xi_type random -query_type random\n./gen -n 100000 -q 100000 -xi_type random -query_type full_range\n./gen -n 100000 -q 100000 -xi_type random -query_type single_point\n./gen -n 100000 -q 100000 -xi_type random -query_type prefixes\n./gen -n 100000 -q 100000 -xi_type random -query_type suffixes\n./gen -n 100000 -q 100000 -xi_type alternate -query_type random\n./gen -n 100000 -q 100000 -xi_type alternate -query_type single_point\n./gen -n 100000 -q 100000 -xi_type long_runs -query_type prefixes\n./gen -n 100000 -q 100000 -xi_type long_runs -query_type suffixes\n./gen -n 100000 -q 100000 -xi_type one_one -query_type full_range\n./gen -n 100000 -q 100000 -xi_type one_zero -query_type full_range\n./gen -n 100000 -q 100000 -xi_type one_one -query_type random\n./gen -n 100000 -q 100000 -xi_type one_zero -query_type random\n./gen -n 100000 -q 100000 -xi_type all_zeros -query_type random\n./gen -n 100000 -q 100000 -xi_type all_ones -query_type random\n./gen -n 50000 -q 50000 -xi_type random -query_type random\n./gen -n 10 -q 100000 -xi_type random -query_type random\n./gen -n 100000 -q 10 -xi_type random -query_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:47.100031",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1062/D",
      "title": "D. Fun with Integers",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains a single integer nn (2≤n≤1000002≤n≤100000) — the given integer described above.",
      "output_spec": "OutputPrint an only integer — the maximum score that can be achieved with the transformations. If it is not possible to perform even a single transformation for all possible starting integers, print 00.",
      "sample_tests": "ExamplesInputCopy4OutputCopy8InputCopy6OutputCopy28InputCopy2OutputCopy0",
      "description": "D. Fun with Integers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputA single line contains a single integer nn (2≤n≤1000002≤n≤100000) — the given integer described above.\n\nOutputPrint an only integer — the maximum score that can be achieved with the transformations. If it is not possible to perform even a single transformation for all possible starting integers, print 00.\n\nInputCopy4OutputCopy8InputCopy6OutputCopy28InputCopy2OutputCopy0\n\nOutputCopy8\n\nOutputCopy28\n\nOutputCopy0\n\nNoteIn the first example, the transformations are 2→4→(−2)→(−4)→22→4→(−2)→(−4)→2.In the third example, it is impossible to perform even a single transformation.",
      "solutions": [
        {
          "title": "Codeforces Round #520 - Codeforces",
          "content": "Hi everyone. I'm glad to announce that the Codeforces Round 520 (Div. 2) will be held on Wednesday, November 14, 2018 at 23:35UTC+8.The round will be rated for Div 2 participants (whose ratings are lower than 2100). However, all the other participants can compete as well, without worrying about ratings being changed.You will be given 2 hours to solve 6 problems. It's better to read all the problems. The scoring distribution will be announced soon before the contest starts.All the problems were prepared by myself, with some help from my friend GiraffeCoder. I want to thank cdkrot for coordinating me in preparing the problems, vintage_Vlad_Makeev, isaf27, demon1999 and Arpa for testing my solutions. I also want to thank csacademy for their graph editor tool. You can check it out at this link.This is the first round I propose. I put a lot of work into it so I hope that you will enjoy it (smiley face).Wish you do your best and get a high rating!Update 1: If you want to discuss about the problems after the contest, here is the link to the CP Community on Discord. Please make sure that you don't give the solutions to other participants during the contest.Update 2: The score distribution will be the standard one: 500 1000 1500 2000 2500 3000.Update 3: Congrats to the winnerOfficial participants: Kataoka_Yuuki Dark_Warlock wcysai coriander fcwww Unofficial participants: budalnik HIR180 KrK ayaze Anadi Tutorial UPDATED",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63136",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1433
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces",
          "content": "1062A - A PrankSince 1≤ai≤1031≤ai≤103 for all ii, let set a0=0a0=0 and an+1=1001an+1=1001. For every i,ji,j such that 0≤i<j≤n+10≤i<j≤n+1, if aj−j=ai−iaj−j=ai−i then we can erase all the elements between ii and jj (not inclusive). So just check for all the valid pairs and maximize the answer. Time complexity: O(n2)O(n2). 1062B - MathBy factorizing nn we get n=p1a1p2a2…pkakn=p1a1p2a2…pkak (kk is the number of prime factors). Because we can't get rid of those prime factors then the smallest nn is p1p2…pkp1p2…pk. For each aiai, let uiui be the positive integer so that 2ui≥ai>2ui−12ui≥ai>2ui−1. Let UU be max(ui)max(ui). It's clear that we have to apply the \"sqrtsqrt\" operation at least UU times, since each time we apply it, aiai is divided by 22 for all ii. If for all ii, ai=2Uai=2U then the answer is UU, obviously. Otherwise, we need to use the operation \"mulmul\" 11 time to make all the aiai equal 2U2U and by now the answer is U+1U+1.Complexity: O(sqrt(N))O(sqrt(N)) 1062C - Banh-miFor each part that we choose, we need to calculate how many times that element is added to our score. You can see that, the first element that we choose is added 2k−12k−1 times in our score (k=r−l+1k=r−l+1), the second element is added 2k−22k−2 times and so on. Therefore, we just need to choose all the 1s1s first and then all the remaining parts. The final score is (2x−1)⋅2y(2x−1)⋅2y, where xx is the number of 1s1s and yy is the number of 0s0s. Complexity: O(n+Q)O(n+Q). 1062D - Fun with IntegersFor every integer xx (1≤x≤n)(1≤x≤n), let's call DD the set of integers that are able to be transformed into xx. As you can see, if aa could be transformed into bb then −a−a could also be transformed into bb. Therefore |D||D| is always even. Let's build a graph consists of 2n−22n−2 nodes, numbered −n−n through nn (except for −1−1, 00, and 11). There is an weighted undirected edge between node uu and vv if and only if uu can be transformed into vv. The weight of the edge is the score of the transformation. Every node in the graph has an even degree so you can split the graph into some connected components so that each components is an Euler circuit (a circuit that contains all the edges). Therefore you just need to find all those Euler circuits and maximize your score. Moreover, you can see that, if an integer aa can be transformed into bb then xx and 22 are in the same component. Proof: Suppose a<ba<b, there exists an integer x=b/ax=b/a. If x=2x=2 then it is proved, otherwise there exists an integer c=2x<b≤nc=2x<b≤n. cc and 22 are in the same component so xx and 22 are also in the same component. Therefore, if we ignore all the nodes that have no edges attached to it, the graph will be connected. So you need to simply get the sum of all the weights of the edges.The complexity is O(n+nlog(n))O(n+nlog(n)) since the number of edges can go up to nlog(n)nlog(n). 1062E - CompanyLet's call inuinu the time that we reach the node uu in depth first search and outu=max(inv1,inv2,⋯,invk)outu=max(inv1,inv2,⋯,invk) where vivi is a child of uu. If node uu is in charge of node vv (uu is an ancestor of vv) then inu≤inv≤outuinu≤inv≤outu. Suppose we don't have to ignore any node then the answer to each query is the LCA of two nodes uu and vv (l≤u,v≤rl≤u,v≤r), where uu and vv are chosen so that inu=max(inl,inl+1,…,inr)inu=max(inl,inl+1,…,inr) and inv=min(inl,inl+1,…,inr)inv=min(inl,inl+1,…,inr). Proof: Let rr be the LCA of uu and vv, then inr≤inv≤inu≤outrinr≤inv≤inu≤outr. For every node w∈[l,r]w∈[l,r], inv≤inw≤inu⇒inr≤inw≤outr⇒rinv≤inw≤inu⇒inr≤inw≤outr⇒r is an ancestor of ww. Therefore, the node that needs to be ignored is either uu or vv. Suppose we ignore uu, the query splits into two halves [l,u−1]∪[u+1,r][l,u−1]∪[u+1,r]. We find the LCA to each half and get the LCA of them. We do similarly for vv and optimize the answer.Complexity: O(Nlog(N)+Qlog(N))O(Nlog(N)+Qlog(N)). 1062F - Upgrading CitiesThe main idea of this problem is to calculate inuinu and outuoutu for every node uu, where inuinu denotes the number of nodes that can reach uu and outuoutu denotes the number of nodes that can be reached by uu. If inu+outu=N+1inu+outu=N+1 then uu is important or NN if uu is semi-important.However, it may not possible to calculate inuinu and outuoutu for every node uu in given time (please tell me if it's possible) so we have to do some tricks.First of all, we need to find an arbitrary longest path (PP)=s1→s2→...→sk=s1→s2→...→sk on the graph (kk is the number of nodes on this path). If a node is important then it must lie on this path (11). Proof: Assume there is a node uu that is important and doesn't lie on (PP). Let sisi be the rightmost node on (PP) and can reach uu. It's true that i<ki<k, because if i=ki=k then we have a longer path than the one we found so it's not possible. By definition of ii, si+1si+1 cannot reach uu. Therefore uu must be able to reach si+1si+1 (because uu is important). This leads to a conflict: We have a path that is longer than the one we found: s1→s2→⋯→si→u→si+1→⋯→sks1→s2→⋯→si→u→si+1→⋯→sk. Therefore statement (11) is proved. It takes O(N+M)O(N+M) to find (PP).Let's deal with important nodes first. Because all important nodes lie on the path (PP) so it makes no sense to calculate inin and outout for those nodes that don't belong to (PP). We can calculate outout by iterate through PP from sksk to s1s1. At each node sisi, we just need to use bfs or dfs to search for the nodes that can be reached by sisi. Because we visit each node 11 time then it takes O(N+M)O(N+M) to do this. To calculate inin we just need to reverse the direction of the edges and do similarly.Now we need to find the semi nodes. There are two types of semi nodes: those belong to (PP) and those don't. For the ones belong to (PP), we just need to check if inu+outu=Ninu+outu=N. For the ones don't belong to (PP), suppose we are dealing with node uu. Let sisi be the rightmost node on (PP) that can reach uu and sjsj be the leftmost node on (PP) that can be reached by uu. It's obvious that i<j−1i<j−1. Let Lu=iLu=i and Ru=jRu=j, let lengleng equal j−i−1j−i−1. If leng>1leng>1 then u is not a semi node (because we have to delete all nodes between i and j not inclusive), or else we must erase si+1si+1 to make uu a semi important node. We can see that the path from sisi to uu contains only sisi and uu, and the path from uu to sjsj contains only uu and sjsj, because otherwise there exists a longer path than (PP), which is false. So we consider uu as a candidate. Moreover, if exists a node vv that is a candidate and Lu=LvLu=Lv (also leads to Ru=RvRu=Rv) then both uu and vv are not semi important nodes. Proof: After we delete si+1si+1, for uu, exists a path that is as long as (PP) and does not go through uu (it goes through vv) so uu is not a important node, based on statement (11). Same for vv. Briefly, at this point we have the path (PP) and a list of nodes u1,u2,...,utu1,u2,...,ut. For every ii, uiui is a candidate and Lui+1=Rui−1Lui+1=Rui−1. For every ii, jj, Lui!=LujLui!=Luj.So now we are going to calculate inin and outout for those candidate nodes. We can do this similarly as when we find the important nodes. To calculate outout, iterate through sksk to s1s1. At each node sisi, bfs or dfs to search for nodes that can be reached by sisi. Additionally, if there is a candidate node vv that Rv=i−1Rv=i−1, we start a search from vv to find those nodes that can be reached by vv, we have outv=outsi+outv=outsi+ the number of nodes we just found. After that we pop those nodes from the stack (or whatever), mark them as not visited and continue to iterate to si−1si−1. To calculate inin we reverse the directs of the edges and do the same. Because each node is visited 11 time by nodes on (PP) and at most 22 times by candidate nodes so it takes O(3(N+M))O(3(N+M)).The total complexity is O(N+M)O(N+M).Sorry if the tutorial for F is too long.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1062\\s*D"
          },
          "content_length": 7894
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #520 - Codeforces - Code 1",
          "code": "2^(num zeroes + num ones) - 2^(num zeroes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63136",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 1",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 2",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int n;\n\n    if (type == \"min\") {\n        n = 2;\n    } else if (type == \"max\") {\n        n = 100000;\n    } else if (type == \"small\") {\n        n = rnd.next(2, 10);\n    } else if (type == \"medium\") {\n        n = rnd.next(100, 1000);\n    } else if (type == \"large\") {\n        n = rnd.next(90000, 100000);\n    } else if (type == \"random\") {\n        n = rnd.next(2, 100000);\n    } else if (type == \"specific\") {\n        n = opt<int>(\"n\");\n        if (n < 2 || n > 100000) {\n            cerr << \"Error: n must be between 2 and 100000\\n\";\n            exit(1);\n        }\n    } else {\n        n = rnd.next(2, 100000);\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int n;\n\n    if (type == \"min\") {\n        n = 2;\n    } else if (type == \"max\") {\n        n = 100000;\n    } else if (type == \"small\") {\n        n = rnd.next(2, 10);\n    } else if (type == \"medium\") {\n        n = rnd.next(100, 1000);\n    } else if (type == \"large\") {\n        n = rnd.next(90000, 100000);\n    } else if (type == \"random\") {\n        n = rnd.next(2, 100000);\n    } else if (type == \"specific\") {\n        n = opt<int>(\"n\");\n        if (n < 2 || n > 100000) {\n            cerr << \"Error: n must be between 2 and 100000\\n\";\n            exit(1);\n        }\n    } else {\n        n = rnd.next(2, 100000);\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type small\n./gen -type medium\n./gen -type large\n./gen -type random\n./gen -type specific -n 2\n./gen -type specific -n 3\n./gen -type specific -n 4\n./gen -type specific -n 5\n./gen -type specific -n 6\n./gen -type specific -n 7\n./gen -type specific -n 8\n./gen -type specific -n 9\n./gen -type specific -n 10\n./gen -type specific -n 15\n./gen -type specific -n 16\n./gen -type specific -n 31\n./gen -type specific -n 32\n./gen -type specific -n 63\n./gen -type specific -n 64\n./gen -type specific -n 99\n./gen -type specific -n 100\n./gen -type specific -n 999\n./gen -type specific -n 1000\n./gen -type specific -n 9999\n./gen -type specific -n 10000\n./gen -type specific -n 99999\n./gen -type specific -n 100000\n./gen -type specific -n 1024\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type large\n./gen -type large\n./gen -type small\n./gen -type small\n./gen -type medium\n./gen -type medium\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:48.831199",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1062/E",
      "title": "E. Company",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and qq (2≤n≤1000002≤n≤100000, 1≤q≤1000001≤q≤100000) — the number of employees and the number of plans, respectively.The second line contains n−1n−1 integers p2,p3,…,pnp2,p3,…,pn (1≤pi≤n1≤pi≤n) meaning pipi is the direct boss of employee ii.It is guaranteed, that values pipi form a directed tree with the root of 11.Each of the following qq lines contains two integers lili and riri (1≤li<ri≤n1≤li<ri≤n) — the range of the employees, involved in the corresponding plan.",
      "output_spec": "OutputPrint qq lines, each containing two integers — the number of the employee which should be kicked from the corresponding plan and the maximum possible level of the project manager in that case.If there are more than one way to choose that employee, print any of them.",
      "sample_tests": "ExampleInputCopy11 51 1 3 3 3 4 2 7 7 64 64 81 119 118 11OutputCopy4 18 11 011 38 1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and qq (2≤n≤1000002≤n≤100000, 1≤q≤1000001≤q≤100000) — the number of employees and the number of plans, respectively.The second line contains n−1n−1 integers p2,p3,…,pnp2,p3,…,pn (1≤pi≤n1≤pi≤n) meaning pipi is the direct boss of employee ii.It is guaranteed, that values pipi form a directed tree with the root of 11.Each of the following qq lines contains two integers lili and riri (1≤li<ri≤n1≤li<ri≤n) — the range of the employees, involved in the corresponding plan.\n\nOutputPrint qq lines, each containing two integers — the number of the employee which should be kicked from the corresponding plan and the maximum possible level of the project manager in that case.If there are more than one way to choose that employee, print any of them.\n\nInputCopy11 51 1 3 3 3 4 2 7 7 64 64 81 119 118 11OutputCopy4 18 11 011 38 1\n\nInputCopy11 51 1 3 3 3 4 2 7 7 64 64 81 119 118 11\n\nOutputCopy4 18 11 011 38 1\n\nNoteIn the example:    In the first query, we can choose whether 44 or 55 or 66 and the project manager will be 33.In the second query, if we choose any employee other than the employee 88, the project manager will be 11. If we choose 88, the project manager will be 33. Since lv(3)=1>lv(1)=0lv(3)=1>lv(1)=0, choosing 88 is the best strategy.In the third query, no matter how we choose the employee, the project manager will always be 11.In the fourth query, if we choose 99 or 1010 then the project manager will be 33. If we choose 1111 then the project manager will be 77. Since lv(7)=3>lv(3)=1lv(7)=3>lv(3)=1, we choose 1111 as the answer.",
      "solutions": [
        {
          "title": "Codeforces Round #520 - Codeforces",
          "content": "Hi everyone. I'm glad to announce that the Codeforces Round 520 (Div. 2) will be held on Wednesday, November 14, 2018 at 23:35UTC+8.The round will be rated for Div 2 participants (whose ratings are lower than 2100). However, all the other participants can compete as well, without worrying about ratings being changed.You will be given 2 hours to solve 6 problems. It's better to read all the problems. The scoring distribution will be announced soon before the contest starts.All the problems were prepared by myself, with some help from my friend GiraffeCoder. I want to thank cdkrot for coordinating me in preparing the problems, vintage_Vlad_Makeev, isaf27, demon1999 and Arpa for testing my solutions. I also want to thank csacademy for their graph editor tool. You can check it out at this link.This is the first round I propose. I put a lot of work into it so I hope that you will enjoy it (smiley face).Wish you do your best and get a high rating!Update 1: If you want to discuss about the problems after the contest, here is the link to the CP Community on Discord. Please make sure that you don't give the solutions to other participants during the contest.Update 2: The score distribution will be the standard one: 500 1000 1500 2000 2500 3000.Update 3: Congrats to the winnerOfficial participants: Kataoka_Yuuki Dark_Warlock wcysai coriander fcwww Unofficial participants: budalnik HIR180 KrK ayaze Anadi Tutorial UPDATED",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63136",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1433
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces",
          "content": "1062A - A PrankSince 1≤ai≤1031≤ai≤103 for all ii, let set a0=0a0=0 and an+1=1001an+1=1001. For every i,ji,j such that 0≤i<j≤n+10≤i<j≤n+1, if aj−j=ai−iaj−j=ai−i then we can erase all the elements between ii and jj (not inclusive). So just check for all the valid pairs and maximize the answer. Time complexity: O(n2)O(n2). 1062B - MathBy factorizing nn we get n=p1a1p2a2…pkakn=p1a1p2a2…pkak (kk is the number of prime factors). Because we can't get rid of those prime factors then the smallest nn is p1p2…pkp1p2…pk. For each aiai, let uiui be the positive integer so that 2ui≥ai>2ui−12ui≥ai>2ui−1. Let UU be max(ui)max(ui). It's clear that we have to apply the \"sqrtsqrt\" operation at least UU times, since each time we apply it, aiai is divided by 22 for all ii. If for all ii, ai=2Uai=2U then the answer is UU, obviously. Otherwise, we need to use the operation \"mulmul\" 11 time to make all the aiai equal 2U2U and by now the answer is U+1U+1.Complexity: O(sqrt(N))O(sqrt(N)) 1062C - Banh-miFor each part that we choose, we need to calculate how many times that element is added to our score. You can see that, the first element that we choose is added 2k−12k−1 times in our score (k=r−l+1k=r−l+1), the second element is added 2k−22k−2 times and so on. Therefore, we just need to choose all the 1s1s first and then all the remaining parts. The final score is (2x−1)⋅2y(2x−1)⋅2y, where xx is the number of 1s1s and yy is the number of 0s0s. Complexity: O(n+Q)O(n+Q). 1062D - Fun with IntegersFor every integer xx (1≤x≤n)(1≤x≤n), let's call DD the set of integers that are able to be transformed into xx. As you can see, if aa could be transformed into bb then −a−a could also be transformed into bb. Therefore |D||D| is always even. Let's build a graph consists of 2n−22n−2 nodes, numbered −n−n through nn (except for −1−1, 00, and 11). There is an weighted undirected edge between node uu and vv if and only if uu can be transformed into vv. The weight of the edge is the score of the transformation. Every node in the graph has an even degree so you can split the graph into some connected components so that each components is an Euler circuit (a circuit that contains all the edges). Therefore you just need to find all those Euler circuits and maximize your score. Moreover, you can see that, if an integer aa can be transformed into bb then xx and 22 are in the same component. Proof: Suppose a<ba<b, there exists an integer x=b/ax=b/a. If x=2x=2 then it is proved, otherwise there exists an integer c=2x<b≤nc=2x<b≤n. cc and 22 are in the same component so xx and 22 are also in the same component. Therefore, if we ignore all the nodes that have no edges attached to it, the graph will be connected. So you need to simply get the sum of all the weights of the edges.The complexity is O(n+nlog(n))O(n+nlog(n)) since the number of edges can go up to nlog(n)nlog(n). 1062E - CompanyLet's call inuinu the time that we reach the node uu in depth first search and outu=max(inv1,inv2,⋯,invk)outu=max(inv1,inv2,⋯,invk) where vivi is a child of uu. If node uu is in charge of node vv (uu is an ancestor of vv) then inu≤inv≤outuinu≤inv≤outu. Suppose we don't have to ignore any node then the answer to each query is the LCA of two nodes uu and vv (l≤u,v≤rl≤u,v≤r), where uu and vv are chosen so that inu=max(inl,inl+1,…,inr)inu=max(inl,inl+1,…,inr) and inv=min(inl,inl+1,…,inr)inv=min(inl,inl+1,…,inr). Proof: Let rr be the LCA of uu and vv, then inr≤inv≤inu≤outrinr≤inv≤inu≤outr. For every node w∈[l,r]w∈[l,r], inv≤inw≤inu⇒inr≤inw≤outr⇒rinv≤inw≤inu⇒inr≤inw≤outr⇒r is an ancestor of ww. Therefore, the node that needs to be ignored is either uu or vv. Suppose we ignore uu, the query splits into two halves [l,u−1]∪[u+1,r][l,u−1]∪[u+1,r]. We find the LCA to each half and get the LCA of them. We do similarly for vv and optimize the answer.Complexity: O(Nlog(N)+Qlog(N))O(Nlog(N)+Qlog(N)). 1062F - Upgrading CitiesThe main idea of this problem is to calculate inuinu and outuoutu for every node uu, where inuinu denotes the number of nodes that can reach uu and outuoutu denotes the number of nodes that can be reached by uu. If inu+outu=N+1inu+outu=N+1 then uu is important or NN if uu is semi-important.However, it may not possible to calculate inuinu and outuoutu for every node uu in given time (please tell me if it's possible) so we have to do some tricks.First of all, we need to find an arbitrary longest path (PP)=s1→s2→...→sk=s1→s2→...→sk on the graph (kk is the number of nodes on this path). If a node is important then it must lie on this path (11). Proof: Assume there is a node uu that is important and doesn't lie on (PP). Let sisi be the rightmost node on (PP) and can reach uu. It's true that i<ki<k, because if i=ki=k then we have a longer path than the one we found so it's not possible. By definition of ii, si+1si+1 cannot reach uu. Therefore uu must be able to reach si+1si+1 (because uu is important). This leads to a conflict: We have a path that is longer than the one we found: s1→s2→⋯→si→u→si+1→⋯→sks1→s2→⋯→si→u→si+1→⋯→sk. Therefore statement (11) is proved. It takes O(N+M)O(N+M) to find (PP).Let's deal with important nodes first. Because all important nodes lie on the path (PP) so it makes no sense to calculate inin and outout for those nodes that don't belong to (PP). We can calculate outout by iterate through PP from sksk to s1s1. At each node sisi, we just need to use bfs or dfs to search for the nodes that can be reached by sisi. Because we visit each node 11 time then it takes O(N+M)O(N+M) to do this. To calculate inin we just need to reverse the direction of the edges and do similarly.Now we need to find the semi nodes. There are two types of semi nodes: those belong to (PP) and those don't. For the ones belong to (PP), we just need to check if inu+outu=Ninu+outu=N. For the ones don't belong to (PP), suppose we are dealing with node uu. Let sisi be the rightmost node on (PP) that can reach uu and sjsj be the leftmost node on (PP) that can be reached by uu. It's obvious that i<j−1i<j−1. Let Lu=iLu=i and Ru=jRu=j, let lengleng equal j−i−1j−i−1. If leng>1leng>1 then u is not a semi node (because we have to delete all nodes between i and j not inclusive), or else we must erase si+1si+1 to make uu a semi important node. We can see that the path from sisi to uu contains only sisi and uu, and the path from uu to sjsj contains only uu and sjsj, because otherwise there exists a longer path than (PP), which is false. So we consider uu as a candidate. Moreover, if exists a node vv that is a candidate and Lu=LvLu=Lv (also leads to Ru=RvRu=Rv) then both uu and vv are not semi important nodes. Proof: After we delete si+1si+1, for uu, exists a path that is as long as (PP) and does not go through uu (it goes through vv) so uu is not a important node, based on statement (11). Same for vv. Briefly, at this point we have the path (PP) and a list of nodes u1,u2,...,utu1,u2,...,ut. For every ii, uiui is a candidate and Lui+1=Rui−1Lui+1=Rui−1. For every ii, jj, Lui!=LujLui!=Luj.So now we are going to calculate inin and outout for those candidate nodes. We can do this similarly as when we find the important nodes. To calculate outout, iterate through sksk to s1s1. At each node sisi, bfs or dfs to search for nodes that can be reached by sisi. Additionally, if there is a candidate node vv that Rv=i−1Rv=i−1, we start a search from vv to find those nodes that can be reached by vv, we have outv=outsi+outv=outsi+ the number of nodes we just found. After that we pop those nodes from the stack (or whatever), mark them as not visited and continue to iterate to si−1si−1. To calculate inin we reverse the directs of the edges and do the same. Because each node is visited 11 time by nodes on (PP) and at most 22 times by candidate nodes so it takes O(3(N+M))O(3(N+M)).The total complexity is O(N+M)O(N+M).Sorry if the tutorial for F is too long.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1062\\s*E"
          },
          "content_length": 7894
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #520 - Codeforces - Code 1",
          "code": "2^(num zeroes + num ones) - 2^(num zeroes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63136",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 1",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 2",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n - 1, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1, 0); // parent[1] = 0 (root)\n    for (int i = 2; i <= n; ++i) {\n        parent[i] = p[i - 2]; // p[0] corresponds to p_2\n        ensuref(parent[i] != i, \"Employee %d cannot be their own boss\", i);\n    }\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 2; i <= n; ++i) {\n        int u = parent[i]; // boss of i\n        int v = i; // employee\n        adj[u].push_back(v);\n    }\n\n    vector<bool> visited(n + 1, false);\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            ensuref(!visited[v], \"Cycle detected at node %d\", v);\n            dfs(v);\n        }\n    };\n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not reachable from root 1\", i);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int l_i = inf.readInt(1, n - 1, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i + 1, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n - 1, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1, 0); // parent[1] = 0 (root)\n    for (int i = 2; i <= n; ++i) {\n        parent[i] = p[i - 2]; // p[0] corresponds to p_2\n        ensuref(parent[i] != i, \"Employee %d cannot be their own boss\", i);\n    }\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 2; i <= n; ++i) {\n        int u = parent[i]; // boss of i\n        int v = i; // employee\n        adj[u].push_back(v);\n    }\n\n    vector<bool> visited(n + 1, false);\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            ensuref(!visited[v], \"Cycle detected at node %d\", v);\n            dfs(v);\n        }\n    };\n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not reachable from root 1\", i);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int l_i = inf.readInt(1, n - 1, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i + 1, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n - 1, 1, n, \"p\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1, 0); // parent[1] = 0 (root)\n    for (int i = 2; i <= n; ++i) {\n        parent[i] = p[i - 2]; // p[0] corresponds to p_2\n        ensuref(parent[i] != i, \"Employee %d cannot be their own boss\", i);\n    }\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 2; i <= n; ++i) {\n        int u = parent[i]; // boss of i\n        int v = i; // employee\n        adj[u].push_back(v);\n    }\n\n    vector<bool> visited(n + 1, false);\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            ensuref(!visited[v], \"Cycle detected at node %d\", v);\n            dfs(v);\n        }\n    };\n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not reachable from root 1\", i);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int l_i = inf.readInt(1, n - 1, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i + 1, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const string WRONG_INDEX_RANGE =\n    \"The 'kicked' employee reported by the answer is not in [l_i, r_i].\";\n\n// We'll store for each query: l_i, r_i from the input file.\nvector<pair<int,int>> queries;\n\n// readAnswer() will read all q lines of answers from a given InStream.\n// For each query i, it reads two integers: kicked_i (the employee removed),\n// and level_i (the chosen manager level).\n// The function returns a vector of these levels so we can compare them\n// with the official solution's levels.\nvector<int> readAnswer(InStream &stream, int q) {\n    vector<int> levels(q);\n    for (int i = 0; i < q; i++) {\n        // read the pair: (kickedEmployee, managerLevel)\n        int kicked = stream.readInt(1, 100000, \"kickedEmployee\");\n        int managerLevel = stream.readInt(0, 100000, \"managerLevel\");\n\n        // Check that kicked is in [l_i, r_i]; if not, verdict depends on stream\n        // (WA if participant, FAIL if jury).\n        int L = queries[i].first;\n        int R = queries[i].second;\n        if (kicked < L || kicked > R) {\n            stream.quitf(_wa, WRONG_INDEX_RANGE.c_str());\n        }\n\n        levels[i] = managerLevel;\n    }\n    return levels;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n, q from the input.\n    int n = inf.readInt();\n    int q = inf.readInt();\n\n    // Read p_2..p_n from the input (not used in this sample checker,\n    // but we must consume them to move pointer in the input file).\n    for(int i = 2; i <= n; i++){\n        inf.readInt();\n    }\n\n    // Read queries.\n    queries.resize(q);\n    for(int i = 0; i < q; i++){\n        int li = inf.readInt();\n        int ri = inf.readInt();\n        queries[i] = make_pair(li, ri);\n    }\n\n    // Read the official solution from ans.\n    vector<int> officialLevels = readAnswer(ans, q);\n    // Read the participant's solution from ouf.\n    vector<int> participantLevels = readAnswer(ouf, q);\n\n    // Now compare them query by query.\n    // If participant's level < official => worse => Wrong Answer.\n    // If participant's level > official => better => the official answer wasn't truly optimal => Fail.\n    // Otherwise levels match => OK. If all match => overall OK.\n    for(int i = 0; i < q; i++) {\n        if (participantLevels[i] < officialLevels[i]) {\n            quitf(_wa,\n                  \"participant has a strictly worse manager level at query %d: official=%d, participant=%d\",\n                  i+1, officialLevels[i], participantLevels[i]);\n        } else if (participantLevels[i] > officialLevels[i]) {\n            quitf(_fail,\n                  \"participant has a strictly better manager level at query %d: official=%d, participant=%d\",\n                  i+1, officialLevels[i], participantLevels[i]);\n        }\n    }\n\n    // If we get here, for every query i, participantLevels[i] == officialLevels[i].\n    quitf(_ok, \"all manager levels match those of the official solution\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n  \nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate the tree\n    vector<int> p(n+1, 0);  // p[1] = 0 (root)\n\n    if (tree_type == \"chain\") {\n        for(int i = 2; i <= n; ++i)\n            p[i] = i - 1;\n    } else if (tree_type == \"star\") {\n        for(int i = 2; i <= n; ++i)\n            p[i] = 1;\n    } else if (tree_type == \"balanced\") {\n        // Generate a balanced binary tree\n        queue<int> q_nodes;\n        q_nodes.push(1);\n        int next_node = 2;\n        while (next_node <= n) {\n            int u = q_nodes.front();\n            q_nodes.pop();\n            int num_children = 2;\n            while (num_children-- && next_node <= n) {\n                p[next_node] = u;\n                q_nodes.push(next_node);\n                ++next_node;\n            }\n        }\n    } else {\n        // Default to random tree\n        for(int i = 2; i <= n; ++i)\n            p[i] = rnd.next(1, i - 1);\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output p_2 to p_n\n    for(int i = 2; i <= n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i != n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Generate and output q queries\n    for(int i = 0; i < q; ++i) {\n        int l = 1, r = n;\n        if (query_type == \"full_range\") {\n            l = 1;\n            r = n;\n        } else if (query_type == \"small_range\") {\n            l = rnd.next(1, n - 1);\n            r = l + 1;\n        } else if (query_type == \"edge_range\") {\n            if (rnd.next(2) == 0) {\n                l = 1;\n                r = rnd.next(2, min(n, 10));\n            } else {\n                r = n;\n                l = rnd.next(max(1, n - 9), n - 1);\n            }\n        } else {\n            // Random range\n            l = rnd.next(1, n - 1);\n            r = rnd.next(l + 1, n);\n        }\n\n        printf(\"%d %d\\n\", l, r);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n  \nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate the tree\n    vector<int> p(n+1, 0);  // p[1] = 0 (root)\n\n    if (tree_type == \"chain\") {\n        for(int i = 2; i <= n; ++i)\n            p[i] = i - 1;\n    } else if (tree_type == \"star\") {\n        for(int i = 2; i <= n; ++i)\n            p[i] = 1;\n    } else if (tree_type == \"balanced\") {\n        // Generate a balanced binary tree\n        queue<int> q_nodes;\n        q_nodes.push(1);\n        int next_node = 2;\n        while (next_node <= n) {\n            int u = q_nodes.front();\n            q_nodes.pop();\n            int num_children = 2;\n            while (num_children-- && next_node <= n) {\n                p[next_node] = u;\n                q_nodes.push(next_node);\n                ++next_node;\n            }\n        }\n    } else {\n        // Default to random tree\n        for(int i = 2; i <= n; ++i)\n            p[i] = rnd.next(1, i - 1);\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output p_2 to p_n\n    for(int i = 2; i <= n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i != n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Generate and output q queries\n    for(int i = 0; i < q; ++i) {\n        int l = 1, r = n;\n        if (query_type == \"full_range\") {\n            l = 1;\n            r = n;\n        } else if (query_type == \"small_range\") {\n            l = rnd.next(1, n - 1);\n            r = l + 1;\n        } else if (query_type == \"edge_range\") {\n            if (rnd.next(2) == 0) {\n                l = 1;\n                r = rnd.next(2, min(n, 10));\n            } else {\n                r = n;\n                l = rnd.next(max(1, n - 9), n - 1);\n            }\n        } else {\n            // Random range\n            l = rnd.next(1, n - 1);\n            r = rnd.next(l + 1, n);\n        }\n\n        printf(\"%d %d\\n\", l, r);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -q 1 -tree_type chain -query_type full_range\n./gen -n 2 -q 1 -tree_type star -query_type small_range\n./gen -n 5 -q 2 -tree_type random -query_type edge_range\n./gen -n 5 -q 3 -tree_type balanced -query_type random\n\n./gen -n 10 -q 5 -tree_type chain -query_type full_range\n./gen -n 10 -q 5 -tree_type star -query_type small_range\n./gen -n 10 -q 5 -tree_type random -query_type edge_range\n./gen -n 10 -q 5 -tree_type balanced -query_type random\n\n./gen -n 1000 -q 100 -tree_type chain -query_type full_range\n./gen -n 1000 -q 100 -tree_type star -query_type small_range\n./gen -n 1000 -q 100 -tree_type random -query_type edge_range\n./gen -n 1000 -q 100 -tree_type balanced -query_type random\n\n./gen -n 100000 -q 100000 -tree_type chain -query_type full_range\n./gen -n 100000 -q 100000 -tree_type chain -query_type small_range\n./gen -n 100000 -q 100000 -tree_type chain -query_type edge_range\n\n./gen -n 100000 -q 100000 -tree_type star -query_type full_range\n./gen -n 100000 -q 100000 -tree_type star -query_type small_range\n./gen -n 100000 -q 100000 -tree_type star -query_type edge_range\n\n./gen -n 100000 -q 100000 -tree_type random -query_type full_range\n./gen -n 100000 -q 100000 -tree_type random -query_type small_range\n./gen -n 100000 -q 100000 -tree_type random -query_type edge_range\n\n./gen -n 100000 -q 50000 -tree_type balanced -query_type full_range\n./gen -n 100000 -q 50000 -tree_type balanced -query_type small_range\n./gen -n 100000 -q 50000 -tree_type balanced -query_type edge_range\n\n./gen -n 100000 -q 1 -tree_type chain -query_type full_range\n./gen -n 100000 -q 1 -tree_type chain -query_type small_range\n./gen -n 100000 -q 1 -tree_type chain -query_type edge_range\n\n./gen -n 2 -q 1 -tree_type random -query_type full_range\n./gen -n 3 -q 2 -tree_type random -query_type small_range\n./gen -n 4 -q 2 -tree_type random -query_type edge_range\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:50.905135",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1062/F",
      "title": "F. Upgrading Cities",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers nn and mm (2≤n≤3000002≤n≤300000, 1≤m≤3000001≤m≤300000) — the number of cities and the number of one-way roads.Next mm lines describe the road system of the kingdom. Each of them contains two integers uiui and vivi (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi), denoting one-way road from uiui to vivi.It is guaranteed, that the kingdoms' roads make an acyclic graph, which doesn't contain multiple edges and self-loops.",
      "output_spec": "OutputPrint a single integer — the number of cities that the king has to upgrade.",
      "sample_tests": "ExamplesInputCopy7 71 22 33 44 72 55 46 4OutputCopy4InputCopy6 71 22 33 41 55 32 66 4OutputCopy4",
      "description": "F. Upgrading Cities\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers nn and mm (2≤n≤3000002≤n≤300000, 1≤m≤3000001≤m≤300000) — the number of cities and the number of one-way roads.Next mm lines describe the road system of the kingdom. Each of them contains two integers uiui and vivi (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi), denoting one-way road from uiui to vivi.It is guaranteed, that the kingdoms' roads make an acyclic graph, which doesn't contain multiple edges and self-loops.\n\nOutputPrint a single integer — the number of cities that the king has to upgrade.\n\nInputCopy7 71 22 33 44 72 55 46 4OutputCopy4InputCopy6 71 22 33 41 55 32 66 4OutputCopy4\n\nInputCopy7 71 22 33 44 72 55 46 4\n\nOutputCopy4\n\nInputCopy6 71 22 33 41 55 32 66 4\n\nOutputCopy4\n\nNoteIn the first example:      Starting at the city 11 we can reach all the other cities, except for the city 66. Also, from the city 66 we cannot reach the city 11. Therefore, if we destroy the city 66 then the city 11 will become important. So 11 is a semi-important city.  For city 22, the set of cities that cannot reach 22 and cannot be reached by 22 is {6}{6}. Therefore, destroying city 66 will make the city 22 important. So city 22 is also semi-important.  For city 33, the set is {5,6}{5,6}. As you can see, destroying either city 55 or 66 will not make the city 33 important. Therefore, it is neither important nor semi-important.  For city 44, the set is empty. So 44 is an important city.  The set for city 55 is {3,6}{3,6} and the set for city 66 is {3,5}{3,5}. Similarly to city 33, both of them are not important nor semi-important.  The city 77 is important since we can reach it from all other cities.  So we have two important cities (44 and 77) and two semi-important cities (11 and 22).In the second example, the important cities are 11 and 44. The semi-important cities are 22 and 33.",
      "solutions": [
        {
          "title": "Codeforces Round #520 - Codeforces",
          "content": "Hi everyone. I'm glad to announce that the Codeforces Round 520 (Div. 2) will be held on Wednesday, November 14, 2018 at 23:35UTC+8.The round will be rated for Div 2 participants (whose ratings are lower than 2100). However, all the other participants can compete as well, without worrying about ratings being changed.You will be given 2 hours to solve 6 problems. It's better to read all the problems. The scoring distribution will be announced soon before the contest starts.All the problems were prepared by myself, with some help from my friend GiraffeCoder. I want to thank cdkrot for coordinating me in preparing the problems, vintage_Vlad_Makeev, isaf27, demon1999 and Arpa for testing my solutions. I also want to thank csacademy for their graph editor tool. You can check it out at this link.This is the first round I propose. I put a lot of work into it so I hope that you will enjoy it (smiley face).Wish you do your best and get a high rating!Update 1: If you want to discuss about the problems after the contest, here is the link to the CP Community on Discord. Please make sure that you don't give the solutions to other participants during the contest.Update 2: The score distribution will be the standard one: 500 1000 1500 2000 2500 3000.Update 3: Congrats to the winnerOfficial participants: Kataoka_Yuuki Dark_Warlock wcysai coriander fcwww Unofficial participants: budalnik HIR180 KrK ayaze Anadi Tutorial UPDATED",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63136",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1433
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces",
          "content": "1062A - A PrankSince 1≤ai≤1031≤ai≤103 for all ii, let set a0=0a0=0 and an+1=1001an+1=1001. For every i,ji,j such that 0≤i<j≤n+10≤i<j≤n+1, if aj−j=ai−iaj−j=ai−i then we can erase all the elements between ii and jj (not inclusive). So just check for all the valid pairs and maximize the answer. Time complexity: O(n2)O(n2). 1062B - MathBy factorizing nn we get n=p1a1p2a2…pkakn=p1a1p2a2…pkak (kk is the number of prime factors). Because we can't get rid of those prime factors then the smallest nn is p1p2…pkp1p2…pk. For each aiai, let uiui be the positive integer so that 2ui≥ai>2ui−12ui≥ai>2ui−1. Let UU be max(ui)max(ui). It's clear that we have to apply the \"sqrtsqrt\" operation at least UU times, since each time we apply it, aiai is divided by 22 for all ii. If for all ii, ai=2Uai=2U then the answer is UU, obviously. Otherwise, we need to use the operation \"mulmul\" 11 time to make all the aiai equal 2U2U and by now the answer is U+1U+1.Complexity: O(sqrt(N))O(sqrt(N)) 1062C - Banh-miFor each part that we choose, we need to calculate how many times that element is added to our score. You can see that, the first element that we choose is added 2k−12k−1 times in our score (k=r−l+1k=r−l+1), the second element is added 2k−22k−2 times and so on. Therefore, we just need to choose all the 1s1s first and then all the remaining parts. The final score is (2x−1)⋅2y(2x−1)⋅2y, where xx is the number of 1s1s and yy is the number of 0s0s. Complexity: O(n+Q)O(n+Q). 1062D - Fun with IntegersFor every integer xx (1≤x≤n)(1≤x≤n), let's call DD the set of integers that are able to be transformed into xx. As you can see, if aa could be transformed into bb then −a−a could also be transformed into bb. Therefore |D||D| is always even. Let's build a graph consists of 2n−22n−2 nodes, numbered −n−n through nn (except for −1−1, 00, and 11). There is an weighted undirected edge between node uu and vv if and only if uu can be transformed into vv. The weight of the edge is the score of the transformation. Every node in the graph has an even degree so you can split the graph into some connected components so that each components is an Euler circuit (a circuit that contains all the edges). Therefore you just need to find all those Euler circuits and maximize your score. Moreover, you can see that, if an integer aa can be transformed into bb then xx and 22 are in the same component. Proof: Suppose a<ba<b, there exists an integer x=b/ax=b/a. If x=2x=2 then it is proved, otherwise there exists an integer c=2x<b≤nc=2x<b≤n. cc and 22 are in the same component so xx and 22 are also in the same component. Therefore, if we ignore all the nodes that have no edges attached to it, the graph will be connected. So you need to simply get the sum of all the weights of the edges.The complexity is O(n+nlog(n))O(n+nlog(n)) since the number of edges can go up to nlog(n)nlog(n). 1062E - CompanyLet's call inuinu the time that we reach the node uu in depth first search and outu=max(inv1,inv2,⋯,invk)outu=max(inv1,inv2,⋯,invk) where vivi is a child of uu. If node uu is in charge of node vv (uu is an ancestor of vv) then inu≤inv≤outuinu≤inv≤outu. Suppose we don't have to ignore any node then the answer to each query is the LCA of two nodes uu and vv (l≤u,v≤rl≤u,v≤r), where uu and vv are chosen so that inu=max(inl,inl+1,…,inr)inu=max(inl,inl+1,…,inr) and inv=min(inl,inl+1,…,inr)inv=min(inl,inl+1,…,inr). Proof: Let rr be the LCA of uu and vv, then inr≤inv≤inu≤outrinr≤inv≤inu≤outr. For every node w∈[l,r]w∈[l,r], inv≤inw≤inu⇒inr≤inw≤outr⇒rinv≤inw≤inu⇒inr≤inw≤outr⇒r is an ancestor of ww. Therefore, the node that needs to be ignored is either uu or vv. Suppose we ignore uu, the query splits into two halves [l,u−1]∪[u+1,r][l,u−1]∪[u+1,r]. We find the LCA to each half and get the LCA of them. We do similarly for vv and optimize the answer.Complexity: O(Nlog(N)+Qlog(N))O(Nlog(N)+Qlog(N)). 1062F - Upgrading CitiesThe main idea of this problem is to calculate inuinu and outuoutu for every node uu, where inuinu denotes the number of nodes that can reach uu and outuoutu denotes the number of nodes that can be reached by uu. If inu+outu=N+1inu+outu=N+1 then uu is important or NN if uu is semi-important.However, it may not possible to calculate inuinu and outuoutu for every node uu in given time (please tell me if it's possible) so we have to do some tricks.First of all, we need to find an arbitrary longest path (PP)=s1→s2→...→sk=s1→s2→...→sk on the graph (kk is the number of nodes on this path). If a node is important then it must lie on this path (11). Proof: Assume there is a node uu that is important and doesn't lie on (PP). Let sisi be the rightmost node on (PP) and can reach uu. It's true that i<ki<k, because if i=ki=k then we have a longer path than the one we found so it's not possible. By definition of ii, si+1si+1 cannot reach uu. Therefore uu must be able to reach si+1si+1 (because uu is important). This leads to a conflict: We have a path that is longer than the one we found: s1→s2→⋯→si→u→si+1→⋯→sks1→s2→⋯→si→u→si+1→⋯→sk. Therefore statement (11) is proved. It takes O(N+M)O(N+M) to find (PP).Let's deal with important nodes first. Because all important nodes lie on the path (PP) so it makes no sense to calculate inin and outout for those nodes that don't belong to (PP). We can calculate outout by iterate through PP from sksk to s1s1. At each node sisi, we just need to use bfs or dfs to search for the nodes that can be reached by sisi. Because we visit each node 11 time then it takes O(N+M)O(N+M) to do this. To calculate inin we just need to reverse the direction of the edges and do similarly.Now we need to find the semi nodes. There are two types of semi nodes: those belong to (PP) and those don't. For the ones belong to (PP), we just need to check if inu+outu=Ninu+outu=N. For the ones don't belong to (PP), suppose we are dealing with node uu. Let sisi be the rightmost node on (PP) that can reach uu and sjsj be the leftmost node on (PP) that can be reached by uu. It's obvious that i<j−1i<j−1. Let Lu=iLu=i and Ru=jRu=j, let lengleng equal j−i−1j−i−1. If leng>1leng>1 then u is not a semi node (because we have to delete all nodes between i and j not inclusive), or else we must erase si+1si+1 to make uu a semi important node. We can see that the path from sisi to uu contains only sisi and uu, and the path from uu to sjsj contains only uu and sjsj, because otherwise there exists a longer path than (PP), which is false. So we consider uu as a candidate. Moreover, if exists a node vv that is a candidate and Lu=LvLu=Lv (also leads to Ru=RvRu=Rv) then both uu and vv are not semi important nodes. Proof: After we delete si+1si+1, for uu, exists a path that is as long as (PP) and does not go through uu (it goes through vv) so uu is not a important node, based on statement (11). Same for vv. Briefly, at this point we have the path (PP) and a list of nodes u1,u2,...,utu1,u2,...,ut. For every ii, uiui is a candidate and Lui+1=Rui−1Lui+1=Rui−1. For every ii, jj, Lui!=LujLui!=Luj.So now we are going to calculate inin and outout for those candidate nodes. We can do this similarly as when we find the important nodes. To calculate outout, iterate through sksk to s1s1. At each node sisi, bfs or dfs to search for nodes that can be reached by sisi. Additionally, if there is a candidate node vv that Rv=i−1Rv=i−1, we start a search from vv to find those nodes that can be reached by vv, we have outv=outsi+outv=outsi+ the number of nodes we just found. After that we pop those nodes from the stack (or whatever), mark them as not visited and continue to iterate to si−1si−1. To calculate inin we reverse the directs of the edges and do the same. Because each node is visited 11 time by nodes on (PP) and at most 22 times by candidate nodes so it takes O(3(N+M))O(3(N+M)).The total complexity is O(N+M)O(N+M).Sorry if the tutorial for F is too long.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/63199",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1062\\s*F"
          },
          "content_length": 7894
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #520 - Codeforces - Code 1",
          "code": "2^(num zeroes + num ones) - 2^(num zeroes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63136",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 1",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #520 TUTORIAL - Codeforces - Code 2",
          "code": "ans += (cnt * (cnt + 1) / 2 - 1) * (r - l + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/63199",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    \n    vector<vector<int>> adj(n+1); // Nodes numbered from 1 to n\n    vector<int> in_degree(n+1, 0);\n    \n    set<pair<int, int>> edges_set;\n    \n    for(int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"No self-loops are allowed (u_i != v_i)\");\n        ensuref(!edges_set.count({u,v}), \"No multiple edges are allowed (edge from %d to %d appears multiple times)\", u, v);\n        edges_set.insert({u, v});\n        adj[u].push_back(v);\n        in_degree[v]++;\n    }\n    \n    inf.readEof();\n    \n    // Check for cycles using Kahn's algorithm\n    int cnt = 0;\n    queue<int> q;\n    for(int i = 1; i <= n; i++) {\n        if(in_degree[i] == 0)\n            q.push(i);\n    }\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        cnt++;\n        for(int v : adj[u]) {\n            in_degree[v]--;\n            if(in_degree[v] == 0)\n                q.push(v);\n        }\n    }\n    ensuref(cnt == n, \"Graph contains a cycle\");\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    \n    vector<vector<int>> adj(n+1); // Nodes numbered from 1 to n\n    vector<int> in_degree(n+1, 0);\n    \n    set<pair<int, int>> edges_set;\n    \n    for(int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"No self-loops are allowed (u_i != v_i)\");\n        ensuref(!edges_set.count({u,v}), \"No multiple edges are allowed (edge from %d to %d appears multiple times)\", u, v);\n        edges_set.insert({u, v});\n        adj[u].push_back(v);\n        in_degree[v]++;\n    }\n    \n    inf.readEof();\n    \n    // Check for cycles using Kahn's algorithm\n    int cnt = 0;\n    queue<int> q;\n    for(int i = 1; i <= n; i++) {\n        if(in_degree[i] == 0)\n            q.push(i);\n    }\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        cnt++;\n        for(int v : adj[u]) {\n            in_degree[v]--;\n            if(in_degree[v] == 0)\n                q.push(v);\n        }\n    }\n    ensuref(cnt == n, \"Graph contains a cycle\");\n    \n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300000, \"m\");\n    inf.readEoln();\n    \n    vector<vector<int>> adj(n+1); // Nodes numbered from 1 to n\n    vector<int> in_degree(n+1, 0);\n    \n    set<pair<int, int>> edges_set;\n    \n    for(int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"No self-loops are allowed (u_i != v_i)\");\n        ensuref(!edges_set.count({u,v}), \"No multiple edges are allowed (edge from %d to %d appears multiple times)\", u, v);\n        edges_set.insert({u, v});\n        adj[u].push_back(v);\n        in_degree[v]++;\n    }\n    \n    inf.readEof();\n    \n    // Check for cycles using Kahn's algorithm\n    int cnt = 0;\n    queue<int> q;\n    for(int i = 1; i <= n; i++) {\n        if(in_degree[i] == 0)\n            q.push(i);\n    }\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        cnt++;\n        for(int v : adj[u]) {\n            in_degree[v]--;\n            if(in_degree[v] == 0)\n                q.push(v);\n        }\n    }\n    ensuref(cnt == n, \"Graph contains a cycle\");\n    \n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m is within valid bounds\n    long long maxEdges = (long long)n * (n - 1) / 2;\n    if (m > maxEdges) {\n        m = maxEdges;\n    }\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"path\") {\n        // Generate a linear chain\n        m = n - 1;\n        for (int i = 1; i < n; i++) {\n            edges.push_back(make_pair(i, i + 1));\n        }\n    } else if (type == \"star\") {\n        // Generate a star graph with node 1 at the center\n        m = n - 1;\n        for (int i = 2; i <= n; i++) {\n            edges.push_back(make_pair(1, i));\n        }\n    } else if (type == \"lastnode\") {\n        // Generate edges from nodes to the last node\n        m = min(m, n - 1);\n        for (int i = 1; i <= m; i++) {\n            edges.push_back(make_pair(i, n));\n        }\n    } else if (type == \"random\") {\n        // Generate a random acyclic graph\n        vector<int> nodes(n);\n        for (int i = 0; i < n; i++) {\n            nodes[i] = i + 1;\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        set<pair<int, int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u_index = rnd.next(0, n - 2); // from 0 to n - 2\n            int v_index = rnd.next(u_index + 1, n - 1); // from u_index + 1 to n - 1\n            int u = nodes[u_index];\n            int v = nodes[v_index];\n\n            if (edgeSet.insert(make_pair(u, v)).second) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (type == \"layered\") {\n        // Generate a layered DAG\n        int layers = opt<int>(\"layers\", 10);\n        vector<vector<int>> layerNodes(layers);\n        int cnt = 1;\n        for (int i = 0; i < layers; i++) {\n            int numNodesInLayer = n / layers;\n            if (i < n % layers) numNodesInLayer++;\n            for (int j = 0; j < numNodesInLayer; j++, cnt++) {\n                layerNodes[i].push_back(cnt);\n            }\n        }\n\n        // Generate edges from layer i to layer i + 1\n        for (int i = 0; i < layers - 1 && (int)edges.size() < m; i++) {\n            for (int u : layerNodes[i]) {\n                for (int v : layerNodes[i + 1]) {\n                    if ((int)edges.size() >= m) break;\n                    edges.push_back(make_pair(u, v));\n                }\n                if ((int)edges.size() >= m) break;\n            }\n            if ((int)edges.size() >= m) break;\n        }\n\n        // If more edges are needed, add random edges between layers\n        while ((int)edges.size() < m) {\n            int i = rnd.next(0, layers - 2);\n            int u = rnd.any(layerNodes[i]);\n            int v = rnd.any(layerNodes[i + 1]);\n            edges.push_back(make_pair(u, v));\n        }\n    } else {\n        // Default to random\n        // Same as random type\n        vector<int> nodes(n);\n        for (int i = 0; i < n; i++) nodes[i] = i + 1;\n        shuffle(nodes.begin(), nodes.end());\n\n        set<pair<int, int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u_index = rnd.next(0, n - 2); // from 0 to n - 2\n            int v_index = rnd.next(u_index + 1, n - 1); // from u_index + 1 to n - 1\n            int u = nodes[u_index];\n            int v = nodes[v_index];\n            if (edgeSet.insert(make_pair(u, v)).second) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m is within valid bounds\n    long long maxEdges = (long long)n * (n - 1) / 2;\n    if (m > maxEdges) {\n        m = maxEdges;\n    }\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"path\") {\n        // Generate a linear chain\n        m = n - 1;\n        for (int i = 1; i < n; i++) {\n            edges.push_back(make_pair(i, i + 1));\n        }\n    } else if (type == \"star\") {\n        // Generate a star graph with node 1 at the center\n        m = n - 1;\n        for (int i = 2; i <= n; i++) {\n            edges.push_back(make_pair(1, i));\n        }\n    } else if (type == \"lastnode\") {\n        // Generate edges from nodes to the last node\n        m = min(m, n - 1);\n        for (int i = 1; i <= m; i++) {\n            edges.push_back(make_pair(i, n));\n        }\n    } else if (type == \"random\") {\n        // Generate a random acyclic graph\n        vector<int> nodes(n);\n        for (int i = 0; i < n; i++) {\n            nodes[i] = i + 1;\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        set<pair<int, int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u_index = rnd.next(0, n - 2); // from 0 to n - 2\n            int v_index = rnd.next(u_index + 1, n - 1); // from u_index + 1 to n - 1\n            int u = nodes[u_index];\n            int v = nodes[v_index];\n\n            if (edgeSet.insert(make_pair(u, v)).second) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (type == \"layered\") {\n        // Generate a layered DAG\n        int layers = opt<int>(\"layers\", 10);\n        vector<vector<int>> layerNodes(layers);\n        int cnt = 1;\n        for (int i = 0; i < layers; i++) {\n            int numNodesInLayer = n / layers;\n            if (i < n % layers) numNodesInLayer++;\n            for (int j = 0; j < numNodesInLayer; j++, cnt++) {\n                layerNodes[i].push_back(cnt);\n            }\n        }\n\n        // Generate edges from layer i to layer i + 1\n        for (int i = 0; i < layers - 1 && (int)edges.size() < m; i++) {\n            for (int u : layerNodes[i]) {\n                for (int v : layerNodes[i + 1]) {\n                    if ((int)edges.size() >= m) break;\n                    edges.push_back(make_pair(u, v));\n                }\n                if ((int)edges.size() >= m) break;\n            }\n            if ((int)edges.size() >= m) break;\n        }\n\n        // If more edges are needed, add random edges between layers\n        while ((int)edges.size() < m) {\n            int i = rnd.next(0, layers - 2);\n            int u = rnd.any(layerNodes[i]);\n            int v = rnd.any(layerNodes[i + 1]);\n            edges.push_back(make_pair(u, v));\n        }\n    } else {\n        // Default to random\n        // Same as random type\n        vector<int> nodes(n);\n        for (int i = 0; i < n; i++) nodes[i] = i + 1;\n        shuffle(nodes.begin(), nodes.end());\n\n        set<pair<int, int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u_index = rnd.next(0, n - 2); // from 0 to n - 2\n            int v_index = rnd.next(u_index + 1, n - 1); // from u_index + 1 to n - 1\n            int u = nodes[u_index];\n            int v = nodes[v_index];\n            if (edgeSet.insert(make_pair(u, v)).second) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small chain graph\n./gen -n 2 -type path\n\n# Small star graph\n./gen -n 2 -type star\n\n# Small random DAG\n./gen -n 10 -m 9 -type random\n\n# Small lastnode graph\n./gen -n 10 -m 9 -type lastnode\n\n# Medium chain graph\n./gen -n 1000 -type path\n\n# Medium star graph\n./gen -n 1000 -type star\n\n# Medium random DAG with specified edges\n./gen -n 1000 -m 5000 -type random\n\n# Medium layered DAG\n./gen -n 1000 -type layered -layers 10\n\n# Maximum size chain graph\n./gen -n 300000 -m 300000 -type path\n\n# Maximum size star graph\n./gen -n 300000 -m 300000 -type star\n\n# Maximum size random DAG\n./gen -n 300000 -m 300000 -type random\n\n# Maximum size lastnode graph\n./gen -n 300000 -m 300000 -type lastnode\n\n# Maximum size layered DAG with 100 layers\n./gen -n 300000 -m 300000 -type layered -layers 100\n\n# Minimum number of edges in a path graph\n./gen -n 300000 -m 1 -type path\n\n# Minimum number of edges in a lastnode graph\n./gen -n 300000 -m 1 -type lastnode\n\n# Medium scale random DAG\n./gen -n 100000 -m 100000 -type random\n\n# Medium scale layered DAG with 50 layers\n./gen -n 100000 -m 100000 -type layered -layers 50\n\n# Edge case with maximum nodes and m = n - 1 edges (path graph)\n./gen -n 300000 -m 299999 -type path\n\n# Edge case with maximum nodes and m = n - 1 edges (star graph)\n./gen -n 300000 -m 299999 -type star\n\n# Random DAG with zero edges\n./gen -n 300000 -m 0 -type random\n\n# Smallest possible random DAG\n./gen -n 2 -m 1 -type random\n\n# Smallest possible path graph\n./gen -n 2 -m 1 -type path\n\n# Single-edge random DAG with maximum nodes\n./gen -n 300000 -m 1 -type random\n\n# Random DAG with maximum allowed edges\n./gen -n 300000 -m 300000 -type random\n\n# Random DAG with small number of edges\n./gen -n 300000 -m 10 -type random\n\n# Random DAG with medium number of edges\n./gen -n 300000 -m 50000 -type random\n\n# Random DAG with large number of edges\n./gen -n 300000 -m 200000 -type random\n\n# Layered DAG with default layers\n./gen -n 50000 -m 100000 -type layered\n\n# Random DAG with nodes but no edges\n./gen -n 300000 -m 0 -type random\n\n# Chain graph with maximum nodes and minimum edges\n./gen -n 300000 -m 1 -type path\n\n# Lastnode graph with maximum nodes and edges\n./gen -n 300000 -m 300000 -type lastnode\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:52.944750",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1063/A",
      "title": "A. Oh Those Palindromes",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer nn (1≤n≤1000001≤n≤100000) — the length of string ss.The second line contains string ss that consists of exactly nn lowercase characters of Latin alphabet.",
      "output_spec": "OutputPrint string tt, which consists of the same set of characters (and each characters appears exactly the same number of times) as string ss. Moreover, tt should have the maximum possible value of palindromic count among all such strings strings.If there are multiple such strings, print any of them.",
      "sample_tests": "ExamplesInputCopy5oololOutputCopyololoInputCopy16gagadbcgghhchbdfOutputCopyabccbaghghghgdfd",
      "description": "A. Oh Those Palindromes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains an integer nn (1≤n≤1000001≤n≤100000) — the length of string ss.The second line contains string ss that consists of exactly nn lowercase characters of Latin alphabet.\n\nOutputPrint string tt, which consists of the same set of characters (and each characters appears exactly the same number of times) as string ss. Moreover, tt should have the maximum possible value of palindromic count among all such strings strings.If there are multiple such strings, print any of them.\n\nInputCopy5oololOutputCopyololoInputCopy16gagadbcgghhchbdfOutputCopyabccbaghghghgdfd\n\nInputCopy5oolol\n\nOutputCopyololo\n\nInputCopy16gagadbcgghhchbdf\n\nOutputCopyabccbaghghghgdfd\n\nNoteIn the first example, string \"ololo\" has 99 palindromic substrings: \"o\", \"l\", \"o\", \"l\", \"o\", \"olo\", \"lol\", \"olo\", \"ololo\". Note, that even though some substrings coincide, they are counted as many times as they appear in the resulting string.In the second example, the palindromic count of string \"abccbaghghghgdfd\" is 2929.",
      "solutions": [
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces",
          "content": "Hi everybody,This Sunday there will be a 16th Moscow Team Olympiad, high school students competition based in Moscow that is an elimination contest for All-Russian Team Olympiad. This contest is prepared by Moscow Olympiad Scientific Committee that you may know by Moscow Open Olympiad, Moscow Olympiad for Young Students and Metropolises Olympiad (rounds 327, 342, 345, 376, 401, 433, 441, 466, 469, 507).Round will be held at 10:05 UTC on Sunday and will last for 2 hours. Each division will have 6 problems.Problems are prepared vintage_Vlad_Makeev, Glebodin, Andreikkaa, qoo2p5, mingaleg, Flyrise, cdkrot, achulkov2, grphil, Sehnsucht, Aphanasiy, Sender, DebNatkh, GreenGrape under my supervision with great help of GlebsHP, meshanya, Endagorion, Zlobober and Helen Andreeva.Thanks to cdkrot for the round coordination and statement translation, and also thanks for MikeMirzayanov for systems codeforces and polygon, which was used to prepare problems of this olympiad.Good luck everybody!UPD1: The scoring distribution will be:500 — 1000 — 1000 — 1500 — 2000 — 2500 for div. 1.500 — 1000 — 1500 — 2000 — 2000 — 2500 for div. 2.UPD2: EditorialUPD3: Winners:Div. 1: mnbvmar bmerry jcvb TLEwpdus WA_TLE Div. 2: Ebola_Emperor Orange_User orbitingfIea little_waxberry fnch",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1272
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces",
          "content": "Credits:Div2A (Make a Trianle): Idea by Zlobober, development by vintage_Vlad_MakeevDiv2B (Equations of Mathematical Magic): Idea and development: GlebodinDiv1A (Oh Those Palindromes): Idea by Endagorion, development by AndreikkaaDiv1B (Labyrinth): Idea and development by qoo2p5Div1C (Dwarves, Hats and Extrasensory Abilities): Idea and development by mingaleg Div1D (Candies for Children): Idea by Endagorion, development by FlyriseDiv1E (Lasers and Mirrors): Idea and development by mingalegDiv1F (String Journey): Original idea by GreenGrape, solution by vintage_Vlad_Makeev, development vintage_Vlad_Makeev and GreenGrape 1064A - Make a triangle!Suppose cc is the largest stick. It is known, that we can build a triangle iff c≤a+b−1c≤a+b−1.So if we can build a triangle the answer is zero. Otherwise we can just increase aa or bb until the inequality above holds.So the answer is max(0,c−(a+b−1))max(0,c−(a+b−1)).Another approach: just bruteforce all possible triangles we can extend to (with sides ≤100≤100) and select the one with smallest a+b+ca+b+c. 1064B - Equations of Mathematical MagicRewriting equation we have a⊕x=a−xa⊕x=a−x.If you look in the xor definition, it is easy to see, that a⊕x≥a−xa⊕x≥a−x, no matter aa and xx (just look at the each bit of the a⊕xa⊕x).And the equality handles only if bits of xx form a subset of bits of aa.So the answer is 2t2t, where tt is the number of bits in aa (also known as popcount). 1063A - Oh Those PalindromesOne possible solution is just to sort the string.Why so?Note that each palindrome have equal character at their ends. Suppose this character is cc with xx number of occurences. Then there are at most x(x+1)/2x(x+1)/2 palindromes with this character.So we have a clear upper bound on answer. It is easy to see, that the sorted string fulfills that bound and hence it is the optimal answer. 1063B - LabyrinthSuppose we started in cell (i0, j0) and examining whether we can reach cell (i1, j1).Let's denote the number of taken moves to the right as R and number of moves to the left as LClearly, j0 + R - L = j1That is, R - L = j1 - j0 = const. Or, put otherwise R = L + const, where const only depends on the starting cell and the target cell.So in fact we just need to minimize any of the left or right moves — the other one will be optimal as well.To calculate the minimum possible number of L-moves to reach some cell we can use 0-1 bfs.Solution is O(nm). 1063C - Dwarves, Hats and Extrasensory AbilitiesThe solution is just.. binary search!We will use just a single line to put our points on. Let's maintain an invariant that all white colored points are on the left and all black colored on the right.Put a new point in the middle of the gap between white points and black points.Depending on the color said by jury shrink the gap to the left or to the right.In the end draw a diagonal line between white points and black points.The initializing binary search may look complicated but it isn't.Put a first point on the leftmost (x = 0) position, suppose that this point is white (if it is black just revert all colors), and then play as if there is a white point in x = 0 and black point in x = 109. 1063D - Candies for ChildrenSolution works in min(n2,k/n)min(n2,k/n) time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.This adds few more cases but the idea stays the same. Basically in the formulas below just few −1−1 will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.So how to solve problem in n2n2?Note, that basically we have two parts of the circle — the part between [l;r][l;r] which get's candies one times more than the rest and the other one.Since we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as xx and yy.To solve in n2n2 let's bruteforce the number of sweet tooth on first part (aa) and the number of sweet tooth on the second part (bb).Suppose that there were full tt loops. This way the number of eaten candies is a∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗ta∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗t.This should be equal to kk. Since we just bruteforced the values of aa and bb we now just have linear equation. If it is solvable, consider relaxing answer with a+ba+b.How to solve problem in k/nk/n?So as the asymptotic suggests the amount of turns ≤k/n≤k/n, so we can bruteforce it instead.Also it is worthy to handle case of 00 turns specifically here since it produces some unpleasant effects otherwise.So each person in \"xx\" part of the circle eats candies t+1t+1 times (so each person contributes t+1t+1 or 2t+22t+2) and the other persons have eaten candies tt times (so each person contributes tt or 2t2t).Let's account all persons as if they are not sweet tooths.So now each person in xx contributes 00 or t+1t+1 and each person in yy contributes 00 or tt.So we basically have (t+1)a+tb=γ(t+1)a+tb=γ. A Diophantine equation.Careful analysis or bits of theory suggest that the solutions area=a0−tza=a0−tz, b=b0+(t+1)zb=b0+(t+1)z, for all integer zz.Where a0a0 and b0b0 some arbitrary solutions which we can get with formulas.Also we need to have 0≤a≤x0≤a≤x, 0≤b≤y0≤b≤y, and the a+b→maxa+b→max.These bounds imply that tt takes values only in some range [t1;t2][t1;t2].Since the a+ba+b is linear function we can only consider t1t1 and t2t2 while searching for maximum a+ba+b. 1063E - Lasers and MirrorsThe answer is always nn (if the permutation is identity) lasers or n−1n−1 (otherwise).Clearly, we can't have more than n−1n−1 matching lasers if the permutation is not identity. Consider just the very first line with mirrors. If the first mirror in this line is «\\» then we miss the laser below this mirror, if the very last mirror is «/» we miss the laser below it. Otherwise there are neighbouring «/» and «\\» and we lost two lasers now.The proof of n−1n−1 is constructive one.Ignore all fixed points in permutation (all xx, that px=xpx=x).Select arbitrary cycle and select one point in it as «dead». We can spend |cycle|−1|cycle|−1 operations to fix all points in this cycle.But we also need to fix all other cycles. We can do it in |cycle|+1|cycle|+1 operations: move arbitrary beam to the wasted laser, fix all other points and move that point back.But this is a bit too much lines.The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line, if we select as the trash beam the rightmost point.See the following picture for an example (trash beam is the rightmost column): 1063F - String JourneyThis problem required quite a lot of nice observations!Observation 1. We can only consider journeys in which neighboring strings differ exactly by removing one symbol.All other journeys can be modified a bit to match the criterion above.Observation 2. If it is possible to start a journey at the symbol i with lengths of strings k, k - 1, ..., 1, it is always possible to start a journey at the same symbol i with lengths t, t - 1, ..., 1, given that t ≤ k.This suggests doing dynamic programming: dp[i] is the maximum possible k such that there is a journey starting at position i of k strings with lengths k, ..., 1.Due to observation 1 we only care about maximum – if we know maximum, we also known that all lesser values are also OK.So let's calculate this dynamic programming from right to left.How to check whether dp[i] ≥ k (given that tool, we can just use binary search for example)?There must be such j, that j ≥ i + k, dp[j] ≥ k - 1 and string sj, ..., sj + k - 2 must be a substring of string sisi + 1... si + k - 1 (basically just two cases \"left substring\" or \"right substring\").This almost gives us a solution, but we need few more observations to have , and not .Observation 3. If dp[i] = k, then dp[i + 1] ≥ k - 1.We can use this to kick binary search from the solution — when you calculate dp[i] you can start trying with dp[i + 1] + 1, descending until the success.Since there are exactly n grows, there will be at most n descendings and the total number of checks is linear. ?Observation? 4. We need to check whether such j exists in a fast way.Recall there are few conditions for us to follow, dp[j] ≥ const, j ≥ const and some string equality.If you carefully look at the restriction j ≥ const you can see, that when we move our dp calculation i → i - 1 or make dp[i] -= 1 this lower bound on j also moves only left, like in two pointers. So each moment some indexes j are \"available\" and some are not, and the border moves only left.Finally, time for some structures. Build Suffix Array and build segment tree over it. Let's store in the leaf of the segment tree dp[j] if it's already available or  - 1 otherwise.Let's check whether dp[i] = k is good. We want for string starting at j be either si, si + 1, ..., si + k - 2, or si + 1, si + 2, ..., si + k - 1. Consider these cases independently (however the procedure is pretty much same).All such strings form a segment of Suffix Array, we can for example use LCP + binary search over sparse tables to find corresponding bounds.Then we just need to query this segment and check if the maximum on it is at least k - 1.The solution is",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62455",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1063\\s*A"
          },
          "content_length": 9243
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 1",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 2",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 3",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 4",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 5",
          "code": "sort(s.begin(), s.end()); cout<<s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 6",
          "code": "'a - 3 times, aa - 2 times aaa - 1 time, total - 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 7",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 8",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 11",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 12",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 13",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 14",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 15",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 16",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 1",
          "code": "you have to call dfs with cell C again; \n   why?\n  because, now C has lesser leftCount or rightCount than before....so it may \n           able to visit more cells than before",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 2",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 3",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n\n    ensuref(int(s.size()) == n, \"The length of string s (%d) does not equal n (%d)\", int(s.length()), n);\n\n    for (int i = 0; i < int(s.size()); ++i) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \"Character at position %d is not a lowercase letter: '%c'\", i+1, s[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n\n    ensuref(int(s.size()) == n, \"The length of string s (%d) does not equal n (%d)\", int(s.length()), n);\n\n    for (int i = 0; i < int(s.size()); ++i) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \"Character at position %d is not a lowercase letter: '%c'\", i+1, s[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n\n    ensuref(int(s.size()) == n, \"The length of string s (%d) does not equal n (%d)\", int(s.length()), n);\n\n    for (int i = 0; i < int(s.size()); ++i) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \"Character at position %d is not a lowercase letter: '%c'\", i+1, s[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\nint n;\n\nlong long countPalindromicSubstrings(const string &s) {\n    int n = s.size();\n    vector<int> d1(n);  // Odd-length palindromes\n    int l = 0, r = -1;\n    long long count = 0;\n    for (int i = 0; i < n; ++i) {\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);  // Current palindrome radius\n        while (i - k >= 0 && i + k < n && s[i - k] == s[i + k])\n            ++k;\n        d1[i] = k--;\n        count += d1[i];\n        if (i + k > r) {\n            l = i - k;\n            r = i + k;\n        }\n    }\n\n    vector<int> d2(n);  // Even-length palindromes\n    l = 0; r = -1;\n    for (int i = 0; i < n; ++i) {\n        int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);\n        while (i - k - 1 >= 0 && i + k < n && s[i - k -1] == s[i + k])\n            ++k;\n        d2[i] = k--;\n        count += d2[i];\n        if (i + k > r) {\n            l = i - k -1;\n            r = i + k;\n        }\n    }\n    return count;\n}\n\nlong long readAns(InStream &stream) {\n    string t = stream.readWord();\n    if (t.size() != n)\n        stream.quitf(_wa, \"Output string length is %d, expected %d\", t.size(), n);\n\n    // Check that t is a permutation of s\n    vector<int> cnt_s(26, 0);\n    vector<int> cnt_t(26, 0);\n    for (char c : s) {\n        if (c < 'a' || c > 'z')\n            quitf(_fail, \"Input string contains invalid character '%c'\", c);\n        cnt_s[c - 'a']++;\n    }\n    for (char c : t) {\n        if (c < 'a' || c > 'z') {\n            stream.quitf(_wa, \"Output string contains invalid character '%c'\", c);\n        }\n        cnt_t[c - 'a']++;\n    }\n\n    if (cnt_s != cnt_t) {\n        stream.quitf(_wa, \"Output string is not a permutation of input\");\n    }\n\n    // Compute palindromic count\n    long long pal_count = countPalindromicSubstrings(t);\n    return pal_count;\n}\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();  // Read n\n    s = inf.readWord();\n    if (s.size() != n)\n        quitf(_fail, \"Input string length is %d, expected %d\", s.size(), n);\n\n    // Read and process jury's answer\n    long long juryAns = readAns(ans);\n\n    // Read and process participant's answer\n    long long participantAns = readAns(ouf);\n\n    if (participantAns < juryAns) {\n        quitf(_wa, \"Participant's palindromic count is less than jury's: participant = %lld, jury = %lld\", participantAns, juryAns);\n    } else if (participantAns == juryAns) {\n        quitf(_ok, \"Palindromic count = %lld\", participantAns);\n    } else {  // participantAns > juryAns\n        quitf(_fail, \"Participant's palindromic count is greater than jury's: participant = %lld, jury = %lld\", participantAns, juryAns);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of length n\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome of length n\n        string half = \"\";\n        int half_len = n / 2;\n        for (int i = 0; i < half_len; ++i) {\n            char c = 'a' + rnd.next(26);\n            half += c;\n        }\n        string rev_half = half;\n        reverse(rev_half.begin(), rev_half.end());\n\n        if (n % 2 == 0) {\n            s = half + rev_half;\n        } else {\n            char middle = 'a' + rnd.next(26);\n            s = half + middle + rev_half;\n        }\n    } else if (type == \"single_char\") {\n        // All characters are the same\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"two_chars\") {\n        // Two different characters\n        char c1 = 'a' + rnd.next(26);\n        char c2;\n        do {\n            c2 = 'a' + rnd.next(26);\n        } while (c2 == c1);\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(2) ? c1 : c2;\n        }\n    } else if (type == \"worst_case\") {\n        // Generate a string that maximizes palindromic substrings\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + (i % 3);\n            s += c;\n        }\n    } else if (type == \"max_unique\") {\n        // All characters are unique if possible\n        s = \"\";\n        int repeats = (n + 25) / 26;\n        vector<char> letters;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            letters.push_back(c);\n        }\n        for (int i = 0; i < repeats; ++i) {\n            shuffle(letters.begin(), letters.end());\n            for (char c : letters) {\n                s += c;\n                if (s.size() == n) break;\n            }\n            if (s.size() == n) break;\n        }\n    } else if (type == \"special\") {\n        // Specially designed string\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + (i % 26);\n            s += c;\n        }\n    } else {\n        // Default to random string\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of length n\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome of length n\n        string half = \"\";\n        int half_len = n / 2;\n        for (int i = 0; i < half_len; ++i) {\n            char c = 'a' + rnd.next(26);\n            half += c;\n        }\n        string rev_half = half;\n        reverse(rev_half.begin(), rev_half.end());\n\n        if (n % 2 == 0) {\n            s = half + rev_half;\n        } else {\n            char middle = 'a' + rnd.next(26);\n            s = half + middle + rev_half;\n        }\n    } else if (type == \"single_char\") {\n        // All characters are the same\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"two_chars\") {\n        // Two different characters\n        char c1 = 'a' + rnd.next(26);\n        char c2;\n        do {\n            c2 = 'a' + rnd.next(26);\n        } while (c2 == c1);\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(2) ? c1 : c2;\n        }\n    } else if (type == \"worst_case\") {\n        // Generate a string that maximizes palindromic substrings\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + (i % 3);\n            s += c;\n        }\n    } else if (type == \"max_unique\") {\n        // All characters are unique if possible\n        s = \"\";\n        int repeats = (n + 25) / 26;\n        vector<char> letters;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            letters.push_back(c);\n        }\n        for (int i = 0; i < repeats; ++i) {\n            shuffle(letters.begin(), letters.end());\n            for (char c : letters) {\n                s += c;\n                if (s.size() == n) break;\n            }\n            if (s.size() == n) break;\n        }\n    } else if (type == \"special\") {\n        // Specially designed string\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + (i % 26);\n            s += c;\n        }\n    } else {\n        // Default to random string\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type palindrome\n./gen -n 10 -type single_char\n./gen -n 15 -type two_chars\n./gen -n 20 -type worst_case\n\n# Intermediate n\n./gen -n 50 -type random\n./gen -n 50 -type palindrome\n./gen -n 50 -type single_char\n./gen -n 50 -type max_unique\n./gen -n 50 -type special\n\n./gen -n 100 -type random\n./gen -n 100 -type palindrome\n./gen -n 100 -type single_char\n./gen -n 100 -type two_chars\n\n# Larger n\n./gen -n 1000 -type random\n./gen -n 1000 -type palindrome\n./gen -n 1000 -type single_char\n./gen -n 1000 -type two_chars\n./gen -n 1000 -type worst_case\n\n# Max n\n./gen -n 99999 -type max_unique\n./gen -n 100000 -type random\n./gen -n 100000 -type palindrome\n./gen -n 100000 -type single_char\n./gen -n 100000 -type two_chars\n./gen -n 100000 -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:55.290574",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1063/B",
      "title": "B. Лабиринт",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа n, m (1 ≤ n, m ≤ 2000) — количество строк и столбцов в лабиринте, соответственно.Вторая строка содержит два целых числа r, c (1 ≤ r ≤ n, 1 ≤ c ≤ m) — номер строки и столбца, на пересечении которых расположена стартовая клетка.Третья строка содержит два целых числа x, y (0 ≤ x, y ≤ 109) — максимальное количество перемещений влево и вправо, соответственно.Следующие n строк содержат описание лабиринта. Каждая из этих строк имеет длину m и состоит только из символов '.' и '*'. В i-й строке j-й символ соответствует клетке лабиринта с номерами строки и столбца i и j, соответственно. Символ '.' соответствует свободной клетке лабиринта, а символ '*' — клетке с препятствием.Гарантируется, что стартовая клетка не занята препятствием.",
      "output_spec": "Выходные данныеВыведите одно число — количество клеток лабиринта, достижимых из стартовой, включая её саму.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 53 21 2......***....***....Выходные данныеСкопировать10Входные данныеСкопировать4 42 20 1......*.........Выходные данныеСкопировать7",
      "description": "B. Лабиринт\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит два целых числа n, m (1 ≤ n, m ≤ 2000) — количество строк и столбцов в лабиринте, соответственно.Вторая строка содержит два целых числа r, c (1 ≤ r ≤ n, 1 ≤ c ≤ m) — номер строки и столбца, на пересечении которых расположена стартовая клетка.Третья строка содержит два целых числа x, y (0 ≤ x, y ≤ 109) — максимальное количество перемещений влево и вправо, соответственно.Следующие n строк содержат описание лабиринта. Каждая из этих строк имеет длину m и состоит только из символов '.' и '*'. В i-й строке j-й символ соответствует клетке лабиринта с номерами строки и столбца i и j, соответственно. Символ '.' соответствует свободной клетке лабиринта, а символ '*' — клетке с препятствием.Гарантируется, что стартовая клетка не занята препятствием.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество клеток лабиринта, достижимых из стартовой, включая её саму.\n\nВыходные данные\n\nВходные данныеСкопировать4 53 21 2......***....***....Выходные данныеСкопировать10Входные данныеСкопировать4 42 20 1......*.........Выходные данныеСкопировать7\n\nВходные данныеСкопировать4 53 21 2......***....***....\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 42 20 1......*.........\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеКлетки, достижимые в соответствующем примере, отмечены '+'.Первый пример  +++..+***.+++***+++. Второй пример  .++..+*..++..++.",
      "solutions": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces",
          "content": "Всем привет!В воскресенье в Москве пройдет шестнадцатая Московская командная олимпиада — командное соревнование для школьников, проходящее в Москве как отборочное соревнование на ВКОШП. Над туром работала Московская методическая комиссия, известная вам также по Открытой олимпиаде школьников по программированию, Московской олимпиаде для 6-9 классов и олимпиаде Мегаполисов (раунды 327, 342, 345, 376, 401, 433, 441, 466, 469, 507).Раунд состоится в 13:05 14 числа и продлится 2 часа. В каждом дивизионе будет предложено по 6 задач.Задачи соревнования подготовлены vintage_Vlad_Makeev, Glebodin, Andreikkaa, qoo2p5, mingaleg, Flyrise, cdkrot, achulkov2, grphil, Sehnsucht, Aphanasiy, Sender, DebNatkh, GreenGrape под моим руководством, а также GlebsHP, meshanya, Endagorion, Zlobober и Андреевой Е. В.За координацию раунда и перевод условий спасибо cdkrot, а так же MikeMirzayanov за системы codeforces и polygon, который использовался при подготовке задач этой олимпиады.Всем удачи!UPD1: Разбалловка:500 — 1000 — 1000 — 1500 — 2000 — 2500 для div. 1.500 — 1000 — 1500 — 2000 — 2000 — 2500 для div. 2.UPD2: РазборUPD3: Победители:Div. 1: mnbvmar bmerry jcvb TLEwpdus WA_TLE Div. 2: Ebola_Emperor Orange_User orbitingfIea little_waxberry fnch",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1241
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces",
          "content": "Credits:Div2A (Make a Trianle): Idea by Zlobober, development by vintage_Vlad_MakeevDiv2B (Equations of Mathematical Magic): Idea and development: GlebodinDiv1A (Oh Those Palindromes): Idea by Endagorion, development by AndreikkaaDiv1B (Labyrinth): Idea and development by qoo2p5Div1C (Dwarves, Hats and Extrasensory Abilities): Idea and development by mingaleg Div1D (Candies for Children): Idea by Endagorion, development by FlyriseDiv1E (Lasers and Mirrors): Idea and development by mingalegDiv1F (String Journey): Original idea by GreenGrape, solution by vintage_Vlad_Makeev, development vintage_Vlad_Makeev and GreenGrape 1064A - Make a triangle!Suppose cc is the largest stick. It is known, that we can build a triangle iff c≤a+b−1c≤a+b−1.So if we can build a triangle the answer is zero. Otherwise we can just increase aa or bb until the inequality above holds.So the answer is max(0,c−(a+b−1))max(0,c−(a+b−1)).Another approach: just bruteforce all possible triangles we can extend to (with sides ≤100≤100) and select the one with smallest a+b+ca+b+c. 1064B - Equations of Mathematical MagicRewriting equation we have a⊕x=a−xa⊕x=a−x.If you look in the xor definition, it is easy to see, that a⊕x≥a−xa⊕x≥a−x, no matter aa and xx (just look at the each bit of the a⊕xa⊕x).And the equality handles only if bits of xx form a subset of bits of aa.So the answer is 2t2t, where tt is the number of bits in aa (also known as popcount). 1063A - Oh Those PalindromesOne possible solution is just to sort the string.Why so?Note that each palindrome have equal character at their ends. Suppose this character is cc with xx number of occurences. Then there are at most x(x+1)/2x(x+1)/2 palindromes with this character.So we have a clear upper bound on answer. It is easy to see, that the sorted string fulfills that bound and hence it is the optimal answer. 1063B - LabyrinthSuppose we started in cell (i0, j0) and examining whether we can reach cell (i1, j1).Let's denote the number of taken moves to the right as R and number of moves to the left as LClearly, j0 + R - L = j1That is, R - L = j1 - j0 = const. Or, put otherwise R = L + const, where const only depends on the starting cell and the target cell.So in fact we just need to minimize any of the left or right moves — the other one will be optimal as well.To calculate the minimum possible number of L-moves to reach some cell we can use 0-1 bfs.Solution is O(nm). 1063C - Dwarves, Hats and Extrasensory AbilitiesThe solution is just.. binary search!We will use just a single line to put our points on. Let's maintain an invariant that all white colored points are on the left and all black colored on the right.Put a new point in the middle of the gap between white points and black points.Depending on the color said by jury shrink the gap to the left or to the right.In the end draw a diagonal line between white points and black points.The initializing binary search may look complicated but it isn't.Put a first point on the leftmost (x = 0) position, suppose that this point is white (if it is black just revert all colors), and then play as if there is a white point in x = 0 and black point in x = 109. 1063D - Candies for ChildrenSolution works in min(n2,k/n)min(n2,k/n) time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.This adds few more cases but the idea stays the same. Basically in the formulas below just few −1−1 will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.So how to solve problem in n2n2?Note, that basically we have two parts of the circle — the part between [l;r][l;r] which get's candies one times more than the rest and the other one.Since we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as xx and yy.To solve in n2n2 let's bruteforce the number of sweet tooth on first part (aa) and the number of sweet tooth on the second part (bb).Suppose that there were full tt loops. This way the number of eaten candies is a∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗ta∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗t.This should be equal to kk. Since we just bruteforced the values of aa and bb we now just have linear equation. If it is solvable, consider relaxing answer with a+ba+b.How to solve problem in k/nk/n?So as the asymptotic suggests the amount of turns ≤k/n≤k/n, so we can bruteforce it instead.Also it is worthy to handle case of 00 turns specifically here since it produces some unpleasant effects otherwise.So each person in \"xx\" part of the circle eats candies t+1t+1 times (so each person contributes t+1t+1 or 2t+22t+2) and the other persons have eaten candies tt times (so each person contributes tt or 2t2t).Let's account all persons as if they are not sweet tooths.So now each person in xx contributes 00 or t+1t+1 and each person in yy contributes 00 or tt.So we basically have (t+1)a+tb=γ(t+1)a+tb=γ. A Diophantine equation.Careful analysis or bits of theory suggest that the solutions area=a0−tza=a0−tz, b=b0+(t+1)zb=b0+(t+1)z, for all integer zz.Where a0a0 and b0b0 some arbitrary solutions which we can get with formulas.Also we need to have 0≤a≤x0≤a≤x, 0≤b≤y0≤b≤y, and the a+b→maxa+b→max.These bounds imply that tt takes values only in some range [t1;t2][t1;t2].Since the a+ba+b is linear function we can only consider t1t1 and t2t2 while searching for maximum a+ba+b. 1063E - Lasers and MirrorsThe answer is always nn (if the permutation is identity) lasers or n−1n−1 (otherwise).Clearly, we can't have more than n−1n−1 matching lasers if the permutation is not identity. Consider just the very first line with mirrors. If the first mirror in this line is «\\» then we miss the laser below this mirror, if the very last mirror is «/» we miss the laser below it. Otherwise there are neighbouring «/» and «\\» and we lost two lasers now.The proof of n−1n−1 is constructive one.Ignore all fixed points in permutation (all xx, that px=xpx=x).Select arbitrary cycle and select one point in it as «dead». We can spend |cycle|−1|cycle|−1 operations to fix all points in this cycle.But we also need to fix all other cycles. We can do it in |cycle|+1|cycle|+1 operations: move arbitrary beam to the wasted laser, fix all other points and move that point back.But this is a bit too much lines.The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line, if we select as the trash beam the rightmost point.See the following picture for an example (trash beam is the rightmost column): 1063F - String JourneyThis problem required quite a lot of nice observations!Observation 1. We can only consider journeys in which neighboring strings differ exactly by removing one symbol.All other journeys can be modified a bit to match the criterion above.Observation 2. If it is possible to start a journey at the symbol i with lengths of strings k, k - 1, ..., 1, it is always possible to start a journey at the same symbol i with lengths t, t - 1, ..., 1, given that t ≤ k.This suggests doing dynamic programming: dp[i] is the maximum possible k such that there is a journey starting at position i of k strings with lengths k, ..., 1.Due to observation 1 we only care about maximum – if we know maximum, we also known that all lesser values are also OK.So let's calculate this dynamic programming from right to left.How to check whether dp[i] ≥ k (given that tool, we can just use binary search for example)?There must be such j, that j ≥ i + k, dp[j] ≥ k - 1 and string sj, ..., sj + k - 2 must be a substring of string sisi + 1... si + k - 1 (basically just two cases \"left substring\" or \"right substring\").This almost gives us a solution, but we need few more observations to have , and not .Observation 3. If dp[i] = k, then dp[i + 1] ≥ k - 1.We can use this to kick binary search from the solution — when you calculate dp[i] you can start trying with dp[i + 1] + 1, descending until the success.Since there are exactly n grows, there will be at most n descendings and the total number of checks is linear. ?Observation? 4. We need to check whether such j exists in a fast way.Recall there are few conditions for us to follow, dp[j] ≥ const, j ≥ const and some string equality.If you carefully look at the restriction j ≥ const you can see, that when we move our dp calculation i → i - 1 or make dp[i] -= 1 this lower bound on j also moves only left, like in two pointers. So each moment some indexes j are \"available\" and some are not, and the border moves only left.Finally, time for some structures. Build Suffix Array and build segment tree over it. Let's store in the leaf of the segment tree dp[j] if it's already available or  - 1 otherwise.Let's check whether dp[i] = k is good. We want for string starting at j be either si, si + 1, ..., si + k - 2, or si + 1, si + 2, ..., si + k - 1. Consider these cases independently (however the procedure is pretty much same).All such strings form a segment of Suffix Array, we can for example use LCP + binary search over sparse tables to find corresponding bounds.Then we just need to query this segment and check if the maximum on it is at least k - 1.The solution is",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62455",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1063\\s*B"
          },
          "content_length": 9243
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 1",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 2",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 3",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 4",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 5",
          "code": "sort(s.begin(), s.end()); cout<<s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 6",
          "code": "'a - 3 times, aa - 2 times aaa - 1 time, total - 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 7",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 8",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 11",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 12",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 13",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 14",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 15",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 16",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 1",
          "code": "you have to call dfs with cell C again; \n   why?\n  because, now C has lesser leftCount or rightCount than before....so it may \n           able to visit more cells than before",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 2",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 3",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    int r = inf.readInt(1, n, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, m, \"c\");\n    inf.readEoln();\n\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\");\n    inf.readEoln();\n\n    vector<string> maze(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(\"[.*]{\" + to_string(m) + \"}\", \"maze row\");\n        maze[i] = s;\n        inf.readEoln();\n    }\n\n    ensuref(maze[r][c - 1] == '.', \"The starting cell must be free ('.')\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    int r = inf.readInt(1, n, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, m, \"c\");\n    inf.readEoln();\n\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\");\n    inf.readEoln();\n\n    vector<string> maze(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(\"[.*]{\" + to_string(m) + \"}\", \"maze row\");\n        maze[i] = s;\n        inf.readEoln();\n    }\n\n    ensuref(maze[r][c - 1] == '.', \"The starting cell must be free ('.')\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    int r = inf.readInt(1, n, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, m, \"c\");\n    inf.readEoln();\n\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\");\n    inf.readEoln();\n\n    vector<string> maze(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(\"[.*]{\" + to_string(m) + \"}\", \"maze row\");\n        maze[i] = s;\n        inf.readEoln();\n    }\n\n    ensuref(maze[r][c - 1] == '.', \"The starting cell must be free ('.')\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, r, c;\nint x, y;\nstring maze_type;\nint obstacle_percent;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\");\n\n    r = opt<int>(\"r\", -1);\n    c = opt<int>(\"c\", -1);\n    x = opt<int>(\"x\", 0);\n    y = opt<int>(\"y\", 0);\n    maze_type = opt<string>(\"maze_type\", \"empty\");\n    obstacle_percent = opt<int>(\"obstacle_percent\", 20);\n\n    // Check constraints\n    ensure(1 <= n && n <= 2000);\n    ensure(1 <= m && m <= 2000);\n\n    if (r == -1) r = n / 2 + 1;\n    if (c == -1) c = m / 2 + 1;\n\n    ensure(1 <= r && r <= n);\n    ensure(1 <= c && c <= m);\n    ensure(0 <= x && x <= 1000000000);\n    ensure(0 <= y && y <= 1000000000);\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (maze_type == \"empty\") {\n        // All free cells\n    } else if (maze_type == \"full\") {\n        // All obstacles except starting cell\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '*');\n        }\n        grid[r - 1][c - 1] = '.';\n    } else if (maze_type == \"random\") {\n        // Random obstacles based on obstacle_percent\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(100) < obstacle_percent)\n                    grid[i][j] = '*';\n                else\n                    grid[i][j] = '.';\n            }\n        }\n        grid[r - 1][c - 1] = '.';\n    } else if (maze_type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = '.';\n                else\n                    grid[i][j] = '*';\n            }\n        }\n        grid[r - 1][c - 1] = '.';\n    } else if (maze_type == \"path\") {\n        // Path from starting cell\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*');\n\n        int x_pos = r - 1;\n        int y_pos = c - 1;\n        grid[x_pos][y_pos] = '.';\n\n        int path_length = rnd.next(1, n * m);\n        set<pair<int, int>> visited;\n        visited.insert({x_pos, y_pos});\n\n        for (int i = 0; i < path_length - 1; ++i) {\n            vector<pair<int, int>> dirs;\n            if (x_pos > 0 && visited.find({x_pos - 1, y_pos}) == visited.end())\n                dirs.push_back({x_pos - 1, y_pos});\n            if (x_pos + 1 < n && visited.find({x_pos + 1, y_pos}) == visited.end())\n                dirs.push_back({x_pos + 1, y_pos});\n            if (y_pos > 0 && visited.find({x_pos, y_pos - 1}) == visited.end())\n                dirs.push_back({x_pos, y_pos - 1});\n            if (y_pos + 1 < m && visited.find({x_pos, y_pos + 1}) == visited.end())\n                dirs.push_back({x_pos, y_pos + 1});\n\n            if (dirs.empty())\n                break;\n\n            int idx = rnd.next(0, (int)dirs.size() - 1);\n            x_pos = dirs[idx].first;\n            y_pos = dirs[idx].second;\n            grid[x_pos][y_pos] = '.';\n            visited.insert({x_pos, y_pos});\n        }\n    } else if (maze_type == \"spiral\") {\n        // Spiral pattern\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*');\n\n        int x1 = 0, y1 = 0, x2 = n - 1, y2 = m - 1;\n        while (x1 <= x2 && y1 <= y2) {\n            for (int i = y1; i <= y2; ++i) grid[x1][i] = '.';\n            for (int i = x1 + 1; i <= x2; ++i) grid[i][y2] = '.';\n            if (x1 < x2) {\n                for (int i = y2 - 1; i >= y1; --i) grid[x2][i] = '.';\n            }\n            if (y1 < y2) {\n                for (int i = x2 - 1; i > x1; --i) grid[i][y1] = '.';\n            }\n            ++x1; ++y1; --x2; --y2;\n        }\n        grid[r - 1][c - 1] = '.';\n    } else {\n        // Default to empty maze\n    }\n\n    // Ensure starting cell is free\n    grid[r - 1][c - 1] = '.';\n\n    // Output the maze\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d %d\\n\", r, c);\n    printf(\"%d %d\\n\", x, y);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, r, c;\nint x, y;\nstring maze_type;\nint obstacle_percent;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\");\n\n    r = opt<int>(\"r\", -1);\n    c = opt<int>(\"c\", -1);\n    x = opt<int>(\"x\", 0);\n    y = opt<int>(\"y\", 0);\n    maze_type = opt<string>(\"maze_type\", \"empty\");\n    obstacle_percent = opt<int>(\"obstacle_percent\", 20);\n\n    // Check constraints\n    ensure(1 <= n && n <= 2000);\n    ensure(1 <= m && m <= 2000);\n\n    if (r == -1) r = n / 2 + 1;\n    if (c == -1) c = m / 2 + 1;\n\n    ensure(1 <= r && r <= n);\n    ensure(1 <= c && c <= m);\n    ensure(0 <= x && x <= 1000000000);\n    ensure(0 <= y && y <= 1000000000);\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (maze_type == \"empty\") {\n        // All free cells\n    } else if (maze_type == \"full\") {\n        // All obstacles except starting cell\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '*');\n        }\n        grid[r - 1][c - 1] = '.';\n    } else if (maze_type == \"random\") {\n        // Random obstacles based on obstacle_percent\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(100) < obstacle_percent)\n                    grid[i][j] = '*';\n                else\n                    grid[i][j] = '.';\n            }\n        }\n        grid[r - 1][c - 1] = '.';\n    } else if (maze_type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = '.';\n                else\n                    grid[i][j] = '*';\n            }\n        }\n        grid[r - 1][c - 1] = '.';\n    } else if (maze_type == \"path\") {\n        // Path from starting cell\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*');\n\n        int x_pos = r - 1;\n        int y_pos = c - 1;\n        grid[x_pos][y_pos] = '.';\n\n        int path_length = rnd.next(1, n * m);\n        set<pair<int, int>> visited;\n        visited.insert({x_pos, y_pos});\n\n        for (int i = 0; i < path_length - 1; ++i) {\n            vector<pair<int, int>> dirs;\n            if (x_pos > 0 && visited.find({x_pos - 1, y_pos}) == visited.end())\n                dirs.push_back({x_pos - 1, y_pos});\n            if (x_pos + 1 < n && visited.find({x_pos + 1, y_pos}) == visited.end())\n                dirs.push_back({x_pos + 1, y_pos});\n            if (y_pos > 0 && visited.find({x_pos, y_pos - 1}) == visited.end())\n                dirs.push_back({x_pos, y_pos - 1});\n            if (y_pos + 1 < m && visited.find({x_pos, y_pos + 1}) == visited.end())\n                dirs.push_back({x_pos, y_pos + 1});\n\n            if (dirs.empty())\n                break;\n\n            int idx = rnd.next(0, (int)dirs.size() - 1);\n            x_pos = dirs[idx].first;\n            y_pos = dirs[idx].second;\n            grid[x_pos][y_pos] = '.';\n            visited.insert({x_pos, y_pos});\n        }\n    } else if (maze_type == \"spiral\") {\n        // Spiral pattern\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*');\n\n        int x1 = 0, y1 = 0, x2 = n - 1, y2 = m - 1;\n        while (x1 <= x2 && y1 <= y2) {\n            for (int i = y1; i <= y2; ++i) grid[x1][i] = '.';\n            for (int i = x1 + 1; i <= x2; ++i) grid[i][y2] = '.';\n            if (x1 < x2) {\n                for (int i = y2 - 1; i >= y1; --i) grid[x2][i] = '.';\n            }\n            if (y1 < y2) {\n                for (int i = x2 - 1; i > x1; --i) grid[i][y1] = '.';\n            }\n            ++x1; ++y1; --x2; --y2;\n        }\n        grid[r - 1][c - 1] = '.';\n    } else {\n        // Default to empty maze\n    }\n\n    // Ensure starting cell is free\n    grid[r - 1][c - 1] = '.';\n\n    // Output the maze\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d %d\\n\", r, c);\n    printf(\"%d %d\\n\", x, y);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -r 1 -c 1 -x 0 -y 0 -maze_type empty\n./gen -n 1 -m 1 -r 1 -c 1 -x 0 -y 0 -maze_type full\n./gen -n 5 -m 5 -r 3 -c 3 -x 1 -y 1 -maze_type random -obstacle_percent 50\n./gen -n 5 -m 5 -r 3 -c 3 -x 2 -y 2 -maze_type checkerboard\n./gen -n 5 -m 5 -r 1 -c 1 -x 2 -y 2 -maze_type path\n./gen -n 5 -m 5 -r 3 -c 3 -x 10 -y 10 -maze_type spiral\n./gen -n 1000 -m 1000 -r 500 -c 500 -x 1000000000 -y 1000000000 -maze_type empty\n./gen -n 1000 -m 1000 -r 500 -c 500 -x 500 -y 500 -maze_type random -obstacle_percent 30\n./gen -n 1000 -m 1000 -r 1 -c 1 -x 0 -y 0 -maze_type path\n./gen -n 2000 -m 2000 -r 1 -c 1 -x 0 -y 0 -maze_type empty\n./gen -n 2000 -m 2000 -r 1000 -c 1000 -x 0 -y 0 -maze_type full\n./gen -n 2000 -m 2000 -r 1000 -c 1000 -x 1000000000 -y 1000000000 -maze_type checkerboard\n./gen -n 10 -m 10 -r 5 -c 5 -x 0 -y 1000000000 -maze_type random -obstacle_percent 0\n./gen -n 10 -m 10 -r 5 -c 5 -x 1000000000 -y 0 -maze_type random -obstacle_percent 0\n./gen -n 1 -m 2000 -r 1 -c 1 -x 1000 -y 1000 -maze_type empty\n./gen -n 2000 -m 1 -r 1 -c 1 -x 0 -y 0 -maze_type full\n./gen -n 1000 -m 1000 -r 1 -c 1 -x 0 -y 0 -maze_type spiral\n./gen -n 1000 -m 1000 -r 500 -c 500 -x 0 -y 0 -maze_type random -obstacle_percent 0\n./gen -n 1000 -m 1000 -r 500 -c 500 -x 0 -y 0 -maze_type random -obstacle_percent 100\n./gen -n 2 -m 2 -r 1 -c 1 -x 1000000000 -y 1000000000 -maze_type empty\n./gen -n 1000 -m 1000 -r 1 -c 1 -x 1000000000 -y 1000000000 -maze_type path\n./gen -n 1000 -m 1000 -r 1 -c 1 -x 1000000000 -y 1000000000 -maze_type spiral\n./gen -n 4 -m 4 -r 1 -c 1 -x 0 -y 0\n./gen -n 2000 -m 2000 -r 1000 -c 1000 -x 1000000000 -y 1000000000 -maze_type random -obstacle_percent 50\n./gen -n 1000 -m 1000 -r 500 -c 500 -x 0 -y 0 -maze_type random -obstacle_percent 90\n./gen -n 1000 -m 1000 -r 500 -c 500 -x 0 -y 0 -maze_type random -obstacle_percent 10\n./gen -n 2000 -m 2000 -r 1000 -c 1000 -x 1999 -y 1999 -maze_type empty\n./gen -n 10 -m 10 -r 5 -c 5 -x 0 -y 0 -maze_type empty\n./gen -n 3 -m 3 -r 2 -c 2 -x 10 -y 10 -maze_type full\n./gen -n 2000 -m 1 -r 1 -c 1 -x 1000000000 -y 1000000000 -maze_type empty\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:57.523153",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1063/D",
      "title": "D. Candies for Children",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains four integers nn, ll, rr and kk (1≤n,k≤10111≤n,k≤1011, 1≤l,r≤n1≤l,r≤n) — the number of children in the circle, the number of friend, who was given a box with candies, the number of friend, who has taken last candy and the initial number of candies in the box respectively.",
      "output_spec": "OutputPrint exactly one integer — the maximum possible number of sweet tooth among the friends of Lena or \"-1\" (quotes for clarity), if Lena is wrong.",
      "sample_tests": "ExamplesInputCopy4 1 4 12OutputCopy2InputCopy5 3 4 10OutputCopy3InputCopy10 5 5 1OutputCopy10InputCopy5 4 5 6OutputCopy-1",
      "description": "D. Candies for Children\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains four integers nn, ll, rr and kk (1≤n,k≤10111≤n,k≤1011, 1≤l,r≤n1≤l,r≤n) — the number of children in the circle, the number of friend, who was given a box with candies, the number of friend, who has taken last candy and the initial number of candies in the box respectively.\n\nOutputPrint exactly one integer — the maximum possible number of sweet tooth among the friends of Lena or \"-1\" (quotes for clarity), if Lena is wrong.\n\nInputCopy4 1 4 12OutputCopy2InputCopy5 3 4 10OutputCopy3InputCopy10 5 5 1OutputCopy10InputCopy5 4 5 6OutputCopy-1\n\nInputCopy4 1 4 12\n\nOutputCopy2\n\nInputCopy5 3 4 10\n\nOutputCopy3\n\nInputCopy10 5 5 1\n\nOutputCopy10\n\nInputCopy5 4 5 6\n\nOutputCopy-1\n\nNoteIn the first example, any two friends can be sweet tooths, this way each person will receive the box with candies twice and the last person to take sweets will be the fourth friend.In the second example, sweet tooths can be any three friends, except for the friend on the third position.In the third example, only one friend will take candy, but he can still be a sweet tooth, but just not being able to take two candies. All other friends in the circle can be sweet tooths as well, they just will not be able to take a candy even once.In the fourth example, Lena is wrong and this situation couldn't happen.",
      "solutions": [
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces",
          "content": "Hi everybody,This Sunday there will be a 16th Moscow Team Olympiad, high school students competition based in Moscow that is an elimination contest for All-Russian Team Olympiad. This contest is prepared by Moscow Olympiad Scientific Committee that you may know by Moscow Open Olympiad, Moscow Olympiad for Young Students and Metropolises Olympiad (rounds 327, 342, 345, 376, 401, 433, 441, 466, 469, 507).Round will be held at 10:05 UTC on Sunday and will last for 2 hours. Each division will have 6 problems.Problems are prepared vintage_Vlad_Makeev, Glebodin, Andreikkaa, qoo2p5, mingaleg, Flyrise, cdkrot, achulkov2, grphil, Sehnsucht, Aphanasiy, Sender, DebNatkh, GreenGrape under my supervision with great help of GlebsHP, meshanya, Endagorion, Zlobober and Helen Andreeva.Thanks to cdkrot for the round coordination and statement translation, and also thanks for MikeMirzayanov for systems codeforces and polygon, which was used to prepare problems of this olympiad.Good luck everybody!UPD1: The scoring distribution will be:500 — 1000 — 1000 — 1500 — 2000 — 2500 for div. 1.500 — 1000 — 1500 — 2000 — 2000 — 2500 for div. 2.UPD2: EditorialUPD3: Winners:Div. 1: mnbvmar bmerry jcvb TLEwpdus WA_TLE Div. 2: Ebola_Emperor Orange_User orbitingfIea little_waxberry fnch",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1272
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces",
          "content": "Credits:Div2A (Make a Trianle): Idea by Zlobober, development by vintage_Vlad_MakeevDiv2B (Equations of Mathematical Magic): Idea and development: GlebodinDiv1A (Oh Those Palindromes): Idea by Endagorion, development by AndreikkaaDiv1B (Labyrinth): Idea and development by qoo2p5Div1C (Dwarves, Hats and Extrasensory Abilities): Idea and development by mingaleg Div1D (Candies for Children): Idea by Endagorion, development by FlyriseDiv1E (Lasers and Mirrors): Idea and development by mingalegDiv1F (String Journey): Original idea by GreenGrape, solution by vintage_Vlad_Makeev, development vintage_Vlad_Makeev and GreenGrape 1064A - Make a triangle!Suppose cc is the largest stick. It is known, that we can build a triangle iff c≤a+b−1c≤a+b−1.So if we can build a triangle the answer is zero. Otherwise we can just increase aa or bb until the inequality above holds.So the answer is max(0,c−(a+b−1))max(0,c−(a+b−1)).Another approach: just bruteforce all possible triangles we can extend to (with sides ≤100≤100) and select the one with smallest a+b+ca+b+c. 1064B - Equations of Mathematical MagicRewriting equation we have a⊕x=a−xa⊕x=a−x.If you look in the xor definition, it is easy to see, that a⊕x≥a−xa⊕x≥a−x, no matter aa and xx (just look at the each bit of the a⊕xa⊕x).And the equality handles only if bits of xx form a subset of bits of aa.So the answer is 2t2t, where tt is the number of bits in aa (also known as popcount). 1063A - Oh Those PalindromesOne possible solution is just to sort the string.Why so?Note that each palindrome have equal character at their ends. Suppose this character is cc with xx number of occurences. Then there are at most x(x+1)/2x(x+1)/2 palindromes with this character.So we have a clear upper bound on answer. It is easy to see, that the sorted string fulfills that bound and hence it is the optimal answer. 1063B - LabyrinthSuppose we started in cell (i0, j0) and examining whether we can reach cell (i1, j1).Let's denote the number of taken moves to the right as R and number of moves to the left as LClearly, j0 + R - L = j1That is, R - L = j1 - j0 = const. Or, put otherwise R = L + const, where const only depends on the starting cell and the target cell.So in fact we just need to minimize any of the left or right moves — the other one will be optimal as well.To calculate the minimum possible number of L-moves to reach some cell we can use 0-1 bfs.Solution is O(nm). 1063C - Dwarves, Hats and Extrasensory AbilitiesThe solution is just.. binary search!We will use just a single line to put our points on. Let's maintain an invariant that all white colored points are on the left and all black colored on the right.Put a new point in the middle of the gap between white points and black points.Depending on the color said by jury shrink the gap to the left or to the right.In the end draw a diagonal line between white points and black points.The initializing binary search may look complicated but it isn't.Put a first point on the leftmost (x = 0) position, suppose that this point is white (if it is black just revert all colors), and then play as if there is a white point in x = 0 and black point in x = 109. 1063D - Candies for ChildrenSolution works in min(n2,k/n)min(n2,k/n) time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.This adds few more cases but the idea stays the same. Basically in the formulas below just few −1−1 will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.So how to solve problem in n2n2?Note, that basically we have two parts of the circle — the part between [l;r][l;r] which get's candies one times more than the rest and the other one.Since we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as xx and yy.To solve in n2n2 let's bruteforce the number of sweet tooth on first part (aa) and the number of sweet tooth on the second part (bb).Suppose that there were full tt loops. This way the number of eaten candies is a∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗ta∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗t.This should be equal to kk. Since we just bruteforced the values of aa and bb we now just have linear equation. If it is solvable, consider relaxing answer with a+ba+b.How to solve problem in k/nk/n?So as the asymptotic suggests the amount of turns ≤k/n≤k/n, so we can bruteforce it instead.Also it is worthy to handle case of 00 turns specifically here since it produces some unpleasant effects otherwise.So each person in \"xx\" part of the circle eats candies t+1t+1 times (so each person contributes t+1t+1 or 2t+22t+2) and the other persons have eaten candies tt times (so each person contributes tt or 2t2t).Let's account all persons as if they are not sweet tooths.So now each person in xx contributes 00 or t+1t+1 and each person in yy contributes 00 or tt.So we basically have (t+1)a+tb=γ(t+1)a+tb=γ. A Diophantine equation.Careful analysis or bits of theory suggest that the solutions area=a0−tza=a0−tz, b=b0+(t+1)zb=b0+(t+1)z, for all integer zz.Where a0a0 and b0b0 some arbitrary solutions which we can get with formulas.Also we need to have 0≤a≤x0≤a≤x, 0≤b≤y0≤b≤y, and the a+b→maxa+b→max.These bounds imply that tt takes values only in some range [t1;t2][t1;t2].Since the a+ba+b is linear function we can only consider t1t1 and t2t2 while searching for maximum a+ba+b. 1063E - Lasers and MirrorsThe answer is always nn (if the permutation is identity) lasers or n−1n−1 (otherwise).Clearly, we can't have more than n−1n−1 matching lasers if the permutation is not identity. Consider just the very first line with mirrors. If the first mirror in this line is «\\» then we miss the laser below this mirror, if the very last mirror is «/» we miss the laser below it. Otherwise there are neighbouring «/» and «\\» and we lost two lasers now.The proof of n−1n−1 is constructive one.Ignore all fixed points in permutation (all xx, that px=xpx=x).Select arbitrary cycle and select one point in it as «dead». We can spend |cycle|−1|cycle|−1 operations to fix all points in this cycle.But we also need to fix all other cycles. We can do it in |cycle|+1|cycle|+1 operations: move arbitrary beam to the wasted laser, fix all other points and move that point back.But this is a bit too much lines.The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line, if we select as the trash beam the rightmost point.See the following picture for an example (trash beam is the rightmost column): 1063F - String JourneyThis problem required quite a lot of nice observations!Observation 1. We can only consider journeys in which neighboring strings differ exactly by removing one symbol.All other journeys can be modified a bit to match the criterion above.Observation 2. If it is possible to start a journey at the symbol i with lengths of strings k, k - 1, ..., 1, it is always possible to start a journey at the same symbol i with lengths t, t - 1, ..., 1, given that t ≤ k.This suggests doing dynamic programming: dp[i] is the maximum possible k such that there is a journey starting at position i of k strings with lengths k, ..., 1.Due to observation 1 we only care about maximum – if we know maximum, we also known that all lesser values are also OK.So let's calculate this dynamic programming from right to left.How to check whether dp[i] ≥ k (given that tool, we can just use binary search for example)?There must be such j, that j ≥ i + k, dp[j] ≥ k - 1 and string sj, ..., sj + k - 2 must be a substring of string sisi + 1... si + k - 1 (basically just two cases \"left substring\" or \"right substring\").This almost gives us a solution, but we need few more observations to have , and not .Observation 3. If dp[i] = k, then dp[i + 1] ≥ k - 1.We can use this to kick binary search from the solution — when you calculate dp[i] you can start trying with dp[i + 1] + 1, descending until the success.Since there are exactly n grows, there will be at most n descendings and the total number of checks is linear. ?Observation? 4. We need to check whether such j exists in a fast way.Recall there are few conditions for us to follow, dp[j] ≥ const, j ≥ const and some string equality.If you carefully look at the restriction j ≥ const you can see, that when we move our dp calculation i → i - 1 or make dp[i] -= 1 this lower bound on j also moves only left, like in two pointers. So each moment some indexes j are \"available\" and some are not, and the border moves only left.Finally, time for some structures. Build Suffix Array and build segment tree over it. Let's store in the leaf of the segment tree dp[j] if it's already available or  - 1 otherwise.Let's check whether dp[i] = k is good. We want for string starting at j be either si, si + 1, ..., si + k - 2, or si + 1, si + 2, ..., si + k - 1. Consider these cases independently (however the procedure is pretty much same).All such strings form a segment of Suffix Array, we can for example use LCP + binary search over sparse tables to find corresponding bounds.Then we just need to query this segment and check if the maximum on it is at least k - 1.The solution is",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62455",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1063\\s*D"
          },
          "content_length": 9243
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 1",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 2",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 3",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 4",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 5",
          "code": "sort(s.begin(), s.end()); cout<<s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 6",
          "code": "'a - 3 times, aa - 2 times aaa - 1 time, total - 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 7",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 8",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 11",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 12",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 13",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 14",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 15",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 16",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 1",
          "code": "you have to call dfs with cell C again; \n   why?\n  because, now C has lesser leftCount or rightCount than before....so it may \n           able to visit more cells than before",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 2",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 3",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 100000000000LL, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, n, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1LL, n, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 100000000000LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 100000000000LL, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, n, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1LL, n, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 100000000000LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 100000000000LL, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, n, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1LL, n, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 100000000000LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    const long long MAX_N = 100000000000LL; // 1e11\n    const long long MIN_N = 1LL;\n\n    long long n = opt<long long>(\"n\", -1);\n    long long k = opt<long long>(\"k\", -1);\n    long long l = opt<long long>(\"l\", -1);\n    long long r = opt<long long>(\"r\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max_n\") {\n        n = MAX_N;\n        k = (k == -1) ? rnd.next(1LL, MAX_N) : k;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (r == -1) ? rnd.next(1LL, n) : r;\n    } else if (type == \"min_n\") {\n        n = 1;\n        k = (k == -1) ? rnd.next(1LL, MAX_N) : k;\n        l = 1;\n        r = 1;\n    } else if (type == \"max_k\") {\n        k = MAX_N;\n        n = (n == -1) ? rnd.next(1LL, MAX_N) : n;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (r == -1) ? rnd.next(1LL, n) : r;\n    } else if (type == \"n_equals_k\") {\n        n = (n == -1) ? rnd.next(1LL, MAX_N) : n;\n        k = n;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (r == -1) ? rnd.next(1LL, n) : r;\n    } else if (type == \"l_equals_r\") {\n        if (n == -1) n = rnd.next(1LL, MAX_N);\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = l;\n        k = (k == -1) ? rnd.next(1LL, MAX_N) : k;\n    } else if (type == \"impossible\") {\n        n = (n == -1) ? rnd.next(2LL, MAX_N / 2) : n;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = l % n + 1;\n        k = 1;\n    } else if (type == \"one_circle\") {\n        n = (n == -1) ? rnd.next(MIN_N, MAX_N) : n;\n        k = n;\n        l = (l == -1) ? 1 : l;\n        r = (r == -1) ? n : r;\n    } else if (type == \"multiple_circles\") {\n        n = (n == -1) ? rnd.next(2LL, MAX_N / 1000) : n;\n        long long num_circles = rnd.next(2LL, 1000LL);\n        k = n * num_circles;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (l + n - 1) % n + 1;\n    } else if (type == \"small\") {\n        n = (n == -1) ? rnd.next(1LL, 100LL) : n;\n        k = (k == -1) ? rnd.next(1LL, 1000LL) : k;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (r == -1) ? rnd.next(1LL, n) : r;\n    } else {\n        // Random case\n        n = (n == -1) ? rnd.next(MIN_N, MAX_N) : n;\n        k = (k == -1) ? rnd.next(1LL, MAX_N) : k;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (r == -1) ? rnd.next(1LL, n) : r;\n    }\n\n    // Adjust values to be within constraints\n    n = max(MIN_N, min(n, MAX_N));\n    k = max(1LL, min(k, MAX_N));\n    l = max(1LL, min(l, n));\n    r = max(1LL, min(r, n));\n\n    // Output\n    printf(\"%lld %lld %lld %lld\\n\", n, l, r, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    const long long MAX_N = 100000000000LL; // 1e11\n    const long long MIN_N = 1LL;\n\n    long long n = opt<long long>(\"n\", -1);\n    long long k = opt<long long>(\"k\", -1);\n    long long l = opt<long long>(\"l\", -1);\n    long long r = opt<long long>(\"r\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max_n\") {\n        n = MAX_N;\n        k = (k == -1) ? rnd.next(1LL, MAX_N) : k;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (r == -1) ? rnd.next(1LL, n) : r;\n    } else if (type == \"min_n\") {\n        n = 1;\n        k = (k == -1) ? rnd.next(1LL, MAX_N) : k;\n        l = 1;\n        r = 1;\n    } else if (type == \"max_k\") {\n        k = MAX_N;\n        n = (n == -1) ? rnd.next(1LL, MAX_N) : n;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (r == -1) ? rnd.next(1LL, n) : r;\n    } else if (type == \"n_equals_k\") {\n        n = (n == -1) ? rnd.next(1LL, MAX_N) : n;\n        k = n;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (r == -1) ? rnd.next(1LL, n) : r;\n    } else if (type == \"l_equals_r\") {\n        if (n == -1) n = rnd.next(1LL, MAX_N);\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = l;\n        k = (k == -1) ? rnd.next(1LL, MAX_N) : k;\n    } else if (type == \"impossible\") {\n        n = (n == -1) ? rnd.next(2LL, MAX_N / 2) : n;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = l % n + 1;\n        k = 1;\n    } else if (type == \"one_circle\") {\n        n = (n == -1) ? rnd.next(MIN_N, MAX_N) : n;\n        k = n;\n        l = (l == -1) ? 1 : l;\n        r = (r == -1) ? n : r;\n    } else if (type == \"multiple_circles\") {\n        n = (n == -1) ? rnd.next(2LL, MAX_N / 1000) : n;\n        long long num_circles = rnd.next(2LL, 1000LL);\n        k = n * num_circles;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (l + n - 1) % n + 1;\n    } else if (type == \"small\") {\n        n = (n == -1) ? rnd.next(1LL, 100LL) : n;\n        k = (k == -1) ? rnd.next(1LL, 1000LL) : k;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (r == -1) ? rnd.next(1LL, n) : r;\n    } else {\n        // Random case\n        n = (n == -1) ? rnd.next(MIN_N, MAX_N) : n;\n        k = (k == -1) ? rnd.next(1LL, MAX_N) : k;\n        l = (l == -1) ? rnd.next(1LL, n) : l;\n        r = (r == -1) ? rnd.next(1LL, n) : r;\n    }\n\n    // Adjust values to be within constraints\n    n = max(MIN_N, min(n, MAX_N));\n    k = max(1LL, min(k, MAX_N));\n    l = max(1LL, min(l, n));\n    r = max(1LL, min(r, n));\n\n    // Output\n    printf(\"%lld %lld %lld %lld\\n\", n, l, r, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 10 -l 3 -r 4 -type small\n./gen -n 100 -k 1000 -type small\n./gen -type max_n\n./gen -type max_k\n./gen -type n_equals_k\n./gen -type l_equals_r\n./gen -type impossible\n./gen -type one_circle\n./gen -type multiple_circles\n./gen -type random\n./gen -type small -n 1\n./gen -type small -n 1 -k 1\n./gen -type small -n 2 -k 1\n./gen -type small -n 2 -k 100\n./gen -type random -n 100000000000 -k 100000000000\n./gen -type random\n./gen -type impossible\n./gen -type impossible -n 1000 -l 10 -r 20\n./gen -type l_equals_r\n./gen -type l_equals_r -n 10 -k 100\n./gen -type multiple_circles -n 10000000000\n./gen -type multiple_circles -n 1000\n./gen -type one_circle -n 5\n./gen -type one_circle -n 10000000000\n./gen -type min_n\n./gen -type min_n -k 100000000000\n./gen -type max_k -n 1\n./gen -type max_n -k 1\n./gen -type random\n./gen -type random\n./gen -type small -n 10 -k 50 -l 2 -r 7\n./gen -type impossible -n 50 -k 1\n./gen -type one_circle -n 20 -l 5 -r 20\n./gen -type multiple_circles -n 100 -l 1 -r 50\n./gen -type l_equals_r -n 10000 -k 5000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:12:59.354434",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1063/E",
      "title": "E. Лазеры и зеркала",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит одно целое число nn (1≤n≤10001≤n≤1000) — размеры лабиринта.Во второй строке дана перестановка из nn целых чисел aiai (1≤ai≤n1≤ai≤n), где aiai задаёт номер приёмника, в который должен попасть ii-й лазер.",
      "output_spec": "Выходные данныеВ первой строке выведите наибольшее возможное количество попавших лазеров.В следующих nn строчках длины nn выведите расстановку зеркал, приводящую к такому количеству попавших лазеров. Если соответствующая клетка пуста, то выведите «.», иначе выведите «/» или «\\», в зависимости от ориентации зеркала.В выводе север должен находиться сверху, юг — снизу, а запад и восток — слева и справа соответственно. Допускается, что некоторые лазеры могут попасть не в свои приёмники, но они не учитываются в подсчёте числа попавших лазеров.Если существует несколько расстановок зеркал, приводящих к оптимальному ответу — выведите любую из них.",
      "sample_tests": "ПримерВходные данныеСкопировать44 1 3 2Выходные данныеСкопировать3.\\..\\\\../../...\\",
      "description": "E. Лазеры и зеркала\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит одно целое число nn (1≤n≤10001≤n≤1000) — размеры лабиринта.Во второй строке дана перестановка из nn целых чисел aiai (1≤ai≤n1≤ai≤n), где aiai задаёт номер приёмника, в который должен попасть ii-й лазер.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите наибольшее возможное количество попавших лазеров.В следующих nn строчках длины nn выведите расстановку зеркал, приводящую к такому количеству попавших лазеров. Если соответствующая клетка пуста, то выведите «.», иначе выведите «/» или «\\», в зависимости от ориентации зеркала.В выводе север должен находиться сверху, юг — снизу, а запад и восток — слева и справа соответственно. Допускается, что некоторые лазеры могут попасть не в свои приёмники, но они не учитываются в подсчёте числа попавших лазеров.Если существует несколько расстановок зеркал, приводящих к оптимальному ответу — выведите любую из них.\n\nВыходные данные\n\nВходные данныеСкопировать44 1 3 2Выходные данныеСкопировать3.\\..\\\\../../...\\\n\nВходные данныеСкопировать44 1 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3.\\..\\\\../../...\\\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеКартинка иллюстрирует расстановку зеркал из первого примера.",
      "solutions": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces",
          "content": "Всем привет!В воскресенье в Москве пройдет шестнадцатая Московская командная олимпиада — командное соревнование для школьников, проходящее в Москве как отборочное соревнование на ВКОШП. Над туром работала Московская методическая комиссия, известная вам также по Открытой олимпиаде школьников по программированию, Московской олимпиаде для 6-9 классов и олимпиаде Мегаполисов (раунды 327, 342, 345, 376, 401, 433, 441, 466, 469, 507).Раунд состоится в 13:05 14 числа и продлится 2 часа. В каждом дивизионе будет предложено по 6 задач.Задачи соревнования подготовлены vintage_Vlad_Makeev, Glebodin, Andreikkaa, qoo2p5, mingaleg, Flyrise, cdkrot, achulkov2, grphil, Sehnsucht, Aphanasiy, Sender, DebNatkh, GreenGrape под моим руководством, а также GlebsHP, meshanya, Endagorion, Zlobober и Андреевой Е. В.За координацию раунда и перевод условий спасибо cdkrot, а так же MikeMirzayanov за системы codeforces и polygon, который использовался при подготовке задач этой олимпиады.Всем удачи!UPD1: Разбалловка:500 — 1000 — 1000 — 1500 — 2000 — 2500 для div. 1.500 — 1000 — 1500 — 2000 — 2000 — 2500 для div. 2.UPD2: РазборUPD3: Победители:Div. 1: mnbvmar bmerry jcvb TLEwpdus WA_TLE Div. 2: Ebola_Emperor Orange_User orbitingfIea little_waxberry fnch",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1241
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces",
          "content": "Credits:Div2A (Make a Trianle): Idea by Zlobober, development by vintage_Vlad_MakeevDiv2B (Equations of Mathematical Magic): Idea and development: GlebodinDiv1A (Oh Those Palindromes): Idea by Endagorion, development by AndreikkaaDiv1B (Labyrinth): Idea and development by qoo2p5Div1C (Dwarves, Hats and Extrasensory Abilities): Idea and development by mingaleg Div1D (Candies for Children): Idea by Endagorion, development by FlyriseDiv1E (Lasers and Mirrors): Idea and development by mingalegDiv1F (String Journey): Original idea by GreenGrape, solution by vintage_Vlad_Makeev, development vintage_Vlad_Makeev and GreenGrape 1064A - Make a triangle!Suppose cc is the largest stick. It is known, that we can build a triangle iff c≤a+b−1c≤a+b−1.So if we can build a triangle the answer is zero. Otherwise we can just increase aa or bb until the inequality above holds.So the answer is max(0,c−(a+b−1))max(0,c−(a+b−1)).Another approach: just bruteforce all possible triangles we can extend to (with sides ≤100≤100) and select the one with smallest a+b+ca+b+c. 1064B - Equations of Mathematical MagicRewriting equation we have a⊕x=a−xa⊕x=a−x.If you look in the xor definition, it is easy to see, that a⊕x≥a−xa⊕x≥a−x, no matter aa and xx (just look at the each bit of the a⊕xa⊕x).And the equality handles only if bits of xx form a subset of bits of aa.So the answer is 2t2t, where tt is the number of bits in aa (also known as popcount). 1063A - Oh Those PalindromesOne possible solution is just to sort the string.Why so?Note that each palindrome have equal character at their ends. Suppose this character is cc with xx number of occurences. Then there are at most x(x+1)/2x(x+1)/2 palindromes with this character.So we have a clear upper bound on answer. It is easy to see, that the sorted string fulfills that bound and hence it is the optimal answer. 1063B - LabyrinthSuppose we started in cell (i0, j0) and examining whether we can reach cell (i1, j1).Let's denote the number of taken moves to the right as R and number of moves to the left as LClearly, j0 + R - L = j1That is, R - L = j1 - j0 = const. Or, put otherwise R = L + const, where const only depends on the starting cell and the target cell.So in fact we just need to minimize any of the left or right moves — the other one will be optimal as well.To calculate the minimum possible number of L-moves to reach some cell we can use 0-1 bfs.Solution is O(nm). 1063C - Dwarves, Hats and Extrasensory AbilitiesThe solution is just.. binary search!We will use just a single line to put our points on. Let's maintain an invariant that all white colored points are on the left and all black colored on the right.Put a new point in the middle of the gap between white points and black points.Depending on the color said by jury shrink the gap to the left or to the right.In the end draw a diagonal line between white points and black points.The initializing binary search may look complicated but it isn't.Put a first point on the leftmost (x = 0) position, suppose that this point is white (if it is black just revert all colors), and then play as if there is a white point in x = 0 and black point in x = 109. 1063D - Candies for ChildrenSolution works in min(n2,k/n)min(n2,k/n) time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.This adds few more cases but the idea stays the same. Basically in the formulas below just few −1−1 will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.So how to solve problem in n2n2?Note, that basically we have two parts of the circle — the part between [l;r][l;r] which get's candies one times more than the rest and the other one.Since we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as xx and yy.To solve in n2n2 let's bruteforce the number of sweet tooth on first part (aa) and the number of sweet tooth on the second part (bb).Suppose that there were full tt loops. This way the number of eaten candies is a∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗ta∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗t.This should be equal to kk. Since we just bruteforced the values of aa and bb we now just have linear equation. If it is solvable, consider relaxing answer with a+ba+b.How to solve problem in k/nk/n?So as the asymptotic suggests the amount of turns ≤k/n≤k/n, so we can bruteforce it instead.Also it is worthy to handle case of 00 turns specifically here since it produces some unpleasant effects otherwise.So each person in \"xx\" part of the circle eats candies t+1t+1 times (so each person contributes t+1t+1 or 2t+22t+2) and the other persons have eaten candies tt times (so each person contributes tt or 2t2t).Let's account all persons as if they are not sweet tooths.So now each person in xx contributes 00 or t+1t+1 and each person in yy contributes 00 or tt.So we basically have (t+1)a+tb=γ(t+1)a+tb=γ. A Diophantine equation.Careful analysis or bits of theory suggest that the solutions area=a0−tza=a0−tz, b=b0+(t+1)zb=b0+(t+1)z, for all integer zz.Where a0a0 and b0b0 some arbitrary solutions which we can get with formulas.Also we need to have 0≤a≤x0≤a≤x, 0≤b≤y0≤b≤y, and the a+b→maxa+b→max.These bounds imply that tt takes values only in some range [t1;t2][t1;t2].Since the a+ba+b is linear function we can only consider t1t1 and t2t2 while searching for maximum a+ba+b. 1063E - Lasers and MirrorsThe answer is always nn (if the permutation is identity) lasers or n−1n−1 (otherwise).Clearly, we can't have more than n−1n−1 matching lasers if the permutation is not identity. Consider just the very first line with mirrors. If the first mirror in this line is «\\» then we miss the laser below this mirror, if the very last mirror is «/» we miss the laser below it. Otherwise there are neighbouring «/» and «\\» and we lost two lasers now.The proof of n−1n−1 is constructive one.Ignore all fixed points in permutation (all xx, that px=xpx=x).Select arbitrary cycle and select one point in it as «dead». We can spend |cycle|−1|cycle|−1 operations to fix all points in this cycle.But we also need to fix all other cycles. We can do it in |cycle|+1|cycle|+1 operations: move arbitrary beam to the wasted laser, fix all other points and move that point back.But this is a bit too much lines.The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line, if we select as the trash beam the rightmost point.See the following picture for an example (trash beam is the rightmost column): 1063F - String JourneyThis problem required quite a lot of nice observations!Observation 1. We can only consider journeys in which neighboring strings differ exactly by removing one symbol.All other journeys can be modified a bit to match the criterion above.Observation 2. If it is possible to start a journey at the symbol i with lengths of strings k, k - 1, ..., 1, it is always possible to start a journey at the same symbol i with lengths t, t - 1, ..., 1, given that t ≤ k.This suggests doing dynamic programming: dp[i] is the maximum possible k such that there is a journey starting at position i of k strings with lengths k, ..., 1.Due to observation 1 we only care about maximum – if we know maximum, we also known that all lesser values are also OK.So let's calculate this dynamic programming from right to left.How to check whether dp[i] ≥ k (given that tool, we can just use binary search for example)?There must be such j, that j ≥ i + k, dp[j] ≥ k - 1 and string sj, ..., sj + k - 2 must be a substring of string sisi + 1... si + k - 1 (basically just two cases \"left substring\" or \"right substring\").This almost gives us a solution, but we need few more observations to have , and not .Observation 3. If dp[i] = k, then dp[i + 1] ≥ k - 1.We can use this to kick binary search from the solution — when you calculate dp[i] you can start trying with dp[i + 1] + 1, descending until the success.Since there are exactly n grows, there will be at most n descendings and the total number of checks is linear. ?Observation? 4. We need to check whether such j exists in a fast way.Recall there are few conditions for us to follow, dp[j] ≥ const, j ≥ const and some string equality.If you carefully look at the restriction j ≥ const you can see, that when we move our dp calculation i → i - 1 or make dp[i] -= 1 this lower bound on j also moves only left, like in two pointers. So each moment some indexes j are \"available\" and some are not, and the border moves only left.Finally, time for some structures. Build Suffix Array and build segment tree over it. Let's store in the leaf of the segment tree dp[j] if it's already available or  - 1 otherwise.Let's check whether dp[i] = k is good. We want for string starting at j be either si, si + 1, ..., si + k - 2, or si + 1, si + 2, ..., si + k - 1. Consider these cases independently (however the procedure is pretty much same).All such strings form a segment of Suffix Array, we can for example use LCP + binary search over sparse tables to find corresponding bounds.Then we just need to query this segment and check if the maximum on it is at least k - 1.The solution is",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62455",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1063\\s*E"
          },
          "content_length": 9243
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 1",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 2",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 3",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 4",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 5",
          "code": "sort(s.begin(), s.end()); cout<<s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 6",
          "code": "'a - 3 times, aa - 2 times aaa - 1 time, total - 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 7",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 8",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 11",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 12",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 13",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 14",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 15",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 16",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 1",
          "code": "you have to call dfs with cell C again; \n   why?\n  because, now C has lesser leftCount or rightCount than before....so it may \n           able to visit more cells than before",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 2",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 3",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and check the constraints\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    // Read the permutation a_i and check the constraints\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    // Check that a_i forms a permutation of [1, n]\n    vector<bool> used(n + 1, false); // Index from 1 to n\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(!used[ai], \"Number %d appears more than once in the permutation\", ai);\n        used[ai] = true;\n    }\n\n    // Ensure all numbers from 1 to n are present\n    for (int i = 1; i <= n; ++i) {\n        ensuref(used[i], \"Number %d is missing from the permutation\", i);\n    }\n\n    // Ensure no extra input after the expected input\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and check the constraints\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    // Read the permutation a_i and check the constraints\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    // Check that a_i forms a permutation of [1, n]\n    vector<bool> used(n + 1, false); // Index from 1 to n\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(!used[ai], \"Number %d appears more than once in the permutation\", ai);\n        used[ai] = true;\n    }\n\n    // Ensure all numbers from 1 to n are present\n    for (int i = 1; i <= n; ++i) {\n        ensuref(used[i], \"Number %d is missing from the permutation\", i);\n    }\n\n    // Ensure no extra input after the expected input\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and check the constraints\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    // Read the permutation a_i and check the constraints\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    // Check that a_i forms a permutation of [1, n]\n    vector<bool> used(n + 1, false); // Index from 1 to n\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(!used[ai], \"Number %d appears more than once in the permutation\", ai);\n        used[ai] = true;\n    }\n\n    // Ensure all numbers from 1 to n are present\n    for (int i = 1; i <= n; ++i) {\n        ensuref(used[i], \"Number %d is missing from the permutation\", i);\n    }\n\n    // Ensure no extra input after the expected input\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> a; // permutation representing the desired receiver for each laser\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input from the input file\n    n = inf.readInt(1, 1000, \"n\");\n    a.resize(n);\n    for(int i = 0; i < n; ++i)\n        a[i] = inf.readInt(1, n, format(\"a[%d]\", i + 1).c_str());\n\n    // Read the jury's answer\n    int m_jury = ans.readInt(0, n, \"m_jury\");\n\n    // Read the participant's answer\n    int m_part = ouf.readInt(0, n, \"m_part\");\n    if (m_part != m_jury)\n        quitf(_wa, \"Participant's claimed number of beams (%d) does not match the maximum (%d)\", m_part, m_jury);\n\n    // Read the participant's maze\n    vector<string> maze;\n    for (int i = 0; i < n; ++i)\n    {\n        string s = ouf.readToken();\n        if ((int)s.length() != n)\n            quitf(_wa, \"Line %d of maze must have length n=%d\", i + 1, n);\n        for (char c : s)\n        {\n            if (c != '.' && c != '/' && c != '\\\\')\n                quitf(_wa, \"Invalid character '%c' in maze at line %d\", c, i + 1);\n        }\n        maze.push_back(s);\n    }\n\n    // Simulate the lasers' beams\n    int correct_beams = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        int x = i;\n        int y = n; // Start just outside the south wall\n        int dx = 0;\n        int dy = -1; // Moving north\n\n        bool reached_receiver = false;\n        while (true)\n        {\n            x += dx;\n            y += dy;\n\n            // Check if the beam is out of maze boundaries\n            if (x < 0 || x >= n || y < 0 || y >= n)\n            {\n                // If it exits through the north wall, check if it reaches the intended receiver\n                if (y == -1)\n                {\n                    int receiver = x;\n                    if (receiver == a[i] - 1)\n                    {\n                        reached_receiver = true;\n                    }\n                }\n                break;\n            }\n\n            // Get the mirror in this cell\n            char c = maze[y][x];\n\n            // Change direction based on mirror\n            if (c == '/')\n            {\n                int temp = dx;\n                dx = -dy;\n                dy = -temp;\n            }\n            else if (c == '\\\\')\n            {\n                int temp = dx;\n                dx = dy;\n                dy = temp;\n            }\n            // else, no mirror, continue in the same direction\n        }\n        if (reached_receiver)\n            correct_beams++;\n    }\n\n    // Check if the number of correct beams matches the claimed number\n    if (correct_beams != m_part)\n        quitf(_wa, \"Participant's maze results in %d beams reaching their intended receivers, but claimed %d\", correct_beams, m_part);\n\n    // If everything is correct\n    quitf(_ok, \"Correct answer: %d beams reach their intended receivers\", m_part);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> permutation(n);\n\n    if (type == \"identity\") {\n        // Identity permutation\n        for (int i = 0; i < n; ++i)\n            permutation[i] = i + 1;\n    } else if (type == \"reversed\") {\n        // Reversed permutation\n        for (int i = 0; i < n; ++i)\n            permutation[i] = n - i;\n    } else if (type == \"random\") {\n        // Random permutation\n        for (int i = 0; i < n; ++i)\n            permutation[i] = i + 1;\n        shuffle(permutation.begin(), permutation.end());\n    } else if (type == \"single_swap\") {\n        // Identity permutation with a single swap\n        for (int i = 0; i < n; ++i)\n            permutation[i] = i + 1;\n        if (n >= 2) {\n            int pos = rnd.next(0, n - 2); // Swap position pos and pos + 1\n            swap(permutation[pos], permutation[pos + 1]);\n        }\n    } else if (type == \"small_cycles\") {\n        // Create permutation with cycles of size 2\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n        for (int i = 0; i < n; i += 2) {\n            if (i + 1 < n) {\n                permutation[indices[i] - 1] = indices[i + 1];\n                permutation[indices[i + 1] - 1] = indices[i];\n            } else {\n                permutation[indices[i] - 1] = indices[i];\n            }\n        }\n    } else if (type == \"large_cycle\") {\n        // Create a single large cycle\n        for (int i = 0; i < n; ++i)\n            permutation[i] = (i + 1) % n + 1;\n    } else if (type == \"sorted_pairs\") {\n        // Swap every pair in the identity permutation\n        for (int i = 0; i < n; ++i)\n            permutation[i] = i + 1;\n        for (int i = 0; i + 1 < n; i += 2)\n            swap(permutation[i], permutation[i + 1]);\n    } else {\n        // Default to random permutation\n        for (int i = 0; i < n; ++i)\n            permutation[i] = i + 1;\n        shuffle(permutation.begin(), permutation.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the permutation\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", permutation[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> permutation(n);\n\n    if (type == \"identity\") {\n        // Identity permutation\n        for (int i = 0; i < n; ++i)\n            permutation[i] = i + 1;\n    } else if (type == \"reversed\") {\n        // Reversed permutation\n        for (int i = 0; i < n; ++i)\n            permutation[i] = n - i;\n    } else if (type == \"random\") {\n        // Random permutation\n        for (int i = 0; i < n; ++i)\n            permutation[i] = i + 1;\n        shuffle(permutation.begin(), permutation.end());\n    } else if (type == \"single_swap\") {\n        // Identity permutation with a single swap\n        for (int i = 0; i < n; ++i)\n            permutation[i] = i + 1;\n        if (n >= 2) {\n            int pos = rnd.next(0, n - 2); // Swap position pos and pos + 1\n            swap(permutation[pos], permutation[pos + 1]);\n        }\n    } else if (type == \"small_cycles\") {\n        // Create permutation with cycles of size 2\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i)\n            indices[i] = i + 1;\n        shuffle(indices.begin(), indices.end());\n        for (int i = 0; i < n; i += 2) {\n            if (i + 1 < n) {\n                permutation[indices[i] - 1] = indices[i + 1];\n                permutation[indices[i + 1] - 1] = indices[i];\n            } else {\n                permutation[indices[i] - 1] = indices[i];\n            }\n        }\n    } else if (type == \"large_cycle\") {\n        // Create a single large cycle\n        for (int i = 0; i < n; ++i)\n            permutation[i] = (i + 1) % n + 1;\n    } else if (type == \"sorted_pairs\") {\n        // Swap every pair in the identity permutation\n        for (int i = 0; i < n; ++i)\n            permutation[i] = i + 1;\n        for (int i = 0; i + 1 < n; i += 2)\n            swap(permutation[i], permutation[i + 1]);\n    } else {\n        // Default to random permutation\n        for (int i = 0; i < n; ++i)\n            permutation[i] = i + 1;\n        shuffle(permutation.begin(), permutation.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the permutation\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", permutation[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type identity\n./gen -n 2 -type identity\n./gen -n 3 -type identity\n./gen -n 4 -type identity\n./gen -n 5 -type identity\n\n./gen -n 1 -type reversed\n./gen -n 2 -type reversed\n./gen -n 3 -type reversed\n./gen -n 4 -type reversed\n./gen -n 5 -type reversed\n\n./gen -n 5 -type single_swap\n./gen -n 5 -type small_cycles\n./gen -n 5 -type large_cycle\n./gen -n 5 -type sorted_pairs\n./gen -n 5 -type random\n\n./gen -n 10 -type identity\n./gen -n 10 -type reversed\n./gen -n 10 -type single_swap\n./gen -n 10 -type small_cycles\n./gen -n 10 -type large_cycle\n./gen -n 10 -type sorted_pairs\n./gen -n 10 -type random\n\n./gen -n 100 -type identity\n./gen -n 100 -type reversed\n./gen -n 100 -type single_swap\n./gen -n 100 -type small_cycles\n./gen -n 100 -type large_cycle\n./gen -n 100 -type sorted_pairs\n./gen -n 100 -type random\n\n./gen -n 1000 -type identity\n./gen -n 1000 -type reversed\n./gen -n 1000 -type single_swap\n./gen -n 1000 -type small_cycles\n./gen -n 1000 -type large_cycle\n./gen -n 1000 -type sorted_pairs\n./gen -n 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:01.591998",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1063/F",
      "title": "F. Путешествие по строке",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 секунд",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано целое число n (1 ≤ n ≤ 500 000) — длина строки s.Во второй строке содержится строка s, состоящая из n строчных английских букв.",
      "output_spec": "Выходные данныеВыведите одно число — наибольшую длину путешествия по строке s.",
      "sample_tests": "ПримерыВходные данныеСкопировать7abcdbccВыходные данныеСкопировать3Входные данныеСкопировать4bbcbВыходные данныеСкопировать2",
      "description": "F. Путешествие по строке\n\nограничение по времени на тест5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке задано целое число n (1 ≤ n ≤ 500 000) — длина строки s.Во второй строке содержится строка s, состоящая из n строчных английских букв.\n\nВходные данные\n\nВыходные данныеВыведите одно число — наибольшую длину путешествия по строке s.\n\nВыходные данные\n\nВходные данныеСкопировать7abcdbccВыходные данныеСкопировать3Входные данныеСкопировать4bbcbВыходные данныеСкопировать2\n\nВходные данныеСкопировать7abcdbcc\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4bbcb\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере путешествием по строке наибольшей длины является {abcd, bc, c}.Во втором примере подходящим вариантом будет {bb, b}.",
      "solutions": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces",
          "content": "Всем привет!В воскресенье в Москве пройдет шестнадцатая Московская командная олимпиада — командное соревнование для школьников, проходящее в Москве как отборочное соревнование на ВКОШП. Над туром работала Московская методическая комиссия, известная вам также по Открытой олимпиаде школьников по программированию, Московской олимпиаде для 6-9 классов и олимпиаде Мегаполисов (раунды 327, 342, 345, 376, 401, 433, 441, 466, 469, 507).Раунд состоится в 13:05 14 числа и продлится 2 часа. В каждом дивизионе будет предложено по 6 задач.Задачи соревнования подготовлены vintage_Vlad_Makeev, Glebodin, Andreikkaa, qoo2p5, mingaleg, Flyrise, cdkrot, achulkov2, grphil, Sehnsucht, Aphanasiy, Sender, DebNatkh, GreenGrape под моим руководством, а также GlebsHP, meshanya, Endagorion, Zlobober и Андреевой Е. В.За координацию раунда и перевод условий спасибо cdkrot, а так же MikeMirzayanov за системы codeforces и polygon, который использовался при подготовке задач этой олимпиады.Всем удачи!UPD1: Разбалловка:500 — 1000 — 1000 — 1500 — 2000 — 2500 для div. 1.500 — 1000 — 1500 — 2000 — 2000 — 2500 для div. 2.UPD2: РазборUPD3: Победители:Div. 1: mnbvmar bmerry jcvb TLEwpdus WA_TLE Div. 2: Ebola_Emperor Orange_User orbitingfIea little_waxberry fnch",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1241
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces",
          "content": "Credits:Div2A (Make a Trianle): Idea by Zlobober, development by vintage_Vlad_MakeevDiv2B (Equations of Mathematical Magic): Idea and development: GlebodinDiv1A (Oh Those Palindromes): Idea by Endagorion, development by AndreikkaaDiv1B (Labyrinth): Idea and development by qoo2p5Div1C (Dwarves, Hats and Extrasensory Abilities): Idea and development by mingaleg Div1D (Candies for Children): Idea by Endagorion, development by FlyriseDiv1E (Lasers and Mirrors): Idea and development by mingalegDiv1F (String Journey): Original idea by GreenGrape, solution by vintage_Vlad_Makeev, development vintage_Vlad_Makeev and GreenGrape 1064A - Make a triangle!Suppose cc is the largest stick. It is known, that we can build a triangle iff c≤a+b−1c≤a+b−1.So if we can build a triangle the answer is zero. Otherwise we can just increase aa or bb until the inequality above holds.So the answer is max(0,c−(a+b−1))max(0,c−(a+b−1)).Another approach: just bruteforce all possible triangles we can extend to (with sides ≤100≤100) and select the one with smallest a+b+ca+b+c. 1064B - Equations of Mathematical MagicRewriting equation we have a⊕x=a−xa⊕x=a−x.If you look in the xor definition, it is easy to see, that a⊕x≥a−xa⊕x≥a−x, no matter aa and xx (just look at the each bit of the a⊕xa⊕x).And the equality handles only if bits of xx form a subset of bits of aa.So the answer is 2t2t, where tt is the number of bits in aa (also known as popcount). 1063A - Oh Those PalindromesOne possible solution is just to sort the string.Why so?Note that each palindrome have equal character at their ends. Suppose this character is cc with xx number of occurences. Then there are at most x(x+1)/2x(x+1)/2 palindromes with this character.So we have a clear upper bound on answer. It is easy to see, that the sorted string fulfills that bound and hence it is the optimal answer. 1063B - LabyrinthSuppose we started in cell (i0, j0) and examining whether we can reach cell (i1, j1).Let's denote the number of taken moves to the right as R and number of moves to the left as LClearly, j0 + R - L = j1That is, R - L = j1 - j0 = const. Or, put otherwise R = L + const, where const only depends on the starting cell and the target cell.So in fact we just need to minimize any of the left or right moves — the other one will be optimal as well.To calculate the minimum possible number of L-moves to reach some cell we can use 0-1 bfs.Solution is O(nm). 1063C - Dwarves, Hats and Extrasensory AbilitiesThe solution is just.. binary search!We will use just a single line to put our points on. Let's maintain an invariant that all white colored points are on the left and all black colored on the right.Put a new point in the middle of the gap between white points and black points.Depending on the color said by jury shrink the gap to the left or to the right.In the end draw a diagonal line between white points and black points.The initializing binary search may look complicated but it isn't.Put a first point on the leftmost (x = 0) position, suppose that this point is white (if it is black just revert all colors), and then play as if there is a white point in x = 0 and black point in x = 109. 1063D - Candies for ChildrenSolution works in min(n2,k/n)min(n2,k/n) time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.This adds few more cases but the idea stays the same. Basically in the formulas below just few −1−1 will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.So how to solve problem in n2n2?Note, that basically we have two parts of the circle — the part between [l;r][l;r] which get's candies one times more than the rest and the other one.Since we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as xx and yy.To solve in n2n2 let's bruteforce the number of sweet tooth on first part (aa) and the number of sweet tooth on the second part (bb).Suppose that there were full tt loops. This way the number of eaten candies is a∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗ta∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗t.This should be equal to kk. Since we just bruteforced the values of aa and bb we now just have linear equation. If it is solvable, consider relaxing answer with a+ba+b.How to solve problem in k/nk/n?So as the asymptotic suggests the amount of turns ≤k/n≤k/n, so we can bruteforce it instead.Also it is worthy to handle case of 00 turns specifically here since it produces some unpleasant effects otherwise.So each person in \"xx\" part of the circle eats candies t+1t+1 times (so each person contributes t+1t+1 or 2t+22t+2) and the other persons have eaten candies tt times (so each person contributes tt or 2t2t).Let's account all persons as if they are not sweet tooths.So now each person in xx contributes 00 or t+1t+1 and each person in yy contributes 00 or tt.So we basically have (t+1)a+tb=γ(t+1)a+tb=γ. A Diophantine equation.Careful analysis or bits of theory suggest that the solutions area=a0−tza=a0−tz, b=b0+(t+1)zb=b0+(t+1)z, for all integer zz.Where a0a0 and b0b0 some arbitrary solutions which we can get with formulas.Also we need to have 0≤a≤x0≤a≤x, 0≤b≤y0≤b≤y, and the a+b→maxa+b→max.These bounds imply that tt takes values only in some range [t1;t2][t1;t2].Since the a+ba+b is linear function we can only consider t1t1 and t2t2 while searching for maximum a+ba+b. 1063E - Lasers and MirrorsThe answer is always nn (if the permutation is identity) lasers or n−1n−1 (otherwise).Clearly, we can't have more than n−1n−1 matching lasers if the permutation is not identity. Consider just the very first line with mirrors. If the first mirror in this line is «\\» then we miss the laser below this mirror, if the very last mirror is «/» we miss the laser below it. Otherwise there are neighbouring «/» and «\\» and we lost two lasers now.The proof of n−1n−1 is constructive one.Ignore all fixed points in permutation (all xx, that px=xpx=x).Select arbitrary cycle and select one point in it as «dead». We can spend |cycle|−1|cycle|−1 operations to fix all points in this cycle.But we also need to fix all other cycles. We can do it in |cycle|+1|cycle|+1 operations: move arbitrary beam to the wasted laser, fix all other points and move that point back.But this is a bit too much lines.The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line, if we select as the trash beam the rightmost point.See the following picture for an example (trash beam is the rightmost column): 1063F - String JourneyThis problem required quite a lot of nice observations!Observation 1. We can only consider journeys in which neighboring strings differ exactly by removing one symbol.All other journeys can be modified a bit to match the criterion above.Observation 2. If it is possible to start a journey at the symbol i with lengths of strings k, k - 1, ..., 1, it is always possible to start a journey at the same symbol i with lengths t, t - 1, ..., 1, given that t ≤ k.This suggests doing dynamic programming: dp[i] is the maximum possible k such that there is a journey starting at position i of k strings with lengths k, ..., 1.Due to observation 1 we only care about maximum – if we know maximum, we also known that all lesser values are also OK.So let's calculate this dynamic programming from right to left.How to check whether dp[i] ≥ k (given that tool, we can just use binary search for example)?There must be such j, that j ≥ i + k, dp[j] ≥ k - 1 and string sj, ..., sj + k - 2 must be a substring of string sisi + 1... si + k - 1 (basically just two cases \"left substring\" or \"right substring\").This almost gives us a solution, but we need few more observations to have , and not .Observation 3. If dp[i] = k, then dp[i + 1] ≥ k - 1.We can use this to kick binary search from the solution — when you calculate dp[i] you can start trying with dp[i + 1] + 1, descending until the success.Since there are exactly n grows, there will be at most n descendings and the total number of checks is linear. ?Observation? 4. We need to check whether such j exists in a fast way.Recall there are few conditions for us to follow, dp[j] ≥ const, j ≥ const and some string equality.If you carefully look at the restriction j ≥ const you can see, that when we move our dp calculation i → i - 1 or make dp[i] -= 1 this lower bound on j also moves only left, like in two pointers. So each moment some indexes j are \"available\" and some are not, and the border moves only left.Finally, time for some structures. Build Suffix Array and build segment tree over it. Let's store in the leaf of the segment tree dp[j] if it's already available or  - 1 otherwise.Let's check whether dp[i] = k is good. We want for string starting at j be either si, si + 1, ..., si + k - 2, or si + 1, si + 2, ..., si + k - 1. Consider these cases independently (however the procedure is pretty much same).All such strings form a segment of Suffix Array, we can for example use LCP + binary search over sparse tables to find corresponding bounds.Then we just need to query this segment and check if the maximum on it is at least k - 1.The solution is",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62455",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1063\\s*F"
          },
          "content_length": 9243
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 1",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 2",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 3",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 4",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 5",
          "code": "sort(s.begin(), s.end()); cout<<s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 6",
          "code": "'a - 3 times, aa - 2 times aaa - 1 time, total - 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 7",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 8",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 11",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 12",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 13",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 14",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 15",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 16",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 1",
          "code": "you have to call dfs with cell C again; \n   why?\n  because, now C has lesser leftCount or rightCount than before....so it may \n           able to visit more cells than before",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 2",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 3",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"samechar\") {\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"alternating\") {\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c1 == c2) c2 = 'a' + rnd.next(26);\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"decreasing\") {\n        // Build a string where s is comprised of decreasing prefixes\n        char c = 'a' + rnd.next(26);\n        for (int i = 0; i < n; ++i) {\n            s += (char)((c + i) % 26 + 'a');\n        }\n    } else if (type == \"palindromic\") {\n        string half;\n        for (int i = 0; i < n / 2; ++i) {\n            half += (char)('a' + rnd.next(26));\n        }\n        s = half;\n        if (n % 2 == 1) {\n            s += (char)('a' + rnd.next(26));\n        }\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (type == \"randommax\") {\n        n = 500000; // Maximum allowed length\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    }\n\n    // Output n and s\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"samechar\") {\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"alternating\") {\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c1 == c2) c2 = 'a' + rnd.next(26);\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"decreasing\") {\n        // Build a string where s is comprised of decreasing prefixes\n        char c = 'a' + rnd.next(26);\n        for (int i = 0; i < n; ++i) {\n            s += (char)((c + i) % 26 + 'a');\n        }\n    } else if (type == \"palindromic\") {\n        string half;\n        for (int i = 0; i < n / 2; ++i) {\n            half += (char)('a' + rnd.next(26));\n        }\n        s = half;\n        if (n % 2 == 1) {\n            s += (char)('a' + rnd.next(26));\n        }\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (type == \"randommax\") {\n        n = 500000; // Maximum allowed length\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n    }\n\n    // Output n and s\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type samechar\n./gen -n 1 -type random\n\n./gen -n 2 -type samechar\n./gen -n 2 -type alternating\n\n./gen -n 3 -type decreasing\n\n./gen -n 5 -type random\n\n./gen -n 5 -type palindromic\n\n./gen -n 10 -type random\n\n./gen -n 15 -type decreasing\n\n./gen -n 20 -type palindromic\n\n./gen -n 50 -type alternating\n\n./gen -n 100 -type samechar\n\n./gen -n 200 -type random\n\n./gen -n 500 -type decreasing\n\n./gen -n 1000 -type palindromic\n\n./gen -n 2000 -type random\n\n./gen -n 5000 -type samechar\n\n./gen -n 10000 -type decreasing\n\n./gen -n 20000 -type random\n\n./gen -n 50000 -type palindromic\n\n./gen -n 100000 -type random\n\n./gen -n 200000 -type decreasing\n\n./gen -n 300000 -type samechar\n\n./gen -n 400000 -type random\n\n./gen -n 500000 -type palindromic\n\n./gen -n 500000 -type randommax\n\n./gen -n 500000 -type samechar\n\n./gen -n 500000 -type alternating\n\n./gen -n 500000 -type decreasing\n\n./gen -n 500000 -type random\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:03.641741",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1064/A",
      "title": "A. Сделай треугольник!",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке даны три целых числа aa, bb и cc (1≤a,b,c≤1001≤a,b,c≤100) — длины палочек, которые есть у Маши.",
      "output_spec": "Выходные данныеВыведите одно целое число — минимальное количество минут, за которое Маша сможет сделать треугольник положительной площади из своих палочек.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 4 5Выходные данныеСкопировать0Входные данныеСкопировать2 5 3Выходные данныеСкопировать1Входные данныеСкопировать100 10 10Выходные данныеСкопировать81",
      "description": "A. Сделай треугольник!\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке даны три целых числа aa, bb и cc (1≤a,b,c≤1001≤a,b,c≤100) — длины палочек, которые есть у Маши.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — минимальное количество минут, за которое Маша сможет сделать треугольник положительной площади из своих палочек.\n\nВыходные данные\n\nВходные данныеСкопировать3 4 5Выходные данныеСкопировать0Входные данныеСкопировать2 5 3Выходные данныеСкопировать1Входные данныеСкопировать100 10 10Выходные данныеСкопировать81\n\nВходные данныеСкопировать3 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 5 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать100 10 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать81\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Маша может сделать треугольник из палочек, не меняя длины ни одной из палочек.Во втором примере Маша не может построить треугольник положительной площади из палочек, которые у нее есть, но может удлинить палочку длиной 22 сантиметра на один сантиметр за одну минуту, после чего построить треугольник из палочек со сторонами 33, 33 и 55 сантиметров.В третьем примере Маша может за 3333 минуты удлинить одну из палочек длиной 1010 сантиметров на 3333 сантиметра, а затем за 4848 минут удлинить другую палочку длиной 1010 сантиметров на 4848 сантиметров. Таким образом, Маша может собрать треугольник со сторонами 4343, 5858 и 100100 сантиметров за 8181 минуту. Можно показать, что Маша не сможет получить треугольник за меньшее время.",
      "solutions": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces",
          "content": "Всем привет!В воскресенье в Москве пройдет шестнадцатая Московская командная олимпиада — командное соревнование для школьников, проходящее в Москве как отборочное соревнование на ВКОШП. Над туром работала Московская методическая комиссия, известная вам также по Открытой олимпиаде школьников по программированию, Московской олимпиаде для 6-9 классов и олимпиаде Мегаполисов (раунды 327, 342, 345, 376, 401, 433, 441, 466, 469, 507).Раунд состоится в 13:05 14 числа и продлится 2 часа. В каждом дивизионе будет предложено по 6 задач.Задачи соревнования подготовлены vintage_Vlad_Makeev, Glebodin, Andreikkaa, qoo2p5, mingaleg, Flyrise, cdkrot, achulkov2, grphil, Sehnsucht, Aphanasiy, Sender, DebNatkh, GreenGrape под моим руководством, а также GlebsHP, meshanya, Endagorion, Zlobober и Андреевой Е. В.За координацию раунда и перевод условий спасибо cdkrot, а так же MikeMirzayanov за системы codeforces и polygon, который использовался при подготовке задач этой олимпиады.Всем удачи!UPD1: Разбалловка:500 — 1000 — 1000 — 1500 — 2000 — 2500 для div. 1.500 — 1000 — 1500 — 2000 — 2000 — 2500 для div. 2.UPD2: РазборUPD3: Победители:Div. 1: mnbvmar bmerry jcvb TLEwpdus WA_TLE Div. 2: Ebola_Emperor Orange_User orbitingfIea little_waxberry fnch",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1241
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces",
          "content": "Credits:Div2A (Make a Trianle): Idea by Zlobober, development by vintage_Vlad_MakeevDiv2B (Equations of Mathematical Magic): Idea and development: GlebodinDiv1A (Oh Those Palindromes): Idea by Endagorion, development by AndreikkaaDiv1B (Labyrinth): Idea and development by qoo2p5Div1C (Dwarves, Hats and Extrasensory Abilities): Idea and development by mingaleg Div1D (Candies for Children): Idea by Endagorion, development by FlyriseDiv1E (Lasers and Mirrors): Idea and development by mingalegDiv1F (String Journey): Original idea by GreenGrape, solution by vintage_Vlad_Makeev, development vintage_Vlad_Makeev and GreenGrape 1064A - Make a triangle!Suppose cc is the largest stick. It is known, that we can build a triangle iff c≤a+b−1c≤a+b−1.So if we can build a triangle the answer is zero. Otherwise we can just increase aa or bb until the inequality above holds.So the answer is max(0,c−(a+b−1))max(0,c−(a+b−1)).Another approach: just bruteforce all possible triangles we can extend to (with sides ≤100≤100) and select the one with smallest a+b+ca+b+c. 1064B - Equations of Mathematical MagicRewriting equation we have a⊕x=a−xa⊕x=a−x.If you look in the xor definition, it is easy to see, that a⊕x≥a−xa⊕x≥a−x, no matter aa and xx (just look at the each bit of the a⊕xa⊕x).And the equality handles only if bits of xx form a subset of bits of aa.So the answer is 2t2t, where tt is the number of bits in aa (also known as popcount). 1063A - Oh Those PalindromesOne possible solution is just to sort the string.Why so?Note that each palindrome have equal character at their ends. Suppose this character is cc with xx number of occurences. Then there are at most x(x+1)/2x(x+1)/2 palindromes with this character.So we have a clear upper bound on answer. It is easy to see, that the sorted string fulfills that bound and hence it is the optimal answer. 1063B - LabyrinthSuppose we started in cell (i0, j0) and examining whether we can reach cell (i1, j1).Let's denote the number of taken moves to the right as R and number of moves to the left as LClearly, j0 + R - L = j1That is, R - L = j1 - j0 = const. Or, put otherwise R = L + const, where const only depends on the starting cell and the target cell.So in fact we just need to minimize any of the left or right moves — the other one will be optimal as well.To calculate the minimum possible number of L-moves to reach some cell we can use 0-1 bfs.Solution is O(nm). 1063C - Dwarves, Hats and Extrasensory AbilitiesThe solution is just.. binary search!We will use just a single line to put our points on. Let's maintain an invariant that all white colored points are on the left and all black colored on the right.Put a new point in the middle of the gap between white points and black points.Depending on the color said by jury shrink the gap to the left or to the right.In the end draw a diagonal line between white points and black points.The initializing binary search may look complicated but it isn't.Put a first point on the leftmost (x = 0) position, suppose that this point is white (if it is black just revert all colors), and then play as if there is a white point in x = 0 and black point in x = 109. 1063D - Candies for ChildrenSolution works in min(n2,k/n)min(n2,k/n) time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.This adds few more cases but the idea stays the same. Basically in the formulas below just few −1−1 will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.So how to solve problem in n2n2?Note, that basically we have two parts of the circle — the part between [l;r][l;r] which get's candies one times more than the rest and the other one.Since we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as xx and yy.To solve in n2n2 let's bruteforce the number of sweet tooth on first part (aa) and the number of sweet tooth on the second part (bb).Suppose that there were full tt loops. This way the number of eaten candies is a∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗ta∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗t.This should be equal to kk. Since we just bruteforced the values of aa and bb we now just have linear equation. If it is solvable, consider relaxing answer with a+ba+b.How to solve problem in k/nk/n?So as the asymptotic suggests the amount of turns ≤k/n≤k/n, so we can bruteforce it instead.Also it is worthy to handle case of 00 turns specifically here since it produces some unpleasant effects otherwise.So each person in \"xx\" part of the circle eats candies t+1t+1 times (so each person contributes t+1t+1 or 2t+22t+2) and the other persons have eaten candies tt times (so each person contributes tt or 2t2t).Let's account all persons as if they are not sweet tooths.So now each person in xx contributes 00 or t+1t+1 and each person in yy contributes 00 or tt.So we basically have (t+1)a+tb=γ(t+1)a+tb=γ. A Diophantine equation.Careful analysis or bits of theory suggest that the solutions area=a0−tza=a0−tz, b=b0+(t+1)zb=b0+(t+1)z, for all integer zz.Where a0a0 and b0b0 some arbitrary solutions which we can get with formulas.Also we need to have 0≤a≤x0≤a≤x, 0≤b≤y0≤b≤y, and the a+b→maxa+b→max.These bounds imply that tt takes values only in some range [t1;t2][t1;t2].Since the a+ba+b is linear function we can only consider t1t1 and t2t2 while searching for maximum a+ba+b. 1063E - Lasers and MirrorsThe answer is always nn (if the permutation is identity) lasers or n−1n−1 (otherwise).Clearly, we can't have more than n−1n−1 matching lasers if the permutation is not identity. Consider just the very first line with mirrors. If the first mirror in this line is «\\» then we miss the laser below this mirror, if the very last mirror is «/» we miss the laser below it. Otherwise there are neighbouring «/» and «\\» and we lost two lasers now.The proof of n−1n−1 is constructive one.Ignore all fixed points in permutation (all xx, that px=xpx=x).Select arbitrary cycle and select one point in it as «dead». We can spend |cycle|−1|cycle|−1 operations to fix all points in this cycle.But we also need to fix all other cycles. We can do it in |cycle|+1|cycle|+1 operations: move arbitrary beam to the wasted laser, fix all other points and move that point back.But this is a bit too much lines.The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line, if we select as the trash beam the rightmost point.See the following picture for an example (trash beam is the rightmost column): 1063F - String JourneyThis problem required quite a lot of nice observations!Observation 1. We can only consider journeys in which neighboring strings differ exactly by removing one symbol.All other journeys can be modified a bit to match the criterion above.Observation 2. If it is possible to start a journey at the symbol i with lengths of strings k, k - 1, ..., 1, it is always possible to start a journey at the same symbol i with lengths t, t - 1, ..., 1, given that t ≤ k.This suggests doing dynamic programming: dp[i] is the maximum possible k such that there is a journey starting at position i of k strings with lengths k, ..., 1.Due to observation 1 we only care about maximum – if we know maximum, we also known that all lesser values are also OK.So let's calculate this dynamic programming from right to left.How to check whether dp[i] ≥ k (given that tool, we can just use binary search for example)?There must be such j, that j ≥ i + k, dp[j] ≥ k - 1 and string sj, ..., sj + k - 2 must be a substring of string sisi + 1... si + k - 1 (basically just two cases \"left substring\" or \"right substring\").This almost gives us a solution, but we need few more observations to have , and not .Observation 3. If dp[i] = k, then dp[i + 1] ≥ k - 1.We can use this to kick binary search from the solution — when you calculate dp[i] you can start trying with dp[i + 1] + 1, descending until the success.Since there are exactly n grows, there will be at most n descendings and the total number of checks is linear. ?Observation? 4. We need to check whether such j exists in a fast way.Recall there are few conditions for us to follow, dp[j] ≥ const, j ≥ const and some string equality.If you carefully look at the restriction j ≥ const you can see, that when we move our dp calculation i → i - 1 or make dp[i] -= 1 this lower bound on j also moves only left, like in two pointers. So each moment some indexes j are \"available\" and some are not, and the border moves only left.Finally, time for some structures. Build Suffix Array and build segment tree over it. Let's store in the leaf of the segment tree dp[j] if it's already available or  - 1 otherwise.Let's check whether dp[i] = k is good. We want for string starting at j be either si, si + 1, ..., si + k - 2, or si + 1, si + 2, ..., si + k - 1. Consider these cases independently (however the procedure is pretty much same).All such strings form a segment of Suffix Array, we can for example use LCP + binary search over sparse tables to find corresponding bounds.Then we just need to query this segment and check if the maximum on it is at least k - 1.The solution is",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62455",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1064\\s*A"
          },
          "content_length": 9243
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 1",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 2",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 3",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 4",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 5",
          "code": "sort(s.begin(), s.end()); cout<<s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 6",
          "code": "'a - 3 times, aa - 2 times aaa - 1 time, total - 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 7",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 8",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 11",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 12",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 13",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 14",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 15",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 16",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 1",
          "code": "you have to call dfs with cell C again; \n   why?\n  because, now C has lesser leftCount or rightCount than before....so it may \n           able to visit more cells than before",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 2",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 3",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 100, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 100, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 100, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int a, b, c;\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random sides within [1, 100]\n        a = rnd.next(1, 100);\n        b = rnd.next(1, 100);\n        c = rnd.next(1, 100);\n    } else if (type == \"max\") {\n        // Maximum sides\n        a = b = c = 100;\n    } else if (type == \"min\") {\n        // Minimum sides\n        a = b = c = 1;\n    } else if (type == \"equal\") {\n        // Equal sides\n        a = b = c = rnd.next(1, 100);\n    } else if (type == \"triangle_fails\") {\n        // a + b ≤ c (triangle inequality fails)\n        a = rnd.next(1, 50);\n        b = rnd.next(1, 50);\n        int sum_ab = a + b;\n        int c_min = sum_ab;\n        int c_max = 100;\n        if (c_min > c_max) c_min = c_max;\n        c = rnd.next(c_min, c_max);\n    } else if (type == \"triangle_barely_fails\") {\n        // a + b = c (triangle inequality barely fails)\n        a = rnd.next(1, 50);\n        b = rnd.next(1, 50);\n        c = a + b;\n        if (c > 100) {\n            c = 100;\n            a = rnd.next(1, c - 1);\n            b = c - a;\n        }\n    } else if (type == \"triangle_just_passes\") {\n        // a + b = c + 1 (triangle inequality just holds)\n        c = rnd.next(1, 98); // c ≤ 98\n        int sum_ab = c + 1;\n        a = rnd.next(1, min(100, sum_ab - 1));\n        b = sum_ab - a;\n        if (b > 100) b = 100;\n    } else if (type == \"one_large_side\") {\n        // One side is much larger than the other two\n        vector<int> sides = {1, 1, 100};\n        shuffle(sides.begin(), sides.end());\n        a = sides[0];\n        b = sides[1];\n        c = sides[2];\n    } else if (type == \"cases_needing_zero_minutes\") {\n        // Triangle inequality holds without any increments\n        a = rnd.next(1, 100);\n        b = rnd.next(1, 100);\n        int min_c = max(abs(a - b) + 1, 1);\n        int max_c = min(a + b - 1, 100);\n        if (min_c > max_c) swap(min_c, max_c);\n        if (min_c > max_c) {\n            // If min_c still greater than max_c, set c to 100\n            c = 100;\n        } else {\n            c = rnd.next(min_c, max_c);\n        }\n    } else if (type == \"cases_needing_one_minute\") {\n        // Need one increment to satisfy triangle inequality\n        a = rnd.next(1, 50);\n        b = rnd.next(1, 50);\n        c = a + b - 1;\n        if (c < 1) c = 1;\n        if (c > 100) {\n            c = 100;\n            a = rnd.next(1, c - 1);\n            b = c - a + 1;\n            if (b > 100) b = 100;\n        }\n    } else if (type == \"max_increase_needed\") {\n        // Maximum number of minutes needed to form a triangle\n        a = b = 1;\n        c = 100;\n    } else if (type == \"large_random\") {\n        // Random large sides\n        a = rnd.next(80, 100);\n        b = rnd.next(80, 100);\n        c = rnd.next(80, 100);\n    } else {\n        // Default random sides\n        a = rnd.next(1, 100);\n        b = rnd.next(1, 100);\n        c = rnd.next(1, 100);\n    }\n\n    // Ensure sides are within [1, 100]\n    a = max(1, min(a, 100));\n    b = max(1, min(b, 100));\n    c = max(1, min(c, 100));\n\n    printf(\"%d %d %d\\n\", a, b, c);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int a, b, c;\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random sides within [1, 100]\n        a = rnd.next(1, 100);\n        b = rnd.next(1, 100);\n        c = rnd.next(1, 100);\n    } else if (type == \"max\") {\n        // Maximum sides\n        a = b = c = 100;\n    } else if (type == \"min\") {\n        // Minimum sides\n        a = b = c = 1;\n    } else if (type == \"equal\") {\n        // Equal sides\n        a = b = c = rnd.next(1, 100);\n    } else if (type == \"triangle_fails\") {\n        // a + b ≤ c (triangle inequality fails)\n        a = rnd.next(1, 50);\n        b = rnd.next(1, 50);\n        int sum_ab = a + b;\n        int c_min = sum_ab;\n        int c_max = 100;\n        if (c_min > c_max) c_min = c_max;\n        c = rnd.next(c_min, c_max);\n    } else if (type == \"triangle_barely_fails\") {\n        // a + b = c (triangle inequality barely fails)\n        a = rnd.next(1, 50);\n        b = rnd.next(1, 50);\n        c = a + b;\n        if (c > 100) {\n            c = 100;\n            a = rnd.next(1, c - 1);\n            b = c - a;\n        }\n    } else if (type == \"triangle_just_passes\") {\n        // a + b = c + 1 (triangle inequality just holds)\n        c = rnd.next(1, 98); // c ≤ 98\n        int sum_ab = c + 1;\n        a = rnd.next(1, min(100, sum_ab - 1));\n        b = sum_ab - a;\n        if (b > 100) b = 100;\n    } else if (type == \"one_large_side\") {\n        // One side is much larger than the other two\n        vector<int> sides = {1, 1, 100};\n        shuffle(sides.begin(), sides.end());\n        a = sides[0];\n        b = sides[1];\n        c = sides[2];\n    } else if (type == \"cases_needing_zero_minutes\") {\n        // Triangle inequality holds without any increments\n        a = rnd.next(1, 100);\n        b = rnd.next(1, 100);\n        int min_c = max(abs(a - b) + 1, 1);\n        int max_c = min(a + b - 1, 100);\n        if (min_c > max_c) swap(min_c, max_c);\n        if (min_c > max_c) {\n            // If min_c still greater than max_c, set c to 100\n            c = 100;\n        } else {\n            c = rnd.next(min_c, max_c);\n        }\n    } else if (type == \"cases_needing_one_minute\") {\n        // Need one increment to satisfy triangle inequality\n        a = rnd.next(1, 50);\n        b = rnd.next(1, 50);\n        c = a + b - 1;\n        if (c < 1) c = 1;\n        if (c > 100) {\n            c = 100;\n            a = rnd.next(1, c - 1);\n            b = c - a + 1;\n            if (b > 100) b = 100;\n        }\n    } else if (type == \"max_increase_needed\") {\n        // Maximum number of minutes needed to form a triangle\n        a = b = 1;\n        c = 100;\n    } else if (type == \"large_random\") {\n        // Random large sides\n        a = rnd.next(80, 100);\n        b = rnd.next(80, 100);\n        c = rnd.next(80, 100);\n    } else {\n        // Default random sides\n        a = rnd.next(1, 100);\n        b = rnd.next(1, 100);\n        c = rnd.next(1, 100);\n    }\n\n    // Ensure sides are within [1, 100]\n    a = max(1, min(a, 100));\n    b = max(1, min(b, 100));\n    c = max(1, min(c, 100));\n\n    printf(\"%d %d %d\\n\", a, b, c);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type max\n./gen -type min\n\n./gen -type equal\n./gen -type equal\n./gen -type equal\n\n./gen -type triangle_fails\n./gen -type triangle_fails\n\n./gen -type triangle_barely_fails\n./gen -type triangle_barely_fails\n\n./gen -type triangle_just_passes\n./gen -type triangle_just_passes\n\n./gen -type one_large_side\n./gen -type one_large_side\n\n./gen -type cases_needing_zero_minutes\n./gen -type cases_needing_zero_minutes\n\n./gen -type cases_needing_one_minute\n./gen -type cases_needing_one_minute\n\n./gen -type max_increase_needed\n./gen -type max_increase_needed\n\n./gen -type large_random\n./gen -type large_random\n./gen -type large_random\n./gen -type large_random\n./gen -type large_random\n\n./gen -type random\n./gen -type triangle_fails\n./gen -type triangle_barely_fails\n./gen -type triangle_just_passes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:05.510334",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1064/B",
      "title": "B. Equations of Mathematical Magic",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputEach test contains several possible values of aa and your task is to find the number of equation's solution for each of them. The first line contains an integer tt (1≤t≤10001≤t≤1000) — the number of these values.The following tt lines contain the values of parameter aa, each value is an integer from 00 to 230−1230−1 inclusive.",
      "output_spec": "OutputFor each value of aa print exactly one integer — the number of non-negative solutions of the equation for the given value of the parameter. Print answers in the same order as values of aa appear in the input.One can show that the number of solutions is always finite.",
      "sample_tests": "ExampleInputCopy3021073741823OutputCopy121073741824",
      "description": "B. Equations of Mathematical Magic\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nColossal! — exclaimed Hawk-nose. — A programmer! That's exactly what we are looking for.Arkadi and Boris Strugatsky. Monday starts on Saturday\n\nColossal! — exclaimed Hawk-nose. — A programmer! That's exactly what we are looking for.\n\nArkadi and Boris Strugatsky. Monday starts on Saturday\n\nInputEach test contains several possible values of aa and your task is to find the number of equation's solution for each of them. The first line contains an integer tt (1≤t≤10001≤t≤1000) — the number of these values.The following tt lines contain the values of parameter aa, each value is an integer from 00 to 230−1230−1 inclusive.\n\nOutputFor each value of aa print exactly one integer — the number of non-negative solutions of the equation for the given value of the parameter. Print answers in the same order as values of aa appear in the input.One can show that the number of solutions is always finite.\n\nInputCopy3021073741823OutputCopy121073741824\n\nInputCopy3021073741823\n\nOutputCopy121073741824\n\nNoteLet's define the bitwise exclusive OR (XOR) operation. Given two integers xx and yy, consider their binary representations (possibly with leading zeroes): xk…x2x1x0xk…x2x1x0 and yk…y2y1y0yk…y2y1y0. Here, xixi is the ii-th bit of the number xx and yiyi is the ii-th bit of the number yy. Let r=x⊕yr=x⊕y be the result of the XOR operation of xx and yy. Then rr is defined as rk…r2r1r0rk…r2r1r0 where:ri={1, if xi≠yi0, if xi=yiri={1, if xi≠yi0, if xi=yiFor the first value of the parameter, only x=0x=0 is a solution of the equation.For the second value of the parameter, solutions are x=0x=0 and x=2x=2.\n\nri={1, if xi≠yi0, if xi=yiri={1, if xi≠yi0, if xi=yi",
      "solutions": [
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces",
          "content": "Hi everybody,This Sunday there will be a 16th Moscow Team Olympiad, high school students competition based in Moscow that is an elimination contest for All-Russian Team Olympiad. This contest is prepared by Moscow Olympiad Scientific Committee that you may know by Moscow Open Olympiad, Moscow Olympiad for Young Students and Metropolises Olympiad (rounds 327, 342, 345, 376, 401, 433, 441, 466, 469, 507).Round will be held at 10:05 UTC on Sunday and will last for 2 hours. Each division will have 6 problems.Problems are prepared vintage_Vlad_Makeev, Glebodin, Andreikkaa, qoo2p5, mingaleg, Flyrise, cdkrot, achulkov2, grphil, Sehnsucht, Aphanasiy, Sender, DebNatkh, GreenGrape under my supervision with great help of GlebsHP, meshanya, Endagorion, Zlobober and Helen Andreeva.Thanks to cdkrot for the round coordination and statement translation, and also thanks for MikeMirzayanov for systems codeforces and polygon, which was used to prepare problems of this olympiad.Good luck everybody!UPD1: The scoring distribution will be:500 — 1000 — 1000 — 1500 — 2000 — 2500 for div. 1.500 — 1000 — 1500 — 2000 — 2000 — 2500 for div. 2.UPD2: EditorialUPD3: Winners:Div. 1: mnbvmar bmerry jcvb TLEwpdus WA_TLE Div. 2: Ebola_Emperor Orange_User orbitingfIea little_waxberry fnch",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/62440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1272
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces",
          "content": "Credits:Div2A (Make a Trianle): Idea by Zlobober, development by vintage_Vlad_MakeevDiv2B (Equations of Mathematical Magic): Idea and development: GlebodinDiv1A (Oh Those Palindromes): Idea by Endagorion, development by AndreikkaaDiv1B (Labyrinth): Idea and development by qoo2p5Div1C (Dwarves, Hats and Extrasensory Abilities): Idea and development by mingaleg Div1D (Candies for Children): Idea by Endagorion, development by FlyriseDiv1E (Lasers and Mirrors): Idea and development by mingalegDiv1F (String Journey): Original idea by GreenGrape, solution by vintage_Vlad_Makeev, development vintage_Vlad_Makeev and GreenGrape 1064A - Make a triangle!Suppose cc is the largest stick. It is known, that we can build a triangle iff c≤a+b−1c≤a+b−1.So if we can build a triangle the answer is zero. Otherwise we can just increase aa or bb until the inequality above holds.So the answer is max(0,c−(a+b−1))max(0,c−(a+b−1)).Another approach: just bruteforce all possible triangles we can extend to (with sides ≤100≤100) and select the one with smallest a+b+ca+b+c. 1064B - Equations of Mathematical MagicRewriting equation we have a⊕x=a−xa⊕x=a−x.If you look in the xor definition, it is easy to see, that a⊕x≥a−xa⊕x≥a−x, no matter aa and xx (just look at the each bit of the a⊕xa⊕x).And the equality handles only if bits of xx form a subset of bits of aa.So the answer is 2t2t, where tt is the number of bits in aa (also known as popcount). 1063A - Oh Those PalindromesOne possible solution is just to sort the string.Why so?Note that each palindrome have equal character at their ends. Suppose this character is cc with xx number of occurences. Then there are at most x(x+1)/2x(x+1)/2 palindromes with this character.So we have a clear upper bound on answer. It is easy to see, that the sorted string fulfills that bound and hence it is the optimal answer. 1063B - LabyrinthSuppose we started in cell (i0, j0) and examining whether we can reach cell (i1, j1).Let's denote the number of taken moves to the right as R and number of moves to the left as LClearly, j0 + R - L = j1That is, R - L = j1 - j0 = const. Or, put otherwise R = L + const, where const only depends on the starting cell and the target cell.So in fact we just need to minimize any of the left or right moves — the other one will be optimal as well.To calculate the minimum possible number of L-moves to reach some cell we can use 0-1 bfs.Solution is O(nm). 1063C - Dwarves, Hats and Extrasensory AbilitiesThe solution is just.. binary search!We will use just a single line to put our points on. Let's maintain an invariant that all white colored points are on the left and all black colored on the right.Put a new point in the middle of the gap between white points and black points.Depending on the color said by jury shrink the gap to the left or to the right.In the end draw a diagonal line between white points and black points.The initializing binary search may look complicated but it isn't.Put a first point on the leftmost (x = 0) position, suppose that this point is white (if it is black just revert all colors), and then play as if there is a white point in x = 0 and black point in x = 109. 1063D - Candies for ChildrenSolution works in min(n2,k/n)min(n2,k/n) time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.This adds few more cases but the idea stays the same. Basically in the formulas below just few −1−1 will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.So how to solve problem in n2n2?Note, that basically we have two parts of the circle — the part between [l;r][l;r] which get's candies one times more than the rest and the other one.Since we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as xx and yy.To solve in n2n2 let's bruteforce the number of sweet tooth on first part (aa) and the number of sweet tooth on the second part (bb).Suppose that there were full tt loops. This way the number of eaten candies is a∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗ta∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗t.This should be equal to kk. Since we just bruteforced the values of aa and bb we now just have linear equation. If it is solvable, consider relaxing answer with a+ba+b.How to solve problem in k/nk/n?So as the asymptotic suggests the amount of turns ≤k/n≤k/n, so we can bruteforce it instead.Also it is worthy to handle case of 00 turns specifically here since it produces some unpleasant effects otherwise.So each person in \"xx\" part of the circle eats candies t+1t+1 times (so each person contributes t+1t+1 or 2t+22t+2) and the other persons have eaten candies tt times (so each person contributes tt or 2t2t).Let's account all persons as if they are not sweet tooths.So now each person in xx contributes 00 or t+1t+1 and each person in yy contributes 00 or tt.So we basically have (t+1)a+tb=γ(t+1)a+tb=γ. A Diophantine equation.Careful analysis or bits of theory suggest that the solutions area=a0−tza=a0−tz, b=b0+(t+1)zb=b0+(t+1)z, for all integer zz.Where a0a0 and b0b0 some arbitrary solutions which we can get with formulas.Also we need to have 0≤a≤x0≤a≤x, 0≤b≤y0≤b≤y, and the a+b→maxa+b→max.These bounds imply that tt takes values only in some range [t1;t2][t1;t2].Since the a+ba+b is linear function we can only consider t1t1 and t2t2 while searching for maximum a+ba+b. 1063E - Lasers and MirrorsThe answer is always nn (if the permutation is identity) lasers or n−1n−1 (otherwise).Clearly, we can't have more than n−1n−1 matching lasers if the permutation is not identity. Consider just the very first line with mirrors. If the first mirror in this line is «\\» then we miss the laser below this mirror, if the very last mirror is «/» we miss the laser below it. Otherwise there are neighbouring «/» and «\\» and we lost two lasers now.The proof of n−1n−1 is constructive one.Ignore all fixed points in permutation (all xx, that px=xpx=x).Select arbitrary cycle and select one point in it as «dead». We can spend |cycle|−1|cycle|−1 operations to fix all points in this cycle.But we also need to fix all other cycles. We can do it in |cycle|+1|cycle|+1 operations: move arbitrary beam to the wasted laser, fix all other points and move that point back.But this is a bit too much lines.The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line, if we select as the trash beam the rightmost point.See the following picture for an example (trash beam is the rightmost column): 1063F - String JourneyThis problem required quite a lot of nice observations!Observation 1. We can only consider journeys in which neighboring strings differ exactly by removing one symbol.All other journeys can be modified a bit to match the criterion above.Observation 2. If it is possible to start a journey at the symbol i with lengths of strings k, k - 1, ..., 1, it is always possible to start a journey at the same symbol i with lengths t, t - 1, ..., 1, given that t ≤ k.This suggests doing dynamic programming: dp[i] is the maximum possible k such that there is a journey starting at position i of k strings with lengths k, ..., 1.Due to observation 1 we only care about maximum – if we know maximum, we also known that all lesser values are also OK.So let's calculate this dynamic programming from right to left.How to check whether dp[i] ≥ k (given that tool, we can just use binary search for example)?There must be such j, that j ≥ i + k, dp[j] ≥ k - 1 and string sj, ..., sj + k - 2 must be a substring of string sisi + 1... si + k - 1 (basically just two cases \"left substring\" or \"right substring\").This almost gives us a solution, but we need few more observations to have , and not .Observation 3. If dp[i] = k, then dp[i + 1] ≥ k - 1.We can use this to kick binary search from the solution — when you calculate dp[i] you can start trying with dp[i + 1] + 1, descending until the success.Since there are exactly n grows, there will be at most n descendings and the total number of checks is linear. ?Observation? 4. We need to check whether such j exists in a fast way.Recall there are few conditions for us to follow, dp[j] ≥ const, j ≥ const and some string equality.If you carefully look at the restriction j ≥ const you can see, that when we move our dp calculation i → i - 1 or make dp[i] -= 1 this lower bound on j also moves only left, like in two pointers. So each moment some indexes j are \"available\" and some are not, and the border moves only left.Finally, time for some structures. Build Suffix Array and build segment tree over it. Let's store in the leaf of the segment tree dp[j] if it's already available or  - 1 otherwise.Let's check whether dp[i] = k is good. We want for string starting at j be either si, si + 1, ..., si + k - 2, or si + 1, si + 2, ..., si + k - 1. Consider these cases independently (however the procedure is pretty much same).All such strings form a segment of Suffix Array, we can for example use LCP + binary search over sparse tables to find corresponding bounds.Then we just need to query this segment and check if the maximum on it is at least k - 1.The solution is",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/62455",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1064\\s*B"
          },
          "content_length": 9243
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 1",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 2",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 3",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 4",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 5",
          "code": "sort(s.begin(), s.end()); cout<<s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 6",
          "code": "'a - 3 times, aa - 2 times aaa - 1 time, total - 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 7",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 8",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 11",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 12",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 13",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 14",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 15",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 16",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 1",
          "code": "you have to call dfs with cell C again; \n   why?\n  because, now C has lesser leftCount or rightCount than before....so it may \n           able to visit more cells than before",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 2",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 3",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int a = inf.readInt(0, 1073741823, \"a\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int a = inf.readInt(0, 1073741823, \"a\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int a = inf.readInt(0, 1073741823, \"a\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    ensuref(1 <= t && t <= 1000, \"t must be between 1 and 1000\");\n\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n\n    for (int i = 0; i < t; i++) {\n        unsigned int a;\n\n        if (type == \"min\") {\n            a = 0;\n        } else if (type == \"max\") {\n            a = (1u << 30) - 1;\n        } else if (type == \"random\") {\n            a = rnd.next(0u, (1u << 30) - 1);\n        } else if (type == \"powers\") {\n            int k = rnd.next(0, 29); // k ranges from 0 to 29\n            a = 1u << k;\n        } else if (type == \"special\") {\n            // Predefined special values of 'a'\n            unsigned int patterns[] = {\n                (0xAAAAAAAA & ((1u << 30) - 1)), // 1010... pattern adjusted to 30 bits\n                (0x55555555 & ((1u << 30) - 1)), // 0101... pattern adjusted to 30 bits\n                (1u << 30) - 1, // Maximum value with all bits set\n                0,              // Minimum value\n                1u << 29,       // Highest bit set\n                1u << 0,        // Lowest bit set\n                (1u << 30) - (1u << 29) - 1, // Max value minus highest bit and minus one\n            };\n            int num_patterns = sizeof(patterns) / sizeof(patterns[0]);\n            a = patterns[i % num_patterns];\n        } else {\n            // Default to random if type is unrecognized\n            a = rnd.next(0u, (1u << 30) - 1);\n        }\n\n        printf(\"%u\\n\", a);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    ensuref(1 <= t && t <= 1000, \"t must be between 1 and 1000\");\n\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n\n    for (int i = 0; i < t; i++) {\n        unsigned int a;\n\n        if (type == \"min\") {\n            a = 0;\n        } else if (type == \"max\") {\n            a = (1u << 30) - 1;\n        } else if (type == \"random\") {\n            a = rnd.next(0u, (1u << 30) - 1);\n        } else if (type == \"powers\") {\n            int k = rnd.next(0, 29); // k ranges from 0 to 29\n            a = 1u << k;\n        } else if (type == \"special\") {\n            // Predefined special values of 'a'\n            unsigned int patterns[] = {\n                (0xAAAAAAAA & ((1u << 30) - 1)), // 1010... pattern adjusted to 30 bits\n                (0x55555555 & ((1u << 30) - 1)), // 0101... pattern adjusted to 30 bits\n                (1u << 30) - 1, // Maximum value with all bits set\n                0,              // Minimum value\n                1u << 29,       // Highest bit set\n                1u << 0,        // Lowest bit set\n                (1u << 30) - (1u << 29) - 1, // Max value minus highest bit and minus one\n            };\n            int num_patterns = sizeof(patterns) / sizeof(patterns[0]);\n            a = patterns[i % num_patterns];\n        } else {\n            // Default to random if type is unrecognized\n            a = rnd.next(0u, (1u << 30) - 1);\n        }\n\n        printf(\"%u\\n\", a);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type min\n./gen -t 1 -type max\n./gen -t 1 -type random\n./gen -t 1 -type powers\n./gen -t 1 -type special\n\n./gen -t 5 -type min\n./gen -t 5 -type max\n./gen -t 5 -type random\n./gen -t 5 -type powers\n./gen -t 5 -type special\n\n./gen -t 10 -type min\n./gen -t 10 -type max\n./gen -t 10 -type random\n./gen -t 10 -type powers\n./gen -t 10 -type special\n\n./gen -t 100 -type min\n./gen -t 100 -type max\n./gen -t 100 -type random\n./gen -t 100 -type powers\n./gen -t 100 -type special\n\n./gen -t 500 -type min\n./gen -t 500 -type max\n./gen -t 500 -type random\n./gen -t 500 -type powers\n./gen -t 500 -type special\n\n./gen -t 1000 -type min\n./gen -t 1000 -type max\n./gen -t 1000 -type random\n./gen -t 1000 -type powers\n./gen -t 1000 -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:07.461305",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1064/C",
      "title": "C. Ох уж эти палиндромы",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано целое число nn (1≤n≤1000001≤n≤100000) — длина строки ss.Во второй строке задана строка ss, состоящая из nn строчных букв латинского алфавита.",
      "output_spec": "Выходные данныеВыведите строку tt, которая состоит из тех же символов (с учётом кратностей), что и ss, и имеет максимальную палиндромность среди всех строк, которые могут быть получены из ss перестановкой символов.Если подходящих строк несколько, выведите любую.",
      "sample_tests": "ПримерыВходные данныеСкопировать5oololВыходные данныеСкопироватьololoВходные данныеСкопировать16gagadbcgghhchbdfВыходные данныеСкопироватьabccbaghghghgdfd",
      "description": "C. Ох уж эти палиндромы\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке задано целое число nn (1≤n≤1000001≤n≤100000) — длина строки ss.Во второй строке задана строка ss, состоящая из nn строчных букв латинского алфавита.\n\nВходные данные\n\nВыходные данныеВыведите строку tt, которая состоит из тех же символов (с учётом кратностей), что и ss, и имеет максимальную палиндромность среди всех строк, которые могут быть получены из ss перестановкой символов.Если подходящих строк несколько, выведите любую.\n\nВыходные данные\n\nВходные данныеСкопировать5oololВыходные данныеСкопироватьololoВходные данныеСкопировать16gagadbcgghhchbdfВыходные данныеСкопироватьabccbaghghghgdfd\n\nВходные данныеСкопировать5oolol\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьololo\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать16gagadbcgghhchbdf\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьabccbaghghghgdfd\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере у строки «ololo» есть 99 подстрок-палиндромов: «o», «l», «o», «l», «o», «olo», «lol», «olo», «ololo». Обратите внимание, что некоторые подстроки совпадают, но учитываются несколько раз.Во втором примере палиндромность строки «abccbaghghghgdfd» равна 2929.",
      "solutions": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces",
          "content": "Всем привет!В воскресенье в Москве пройдет шестнадцатая Московская командная олимпиада — командное соревнование для школьников, проходящее в Москве как отборочное соревнование на ВКОШП. Над туром работала Московская методическая комиссия, известная вам также по Открытой олимпиаде школьников по программированию, Московской олимпиаде для 6-9 классов и олимпиаде Мегаполисов (раунды 327, 342, 345, 376, 401, 433, 441, 466, 469, 507).Раунд состоится в 13:05 14 числа и продлится 2 часа. В каждом дивизионе будет предложено по 6 задач.Задачи соревнования подготовлены vintage_Vlad_Makeev, Glebodin, Andreikkaa, qoo2p5, mingaleg, Flyrise, cdkrot, achulkov2, grphil, Sehnsucht, Aphanasiy, Sender, DebNatkh, GreenGrape под моим руководством, а также GlebsHP, meshanya, Endagorion, Zlobober и Андреевой Е. В.За координацию раунда и перевод условий спасибо cdkrot, а так же MikeMirzayanov за системы codeforces и polygon, который использовался при подготовке задач этой олимпиады.Всем удачи!UPD1: Разбалловка:500 — 1000 — 1000 — 1500 — 2000 — 2500 для div. 1.500 — 1000 — 1500 — 2000 — 2000 — 2500 для div. 2.UPD2: РазборUPD3: Победители:Div. 1: mnbvmar bmerry jcvb TLEwpdus WA_TLE Div. 2: Ebola_Emperor Orange_User orbitingfIea little_waxberry fnch",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1241
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces",
          "content": "Credits:Div2A (Make a Trianle): Idea by Zlobober, development by vintage_Vlad_MakeevDiv2B (Equations of Mathematical Magic): Idea and development: GlebodinDiv1A (Oh Those Palindromes): Idea by Endagorion, development by AndreikkaaDiv1B (Labyrinth): Idea and development by qoo2p5Div1C (Dwarves, Hats and Extrasensory Abilities): Idea and development by mingaleg Div1D (Candies for Children): Idea by Endagorion, development by FlyriseDiv1E (Lasers and Mirrors): Idea and development by mingalegDiv1F (String Journey): Original idea by GreenGrape, solution by vintage_Vlad_Makeev, development vintage_Vlad_Makeev and GreenGrape 1064A - Make a triangle!Suppose cc is the largest stick. It is known, that we can build a triangle iff c≤a+b−1c≤a+b−1.So if we can build a triangle the answer is zero. Otherwise we can just increase aa or bb until the inequality above holds.So the answer is max(0,c−(a+b−1))max(0,c−(a+b−1)).Another approach: just bruteforce all possible triangles we can extend to (with sides ≤100≤100) and select the one with smallest a+b+ca+b+c. 1064B - Equations of Mathematical MagicRewriting equation we have a⊕x=a−xa⊕x=a−x.If you look in the xor definition, it is easy to see, that a⊕x≥a−xa⊕x≥a−x, no matter aa and xx (just look at the each bit of the a⊕xa⊕x).And the equality handles only if bits of xx form a subset of bits of aa.So the answer is 2t2t, where tt is the number of bits in aa (also known as popcount). 1063A - Oh Those PalindromesOne possible solution is just to sort the string.Why so?Note that each palindrome have equal character at their ends. Suppose this character is cc with xx number of occurences. Then there are at most x(x+1)/2x(x+1)/2 palindromes with this character.So we have a clear upper bound on answer. It is easy to see, that the sorted string fulfills that bound and hence it is the optimal answer. 1063B - LabyrinthSuppose we started in cell (i0, j0) and examining whether we can reach cell (i1, j1).Let's denote the number of taken moves to the right as R and number of moves to the left as LClearly, j0 + R - L = j1That is, R - L = j1 - j0 = const. Or, put otherwise R = L + const, where const only depends on the starting cell and the target cell.So in fact we just need to minimize any of the left or right moves — the other one will be optimal as well.To calculate the minimum possible number of L-moves to reach some cell we can use 0-1 bfs.Solution is O(nm). 1063C - Dwarves, Hats and Extrasensory AbilitiesThe solution is just.. binary search!We will use just a single line to put our points on. Let's maintain an invariant that all white colored points are on the left and all black colored on the right.Put a new point in the middle of the gap between white points and black points.Depending on the color said by jury shrink the gap to the left or to the right.In the end draw a diagonal line between white points and black points.The initializing binary search may look complicated but it isn't.Put a first point on the leftmost (x = 0) position, suppose that this point is white (if it is black just revert all colors), and then play as if there is a white point in x = 0 and black point in x = 109. 1063D - Candies for ChildrenSolution works in min(n2,k/n)min(n2,k/n) time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.This adds few more cases but the idea stays the same. Basically in the formulas below just few −1−1 will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.So how to solve problem in n2n2?Note, that basically we have two parts of the circle — the part between [l;r][l;r] which get's candies one times more than the rest and the other one.Since we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as xx and yy.To solve in n2n2 let's bruteforce the number of sweet tooth on first part (aa) and the number of sweet tooth on the second part (bb).Suppose that there were full tt loops. This way the number of eaten candies is a∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗ta∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗t.This should be equal to kk. Since we just bruteforced the values of aa and bb we now just have linear equation. If it is solvable, consider relaxing answer with a+ba+b.How to solve problem in k/nk/n?So as the asymptotic suggests the amount of turns ≤k/n≤k/n, so we can bruteforce it instead.Also it is worthy to handle case of 00 turns specifically here since it produces some unpleasant effects otherwise.So each person in \"xx\" part of the circle eats candies t+1t+1 times (so each person contributes t+1t+1 or 2t+22t+2) and the other persons have eaten candies tt times (so each person contributes tt or 2t2t).Let's account all persons as if they are not sweet tooths.So now each person in xx contributes 00 or t+1t+1 and each person in yy contributes 00 or tt.So we basically have (t+1)a+tb=γ(t+1)a+tb=γ. A Diophantine equation.Careful analysis or bits of theory suggest that the solutions area=a0−tza=a0−tz, b=b0+(t+1)zb=b0+(t+1)z, for all integer zz.Where a0a0 and b0b0 some arbitrary solutions which we can get with formulas.Also we need to have 0≤a≤x0≤a≤x, 0≤b≤y0≤b≤y, and the a+b→maxa+b→max.These bounds imply that tt takes values only in some range [t1;t2][t1;t2].Since the a+ba+b is linear function we can only consider t1t1 and t2t2 while searching for maximum a+ba+b. 1063E - Lasers and MirrorsThe answer is always nn (if the permutation is identity) lasers or n−1n−1 (otherwise).Clearly, we can't have more than n−1n−1 matching lasers if the permutation is not identity. Consider just the very first line with mirrors. If the first mirror in this line is «\\» then we miss the laser below this mirror, if the very last mirror is «/» we miss the laser below it. Otherwise there are neighbouring «/» and «\\» and we lost two lasers now.The proof of n−1n−1 is constructive one.Ignore all fixed points in permutation (all xx, that px=xpx=x).Select arbitrary cycle and select one point in it as «dead». We can spend |cycle|−1|cycle|−1 operations to fix all points in this cycle.But we also need to fix all other cycles. We can do it in |cycle|+1|cycle|+1 operations: move arbitrary beam to the wasted laser, fix all other points and move that point back.But this is a bit too much lines.The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line, if we select as the trash beam the rightmost point.See the following picture for an example (trash beam is the rightmost column): 1063F - String JourneyThis problem required quite a lot of nice observations!Observation 1. We can only consider journeys in which neighboring strings differ exactly by removing one symbol.All other journeys can be modified a bit to match the criterion above.Observation 2. If it is possible to start a journey at the symbol i with lengths of strings k, k - 1, ..., 1, it is always possible to start a journey at the same symbol i with lengths t, t - 1, ..., 1, given that t ≤ k.This suggests doing dynamic programming: dp[i] is the maximum possible k such that there is a journey starting at position i of k strings with lengths k, ..., 1.Due to observation 1 we only care about maximum – if we know maximum, we also known that all lesser values are also OK.So let's calculate this dynamic programming from right to left.How to check whether dp[i] ≥ k (given that tool, we can just use binary search for example)?There must be such j, that j ≥ i + k, dp[j] ≥ k - 1 and string sj, ..., sj + k - 2 must be a substring of string sisi + 1... si + k - 1 (basically just two cases \"left substring\" or \"right substring\").This almost gives us a solution, but we need few more observations to have , and not .Observation 3. If dp[i] = k, then dp[i + 1] ≥ k - 1.We can use this to kick binary search from the solution — when you calculate dp[i] you can start trying with dp[i + 1] + 1, descending until the success.Since there are exactly n grows, there will be at most n descendings and the total number of checks is linear. ?Observation? 4. We need to check whether such j exists in a fast way.Recall there are few conditions for us to follow, dp[j] ≥ const, j ≥ const and some string equality.If you carefully look at the restriction j ≥ const you can see, that when we move our dp calculation i → i - 1 or make dp[i] -= 1 this lower bound on j also moves only left, like in two pointers. So each moment some indexes j are \"available\" and some are not, and the border moves only left.Finally, time for some structures. Build Suffix Array and build segment tree over it. Let's store in the leaf of the segment tree dp[j] if it's already available or  - 1 otherwise.Let's check whether dp[i] = k is good. We want for string starting at j be either si, si + 1, ..., si + k - 2, or si + 1, si + 2, ..., si + k - 1. Consider these cases independently (however the procedure is pretty much same).All such strings form a segment of Suffix Array, we can for example use LCP + binary search over sparse tables to find corresponding bounds.Then we just need to query this segment and check if the maximum on it is at least k - 1.The solution is",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62455",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1064 和字母"
          },
          "content_length": 9243
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 1",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 2",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 3",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 4",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 5",
          "code": "sort(s.begin(), s.end()); cout<<s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 6",
          "code": "'a - 3 times, aa - 2 times aaa - 1 time, total - 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 7",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 8",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 11",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 12",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 13",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 14",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 15",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 16",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 1",
          "code": "you have to call dfs with cell C again; \n   why?\n  because, now C has lesser leftCount or rightCount than before....so it may \n           able to visit more cells than before",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 2",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 3",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z]+\", \"s\");\n    inf.readEoln();\n    ensuref((int)s.size() == n, \"The length of s must be equal to n, but s.size() = %d, n = %d\", (int)s.size(), n);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z]+\", \"s\");\n    inf.readEoln();\n    ensuref((int)s.size() == n, \"The length of s must be equal to n, but s.size() = %d, n = %d\", (int)s.size(), n);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z]+\", \"s\");\n    inf.readEoln();\n    ensuref((int)s.size() == n, \"The length of s must be equal to n, but s.size() = %d, n = %d\", (int)s.size(), n);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    string s = inf.readToken();\n    if (int(s.size()) != n)\n        quitf(_fail, \"Input string length doesn't match n\");\n\n    map<char, int> cnt;\n    for (char c : s) cnt[c]++;\n\n    long long max_palindromic_count = 0;\n    for (auto p : cnt) {\n        int c = p.second;\n        max_palindromic_count += 1LL * c * (c + 1) / 2;\n    }\n\n    string t = ouf.readToken();\n    if (int(t.size()) != n)\n        quitf(_wa, \"Output string length doesn't match n\");\n\n    map<char, int> t_cnt;\n    for (char c : t) t_cnt[c]++;\n\n    if (cnt != t_cnt)\n        quitf(_wa, \"Output string letters do not match input letters\");\n\n    // Compute palindromic substrings in t using Manacher's algorithm\n    int len = t.size();\n    long long total_palindromes = 0;\n    \n    // Odd length palindromic substrings\n    vector<int> d1(len);\n    for (int i = 0, l = 0, r = -1; i < len; ++i) {\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\n        while (i - k >= 0 && i + k < len && t[i - k] == t[i + k]) ++k;\n        d1[i] = k--;\n        total_palindromes += d1[i];\n        if (i + k > r) {\n            l = i - k;\n            r = i + k;\n        }\n    }\n    // Even length palindromic substrings\n    vector<int> d2(len);\n    for (int i = 0, l = 0, r = -1; i < len; ++i) {\n        int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);\n        while (i - k - 1 >= 0 && i + k < len && t[i - k - 1] == t[i + k]) ++k;\n        d2[i] = k--;\n        total_palindromes += d2[i];\n        if (i + k > r) {\n            l = i - k - 1;\n            r = i + k;\n        }\n    }\n\n    if (total_palindromes != max_palindromic_count)\n        quitf(_wa, \"Palindromic count is less than maximal possible: %lld vs %lld\", total_palindromes, max_palindromic_count);\n\n    quitf(_ok, \"Palindromic count is maximal: %lld\", total_palindromes);\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1);\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of length n\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);  // Random letter from 'a' to 'z'\n        }\n    } else if (type == \"same_char\") {\n        // Generate a string with one repeated character\n        char ch = 'a' + rnd.next(26);  // Random lowercase letter\n        s = string(n, ch);\n    } else if (type == \"palindromic\") {\n        // Generate a palindromic string\n        s.resize(n);\n        int mid = n / 2;\n        for (int i = 0; i < mid; ++i) {\n            s[i] = s[n - 1 - i] = 'a' + rnd.next(26);\n        }\n        if (n % 2 == 1) {\n            s[mid] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"anti_palindromic\") {\n        // Generate a string designed to have minimal palindromic substrings\n        s.resize(n);\n        char ch1 = 'a', ch2 = 'b';\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? ch1 : ch2;\n        }\n    } else if (type == \"few_distinct\") {\n        if (k == -1 || k > 26) {\n            // default to 2\n            k = 2;\n        }\n        s.resize(n);\n        vector<char> chars(k);\n        for (int i = 0; i < k; ++i) {\n            chars[i] = 'a' + i;  // Use 'a', 'b', 'c', etc.\n        }\n        for (int i = 0; i < n; ++i) {\n            s[i] = chars[rnd.next(k)];\n        }\n    } else {\n        // default random\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);  // Random letter from 'a' to 'z'\n        }\n    }\n\n    // Output n and s\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1);\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of length n\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);  // Random letter from 'a' to 'z'\n        }\n    } else if (type == \"same_char\") {\n        // Generate a string with one repeated character\n        char ch = 'a' + rnd.next(26);  // Random lowercase letter\n        s = string(n, ch);\n    } else if (type == \"palindromic\") {\n        // Generate a palindromic string\n        s.resize(n);\n        int mid = n / 2;\n        for (int i = 0; i < mid; ++i) {\n            s[i] = s[n - 1 - i] = 'a' + rnd.next(26);\n        }\n        if (n % 2 == 1) {\n            s[mid] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"anti_palindromic\") {\n        // Generate a string designed to have minimal palindromic substrings\n        s.resize(n);\n        char ch1 = 'a', ch2 = 'b';\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? ch1 : ch2;\n        }\n    } else if (type == \"few_distinct\") {\n        if (k == -1 || k > 26) {\n            // default to 2\n            k = 2;\n        }\n        s.resize(n);\n        vector<char> chars(k);\n        for (int i = 0; i < k; ++i) {\n            chars[i] = 'a' + i;  // Use 'a', 'b', 'c', etc.\n        }\n        for (int i = 0; i < n; ++i) {\n            s[i] = chars[rnd.next(k)];\n        }\n    } else {\n        // default random\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);  // Random letter from 'a' to 'z'\n        }\n    }\n\n    // Output n and s\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type same_char\n./gen -n 1 -type palindromic\n./gen -n 1 -type anti_palindromic\n./gen -n 1 -type few_distinct -k 1\n\n./gen -n 2 -type random\n./gen -n 2 -type palindromic\n\n./gen -n 3 -type anti_palindromic\n./gen -n 3 -type palindromic\n\n./gen -n 26 -type random\n\n./gen -n 50 -type few_distinct -k 1\n./gen -n 50 -type few_distinct -k 2\n\n./gen -n 100 -type random\n./gen -n 100 -type palindromic\n\n./gen -n 500 -type anti_palindromic\n./gen -n 500 -type few_distinct -k 3\n\n./gen -n 1000 -type same_char\n./gen -n 1000 -type palindromic\n\n./gen -n 5000 -type random\n./gen -n 5000 -type few_distinct -k 5\n\n./gen -n 10000 -type anti_palindromic\n./gen -n 10000 -type palindromic\n\n./gen -n 50000 -type random\n./gen -n 50000 -type few_distinct -k 10\n\n./gen -n 100000 -type random\n./gen -n 100000 -type same_char\n./gen -n 100000 -type palindromic\n./gen -n 100000 -type anti_palindromic\n./gen -n 100000 -type few_distinct -k 2\n./gen -n 100000 -type few_distinct -k 5\n./gen -n 100000 -type few_distinct -k 26\n\n./gen -n 99999 -type palindromic\n./gen -n 99997 -type anti_palindromic\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:09.532782",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1064/D",
      "title": "D. Лабиринт",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа n, m (1 ≤ n, m ≤ 2000) — количество строк и столбцов в лабиринте, соответственно.Вторая строка содержит два целых числа r, c (1 ≤ r ≤ n, 1 ≤ c ≤ m) — номер строки и столбца, на пересечении которых расположена стартовая клетка.Третья строка содержит два целых числа x, y (0 ≤ x, y ≤ 109) — максимальное количество перемещений влево и вправо, соответственно.Следующие n строк содержат описание лабиринта. Каждая из этих строк имеет длину m и состоит только из символов '.' и '*'. В i-й строке j-й символ соответствует клетке лабиринта с номерами строки и столбца i и j, соответственно. Символ '.' соответствует свободной клетке лабиринта, а символ '*' — клетке с препятствием.Гарантируется, что стартовая клетка не занята препятствием.",
      "output_spec": "Выходные данныеВыведите одно число — количество клеток лабиринта, достижимых из стартовой, включая её саму.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 53 21 2......***....***....Выходные данныеСкопировать10Входные данныеСкопировать4 42 20 1......*.........Выходные данныеСкопировать7",
      "description": "D. Лабиринт\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит два целых числа n, m (1 ≤ n, m ≤ 2000) — количество строк и столбцов в лабиринте, соответственно.Вторая строка содержит два целых числа r, c (1 ≤ r ≤ n, 1 ≤ c ≤ m) — номер строки и столбца, на пересечении которых расположена стартовая клетка.Третья строка содержит два целых числа x, y (0 ≤ x, y ≤ 109) — максимальное количество перемещений влево и вправо, соответственно.Следующие n строк содержат описание лабиринта. Каждая из этих строк имеет длину m и состоит только из символов '.' и '*'. В i-й строке j-й символ соответствует клетке лабиринта с номерами строки и столбца i и j, соответственно. Символ '.' соответствует свободной клетке лабиринта, а символ '*' — клетке с препятствием.Гарантируется, что стартовая клетка не занята препятствием.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество клеток лабиринта, достижимых из стартовой, включая её саму.\n\nВыходные данные\n\nВходные данныеСкопировать4 53 21 2......***....***....Выходные данныеСкопировать10Входные данныеСкопировать4 42 20 1......*.........Выходные данныеСкопировать7\n\nВходные данныеСкопировать4 53 21 2......***....***....\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 42 20 1......*.........\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеКлетки, достижимые в соответствующем примере, отмечены '+'.Первый пример  +++..+***.+++***+++. Второй пример  .++..+*..++..++.",
      "solutions": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces",
          "content": "Всем привет!В воскресенье в Москве пройдет шестнадцатая Московская командная олимпиада — командное соревнование для школьников, проходящее в Москве как отборочное соревнование на ВКОШП. Над туром работала Московская методическая комиссия, известная вам также по Открытой олимпиаде школьников по программированию, Московской олимпиаде для 6-9 классов и олимпиаде Мегаполисов (раунды 327, 342, 345, 376, 401, 433, 441, 466, 469, 507).Раунд состоится в 13:05 14 числа и продлится 2 часа. В каждом дивизионе будет предложено по 6 задач.Задачи соревнования подготовлены vintage_Vlad_Makeev, Glebodin, Andreikkaa, qoo2p5, mingaleg, Flyrise, cdkrot, achulkov2, grphil, Sehnsucht, Aphanasiy, Sender, DebNatkh, GreenGrape под моим руководством, а также GlebsHP, meshanya, Endagorion, Zlobober и Андреевой Е. В.За координацию раунда и перевод условий спасибо cdkrot, а так же MikeMirzayanov за системы codeforces и polygon, который использовался при подготовке задач этой олимпиады.Всем удачи!UPD1: Разбалловка:500 — 1000 — 1000 — 1500 — 2000 — 2500 для div. 1.500 — 1000 — 1500 — 2000 — 2000 — 2500 для div. 2.UPD2: РазборUPD3: Победители:Div. 1: mnbvmar bmerry jcvb TLEwpdus WA_TLE Div. 2: Ebola_Emperor Orange_User orbitingfIea little_waxberry fnch",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1241
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces",
          "content": "Credits:Div2A (Make a Trianle): Idea by Zlobober, development by vintage_Vlad_MakeevDiv2B (Equations of Mathematical Magic): Idea and development: GlebodinDiv1A (Oh Those Palindromes): Idea by Endagorion, development by AndreikkaaDiv1B (Labyrinth): Idea and development by qoo2p5Div1C (Dwarves, Hats and Extrasensory Abilities): Idea and development by mingaleg Div1D (Candies for Children): Idea by Endagorion, development by FlyriseDiv1E (Lasers and Mirrors): Idea and development by mingalegDiv1F (String Journey): Original idea by GreenGrape, solution by vintage_Vlad_Makeev, development vintage_Vlad_Makeev and GreenGrape 1064A - Make a triangle!Suppose cc is the largest stick. It is known, that we can build a triangle iff c≤a+b−1c≤a+b−1.So if we can build a triangle the answer is zero. Otherwise we can just increase aa or bb until the inequality above holds.So the answer is max(0,c−(a+b−1))max(0,c−(a+b−1)).Another approach: just bruteforce all possible triangles we can extend to (with sides ≤100≤100) and select the one with smallest a+b+ca+b+c. 1064B - Equations of Mathematical MagicRewriting equation we have a⊕x=a−xa⊕x=a−x.If you look in the xor definition, it is easy to see, that a⊕x≥a−xa⊕x≥a−x, no matter aa and xx (just look at the each bit of the a⊕xa⊕x).And the equality handles only if bits of xx form a subset of bits of aa.So the answer is 2t2t, where tt is the number of bits in aa (also known as popcount). 1063A - Oh Those PalindromesOne possible solution is just to sort the string.Why so?Note that each palindrome have equal character at their ends. Suppose this character is cc with xx number of occurences. Then there are at most x(x+1)/2x(x+1)/2 palindromes with this character.So we have a clear upper bound on answer. It is easy to see, that the sorted string fulfills that bound and hence it is the optimal answer. 1063B - LabyrinthSuppose we started in cell (i0, j0) and examining whether we can reach cell (i1, j1).Let's denote the number of taken moves to the right as R and number of moves to the left as LClearly, j0 + R - L = j1That is, R - L = j1 - j0 = const. Or, put otherwise R = L + const, where const only depends on the starting cell and the target cell.So in fact we just need to minimize any of the left or right moves — the other one will be optimal as well.To calculate the minimum possible number of L-moves to reach some cell we can use 0-1 bfs.Solution is O(nm). 1063C - Dwarves, Hats and Extrasensory AbilitiesThe solution is just.. binary search!We will use just a single line to put our points on. Let's maintain an invariant that all white colored points are on the left and all black colored on the right.Put a new point in the middle of the gap between white points and black points.Depending on the color said by jury shrink the gap to the left or to the right.In the end draw a diagonal line between white points and black points.The initializing binary search may look complicated but it isn't.Put a first point on the leftmost (x = 0) position, suppose that this point is white (if it is black just revert all colors), and then play as if there is a white point in x = 0 and black point in x = 109. 1063D - Candies for ChildrenSolution works in min(n2,k/n)min(n2,k/n) time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.This adds few more cases but the idea stays the same. Basically in the formulas below just few −1−1 will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.So how to solve problem in n2n2?Note, that basically we have two parts of the circle — the part between [l;r][l;r] which get's candies one times more than the rest and the other one.Since we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as xx and yy.To solve in n2n2 let's bruteforce the number of sweet tooth on first part (aa) and the number of sweet tooth on the second part (bb).Suppose that there were full tt loops. This way the number of eaten candies is a∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗ta∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗t.This should be equal to kk. Since we just bruteforced the values of aa and bb we now just have linear equation. If it is solvable, consider relaxing answer with a+ba+b.How to solve problem in k/nk/n?So as the asymptotic suggests the amount of turns ≤k/n≤k/n, so we can bruteforce it instead.Also it is worthy to handle case of 00 turns specifically here since it produces some unpleasant effects otherwise.So each person in \"xx\" part of the circle eats candies t+1t+1 times (so each person contributes t+1t+1 or 2t+22t+2) and the other persons have eaten candies tt times (so each person contributes tt or 2t2t).Let's account all persons as if they are not sweet tooths.So now each person in xx contributes 00 or t+1t+1 and each person in yy contributes 00 or tt.So we basically have (t+1)a+tb=γ(t+1)a+tb=γ. A Diophantine equation.Careful analysis or bits of theory suggest that the solutions area=a0−tza=a0−tz, b=b0+(t+1)zb=b0+(t+1)z, for all integer zz.Where a0a0 and b0b0 some arbitrary solutions which we can get with formulas.Also we need to have 0≤a≤x0≤a≤x, 0≤b≤y0≤b≤y, and the a+b→maxa+b→max.These bounds imply that tt takes values only in some range [t1;t2][t1;t2].Since the a+ba+b is linear function we can only consider t1t1 and t2t2 while searching for maximum a+ba+b. 1063E - Lasers and MirrorsThe answer is always nn (if the permutation is identity) lasers or n−1n−1 (otherwise).Clearly, we can't have more than n−1n−1 matching lasers if the permutation is not identity. Consider just the very first line with mirrors. If the first mirror in this line is «\\» then we miss the laser below this mirror, if the very last mirror is «/» we miss the laser below it. Otherwise there are neighbouring «/» and «\\» and we lost two lasers now.The proof of n−1n−1 is constructive one.Ignore all fixed points in permutation (all xx, that px=xpx=x).Select arbitrary cycle and select one point in it as «dead». We can spend |cycle|−1|cycle|−1 operations to fix all points in this cycle.But we also need to fix all other cycles. We can do it in |cycle|+1|cycle|+1 operations: move arbitrary beam to the wasted laser, fix all other points and move that point back.But this is a bit too much lines.The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line, if we select as the trash beam the rightmost point.See the following picture for an example (trash beam is the rightmost column): 1063F - String JourneyThis problem required quite a lot of nice observations!Observation 1. We can only consider journeys in which neighboring strings differ exactly by removing one symbol.All other journeys can be modified a bit to match the criterion above.Observation 2. If it is possible to start a journey at the symbol i with lengths of strings k, k - 1, ..., 1, it is always possible to start a journey at the same symbol i with lengths t, t - 1, ..., 1, given that t ≤ k.This suggests doing dynamic programming: dp[i] is the maximum possible k such that there is a journey starting at position i of k strings with lengths k, ..., 1.Due to observation 1 we only care about maximum – if we know maximum, we also known that all lesser values are also OK.So let's calculate this dynamic programming from right to left.How to check whether dp[i] ≥ k (given that tool, we can just use binary search for example)?There must be such j, that j ≥ i + k, dp[j] ≥ k - 1 and string sj, ..., sj + k - 2 must be a substring of string sisi + 1... si + k - 1 (basically just two cases \"left substring\" or \"right substring\").This almost gives us a solution, but we need few more observations to have , and not .Observation 3. If dp[i] = k, then dp[i + 1] ≥ k - 1.We can use this to kick binary search from the solution — when you calculate dp[i] you can start trying with dp[i + 1] + 1, descending until the success.Since there are exactly n grows, there will be at most n descendings and the total number of checks is linear. ?Observation? 4. We need to check whether such j exists in a fast way.Recall there are few conditions for us to follow, dp[j] ≥ const, j ≥ const and some string equality.If you carefully look at the restriction j ≥ const you can see, that when we move our dp calculation i → i - 1 or make dp[i] -= 1 this lower bound on j also moves only left, like in two pointers. So each moment some indexes j are \"available\" and some are not, and the border moves only left.Finally, time for some structures. Build Suffix Array and build segment tree over it. Let's store in the leaf of the segment tree dp[j] if it's already available or  - 1 otherwise.Let's check whether dp[i] = k is good. We want for string starting at j be either si, si + 1, ..., si + k - 2, or si + 1, si + 2, ..., si + k - 1. Consider these cases independently (however the procedure is pretty much same).All such strings form a segment of Suffix Array, we can for example use LCP + binary search over sparse tables to find corresponding bounds.Then we just need to query this segment and check if the maximum on it is at least k - 1.The solution is",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62455",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1064 和字母"
          },
          "content_length": 9243
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 1",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 2",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 3",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 4",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 5",
          "code": "sort(s.begin(), s.end()); cout<<s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 6",
          "code": "'a - 3 times, aa - 2 times aaa - 1 time, total - 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 7",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 8",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 11",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 12",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 13",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 14",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 15",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (по задачам МКОШП) [Рейтинговый] - Codeforces - Code 16",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 1",
          "code": "you have to call dfs with cell C again; \n   why?\n  because, now C has lesser leftCount or rightCount than before....so it may \n           able to visit more cells than before",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 2",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 3",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 2000;\n    const int MAX_M = 2000;\n    const int MAX_XY = 1000000000;\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_M, \"m\");\n    inf.readEoln();\n    int r = inf.readInt(1, n, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, m, \"c\");\n    inf.readEoln();\n    int x = inf.readInt(0, MAX_XY, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, MAX_XY, \"y\");\n    inf.readEoln();\n    vector<string> maze(n);\n    string pattern = \"[\\\\.\\\\*]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        maze[i] = inf.readToken(pattern, \"maze_row_\" + to_string(i+1));\n        inf.readEoln();\n    }\n    ensuref(maze[r-1][c-1] == '.', \"Starting cell at (%d,%d) must be free\", r, c);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 2000;\n    const int MAX_M = 2000;\n    const int MAX_XY = 1000000000;\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_M, \"m\");\n    inf.readEoln();\n    int r = inf.readInt(1, n, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, m, \"c\");\n    inf.readEoln();\n    int x = inf.readInt(0, MAX_XY, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, MAX_XY, \"y\");\n    inf.readEoln();\n    vector<string> maze(n);\n    string pattern = \"[\\\\.\\\\*]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        maze[i] = inf.readToken(pattern, \"maze_row_\" + to_string(i+1));\n        inf.readEoln();\n    }\n    ensuref(maze[r-1][c-1] == '.', \"Starting cell at (%d,%d) must be free\", r, c);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 2000;\n    const int MAX_M = 2000;\n    const int MAX_XY = 1000000000;\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_M, \"m\");\n    inf.readEoln();\n    int r = inf.readInt(1, n, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, m, \"c\");\n    inf.readEoln();\n    int x = inf.readInt(0, MAX_XY, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, MAX_XY, \"y\");\n    inf.readEoln();\n    vector<string> maze(n);\n    string pattern = \"[\\\\.\\\\*]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        maze[i] = inf.readToken(pattern, \"maze_row_\" + to_string(i+1));\n        inf.readEoln();\n    }\n    ensuref(maze[r-1][c-1] == '.', \"Starting cell at (%d,%d) must be free\", r, c);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    \n    long long x = opt<long long>(\"x\", 0);\n    long long y = opt<long long>(\"y\", 0);\n\n    string start = opt<string>(\"start\", \"random\");\n    int r = -1, c = -1;\n\n    if (start == \"custom\") {\n        r = opt<int>(\"r\");\n        c = opt<int>(\"c\");\n    }\n\n    string pattern = opt<string>(\"pattern\", \"random\");\n    double density = opt<double>(\"density\", 0.5);\n\n    // Check that n and m are within bounds\n    assert(1 <= n && n <= 2000);\n    assert(1 <= m && m <= 2000);\n    assert(0 <= x && x <= 1000000000);\n    assert(0 <= y && y <= 1000000000);\n\n    // Set starting position\n    if (start == \"random\") {\n        r = rnd.next(1, n);\n        c = rnd.next(1, m);\n    } else if (start == \"corner\") {\n        r = 1;\n        c = 1;\n    } else if (start == \"center\") {\n        r = (n + 1) / 2;\n        c = (m + 1) / 2;\n    } else if (start == \"custom\") {\n        // r and c should have been set\n        assert(1 <= r && r <= n);\n        assert(1 <= c && c <= m);\n    } else {\n        // Invalid start\n        // Should not reach here due to input validation\n    }\n\n    // Generate grid\n    vector<string> grid(n, string(m, '.'));\n\n    if (pattern == \"none\") {\n        // Do nothing, grid is already free\n    } else if (pattern == \"full\") {\n        // Fill grid with obstacles, except starting cell\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*');\n        grid[r - 1][c - 1] = '.';\n    } else if (pattern == \"random\") {\n        // Place obstacles randomly with given density\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (rnd.next() < density && !(i == r - 1 && j == c - 1))\n                    grid[i][j] = '*';\n    } else if (pattern == \"walls\") {\n        // Create walls of obstacles\n        // For example, create vertical walls every 3 columns\n        for (int j = 0; j < m; ++j)\n            if (j % 3 == 0)\n                for (int i = 0; i < n; ++i)\n                    if (!(i == r - 1 && j == c - 1))\n                        grid[i][j] = '*';\n    } else {\n        // Invalid pattern\n        // Should not reach here due to input validation\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d %d\\n\", r, c);\n    printf(\"%lld %lld\\n\", x, y);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    \n    long long x = opt<long long>(\"x\", 0);\n    long long y = opt<long long>(\"y\", 0);\n\n    string start = opt<string>(\"start\", \"random\");\n    int r = -1, c = -1;\n\n    if (start == \"custom\") {\n        r = opt<int>(\"r\");\n        c = opt<int>(\"c\");\n    }\n\n    string pattern = opt<string>(\"pattern\", \"random\");\n    double density = opt<double>(\"density\", 0.5);\n\n    // Check that n and m are within bounds\n    assert(1 <= n && n <= 2000);\n    assert(1 <= m && m <= 2000);\n    assert(0 <= x && x <= 1000000000);\n    assert(0 <= y && y <= 1000000000);\n\n    // Set starting position\n    if (start == \"random\") {\n        r = rnd.next(1, n);\n        c = rnd.next(1, m);\n    } else if (start == \"corner\") {\n        r = 1;\n        c = 1;\n    } else if (start == \"center\") {\n        r = (n + 1) / 2;\n        c = (m + 1) / 2;\n    } else if (start == \"custom\") {\n        // r and c should have been set\n        assert(1 <= r && r <= n);\n        assert(1 <= c && c <= m);\n    } else {\n        // Invalid start\n        // Should not reach here due to input validation\n    }\n\n    // Generate grid\n    vector<string> grid(n, string(m, '.'));\n\n    if (pattern == \"none\") {\n        // Do nothing, grid is already free\n    } else if (pattern == \"full\") {\n        // Fill grid with obstacles, except starting cell\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*');\n        grid[r - 1][c - 1] = '.';\n    } else if (pattern == \"random\") {\n        // Place obstacles randomly with given density\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (rnd.next() < density && !(i == r - 1 && j == c - 1))\n                    grid[i][j] = '*';\n    } else if (pattern == \"walls\") {\n        // Create walls of obstacles\n        // For example, create vertical walls every 3 columns\n        for (int j = 0; j < m; ++j)\n            if (j % 3 == 0)\n                for (int i = 0; i < n; ++i)\n                    if (!(i == r - 1 && j == c - 1))\n                        grid[i][j] = '*';\n    } else {\n        // Invalid pattern\n        // Should not reach here due to input validation\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d %d\\n\", r, c);\n    printf(\"%lld %lld\\n\", x, y);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal size grid, no obstacles\n./gen -n 1 -m 1 -x 0 -y 0 -start corner -pattern none\n\n# Small grid, no obstacles\n./gen -n 2 -m 2 -x 1 -y 1 -start corner -pattern none\n\n# Small grid, starting from the center\n./gen -n 3 -m 3 -x 1 -y 1 -start center -pattern none\n\n# Large grid, no obstacles\n./gen -n 2000 -m 2000 -x 1000000000 -y 1000000000 -start random -pattern none\n\n# Small grid, starting cell is the only free cell\n./gen -n 3 -m 3 -x 1 -y 1 -start center -pattern full\n\n# Medium grid, random obstacles, low density\n./gen -n 1000 -m 1000 -x 100 -y 100 -pattern random -density 0.1\n\n# Medium grid, random obstacles, high density\n./gen -n 1000 -m 1000 -x 500 -y 500 -pattern random -density 0.9\n\n# Grid with walls\n./gen -n 50 -m 50 -x 25 -y 25 -pattern walls -start center\n\n# Can't move left\n./gen -n 20 -m 20 -x 0 -y 10 -pattern none -start center\n\n# Can't move right\n./gen -n 20 -m 20 -x 10 -y 0 -pattern none -start center\n\n# Can't move left or right\n./gen -n 20 -m 20 -x 0 -y 0 -pattern none -start center\n\n# Max x and y, random obstacles\n./gen -n 1000 -m 1000 -x 1000000000 -y 1000000000 -pattern random -density 0.5\n\n# Start at top-left corner\n./gen -n 100 -m 100 -x 20 -y 20 -pattern random -start corner\n\n# Start at custom position\n./gen -n 200 -m 200 -x 50 -y 50 -pattern random -start custom -r 100 -c 100\n\n# Can't move left, starting at corner\n./gen -n 100 -m 100 -x 0 -y 50 -pattern random -density 0.2 -start corner\n\n# Can't move right, starting at opposite corner\n./gen -n 100 -m 100 -x 50 -y 0 -pattern random -density 0.2 -start custom -r 1 -c 100\n\n# Max grid size, no obstacles, max x/y\n./gen -n 2000 -m 2000 -x 1000000000 -y 1000000000 -start center -pattern none\n\n# Small grid with high-density obstacles\n./gen -n 10 -m 10 -x 5 -y 5 -pattern random -density 0.8 -start random\n\n# Grid with obstacles forming walls every 2 rows\n./gen -n 50 -m 50 -x 25 -y 25 -pattern walls -start random\n\n# Grid with no possible moves (blocked starting cell)\n./gen -n 5 -m 5 -x 1 -y 1 -pattern full -start custom -r 3 -c 3\n\n# Grid with narrow path\n./gen -n 100 -m 100 -x 50 -y 50 -pattern walls -start custom -r 50 -c 1\n\n# Grid with zero x and y, large grid\n./gen -n 500 -m 500 -x 0 -y 0 -pattern none -start center\n\n# Large grid, random obstacles, random start\n./gen -n 2000 -m 2000 -x 1000000000 -y 1000000000 -pattern random -density 0.5 -start random\n\n# Small grid, cannot move at all\n./gen -n 5 -m 5 -x 0 -y 0 -pattern random -density 0.0 -start center\n\n# Medium grid, high x and low y\n./gen -n 1000 -m 1000 -x 1000000000 -y 0 -pattern random -density 0.5 -start random\n\n# Medium grid, low x and high y\n./gen -n 1000 -m 1000 -x 0 -y 1000000000 -pattern random -density 0.5 -start random\n\n# Grid with obstacles in checkerboard pattern\n./gen -n 50 -m 50 -x 25 -y 25 -pattern random -density 0.5 -start center\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:11.528754",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1064/F",
      "title": "F. Candies for Children",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains four integers nn, ll, rr and kk (1≤n,k≤10111≤n,k≤1011, 1≤l,r≤n1≤l,r≤n) — the number of children in the circle, the number of friend, who was given a box with candies, the number of friend, who has taken last candy and the initial number of candies in the box respectively.",
      "output_spec": "OutputPrint exactly one integer — the maximum possible number of sweet tooth among the friends of Lena or \"-1\" (quotes for clarity), if Lena is wrong.",
      "sample_tests": "ExamplesInputCopy4 1 4 12OutputCopy2InputCopy5 3 4 10OutputCopy3InputCopy10 5 5 1OutputCopy10InputCopy5 4 5 6OutputCopy-1",
      "description": "F. Candies for Children\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line contains four integers nn, ll, rr and kk (1≤n,k≤10111≤n,k≤1011, 1≤l,r≤n1≤l,r≤n) — the number of children in the circle, the number of friend, who was given a box with candies, the number of friend, who has taken last candy and the initial number of candies in the box respectively.\n\nOutputPrint exactly one integer — the maximum possible number of sweet tooth among the friends of Lena or \"-1\" (quotes for clarity), if Lena is wrong.\n\nInputCopy4 1 4 12OutputCopy2InputCopy5 3 4 10OutputCopy3InputCopy10 5 5 1OutputCopy10InputCopy5 4 5 6OutputCopy-1\n\nInputCopy4 1 4 12\n\nOutputCopy2\n\nInputCopy5 3 4 10\n\nOutputCopy3\n\nInputCopy10 5 5 1\n\nOutputCopy10\n\nInputCopy5 4 5 6\n\nOutputCopy-1\n\nNoteIn the first example, any two friends can be sweet tooths, this way each person will receive the box with candies twice and the last person to take sweets will be the fourth friend.In the second example, sweet tooths can be any three friends, except for the friend on the third position.In the third example, only one friend will take candy, but he can still be a sweet tooth, but just not being able to take two candies. All other friends in the circle can be sweet tooths as well, they just will not be able to take a candy even once.In the fourth example, Lena is wrong and this situation couldn't happen.",
      "solutions": [
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces",
          "content": "Hi everybody,This Sunday there will be a 16th Moscow Team Olympiad, high school students competition based in Moscow that is an elimination contest for All-Russian Team Olympiad. This contest is prepared by Moscow Olympiad Scientific Committee that you may know by Moscow Open Olympiad, Moscow Olympiad for Young Students and Metropolises Olympiad (rounds 327, 342, 345, 376, 401, 433, 441, 466, 469, 507).Round will be held at 10:05 UTC on Sunday and will last for 2 hours. Each division will have 6 problems.Problems are prepared vintage_Vlad_Makeev, Glebodin, Andreikkaa, qoo2p5, mingaleg, Flyrise, cdkrot, achulkov2, grphil, Sehnsucht, Aphanasiy, Sender, DebNatkh, GreenGrape under my supervision with great help of GlebsHP, meshanya, Endagorion, Zlobober and Helen Andreeva.Thanks to cdkrot for the round coordination and statement translation, and also thanks for MikeMirzayanov for systems codeforces and polygon, which was used to prepare problems of this olympiad.Good luck everybody!UPD1: The scoring distribution will be:500 — 1000 — 1000 — 1500 — 2000 — 2500 for div. 1.500 — 1000 — 1500 — 2000 — 2000 — 2500 for div. 2.UPD2: EditorialUPD3: Winners:Div. 1: mnbvmar bmerry jcvb TLEwpdus WA_TLE Div. 2: Ebola_Emperor Orange_User orbitingfIea little_waxberry fnch",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62440",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1272
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces",
          "content": "Credits:Div2A (Make a Trianle): Idea by Zlobober, development by vintage_Vlad_MakeevDiv2B (Equations of Mathematical Magic): Idea and development: GlebodinDiv1A (Oh Those Palindromes): Idea by Endagorion, development by AndreikkaaDiv1B (Labyrinth): Idea and development by qoo2p5Div1C (Dwarves, Hats and Extrasensory Abilities): Idea and development by mingaleg Div1D (Candies for Children): Idea by Endagorion, development by FlyriseDiv1E (Lasers and Mirrors): Idea and development by mingalegDiv1F (String Journey): Original idea by GreenGrape, solution by vintage_Vlad_Makeev, development vintage_Vlad_Makeev and GreenGrape 1064A - Make a triangle!Suppose cc is the largest stick. It is known, that we can build a triangle iff c≤a+b−1c≤a+b−1.So if we can build a triangle the answer is zero. Otherwise we can just increase aa or bb until the inequality above holds.So the answer is max(0,c−(a+b−1))max(0,c−(a+b−1)).Another approach: just bruteforce all possible triangles we can extend to (with sides ≤100≤100) and select the one with smallest a+b+ca+b+c. 1064B - Equations of Mathematical MagicRewriting equation we have a⊕x=a−xa⊕x=a−x.If you look in the xor definition, it is easy to see, that a⊕x≥a−xa⊕x≥a−x, no matter aa and xx (just look at the each bit of the a⊕xa⊕x).And the equality handles only if bits of xx form a subset of bits of aa.So the answer is 2t2t, where tt is the number of bits in aa (also known as popcount). 1063A - Oh Those PalindromesOne possible solution is just to sort the string.Why so?Note that each palindrome have equal character at their ends. Suppose this character is cc with xx number of occurences. Then there are at most x(x+1)/2x(x+1)/2 palindromes with this character.So we have a clear upper bound on answer. It is easy to see, that the sorted string fulfills that bound and hence it is the optimal answer. 1063B - LabyrinthSuppose we started in cell (i0, j0) and examining whether we can reach cell (i1, j1).Let's denote the number of taken moves to the right as R and number of moves to the left as LClearly, j0 + R - L = j1That is, R - L = j1 - j0 = const. Or, put otherwise R = L + const, where const only depends on the starting cell and the target cell.So in fact we just need to minimize any of the left or right moves — the other one will be optimal as well.To calculate the minimum possible number of L-moves to reach some cell we can use 0-1 bfs.Solution is O(nm). 1063C - Dwarves, Hats and Extrasensory AbilitiesThe solution is just.. binary search!We will use just a single line to put our points on. Let's maintain an invariant that all white colored points are on the left and all black colored on the right.Put a new point in the middle of the gap between white points and black points.Depending on the color said by jury shrink the gap to the left or to the right.In the end draw a diagonal line between white points and black points.The initializing binary search may look complicated but it isn't.Put a first point on the leftmost (x = 0) position, suppose that this point is white (if it is black just revert all colors), and then play as if there is a white point in x = 0 and black point in x = 109. 1063D - Candies for ChildrenSolution works in min(n2,k/n)min(n2,k/n) time. Also I will drop the case about the last person being sweet tooth and eating one candy instead of two.This adds few more cases but the idea stays the same. Basically in the formulas below just few −1−1 will appear, however there must be condition that there is at least one sweet tooth in corresponding part of the circle.So how to solve problem in n2n2?Note, that basically we have two parts of the circle — the part between [l;r][l;r] which get's candies one times more than the rest and the other one.Since we don't care about absolute values we can only worry about the lengths of this parts, let's denote them as xx and yy.To solve in n2n2 let's bruteforce the number of sweet tooth on first part (aa) and the number of sweet tooth on the second part (bb).Suppose that there were full tt loops. This way the number of eaten candies is a∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗ta∗2∗(t+1)+(x−a)∗1∗(t+1)+b∗2∗t+(y−b)∗1∗t.This should be equal to kk. Since we just bruteforced the values of aa and bb we now just have linear equation. If it is solvable, consider relaxing answer with a+ba+b.How to solve problem in k/nk/n?So as the asymptotic suggests the amount of turns ≤k/n≤k/n, so we can bruteforce it instead.Also it is worthy to handle case of 00 turns specifically here since it produces some unpleasant effects otherwise.So each person in \"xx\" part of the circle eats candies t+1t+1 times (so each person contributes t+1t+1 or 2t+22t+2) and the other persons have eaten candies tt times (so each person contributes tt or 2t2t).Let's account all persons as if they are not sweet tooths.So now each person in xx contributes 00 or t+1t+1 and each person in yy contributes 00 or tt.So we basically have (t+1)a+tb=γ(t+1)a+tb=γ. A Diophantine equation.Careful analysis or bits of theory suggest that the solutions area=a0−tza=a0−tz, b=b0+(t+1)zb=b0+(t+1)z, for all integer zz.Where a0a0 and b0b0 some arbitrary solutions which we can get with formulas.Also we need to have 0≤a≤x0≤a≤x, 0≤b≤y0≤b≤y, and the a+b→maxa+b→max.These bounds imply that tt takes values only in some range [t1;t2][t1;t2].Since the a+ba+b is linear function we can only consider t1t1 and t2t2 while searching for maximum a+ba+b. 1063E - Lasers and MirrorsThe answer is always nn (if the permutation is identity) lasers or n−1n−1 (otherwise).Clearly, we can't have more than n−1n−1 matching lasers if the permutation is not identity. Consider just the very first line with mirrors. If the first mirror in this line is «\\» then we miss the laser below this mirror, if the very last mirror is «/» we miss the laser below it. Otherwise there are neighbouring «/» and «\\» and we lost two lasers now.The proof of n−1n−1 is constructive one.Ignore all fixed points in permutation (all xx, that px=xpx=x).Select arbitrary cycle and select one point in it as «dead». We can spend |cycle|−1|cycle|−1 operations to fix all points in this cycle.But we also need to fix all other cycles. We can do it in |cycle|+1|cycle|+1 operations: move arbitrary beam to the wasted laser, fix all other points and move that point back.But this is a bit too much lines.The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line, if we select as the trash beam the rightmost point.See the following picture for an example (trash beam is the rightmost column): 1063F - String JourneyThis problem required quite a lot of nice observations!Observation 1. We can only consider journeys in which neighboring strings differ exactly by removing one symbol.All other journeys can be modified a bit to match the criterion above.Observation 2. If it is possible to start a journey at the symbol i with lengths of strings k, k - 1, ..., 1, it is always possible to start a journey at the same symbol i with lengths t, t - 1, ..., 1, given that t ≤ k.This suggests doing dynamic programming: dp[i] is the maximum possible k such that there is a journey starting at position i of k strings with lengths k, ..., 1.Due to observation 1 we only care about maximum – if we know maximum, we also known that all lesser values are also OK.So let's calculate this dynamic programming from right to left.How to check whether dp[i] ≥ k (given that tool, we can just use binary search for example)?There must be such j, that j ≥ i + k, dp[j] ≥ k - 1 and string sj, ..., sj + k - 2 must be a substring of string sisi + 1... si + k - 1 (basically just two cases \"left substring\" or \"right substring\").This almost gives us a solution, but we need few more observations to have , and not .Observation 3. If dp[i] = k, then dp[i + 1] ≥ k - 1.We can use this to kick binary search from the solution — when you calculate dp[i] you can start trying with dp[i + 1] + 1, descending until the success.Since there are exactly n grows, there will be at most n descendings and the total number of checks is linear. ?Observation? 4. We need to check whether such j exists in a fast way.Recall there are few conditions for us to follow, dp[j] ≥ const, j ≥ const and some string equality.If you carefully look at the restriction j ≥ const you can see, that when we move our dp calculation i → i - 1 or make dp[i] -= 1 this lower bound on j also moves only left, like in two pointers. So each moment some indexes j are \"available\" and some are not, and the border moves only left.Finally, time for some structures. Build Suffix Array and build segment tree over it. Let's store in the leaf of the segment tree dp[j] if it's already available or  - 1 otherwise.Let's check whether dp[i] = k is good. We want for string starting at j be either si, si + 1, ..., si + k - 2, or si + 1, si + 2, ..., si + k - 1. Consider these cases independently (however the procedure is pretty much same).All such strings form a segment of Suffix Array, we can for example use LCP + binary search over sparse tables to find corresponding bounds.Then we just need to query this segment and check if the maximum on it is at least k - 1.The solution is",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62455",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1064 和字母"
          },
          "content_length": 9243
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 1",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 2",
          "code": "20 7\n3 6\n5 2\n......*\n.****.*\n.****.*\n....*.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**.**.*\n**....*\n*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 3",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 4",
          "code": "if(lf[xx-DX][yy-DY] < lx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 5",
          "code": "sort(s.begin(), s.end()); cout<<s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 6",
          "code": "'a - 3 times, aa - 2 times aaa - 1 time, total - 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 7",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 8",
          "code": "10 6  \n10 6  \n5 2  \n**....  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n**.**.  \n....*.  \n.****.  \n......",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 9",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 10",
          "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC diagnostic ignored \"-Wunused-result\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 11",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 12",
          "code": "def ans():\n    n = int(input())\n    c = bin(n).count(\"1\")\n    ans = pow(2, c)\n\n    print(ans)\n\ntc = int(input())\nfor _ in range(tc):\n    ans()",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 13",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 14",
          "code": "input();print(''.join(sorted(input();input())))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 15",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (on the problems of Moscow Team Olympiad) [Rated] - Codeforces - Code 16",
          "code": "3 3\n1 1\n1000000000 1000000000\n.**\n***\n**.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62440",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 1",
          "code": "you have to call dfs with cell C again; \n   why?\n  because, now C has lesser leftCount or rightCount than before....so it may \n           able to visit more cells than before",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 2",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #516 (by Moscow Team Olympiad) — Editorial - Codeforces - Code 3",
          "code": "10 14\n7 7\n7 7\n******..******\n**...*.*******\n**.*..........\n...**********.\n.************.\n.*...********.\n.*.*.*........\n.*.*.*.*******\n.*.*.*.*******\n...*...*******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62455",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 100000000000LL, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1, n, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1, n, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(1, 100000000000LL, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 100000000000LL, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1, n, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1, n, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(1, 100000000000LL, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 100000000000LL, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1, n, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1, n, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(1, 100000000000LL, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    long long n = opt<long long>(\"n\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n    \n    long long l, r, k;\n\n    if (type == \"random\") {\n        l = rnd.next(1LL, n);\n        r = rnd.next(1LL, n);\n        k = rnd.next(1LL, min(n * 2LL, 100000000000LL));\n    } else if (type == \"l_equals_r\") {\n        l = rnd.next(1LL, n);\n        r = l;\n        k = rnd.next(1LL, min(n * 2LL, 100000000000LL));\n    } else if (type == \"edge_n1\") {\n        n = 1;\n        l = r = 1;\n        k = rnd.next(1LL, 2LL);\n    } else if (type == \"edge_k1\") {\n        l = rnd.next(1LL, n);\n        r = rnd.next(1LL, n);\n        k = 1;\n    } else if (type == \"max_k\") {\n        l = rnd.next(1LL, n);\n        r = rnd.next(1LL, n);\n        k = 100000000000LL;\n    } else if (type == \"max_n\") {\n        n = 100000000000LL;\n        l = rnd.next(1LL, n);\n        r = rnd.next(1LL, n);\n        k = rnd.next(1LL, 100000000000LL);\n    } else if (type == \"l_r_far\") {\n        l = 1;\n        r = n;\n        k = rnd.next(1LL, min(n * 2LL, 100000000000LL));\n    } else if (type == \"l_r_close\") {\n        l = rnd.next(1LL, n);\n        r = l % n + 1; // Next friend in the circle\n        k = rnd.next(1LL, min(n * 2LL, 100000000000LL));\n    } else {\n        // Default to random case\n        l = rnd.next(1LL, n);\n        r = rnd.next(1LL, n);\n        k = rnd.next(1LL, min(n * 2LL, 100000000000LL));\n    }\n\n    // Output the test case\n    printf(\"%lld %lld %lld %lld\\n\", n, l, r, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    long long n = opt<long long>(\"n\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n    \n    long long l, r, k;\n\n    if (type == \"random\") {\n        l = rnd.next(1LL, n);\n        r = rnd.next(1LL, n);\n        k = rnd.next(1LL, min(n * 2LL, 100000000000LL));\n    } else if (type == \"l_equals_r\") {\n        l = rnd.next(1LL, n);\n        r = l;\n        k = rnd.next(1LL, min(n * 2LL, 100000000000LL));\n    } else if (type == \"edge_n1\") {\n        n = 1;\n        l = r = 1;\n        k = rnd.next(1LL, 2LL);\n    } else if (type == \"edge_k1\") {\n        l = rnd.next(1LL, n);\n        r = rnd.next(1LL, n);\n        k = 1;\n    } else if (type == \"max_k\") {\n        l = rnd.next(1LL, n);\n        r = rnd.next(1LL, n);\n        k = 100000000000LL;\n    } else if (type == \"max_n\") {\n        n = 100000000000LL;\n        l = rnd.next(1LL, n);\n        r = rnd.next(1LL, n);\n        k = rnd.next(1LL, 100000000000LL);\n    } else if (type == \"l_r_far\") {\n        l = 1;\n        r = n;\n        k = rnd.next(1LL, min(n * 2LL, 100000000000LL));\n    } else if (type == \"l_r_close\") {\n        l = rnd.next(1LL, n);\n        r = l % n + 1; // Next friend in the circle\n        k = rnd.next(1LL, min(n * 2LL, 100000000000LL));\n    } else {\n        // Default to random case\n        l = rnd.next(1LL, n);\n        r = rnd.next(1LL, n);\n        k = rnd.next(1LL, min(n * 2LL, 100000000000LL));\n    }\n\n    // Output the test case\n    printf(\"%lld %lld %lld %lld\\n\", n, l, r, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type edge_n1\n./gen -n 1 -type random\n./gen -n 5 -type random\n./gen -n 5 -type edge_k1\n./gen -n 5 -type l_equals_r\n./gen -n 5 -type l_r_close\n./gen -n 10 -type random\n./gen -n 1000 -type random\n./gen -n 1000000 -type random\n./gen -n 1000000000 -type random\n./gen -n 100000000000 -type random\n./gen -n 100000000000 -type max_n\n./gen -n 100000000000 -type max_k\n./gen -n 1000 -type edge_k1\n./gen -n 1000 -type l_r_far\n./gen -n 1000 -type l_r_close\n./gen -n 100000 -type l_r_far\n./gen -n 100000 -type l_equals_r\n./gen -n 1000000 -type l_r_close\n./gen -n 10000000 -type edge_k1\n./gen -n 10000000 -type l_equals_r\n./gen -n 100000000 -type l_r_close\n./gen -n 1000000000 -type l_r_far\n./gen -n 1000000000 -type l_equals_r\n./gen -n 100000000000 -type l_equals_r\n./gen -n 100000000000 -type l_r_far\n./gen -n 100000000000 -type l_r_close\n./gen -n 99999999999 -type max_k\n./gen -n 100000 -type edge_k1\n./gen -n 50000000000 -type l_equals_r\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:13.494839",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1065/A",
      "title": "A. Vasya and Chocolate",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer tt (1≤t≤1001≤t≤100) — the number of testcases.Each of the next tt lines contains four integers s,a,b,c (1≤s,a,b,c≤109)s,a,b,c (1≤s,a,b,c≤109) — the number of roubles Vasya has, the number of chocolate bars you have to buy to use the special offer, the number of bars you get for free, and the cost of one bar, respectively.",
      "output_spec": "OutputPrint tt lines. ii-th line should contain the maximum possible number of chocolate bars Vasya can get in ii-th test.",
      "sample_tests": "ExampleInputCopy210 3 1 11000000000 1 1000000000 1OutputCopy131000000001000000000",
      "description": "A. Vasya and Chocolate\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one integer tt (1≤t≤1001≤t≤100) — the number of testcases.Each of the next tt lines contains four integers s,a,b,c (1≤s,a,b,c≤109)s,a,b,c (1≤s,a,b,c≤109) — the number of roubles Vasya has, the number of chocolate bars you have to buy to use the special offer, the number of bars you get for free, and the cost of one bar, respectively.\n\nOutputPrint tt lines. ii-th line should contain the maximum possible number of chocolate bars Vasya can get in ii-th test.\n\nInputCopy210 3 1 11000000000 1 1000000000 1OutputCopy131000000001000000000\n\nInputCopy210 3 1 11000000000 1 1000000000 1\n\nOutputCopy131000000001000000000\n\nNoteIn the first test of the example Vasya can buy 99 bars, get 33 for free, buy another bar, and so he will get 1313 bars.In the second test Vasya buys 10000000001000000000 bars and gets 10000000000000000001000000000000000000 for free. So he has 10000000010000000001000000001000000000 bars.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces",
          "content": "On Thursday, October 11, 2018 at 22:50UTC+8 Educational Codeforces Round 52 (Rated for Div. 2) will start. Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. The penalty for each incorrect submission until the submission with a full solution is 10 minutes. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Roman Roms Glazov, Adilbek adedalic Dalabaev, Vladimir vovuh Petrov, Ivan BledDest Androsov and me.Good luck to all participants!UPD 1: Our friends from Harbour.Space University are proposing you an unprecedented offer of free (and even with a scholarship!) robotics study in Barcelona! Read the details in the post by the link https://codeforces.com/blog/entry/62357UPD 2: I'll be on the community Discord server shortly after the contest to discuss the problems.Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 isaf27 7 263 2 HanwhaEagles 7 340 3 Skywynne 6 251 4 CJYeong 6 273 5 -wawawa8 6 280 Congratulations to the best hackers: Rank Competitor Hack Count 1 Laggy 63:-10 2 Doriath 38 3 BohdanPastuschak 38:-7 4 Kerman 36:-6 5 zoooma13 33:-2 860 successful hacks and 719 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A xiaowuc1 0:01 B xiaowuc1 0:03 C HanwhaEagles 0:07 D isaf27 0:33 E Kyouko 0:19 F mHuman 0:35 G tfg 0:44 UPD 3: Editorial is published",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1829
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces",
          "content": "1065A - Vasya and Chocolate Tutorial1065A - Vasya and ChocolateNumber of chocolate bars Vasya can buy without offer is cnt=⌊sc⌋cnt=⌊sc⌋.Number of \"bundles\" with aa bars x=⌊cnta⌋x=⌊cnta⌋.Then number of additional bars add=x⋅badd=x⋅b.In result, total number of bars is add+cntadd+cnt. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int s, a, b, c;\n int t;\n cin >> t;\n for(int i = 0; i < t; ++i){\n cin >> s >> a >> b >> c;\n\n s /= c;\n int x = s / a;\n s %= a;\n long long res = x * 1LL * (a + b);\n res += s;\n\n cout << res << endl;\n }\n return 0;\n}1065B - Vasya and Isolated Vertices Tutorial1065B - Vasya and Isolated VerticesVasya can decrease number of isolated vertices up to 22 using one edge and pairing them. So minimum number of isolated vertices is max(0,n−2m)max(0,n−2m).To calculate maximum number of isolated vertices let's keep number of non-isolated vertices knowing that each pair connected by edge (i.e. size of clique). Let we have size of clique curcur and remrem edges remained unassigned at current step. If rem=0rem=0 then answer is n−curn−cur. Otherwise we need to increase clique with one vertex. Maximum number of edges we can add to connect this vertex is add=min (rem,cur)add=min (rem,cur). So, subtract it from remrem and increase curcur by one. Repeat this step while remrem greater than zero. Answer is n−curn−cur.One corner case is next: if cur=1cur=1, then answer is nn, not n−curn−cur. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int n;\n long long m;\n cin >> n >> m;\n long long cur = 1;\n long long rem = m;\n while(rem > 0){\n long long d = min(cur, rem);\n rem -= d;\n ++cur;\n }\n assert(rem == 0);\n\n long long res = n;\n if(cur > 1) res = n - cur;\n\n cout << max(0ll, n - m * 2) << ' ' << res << endl;\n return 0;\n}1065C - Make It Equal Tutorial1065C - Make It EqualLet's iterate over height pospos of slice in decreasing order. All we need to know is a number of towers with height more than pospos (name it cc) and sum of its heights sumsum.Current slice on height pospos is good if k≥sum−c⋅posk≥sum−c⋅pos. Let's greedily decrease value pospos while slice on pospos is good keeping correct values cc and sumsum. When we found minimal good slice we can perform it increasing answer by one and \"changing tower heights\" just by setting new value to sumsum equal to c⋅posc⋅pos.Finish algorithm when pospos becomes equal to minimal height of towers and make final slice. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n scanf(\"%d %d\", &n, &k);\n for(int i = 0; i < n; ++i){\n int x;\n scanf(\"%d\", &x);\n h = max(h, x);\n need = min(need, x);\n ++cnt[x];\n }\n\n int pos = N - 1;\n int res = 0;\n long long sum = 0;\n int c = 0;\n while(true){\n long long x = sum - c * 1LL * (pos - 1);\n if(x > k){\n ++res;\n h = pos;\n sum = pos * 1LL * c;\n } \n\n --pos;\n if(pos == need) break;\n c += cnt[pos];\n sum += cnt[pos] * 1LL * pos;\n }\n\n if(h != need) ++res;\n\n cout << res << endl;\n}1065D - Three Pieces Tutorial1065D - Three PiecesThere are a lot of different solutions for the problem. Most of them have the similar structure.The first part is to find the shortest distance between the states (x1,y1,p1)(x1,y1,p1) and (x2,y2,p2)(x2,y2,p2), where xx and yy are the coordinates of the square and pp is the current piece. This can be done with 0-1 bfs, Floyd or Dijkstra. Just represent the triple as a single integer by transforming it to (x⋅n⋅3+y⋅3+p)(x⋅n⋅3+y⋅3+p) and do everything on that graph.The second part is to write some dp to go from ii-th square with piece p1p1 to (i+1)(i+1)-th square with piece p2p2. The value of this dp[n][3]dp[n][3] is a pair (moves, replacements). It is easy to see that you can always choose the minimum of two such pairs while updating.Overall complexity may vary. We believe, O(n4)O(n4) is achievable. However, the particular solution I coded works in O(n6)O(n6). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\nint dy[] = { 1, 2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n scanf(\"%d\", &n);\n forn(i, n) forn(j, n){\n scanf(\"%d\", &a[i][j]);\n --a[i][j];\n pos[a[i][j]] = mp(i, j);\n }\n\n forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n forn(i, M) dist[i][i] = mp(0, 0);\n\n forn(x, n) forn(y, n){\n forn(i, 8){\n int nx = x + dx[i];\n int ny = y + dy[i];\n if (in(nx, ny))\n dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n }\n\n for (int i = -n + 1; i <= n - 1; ++i){\n int nx = x + i;\n int ny = y + i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n ny = y - i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n }\n\n forn(i, n){\n int nx = x;\n int ny = i;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n nx = i;\n ny = y;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n }\n\n forn(i, 3) forn(j, 3){\n if (i != j){\n dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n }\n }\n }\n\n forn(k, M) forn(i, M) forn(j, M)\n dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n\n pt ans = mp(INF, INF);\n ans = min(ans, dp[n * n - 1][0]);\n ans = min(ans, dp[n * n - 1][1]);\n ans = min(ans, dp[n * n - 1][2]);\n\n printf(\"%d %d\\n\", ans.x, ans.y);\n return 0;\n}1065E - Side Transmutations Tutorial1065E - Side TransmutationsLet's take a look at any operation. You can notice that each letter can only go from position ii to n−i−1n−i−1 (00-indexed). Then, doing some operation twice is the same as doing that operation zero times.Now consider some set of operations l1,l2,…,lkl1,l2,…,lk, sorted in increasing order. Actually, they do the following altogether. Replace segment [lk−1..lk)[lk−1..lk) with the reversed segment ((n−lk−1)..(n−lk−1−1)]((n−lk−1)..(n−lk−1−1)] and vice versa. Then replace segment [lk−3..lk−2)[lk−3..lk−2) with the reversed segment ((n−lk−2−1)..(n−lk−3−1)]((n−lk−2−1)..(n−lk−3−1)] and vice versa. And continue until you reach the first pair. Segment [0..l1)[0..l1) might also be included in the answer when the parity is right.Moreover, every subset of segments [0..l1),[l1,l2),…[lk−1,lk)[0..l1),[l1,l2),…[lk−1,lk) is achievable. So for each segment you can either swap it or not. Let's translate it to math language.Let cnticnti be the number of such pairs of strings xx and yy that x≤yx≤y. Why is there such an order? You want to consider only unique strings, thus, you need to pick exactly one of equal strings from each component. Let it be the smallest one.Then for each segment of the set you have cntlencntlen pairs to choose from, where lenlen is the length of that segment.And that part of the formula is:cntb1⋅∏i=1mcntbi−bi−1cntb1⋅∏i=1mcntbi−bi−1.However, the part covered by zero segments is left. There are ALn−2bmALn−2bm possible strings up there.cnticnti is actually a number of all pairs of strings of length ii plus the number of all pairs of equal strings of length ii divided by 22. cnti=AL2i+ALi2cnti=AL2i+ALi2.Overall complexity: O(mlogn)O(mlog⁡n). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n a += b;\n if (a >= MOD)\n a -= MOD;\n return a;\n}\n\nint mul(int a, int b){\n return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n int res = 1;\n while (b){\n if (b & 1)\n res = mul(res, a);\n a = mul(a, a);\n b >>= 1;\n }\n return res;\n}\n\nint cnt(int x){\n int base = binpow(A, x);\n return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n scanf(\"%d%d%d\", &n, &m, &A);\n forn(i, m)\n scanf(\"%d\", &b[i]);\n\n int ans = binpow(A, n - b[m - 1] * 2);\n ans = mul(ans, cnt(b[0]));\n forn(i, m - 1)\n ans = mul(ans, cnt(b[i + 1] - b[i]));\n\n printf(\"%d\\n\", ans);\n return 0;\n}1065F - Up and Down the Tree Tutorial1065F - Up and Down the TreeLet's calculate answer in two steps. At first, let's calculate for each vertex vv drev(v)drev(v) — what we can gain if we must return from subtree of vv in the end. We need only pair of values: minimal possible depth we can acquire to move up from subtree of vv and maximal number of different leaves we can visit. Note, that this two values are independent since we must return from vv and if for some child toto of vv we can return from it, it's profitable to visit toto and return. But if we can't return from toto so we are prohibited to descent to toto. So, drev(v).seconddrev(v).second (number of visited leaves) is just a sum of all drev(to).seconddrev(to).second if drev(to).first≤hvdrev(to).first≤hv. Also note that we can always reorder all children in such way that last visited vertex toto will have minimal drev(to).firstdrev(to).first. So drev(to).firstdrev(to).first (minimal possible depth) is a minimum over all drev(to).firstdrev(to).first.At second, let's calculate d(v)d(v) — maximal number of different leaves we can visit if we don't need to return from subtree of vv. It can be calculated quite easy using array drev(v)drev(v). We just need to choose child toto we will not return from, so from vertex toto we will take value d(to)d(to) and from other childen (which we can return from) value drev(v).seconddrev(v).second.Result complexity is O(n)O(n). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n out << \"[\";\n fore(i, 0, v.size()) {\n if(i) out << \", \";\n out << v[i];\n }\n return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n if(!(cin >> n >> k))\n return false;\n fore(i, 1, n) {\n int p; assert(scanf(\"%d\", &p) == 1);\n p--;\n\n g[p].push_back(i);\n g[i].push_back(p);\n }\n return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n drev[v] = pt(INF, 0);\n for(int to : g[v]) {\n if(to == p) continue;\n\n h[to] = h[v] + 1;\n calcRev(to, v);\n\n if(drev[to].x <= h[v]) {\n drev[v].x = min(drev[v].x, drev[to].x);\n drev[v].y += drev[to].y;\n }\n }\n\n if(p >= 0 && g[v].size() == 1)\n drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n d[v] = (p >= 0 && g[v].size() == 1);\n for(int to : g[v]) {\n if(to == p) continue;\n calcAns(to, v);\n\n int tmp = drev[v].y;\n if(drev[to].x <= h[v])\n tmp -= drev[to].y;\n\n d[v] = max(d[v], tmp + d[to]);\n }\n}\n\ninline void solve() {\n h[0] = 0;\n calcRev(0, -1);\n calcAns(0, -1);\n cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n freopen(\"input.txt\", \"r\", stdin);\n int tt = clock();\n#endif\n cout << fixed << setprecision(15);\n\n if(read()) {\n solve();\n\n#ifdef _DEBUG\n cerr << \"TIME = \" << clock() - tt << endl;\n tt = clock();\n#endif\n }\n return 0;\n}1065G - Fibonacci Suffix Tutorial1065G - Fibonacci SuffixSuppose we added all the suffixes of F(n)F(n) into a trie. Then we can find kk-th suffix by descending the trie, checking the sizes of subtrees to choose where to go on each iteration.The model solution actually does that, but computes the sizes of subtrees without building the whole trie. Recall that if we insert all suffixes of a string into the trie, then the size of subtree of some vertex is equal to the number of occurences of the string denoted by this vertex in the original string.Since in our problem the strings are recurrent, we may use prefix automaton to count the number of occurences. To calculate the number of occurences of string ss in F(x)F(x), let's build prefix function for ss, and an automaton Ap,cAp,c which tells the value of prefix function, if the previous value was pp, and we appended cc to the string (the same approach is used in KMP substring search algorithm). Then, let's build another automaton that will help us work with Fibonacci string: Fp,xFp,x — what will be the value of prefix function, if we append F(x)F(x) to the string? For x=0x=0 and x=1x=1, this automaton can be easily built using Ap,0Ap,0 and Ap,1Ap,1; and for x>1x>1, we may build Fp,xFp,x using the automatons for x−2x−2 and x−1x−1. We also have to keep track of the number of occurences, that can be done with another automaton on fibonacci strings.There is a corner case when we need to stop descending the trie; to handle it, we need to check whether some string is a suffix of F(n)F(n), but that can be easily made by checking if F0,n=|s|F0,n=|s|.Each step in trie forces us to do up to three (depending on your implementation) queries like \"count the number of occurences of some string in F(n)F(n)\", so overall the solution works in O(nm2)O(nm2). Solution (BledDest)#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n z = (int)(s.size());\n p[0] = 0;\n for(int i = 1; i < z; i++)\n {\n int j = p[i - 1];\n while(j > 0 && s[j] != s[i])\n j = p[j - 1];\n if(s[j] == s[i])\n j++;\n p[i] = j;\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n if(i < z && s[i] == char('0' + j))\n A1[i][j] = i + 1;\n else if(i == 0)\n A1[i][j] = 0;\n else\n A1[i][j] = A1[p[i - 1]][j];\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n A3[i][j] = A1[i][j];\n A2[i][j] = (A3[i][j] == z ? 1 : 0);\n }\n for(int i = 2; i <= n; i++)\n for(int j = 0; j <= z; j++)\n {\n A3[j][i] = A3[A3[j][i - 2]][i - 1];\n A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n }\n}\n\nint main()\n{\n cin >> n >> k >> m;\n string cur = \"\";\n for(int i = 0; i < m; i++)\n {\n if(cur != \"\") build(cur);\n li x = 0;\n if(cur != \"\" && A3[0][n] == i)\n x = 1;\n if(k == 1 && x == 1)\n break;\n k -= x;\n build(cur + '0');\n li x1 = A2[0][n];\n if(k > x1)\n {\n cur += '1';\n k -= x1;\n }\n else\n cur += '0';\n }\n cout << cur << endl;\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62411",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1065\\s*A"
          },
          "content_length": 14742
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "is what programmers are looking for",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 15",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 16",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 17",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 18",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100);\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int s = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int a = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int b = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int c = inf.readInt(1, 1000000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100);\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int s = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int a = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int b = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int c = inf.readInt(1, 1000000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100);\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int s = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int a = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int b = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int c = inf.readInt(1, 1000000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n\n    for (int i = 0; i < t; ++i) {\n        long long s, a, b, c;\n        if (type == \"random\") {\n            s = rnd.next(1LL, 1000000000LL);\n            a = rnd.next(1LL, 1000000000LL);\n            b = rnd.next(1LL, 1000000000LL);\n            c = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"max_values\") {\n            s = 1000000000LL;\n            a = 1000000000LL;\n            b = 1000000000LL;\n            c = 1;\n        } else if (type == \"min_values\") {\n            s = 1;\n            a = 1;\n            b = 1;\n            c = 1;\n        } else if (type == \"a_is_1\") {\n            s = rnd.next(1LL, 1000000000LL);\n            a = 1;\n            b = rnd.next(1LL, 1000000000LL);\n            c = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"b_is_large\") {\n            s = rnd.next(1LL, 1000000000LL);\n            a = rnd.next(1LL, 1000000000LL);\n            b = 1000000000LL;\n            c = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"offer_never_used\") {\n            c = rnd.next(1LL, 1000000000LL);\n            s = rnd.next(c, 1000000000LL);\n            long long N_buy = s / c;\n            a = N_buy + rnd.next(1LL, 1000LL);\n            b = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"offer_always_used\") {\n            s = rnd.next(1LL, 1000000000LL);\n            c = rnd.next(1LL, 1000000000LL);\n            a = rnd.next(1LL, 10LL);\n            b = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"edge_cases\") {\n            if (i % 2 == 0) {\n                // s less than c\n                c = rnd.next(2LL, 1000000000LL);\n                s = rnd.next(1LL, c - 1);\n                a = rnd.next(1LL, 1000000000LL);\n                b = rnd.next(1LL, 1000000000LL);\n            } else {\n                // N_buy is exact multiple of a\n                c = rnd.next(1LL, 1000000000LL);\n                long long multiplier = rnd.next(1LL, 100000LL);\n                s = c * multiplier * rnd.next(1LL, 1000LL);\n                a = rnd.next(1LL, 1000LL);\n                if (multiplier % a != 0) {\n                    a = 1;\n                }\n                b = rnd.next(1LL, 1000000000LL);\n            }\n        } else {\n            // Default random\n            s = rnd.next(1LL, 1000000000LL);\n            a = rnd.next(1LL, 1000000000LL);\n            b = rnd.next(1LL, 1000000000LL);\n            c = rnd.next(1LL, 1000000000LL);\n        }\n        printf(\"%lld %lld %lld %lld\\n\", s, a, b, c);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n\n    for (int i = 0; i < t; ++i) {\n        long long s, a, b, c;\n        if (type == \"random\") {\n            s = rnd.next(1LL, 1000000000LL);\n            a = rnd.next(1LL, 1000000000LL);\n            b = rnd.next(1LL, 1000000000LL);\n            c = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"max_values\") {\n            s = 1000000000LL;\n            a = 1000000000LL;\n            b = 1000000000LL;\n            c = 1;\n        } else if (type == \"min_values\") {\n            s = 1;\n            a = 1;\n            b = 1;\n            c = 1;\n        } else if (type == \"a_is_1\") {\n            s = rnd.next(1LL, 1000000000LL);\n            a = 1;\n            b = rnd.next(1LL, 1000000000LL);\n            c = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"b_is_large\") {\n            s = rnd.next(1LL, 1000000000LL);\n            a = rnd.next(1LL, 1000000000LL);\n            b = 1000000000LL;\n            c = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"offer_never_used\") {\n            c = rnd.next(1LL, 1000000000LL);\n            s = rnd.next(c, 1000000000LL);\n            long long N_buy = s / c;\n            a = N_buy + rnd.next(1LL, 1000LL);\n            b = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"offer_always_used\") {\n            s = rnd.next(1LL, 1000000000LL);\n            c = rnd.next(1LL, 1000000000LL);\n            a = rnd.next(1LL, 10LL);\n            b = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"edge_cases\") {\n            if (i % 2 == 0) {\n                // s less than c\n                c = rnd.next(2LL, 1000000000LL);\n                s = rnd.next(1LL, c - 1);\n                a = rnd.next(1LL, 1000000000LL);\n                b = rnd.next(1LL, 1000000000LL);\n            } else {\n                // N_buy is exact multiple of a\n                c = rnd.next(1LL, 1000000000LL);\n                long long multiplier = rnd.next(1LL, 100000LL);\n                s = c * multiplier * rnd.next(1LL, 1000LL);\n                a = rnd.next(1LL, 1000LL);\n                if (multiplier % a != 0) {\n                    a = 1;\n                }\n                b = rnd.next(1LL, 1000000000LL);\n            }\n        } else {\n            // Default random\n            s = rnd.next(1LL, 1000000000LL);\n            a = rnd.next(1LL, 1000000000LL);\n            b = rnd.next(1LL, 1000000000LL);\n            c = rnd.next(1LL, 1000000000LL);\n        }\n        printf(\"%lld %lld %lld %lld\\n\", s, a, b, c);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type min_values\n./gen -t 1 -type max_values\n./gen -t 1 -type random\n\n./gen -t 10 -type random\n./gen -t 100 -type random\n\n./gen -t 10 -type a_is_1\n./gen -t 10 -type b_is_large\n./gen -t 10 -type offer_never_used\n./gen -t 10 -type offer_always_used\n./gen -t 10 -type edge_cases\n\n./gen -t 100 -type a_is_1\n./gen -t 100 -type b_is_large\n./gen -t 100 -type offer_never_used\n./gen -t 100 -type offer_always_used\n./gen -t 100 -type edge_cases\n\n./gen -t 50 -type a_is_1\n./gen -t 50 -type b_is_large\n\n./gen -t 50 -type offer_never_used\n./gen -t 50 -type offer_always_used\n\n./gen -t 50 -type min_values\n./gen -t 50 -type max_values\n\n./gen -t 5 -type edge_cases\n\n./gen -t 20 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:15.379885",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1065/B",
      "title": "B. Вася и изолированные вершины",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеЕдинственная строка содержит два числа nn и m (1≤n≤105,0≤m≤n(n−1)2)m (1≤n≤105,0≤m≤n(n−1)2).Гарантируется, что при данных ограничениях существует граф без петель и кратных ребер.",
      "output_spec": "Выходные данныеВ единственной строке выведите два числа minmin и maxmax — минимальное и максимальное количество изолированных вершин соответственно.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 2Выходные данныеСкопировать0 1Входные данныеСкопировать3 1Выходные данныеСкопировать1 1",
      "description": "B. Вася и изолированные вершины\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеЕдинственная строка содержит два числа nn и m (1≤n≤105,0≤m≤n(n−1)2)m (1≤n≤105,0≤m≤n(n−1)2).Гарантируется, что при данных ограничениях существует граф без петель и кратных ребер.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите два числа minmin и maxmax — минимальное и максимальное количество изолированных вершин соответственно.\n\nВыходные данные\n\nВходные данныеСкопировать4 2Выходные данныеСкопировать0 1Входные данныеСкопировать3 1Выходные данныеСкопировать1 1\n\nВходные данныеСкопировать4 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере 00 изолированных вершин будет в графе, состоящим из ребер (1,2)(1,2) и (3,4)(3,4). Одна изолированная вершина будет в графе, состоящим из ребер (1,2)(1,2) и (1,3)(1,3). Во втором тестовом примере в любом случае будет одна изолированная вершина.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 52 [рейтинговый для Div. 2] - Codeforces",
          "content": "Привет, Codeforces!В четверг, 11 октября 2018 г. в 22:50UTC+8 состоится Educational Codeforces Round 52 (рейтинговый для Див. 2). Продолжается серия образовательных раундов в рамках инициативы Harbour.Space University! Подробности о сотрудничестве Harbour.Space University и Codeforces можно прочитать в посте.Этот раунд будет рейтинговым для участников с рейтингом менее 2100. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. Штраф за каждую неверную посылку до посылки, являющейся полным решением, равен 10 минутам. После окончания раунда будет период времени длительностью в 12 часов, в течение которого вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования.Вам будет предложено 7 задач на 2 часа. Мы надеемся, что вам они покажутся интересными.Задачи вместе со мной придумывали и готовили Роман Roms Глазов, Адилбек adedalic Далабаев, Владимир vovuh Петров и Иван BledDest Андросов.Удачи в раунде! Успешных решений!UPD 1: Наши партнёры из университета Harbour.Space попросили донести до участников раунда беспрецедентное предложение о бесплатном обучении в Барселоне (плюс стипендия!) по направлению робототехника. Подразумевается магистерская программа в Harbour.Space University. Все подробности в посте https://codeforces.com/blog/entry/62357.UPD 2: Жду всех желающих в местном Discord сервере сразу после контеста для обсуждения задач.Поздравляем победителей: Место Участник Задач решено Штраф 1 isaf27 7 263 2 HanwhaEagles 7 340 3 Skywynne 6 251 4 CJYeong 6 273 5 -wawawa8 6 280 Поздравляем лучших взломщиков: Место Участник Число взломов 1 Laggy 63:-10 2 Doriath 38 3 BohdanPastuschak 38:-7 4 Kerman 36:-6 5 zoooma13 33:-2 Было сделано 860 успешных и 719 неудачных взломов.И, наконец, поздравляем людей, отправивших первое полное решение по задаче: Задача Участник Штраф A xiaowuc1 0:01 B xiaowuc1 0:03 C HanwhaEagles 0:07 D isaf27 0:33 E Kyouko 0:19 F mHuman 0:35 G tfg 0:44 UPD 3: Разбор опубликован",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2038
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces",
          "content": "1065A - Вася и шоколадки Разбор1065A - Вася и шоколадкиКоличество шоколадок, которые Вася может купить без акции равно cnt=⌊sc⌋cnt=⌊sc⌋.Количество «групп» по aa шоколадок равно x=⌊cnta⌋x=⌊cnta⌋.Количество дополнительных шоколадок равно add=x⋅badd=x⋅b.А значит, всего общее количество шоколадок равно add+cntadd+cnt. Решение (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int s, a, b, c;\n int t;\n cin >> t;\n for(int i = 0; i < t; ++i){\n cin >> s >> a >> b >> c;\n\n s /= c;\n int x = s / a;\n s %= a;\n long long res = x * 1LL * (a + b);\n res += s;\n\n cout << res << endl;\n }\n return 0;\n}1065B - Вася и изолированные вершины Разбор1065B - Вася и изолированные вершиныДобавляя одно ребро, Вася всегда может уменьшить количество изолированных вершин на 2 (конечно, если в графе есть хотя бы две изолированные вершины). А значит, минимальное количество изолированных вершин равно max (0,n−2m)max (0,n−2m).Для того, чтобы посчитать максимальное количество изолированных вершин будем поддерживать размер множества неизолированных вершин, при этом это множество должно содержать максимальное количество ребер. Пусть сейчас у нас множество размера curcur и осталось remrem ребер. Если remrem равно нулю, то ответ равен n−curn−cur. Иначе нам нужно добавить в множество минимум одну вершину. При этом максимальное количество ребер, которое добавится равно add=min (rem,cur)add=min (rem,cur). Отнимем это количество от remrem и увеличим curcur на еденицу. Будем выполнять этот процесс, пока remrem не станет равным нулю. Ответом же будет n−curn−cur. Есть один частный случай. Если cur=1cur=1, то ответ равен nn, а не n−curn−cur. Решение (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int n;\n long long m;\n cin >> n >> m;\n long long cur = 1;\n long long rem = m;\n while(rem > 0){\n long long d = min(cur, rem);\n rem -= d;\n ++cur;\n }\n assert(rem == 0);\n\n long long res = n;\n if(cur > 1) res = n - cur;\n\n cout << max(0ll, n - m * 2) << ' ' << res << endl;\n return 0;\n}1065C - Выравниваем высоты Разбор1065C - Выравниваем высотыБудем перебирать величину среза от больших значений к меньшим. Все, что нам нужно знать при этом это количество башен с большей высотой (назовем это значение cc) и сумму высот этих башен (назовем это значение sumsum).Пусть сейчас мы рассматриваем срез pospos. Тогда этот срез будет хорошим если k≥sum−c⋅posk≥sum−c⋅pos. Будем уменьшать значение pospos, пока срез pospos будет хорошим, при этом будем корректоно поддерживать значения cc и sumsum. После того, как мы нашли минимальный хороший срез, увеличим ответ на единицу, срежем наши башни по нему и изменим значение sumsum на c⋅posc⋅pos.После того, как pospos станет равен высоте минимальной башни, перестанем его уменьшать. При этом к ответу нужно добавить единицу, если последний срез, который мы делали больше высоты минимальной башни. Решение (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n scanf(\"%d %d\", &n, &k);\n for(int i = 0; i < n; ++i){\n int x;\n scanf(\"%d\", &x);\n h = max(h, x);\n need = min(need, x);\n ++cnt[x];\n }\n\n int pos = N - 1;\n int res = 0;\n long long sum = 0;\n int c = 0;\n while(true){\n long long x = sum - c * 1LL * (pos - 1);\n if(x > k){\n ++res;\n h = pos;\n sum = pos * 1LL * c;\n } \n\n --pos;\n if(pos == need) break;\n c += cnt[pos];\n sum += cnt[pos] * 1LL * pos;\n }\n\n if(h != need) ++res;\n\n cout << res << endl;\n}1065D - Три фигуры Разбор1065D - Три фигурыЕсть множество подходов к данной задаче. Большинство из них имеют одинаковую структуру.В первой части необходимо найти кратчайшее расстояние между состояниями (x1,y1,p1)(x1,y1,p1) и (x2,y2,p2)(x2,y2,p2), где xx и yy — координаты клетки, а pp — текущая фигура. Это может быть насчитано с помощью 0-1 bfs, Флойда или Дейкстры. Просто представим тройку, как одно число, преобразовав его в (x⋅n⋅3+y⋅3+p)(x⋅n⋅3+y⋅3+p), и будем решать задачу на этом графе.Во второй части требовалась некоторая динамика для перехода от ii-го квадрата с фигурой p1p1 к (i+1)(i+1)-у квадрату с фигурой p2p2. Значение этого dp[n][3]dp[n][3] — это пара (ходы, замены). Легко показать, что можно всегда выбирать минимальную из двух таких пар при обновлении.Асимптотика решения может отличаться. Мы полагаем, O(n4)O(n4) вполне реально. Однако, решение, которое я написал, работает за O(n6)O(n6). Решение (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\nint dy[] = { 1, 2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n scanf(\"%d\", &n);\n forn(i, n) forn(j, n){\n scanf(\"%d\", &a[i][j]);\n --a[i][j];\n pos[a[i][j]] = mp(i, j);\n }\n\n forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n forn(i, M) dist[i][i] = mp(0, 0);\n\n forn(x, n) forn(y, n){\n forn(i, 8){\n int nx = x + dx[i];\n int ny = y + dy[i];\n if (in(nx, ny))\n dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n }\n\n for (int i = -n + 1; i <= n - 1; ++i){\n int nx = x + i;\n int ny = y + i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n ny = y - i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n }\n\n forn(i, n){\n int nx = x;\n int ny = i;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n nx = i;\n ny = y;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n }\n\n forn(i, 3) forn(j, 3){\n if (i != j){\n dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n }\n }\n }\n\n forn(k, M) forn(i, M) forn(j, M)\n dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n\n pt ans = mp(INF, INF);\n ans = min(ans, dp[n * n - 1][0]);\n ans = min(ans, dp[n * n - 1][1]);\n ans = min(ans, dp[n * n - 1][2]);\n\n printf(\"%d %d\\n\", ans.x, ans.y);\n return 0;\n}1065E - Преобразования краев Разбор1065E - Преобразования краевВзглянем на любую операцию. Можно заметить, что каждая буква перемещается только с позиции ii на n−i−1n−i−1 (в 00-индексации). Значит проделать операцию дважды — это то же, что не проделать ее вообще.Теперь взглянем на некоторый набор операций l1,l2,…,lkl1,l2,…,lk, отсортированных в возрастающем порядке. На самом деле, вот что они вместе делают. Заменить отрезок [lk−1..lk)[lk−1..lk) на перевернутый отрезок ((n−lk−1)..(n−lk−1−1)]((n−lk−1)..(n−lk−1−1)] и наоборот. Потом заменить отрезок [lk−3..lk−2)[lk−3..lk−2) на перевернутый отрезок ((n−lk−2−1)..(n−lk−3−1)]((n−lk−2−1)..(n−lk−3−1)] и наоборот. Продолжать, пока не достигнется первая пара. Отрезок [0..l1)[0..l1) может также оказаться включен в ответ, если четность правильная.Более того, любой поднабор отрезков [0..l1),[l1,l2),…[lk−1,lk)[0..l1),[l1,l2),…[lk−1,lk) можно собрать. Тогда можно либо заменять некоторый отрезок, либо не заменять. Переведем это на математический язык.Пусть cnticnti — это количество таких пар строк xx и yy, что x≤yx≤y. Почему такой порядок? Мы хотим рассматривать только уникальные строки, поэтому из каждой компоненты надо выбрать ровно одну. Давайте выберем меньшую.Тогда для каждого отрезка из множества есть cntlencntlen пар для выбора, где lenlen — это длина этого отрезка.Тогда эта часть формулы:cntb1⋅∏i=1mcntbi−bi−1cntb1⋅∏i=1mcntbi−bi−1.Однако, потерялась часть, не покрытая ни одним отрезком. Есть ALn−2bmALn−2bm возможных строк для нее.cnticnti — это, на самом деле, количество всех пар строк длины ii плюс количество пар равных строк длины ii, все деленное на 22. cnti=AL2i+ALi2cnti=AL2i+ALi2.Асимптотика решения: O(mlogn)O(mlog⁡n). Решение (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n a += b;\n if (a >= MOD)\n a -= MOD;\n return a;\n}\n\nint mul(int a, int b){\n return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n int res = 1;\n while (b){\n if (b & 1)\n res = mul(res, a);\n a = mul(a, a);\n b >>= 1;\n }\n return res;\n}\n\nint cnt(int x){\n int base = binpow(A, x);\n return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n scanf(\"%d%d%d\", &n, &m, &A);\n forn(i, m)\n scanf(\"%d\", &b[i]);\n\n int ans = binpow(A, n - b[m - 1] * 2);\n ans = mul(ans, cnt(b[0]));\n forn(i, m - 1)\n ans = mul(ans, cnt(b[i + 1] - b[i]));\n\n printf(\"%d\\n\", ans);\n return 0;\n}1065F - Вверх и вниз по дереву Разбор1065F - Вверх и вниз по деревуПосчитаем ответ в 2 этапа: Во-первых, почитаем для каждой вершины vv drev(v)drev(v) — что мы сможем получить если в конце обязаны вернуться из поддерева вершины vv. Нам нужны только только два значения: минимальная возможная глубина на которую мы сможем выпрыгнуть из поддерева vv и максимальное количество различных листов, которые мы сможем посетить. Заметим, что данные величины независимы, так как мы обязаны вернуться из поддерева vv и, если для какого-то сына toto вершины vv мы сможем вернуться из него, то всегда выгодно посетить toto и вернуться. С другой стороны, если мы не сможем вернуться из поддерева toto, то нам и нельзя спускаться в toto. Поэтому, drev(v).seconddrev(v).second (количество посещенных листов) — просто сумма по всем drev(to).seconddrev(to).second у которых drev(to).first≤hvdrev(to).first≤hv. Также заметим, что мы всегда можем обходить детей в таком порядке, что у последнего посещенного toto будет минимальное drev(to).firstdrev(to).first. Поэтому, drev(to).firstdrev(to).first (минимальная возможная глубина) — это минимум по всем drev(to).firstdrev(to).first.Во-вторых, посчитаем d(v)d(v) — максимальное количество различных листов, которые мы сможем посетить, если нам не нужно возвращаться из поддерева vv. Это значение может быть посчитано довольно просто, используя массив drev(v)drev(v). Нам просто надо выбрать сына toto, в которого мы перейдем и не вернемся, тогда от него мы возьмем d(to)d(to), а от всех остальных детей (из которых возможно вернуться) значения drev(v).seconddrev(v).second.Результирующая асимптотика — O(n)O(n). Решение (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n out << \"[\";\n fore(i, 0, v.size()) {\n if(i) out << \", \";\n out << v[i];\n }\n return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n if(!(cin >> n >> k))\n return false;\n fore(i, 1, n) {\n int p; assert(scanf(\"%d\", &p) == 1);\n p--;\n\n g[p].push_back(i);\n g[i].push_back(p);\n }\n return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n drev[v] = pt(INF, 0);\n for(int to : g[v]) {\n if(to == p) continue;\n\n h[to] = h[v] + 1;\n calcRev(to, v);\n\n if(drev[to].x <= h[v]) {\n drev[v].x = min(drev[v].x, drev[to].x);\n drev[v].y += drev[to].y;\n }\n }\n\n if(p >= 0 && g[v].size() == 1)\n drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n d[v] = (p >= 0 && g[v].size() == 1);\n for(int to : g[v]) {\n if(to == p) continue;\n calcAns(to, v);\n\n int tmp = drev[v].y;\n if(drev[to].x <= h[v])\n tmp -= drev[to].y;\n\n d[v] = max(d[v], tmp + d[to]);\n }\n}\n\ninline void solve() {\n h[0] = 0;\n calcRev(0, -1);\n calcAns(0, -1);\n cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n freopen(\"input.txt\", \"r\", stdin);\n int tt = clock();\n#endif\n cout << fixed << setprecision(15);\n\n if(read()) {\n solve();\n\n#ifdef _DEBUG\n cerr << \"TIME = \" << clock() - tt << endl;\n tt = clock();\n#endif\n }\n return 0;\n}1065G - Суффиксы Фибоначчи Разбор1065G - Суффиксы ФибоначчиПредположим, мы вставили все суффиксы F(n)F(n) в бор. Тогда можно найти kk-й суффикс спуском по бору, принимая решение, в какое поддерево идти, на основании размеров поддеревьев.Авторское решение именно так и поступает, за одним исключением: оно не строит бор в явном виде. Напомним, что если вставить все суффиксы строки в бор, то размер поддерева некоторой вершины равен кол-ву вхождений подстроки, задаваемой этой вершиной, в исходную строку.Так как в нашей задаче строки задаются рекуррентным соотношением, то можно использовать автомат по префикс-функции. Чтобы посчитать количество вхождений строки ss в F(x)F(x), построим префикс-функцию для ss, а по ней — автомат Ap,cAp,c, отвечающий на запросы, каким будет новое значение префикс-функции, если предыдущее было равно pp, и мы дописали cc в конец строки (то же самое используется в алгоритме Кнута —  Морриса —  Пратта). Затем построим второй автомат, который позволит работать со строками Фибоначчи: Fp,xFp,x — каким станет значение префикс-функции, если дописать F(x)F(x) в конец строки? Для x=0x=0 и x=1x=1 можно использовать значения Ap,0Ap,0 и Ap,1Ap,1; а при x>1x>1 Fp,xFp,x строится через автоматы для x−2x−2 и x−1x−1. Надо еще поддерживать количество вхождений, это можно делать третьим автоматом по строкам Фибоначчи.Есть частный случай, когда не нужно продолжать спускаться по бору; чтобы его обработать, нам нужно уметь проверять, что строка является суффиксом F(n)F(n), но это легко делается проверкой того, что F0,n=|s|F0,n=|s|.Каждый шаг в боре требует до трех (в зависимости от реализации) запросов «подсчитать количество вхождений некоторой строки в F(n)F(n)», поэтому решение работает за O(nm2)O(nm2). Решение (BledDest)#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n z = (int)(s.size());\n p[0] = 0;\n for(int i = 1; i < z; i++)\n {\n int j = p[i - 1];\n while(j > 0 && s[j] != s[i])\n j = p[j - 1];\n if(s[j] == s[i])\n j++;\n p[i] = j;\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n if(i < z && s[i] == char('0' + j))\n A1[i][j] = i + 1;\n else if(i == 0)\n A1[i][j] = 0;\n else\n A1[i][j] = A1[p[i - 1]][j];\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n A3[i][j] = A1[i][j];\n A2[i][j] = (A3[i][j] == z ? 1 : 0);\n }\n for(int i = 2; i <= n; i++)\n for(int j = 0; j <= z; j++)\n {\n A3[j][i] = A3[A3[j][i - 2]][i - 1];\n A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n }\n}\n\nint main()\n{\n cin >> n >> k >> m;\n string cur = \"\";\n for(int i = 0; i < m; i++)\n {\n if(cur != \"\") build(cur);\n li x = 0;\n if(cur != \"\" && A3[0][n] == i)\n x = 1;\n if(k == 1 && x == 1)\n break;\n k -= x;\n build(cur + '0');\n li x1 = A2[0][n];\n if(k > x1)\n {\n cur += '1';\n k -= x1;\n }\n else\n cur += '0';\n }\n cout << cur << endl;\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62411",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1065\\s*B"
          },
          "content_length": 15198
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 52 [рейтинговый для Div. 2] - Codeforces - Code 1",
          "code": "is what programmers are looking for",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [рейтинговый для Div. 2] - Codeforces - Code 2",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [рейтинговый для Div. 2] - Codeforces - Code 3",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 15",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 16",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 17",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 52 - Codeforces - Code 18",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long nLong = n;\n    long long maxM = nLong * (nLong - 1) / 2;\n    long long m = inf.readLong(0, maxM, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long nLong = n;\n    long long maxM = nLong * (nLong - 1) / 2;\n    long long m = inf.readLong(0, maxM, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long nLong = n;\n    long long maxM = nLong * (nLong - 1) / 2;\n    long long m = inf.readLong(0, maxM, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    long long m;\n\n    if (type == \"zero_m\") {\n        m = 0;\n    } else if (type == \"max_m\") {\n        m = 1LL * n * (n - 1) / 2;\n    } else if (type == \"minimal\") {\n        // minimal isolated vertices (n - 2m = 0)\n        m = n / 2;\n    } else if (type == \"maximal\") {\n        // maximal isolated vertices (n - k where m ≤ k(k-1)/2)\n        // Since m = 0, maximal number of isolated vertices is n\n        m = 0;\n    } else if (type == \"random\") {\n        long long max_edges = 1LL * n * (n - 1) / 2;\n        m = rnd.next(0LL, max_edges);\n    } else if (type == \"edge_case\") {\n        // m values around k(k-1)/2 for some k\n        int k = rnd.next(1, n);\n        long long kk = 1LL * k * (k - 1) / 2;\n        // Choose m as kk, kk -1, or kk +1 to test boundary conditions\n        int delta = rnd.next(-1, 1);\n        m = kk + delta;\n        if (m < 0) m = 0;\n        if (m > 1LL * n * (n - 1) / 2) m = 1LL * n * (n - 1) / 2;\n    } else if (type == \"half\") {\n        m = (1LL * n * (n - 1)) / 4;\n    } else if (type == \"almost_max\") {\n        m = 1LL * n * (n - 1) / 2 - 1;\n    } else if (type == \"one\") {\n        m = 1;\n    } else if (type == \"just_enough\") {\n        // minimal k such that k(k -1)/2 ≥ m\n        // Let's pick k and compute m = k(k -1)/2\n        int k = rnd.next(1, n);\n        m = 1LL * k * (k - 1) / 2;\n    } else if (type == \"just_less\") {\n        // m = k(k -1)/2 - 1\n        int k = rnd.next(2, n);\n        m = 1LL * k * (k - 1) / 2 - 1;\n        if (m < 0) m = 0;\n    } else {\n        // default random\n        long long max_edges = 1LL * n * (n - 1) / 2;\n        m = rnd.next(0LL, max_edges);\n    }\n\n    // Ensure m is within the allowed range\n    long long max_edges = 1LL * n * (n - 1) / 2;\n    if (m < 0) m = 0;\n    if (m > max_edges) m = max_edges;\n\n    // Output n and m\n    printf(\"%d %lld\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    long long m;\n\n    if (type == \"zero_m\") {\n        m = 0;\n    } else if (type == \"max_m\") {\n        m = 1LL * n * (n - 1) / 2;\n    } else if (type == \"minimal\") {\n        // minimal isolated vertices (n - 2m = 0)\n        m = n / 2;\n    } else if (type == \"maximal\") {\n        // maximal isolated vertices (n - k where m ≤ k(k-1)/2)\n        // Since m = 0, maximal number of isolated vertices is n\n        m = 0;\n    } else if (type == \"random\") {\n        long long max_edges = 1LL * n * (n - 1) / 2;\n        m = rnd.next(0LL, max_edges);\n    } else if (type == \"edge_case\") {\n        // m values around k(k-1)/2 for some k\n        int k = rnd.next(1, n);\n        long long kk = 1LL * k * (k - 1) / 2;\n        // Choose m as kk, kk -1, or kk +1 to test boundary conditions\n        int delta = rnd.next(-1, 1);\n        m = kk + delta;\n        if (m < 0) m = 0;\n        if (m > 1LL * n * (n - 1) / 2) m = 1LL * n * (n - 1) / 2;\n    } else if (type == \"half\") {\n        m = (1LL * n * (n - 1)) / 4;\n    } else if (type == \"almost_max\") {\n        m = 1LL * n * (n - 1) / 2 - 1;\n    } else if (type == \"one\") {\n        m = 1;\n    } else if (type == \"just_enough\") {\n        // minimal k such that k(k -1)/2 ≥ m\n        // Let's pick k and compute m = k(k -1)/2\n        int k = rnd.next(1, n);\n        m = 1LL * k * (k - 1) / 2;\n    } else if (type == \"just_less\") {\n        // m = k(k -1)/2 - 1\n        int k = rnd.next(2, n);\n        m = 1LL * k * (k - 1) / 2 - 1;\n        if (m < 0) m = 0;\n    } else {\n        // default random\n        long long max_edges = 1LL * n * (n - 1) / 2;\n        m = rnd.next(0LL, max_edges);\n    }\n\n    // Ensure m is within the allowed range\n    long long max_edges = 1LL * n * (n - 1) / 2;\n    if (m < 0) m = 0;\n    if (m > max_edges) m = max_edges;\n\n    // Output n and m\n    printf(\"%d %lld\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zero_m\n./gen -n 1 -type max_m\n\n./gen -n 2 -type zero_m\n./gen -n 2 -type max_m\n\n./gen -n 3 -type minimal\n./gen -n 3 -type maximal\n\n./gen -n 4 -type minimal\n./gen -n 4 -type maximal\n\n./gen -n 5 -type random\n./gen -n 5 -type edge_case\n\n./gen -n 100 -type zero_m\n./gen -n 100 -type max_m\n./gen -n 100 -type random\n./gen -n 100 -type just_less\n./gen -n 100 -type just_enough\n\n./gen -n 1000 -type random\n./gen -n 1000 -type half\n./gen -n 1000 -type almost_max\n\n./gen -n 10000 -type minimal\n./gen -n 10000 -type maximal\n./gen -n 10000 -type random\n\n./gen -n 100000 -type minimal\n./gen -n 100000 -type maximal\n./gen -n 100000 -type random\n./gen -n 100000 -type just_less\n./gen -n 100000 -type just_enough\n\n./gen -n 99999 -type random\n./gen -n 99999 -type edge_case\n./gen -n 99999 -type half\n\n./gen -n 54321 -type random\n./gen -n 54321 -type minimal\n./gen -n 54321 -type maximal\n\n./gen -n 77777 -type one\n./gen -n 77777 -type zero_m\n./gen -n 77777 -type max_m\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:16.930072",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1065/C",
      "title": "C. Make It Equal",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and kk (1≤n≤2⋅1051≤n≤2⋅105, n≤k≤109n≤k≤109) — the number of towers and the restriction on slices, respectively.The second line contains nn space separated integers h1,h2,…,hnh1,h2,…,hn (1≤hi≤2⋅1051≤hi≤2⋅105) — the initial heights of towers.",
      "output_spec": "OutputPrint one integer — the minimum number of good slices you have to do to make all towers have the same heigth.",
      "sample_tests": "ExamplesInputCopy5 53 1 2 2 4OutputCopy2InputCopy4 52 3 4 5OutputCopy2",
      "description": "C. Make It Equal\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and kk (1≤n≤2⋅1051≤n≤2⋅105, n≤k≤109n≤k≤109) — the number of towers and the restriction on slices, respectively.The second line contains nn space separated integers h1,h2,…,hnh1,h2,…,hn (1≤hi≤2⋅1051≤hi≤2⋅105) — the initial heights of towers.\n\nOutputPrint one integer — the minimum number of good slices you have to do to make all towers have the same heigth.\n\nInputCopy5 53 1 2 2 4OutputCopy2InputCopy4 52 3 4 5OutputCopy2\n\nInputCopy5 53 1 2 2 4\n\nOutputCopy2\n\nInputCopy4 52 3 4 5\n\nOutputCopy2\n\nNoteIn the first example it's optimal to make 22 slices. The first slice is on height 22 (its cost is 33), and the second one is on height 11 (its cost is 44).",
      "solutions": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces",
          "content": "On Thursday, October 11, 2018 at 22:50UTC+8 Educational Codeforces Round 52 (Rated for Div. 2) will start. Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. The penalty for each incorrect submission until the submission with a full solution is 10 minutes. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Roman Roms Glazov, Adilbek adedalic Dalabaev, Vladimir vovuh Petrov, Ivan BledDest Androsov and me.Good luck to all participants!UPD 1: Our friends from Harbour.Space University are proposing you an unprecedented offer of free (and even with a scholarship!) robotics study in Barcelona! Read the details in the post by the link https://codeforces.com/blog/entry/62357UPD 2: I'll be on the community Discord server shortly after the contest to discuss the problems.Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 isaf27 7 263 2 HanwhaEagles 7 340 3 Skywynne 6 251 4 CJYeong 6 273 5 -wawawa8 6 280 Congratulations to the best hackers: Rank Competitor Hack Count 1 Laggy 63:-10 2 Doriath 38 3 BohdanPastuschak 38:-7 4 Kerman 36:-6 5 zoooma13 33:-2 860 successful hacks and 719 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A xiaowuc1 0:01 B xiaowuc1 0:03 C HanwhaEagles 0:07 D isaf27 0:33 E Kyouko 0:19 F mHuman 0:35 G tfg 0:44 UPD 3: Editorial is published",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1829
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces",
          "content": "1065A - Vasya and Chocolate Tutorial1065A - Vasya and ChocolateNumber of chocolate bars Vasya can buy without offer is cnt=⌊sc⌋cnt=⌊sc⌋.Number of \"bundles\" with aa bars x=⌊cnta⌋x=⌊cnta⌋.Then number of additional bars add=x⋅badd=x⋅b.In result, total number of bars is add+cntadd+cnt. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int s, a, b, c;\n int t;\n cin >> t;\n for(int i = 0; i < t; ++i){\n cin >> s >> a >> b >> c;\n\n s /= c;\n int x = s / a;\n s %= a;\n long long res = x * 1LL * (a + b);\n res += s;\n\n cout << res << endl;\n }\n return 0;\n}1065B - Vasya and Isolated Vertices Tutorial1065B - Vasya and Isolated VerticesVasya can decrease number of isolated vertices up to 22 using one edge and pairing them. So minimum number of isolated vertices is max(0,n−2m)max(0,n−2m).To calculate maximum number of isolated vertices let's keep number of non-isolated vertices knowing that each pair connected by edge (i.e. size of clique). Let we have size of clique curcur and remrem edges remained unassigned at current step. If rem=0rem=0 then answer is n−curn−cur. Otherwise we need to increase clique with one vertex. Maximum number of edges we can add to connect this vertex is add=min (rem,cur)add=min (rem,cur). So, subtract it from remrem and increase curcur by one. Repeat this step while remrem greater than zero. Answer is n−curn−cur.One corner case is next: if cur=1cur=1, then answer is nn, not n−curn−cur. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int n;\n long long m;\n cin >> n >> m;\n long long cur = 1;\n long long rem = m;\n while(rem > 0){\n long long d = min(cur, rem);\n rem -= d;\n ++cur;\n }\n assert(rem == 0);\n\n long long res = n;\n if(cur > 1) res = n - cur;\n\n cout << max(0ll, n - m * 2) << ' ' << res << endl;\n return 0;\n}1065C - Make It Equal Tutorial1065C - Make It EqualLet's iterate over height pospos of slice in decreasing order. All we need to know is a number of towers with height more than pospos (name it cc) and sum of its heights sumsum.Current slice on height pospos is good if k≥sum−c⋅posk≥sum−c⋅pos. Let's greedily decrease value pospos while slice on pospos is good keeping correct values cc and sumsum. When we found minimal good slice we can perform it increasing answer by one and \"changing tower heights\" just by setting new value to sumsum equal to c⋅posc⋅pos.Finish algorithm when pospos becomes equal to minimal height of towers and make final slice. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n scanf(\"%d %d\", &n, &k);\n for(int i = 0; i < n; ++i){\n int x;\n scanf(\"%d\", &x);\n h = max(h, x);\n need = min(need, x);\n ++cnt[x];\n }\n\n int pos = N - 1;\n int res = 0;\n long long sum = 0;\n int c = 0;\n while(true){\n long long x = sum - c * 1LL * (pos - 1);\n if(x > k){\n ++res;\n h = pos;\n sum = pos * 1LL * c;\n } \n\n --pos;\n if(pos == need) break;\n c += cnt[pos];\n sum += cnt[pos] * 1LL * pos;\n }\n\n if(h != need) ++res;\n\n cout << res << endl;\n}1065D - Three Pieces Tutorial1065D - Three PiecesThere are a lot of different solutions for the problem. Most of them have the similar structure.The first part is to find the shortest distance between the states (x1,y1,p1)(x1,y1,p1) and (x2,y2,p2)(x2,y2,p2), where xx and yy are the coordinates of the square and pp is the current piece. This can be done with 0-1 bfs, Floyd or Dijkstra. Just represent the triple as a single integer by transforming it to (x⋅n⋅3+y⋅3+p)(x⋅n⋅3+y⋅3+p) and do everything on that graph.The second part is to write some dp to go from ii-th square with piece p1p1 to (i+1)(i+1)-th square with piece p2p2. The value of this dp[n][3]dp[n][3] is a pair (moves, replacements). It is easy to see that you can always choose the minimum of two such pairs while updating.Overall complexity may vary. We believe, O(n4)O(n4) is achievable. However, the particular solution I coded works in O(n6)O(n6). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\nint dy[] = { 1, 2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n scanf(\"%d\", &n);\n forn(i, n) forn(j, n){\n scanf(\"%d\", &a[i][j]);\n --a[i][j];\n pos[a[i][j]] = mp(i, j);\n }\n\n forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n forn(i, M) dist[i][i] = mp(0, 0);\n\n forn(x, n) forn(y, n){\n forn(i, 8){\n int nx = x + dx[i];\n int ny = y + dy[i];\n if (in(nx, ny))\n dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n }\n\n for (int i = -n + 1; i <= n - 1; ++i){\n int nx = x + i;\n int ny = y + i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n ny = y - i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n }\n\n forn(i, n){\n int nx = x;\n int ny = i;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n nx = i;\n ny = y;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n }\n\n forn(i, 3) forn(j, 3){\n if (i != j){\n dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n }\n }\n }\n\n forn(k, M) forn(i, M) forn(j, M)\n dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n\n pt ans = mp(INF, INF);\n ans = min(ans, dp[n * n - 1][0]);\n ans = min(ans, dp[n * n - 1][1]);\n ans = min(ans, dp[n * n - 1][2]);\n\n printf(\"%d %d\\n\", ans.x, ans.y);\n return 0;\n}1065E - Side Transmutations Tutorial1065E - Side TransmutationsLet's take a look at any operation. You can notice that each letter can only go from position ii to n−i−1n−i−1 (00-indexed). Then, doing some operation twice is the same as doing that operation zero times.Now consider some set of operations l1,l2,…,lkl1,l2,…,lk, sorted in increasing order. Actually, they do the following altogether. Replace segment [lk−1..lk)[lk−1..lk) with the reversed segment ((n−lk−1)..(n−lk−1−1)]((n−lk−1)..(n−lk−1−1)] and vice versa. Then replace segment [lk−3..lk−2)[lk−3..lk−2) with the reversed segment ((n−lk−2−1)..(n−lk−3−1)]((n−lk−2−1)..(n−lk−3−1)] and vice versa. And continue until you reach the first pair. Segment [0..l1)[0..l1) might also be included in the answer when the parity is right.Moreover, every subset of segments [0..l1),[l1,l2),…[lk−1,lk)[0..l1),[l1,l2),…[lk−1,lk) is achievable. So for each segment you can either swap it or not. Let's translate it to math language.Let cnticnti be the number of such pairs of strings xx and yy that x≤yx≤y. Why is there such an order? You want to consider only unique strings, thus, you need to pick exactly one of equal strings from each component. Let it be the smallest one.Then for each segment of the set you have cntlencntlen pairs to choose from, where lenlen is the length of that segment.And that part of the formula is:cntb1⋅∏i=1mcntbi−bi−1cntb1⋅∏i=1mcntbi−bi−1.However, the part covered by zero segments is left. There are ALn−2bmALn−2bm possible strings up there.cnticnti is actually a number of all pairs of strings of length ii plus the number of all pairs of equal strings of length ii divided by 22. cnti=AL2i+ALi2cnti=AL2i+ALi2.Overall complexity: O(mlogn)O(mlog⁡n). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n a += b;\n if (a >= MOD)\n a -= MOD;\n return a;\n}\n\nint mul(int a, int b){\n return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n int res = 1;\n while (b){\n if (b & 1)\n res = mul(res, a);\n a = mul(a, a);\n b >>= 1;\n }\n return res;\n}\n\nint cnt(int x){\n int base = binpow(A, x);\n return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n scanf(\"%d%d%d\", &n, &m, &A);\n forn(i, m)\n scanf(\"%d\", &b[i]);\n\n int ans = binpow(A, n - b[m - 1] * 2);\n ans = mul(ans, cnt(b[0]));\n forn(i, m - 1)\n ans = mul(ans, cnt(b[i + 1] - b[i]));\n\n printf(\"%d\\n\", ans);\n return 0;\n}1065F - Up and Down the Tree Tutorial1065F - Up and Down the TreeLet's calculate answer in two steps. At first, let's calculate for each vertex vv drev(v)drev(v) — what we can gain if we must return from subtree of vv in the end. We need only pair of values: minimal possible depth we can acquire to move up from subtree of vv and maximal number of different leaves we can visit. Note, that this two values are independent since we must return from vv and if for some child toto of vv we can return from it, it's profitable to visit toto and return. But if we can't return from toto so we are prohibited to descent to toto. So, drev(v).seconddrev(v).second (number of visited leaves) is just a sum of all drev(to).seconddrev(to).second if drev(to).first≤hvdrev(to).first≤hv. Also note that we can always reorder all children in such way that last visited vertex toto will have minimal drev(to).firstdrev(to).first. So drev(to).firstdrev(to).first (minimal possible depth) is a minimum over all drev(to).firstdrev(to).first.At second, let's calculate d(v)d(v) — maximal number of different leaves we can visit if we don't need to return from subtree of vv. It can be calculated quite easy using array drev(v)drev(v). We just need to choose child toto we will not return from, so from vertex toto we will take value d(to)d(to) and from other childen (which we can return from) value drev(v).seconddrev(v).second.Result complexity is O(n)O(n). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n out << \"[\";\n fore(i, 0, v.size()) {\n if(i) out << \", \";\n out << v[i];\n }\n return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n if(!(cin >> n >> k))\n return false;\n fore(i, 1, n) {\n int p; assert(scanf(\"%d\", &p) == 1);\n p--;\n\n g[p].push_back(i);\n g[i].push_back(p);\n }\n return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n drev[v] = pt(INF, 0);\n for(int to : g[v]) {\n if(to == p) continue;\n\n h[to] = h[v] + 1;\n calcRev(to, v);\n\n if(drev[to].x <= h[v]) {\n drev[v].x = min(drev[v].x, drev[to].x);\n drev[v].y += drev[to].y;\n }\n }\n\n if(p >= 0 && g[v].size() == 1)\n drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n d[v] = (p >= 0 && g[v].size() == 1);\n for(int to : g[v]) {\n if(to == p) continue;\n calcAns(to, v);\n\n int tmp = drev[v].y;\n if(drev[to].x <= h[v])\n tmp -= drev[to].y;\n\n d[v] = max(d[v], tmp + d[to]);\n }\n}\n\ninline void solve() {\n h[0] = 0;\n calcRev(0, -1);\n calcAns(0, -1);\n cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n freopen(\"input.txt\", \"r\", stdin);\n int tt = clock();\n#endif\n cout << fixed << setprecision(15);\n\n if(read()) {\n solve();\n\n#ifdef _DEBUG\n cerr << \"TIME = \" << clock() - tt << endl;\n tt = clock();\n#endif\n }\n return 0;\n}1065G - Fibonacci Suffix Tutorial1065G - Fibonacci SuffixSuppose we added all the suffixes of F(n)F(n) into a trie. Then we can find kk-th suffix by descending the trie, checking the sizes of subtrees to choose where to go on each iteration.The model solution actually does that, but computes the sizes of subtrees without building the whole trie. Recall that if we insert all suffixes of a string into the trie, then the size of subtree of some vertex is equal to the number of occurences of the string denoted by this vertex in the original string.Since in our problem the strings are recurrent, we may use prefix automaton to count the number of occurences. To calculate the number of occurences of string ss in F(x)F(x), let's build prefix function for ss, and an automaton Ap,cAp,c which tells the value of prefix function, if the previous value was pp, and we appended cc to the string (the same approach is used in KMP substring search algorithm). Then, let's build another automaton that will help us work with Fibonacci string: Fp,xFp,x — what will be the value of prefix function, if we append F(x)F(x) to the string? For x=0x=0 and x=1x=1, this automaton can be easily built using Ap,0Ap,0 and Ap,1Ap,1; and for x>1x>1, we may build Fp,xFp,x using the automatons for x−2x−2 and x−1x−1. We also have to keep track of the number of occurences, that can be done with another automaton on fibonacci strings.There is a corner case when we need to stop descending the trie; to handle it, we need to check whether some string is a suffix of F(n)F(n), but that can be easily made by checking if F0,n=|s|F0,n=|s|.Each step in trie forces us to do up to three (depending on your implementation) queries like \"count the number of occurences of some string in F(n)F(n)\", so overall the solution works in O(nm2)O(nm2). Solution (BledDest)#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n z = (int)(s.size());\n p[0] = 0;\n for(int i = 1; i < z; i++)\n {\n int j = p[i - 1];\n while(j > 0 && s[j] != s[i])\n j = p[j - 1];\n if(s[j] == s[i])\n j++;\n p[i] = j;\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n if(i < z && s[i] == char('0' + j))\n A1[i][j] = i + 1;\n else if(i == 0)\n A1[i][j] = 0;\n else\n A1[i][j] = A1[p[i - 1]][j];\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n A3[i][j] = A1[i][j];\n A2[i][j] = (A3[i][j] == z ? 1 : 0);\n }\n for(int i = 2; i <= n; i++)\n for(int j = 0; j <= z; j++)\n {\n A3[j][i] = A3[A3[j][i - 2]][i - 1];\n A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n }\n}\n\nint main()\n{\n cin >> n >> k >> m;\n string cur = \"\";\n for(int i = 0; i < m; i++)\n {\n if(cur != \"\") build(cur);\n li x = 0;\n if(cur != \"\" && A3[0][n] == i)\n x = 1;\n if(k == 1 && x == 1)\n break;\n k -= x;\n build(cur + '0');\n li x1 = A2[0][n];\n if(k > x1)\n {\n cur += '1';\n k -= x1;\n }\n else\n cur += '0';\n }\n cout << cur << endl;\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62411",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1065\\s*C"
          },
          "content_length": 14742
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "is what programmers are looking for",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 15",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 16",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 17",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 18",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(n, 1000000000, \"k\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 200000, \"h_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(n, 1000000000, \"k\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 200000, \"h_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(n, 1000000000, \"k\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 200000, \"h_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 200000) {\n        fprintf(stderr, \"Parameter n must satisfy 1 ≤ n ≤ 200000\\n\");\n        return 1;\n    }\n    if (k < n || k > 1000000000) {\n        fprintf(stderr, \"Parameter k must satisfy n ≤ k ≤ 10^9\\n\");\n        return 1;\n    }\n\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        // Random heights between 1 and 200000\n        for(int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, 200000);\n        }\n    } else if (type == \"same_height\") {\n        // All the same height\n        int height = rnd.next(1, 200000);\n        for(int i = 0; i < n; ++i) {\n            h[i] = height;\n        }\n    } else if (type == \"max_height\") {\n        // All heights are maximum\n        for(int i = 0; i < n; ++i) {\n            h[i] = 200000;\n        }\n    } else if (type == \"min_height\") {\n        // All heights are minimum\n        for(int i = 0; i < n; ++i) {\n            h[i] = 1;\n        }\n    } else if (type == \"ascending\") {\n        // Heights from 1 to 200000, in ascending order\n        for(int i = 0; i < n; ++i) {\n            h[i] = (i % 200000) + 1;\n        }\n        sort(h.begin(), h.end());\n    } else if (type == \"descending\") {\n        // Heights from 200000 down to 1\n        for(int i = 0; i < n; ++i) {\n            h[i] = 200000 - (i % 200000);\n        }\n        sort(h.rbegin(), h.rend());\n    } else if (type == \"one_high_rest_low\") {\n        // One tower with maximum height, rest with minimum height\n        h[0] = 200000;\n        for(int i = 1; i < n; ++i) {\n            h[i] = 1;\n        }\n        shuffle(h.begin(), h.end());\n    } else if (type == \"two_heights\") {\n        // Half towers with one height, half with another\n        int h1 = rnd.next(1, 200000);\n        int h2 = rnd.next(1, 200000);\n        while(h2 == h1) {\n            h2 = rnd.next(1, 200000);\n        }\n        for(int i = 0; i < n; ++i) {\n            if(i % 2 == 0) {\n                h[i] = h1;\n            } else {\n                h[i] = h2;\n            }\n        }\n        shuffle(h.begin(), h.end());\n    } else if (type == \"random_uniform\") {\n        // Heights chosen uniformly randomly between min_h and max_h\n        int min_h = opt<int>(\"min_h\", 1);\n        int max_h = opt<int>(\"max_h\", 200000);\n        if (min_h < 1 || max_h > 200000 || min_h > max_h) {\n            fprintf(stderr, \"Invalid min_h or max_h: must satisfy 1 ≤ min_h ≤ max_h ≤ 200000\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n; ++i) {\n            h[i] = rnd.next(min_h, max_h);\n        }\n    } else if (type == \"random_skewed\") {\n        // Skewed distribution - more low heights\n        for(int i = 0; i < n; ++i) {\n            int prob = rnd.next(1, 100);\n            if(prob <= 80) {\n                h[i] = rnd.next(1, 1000); // Low height\n            } else {\n                h[i] = rnd.next(100000, 200000); // High height\n            }\n        }\n    } else {\n        // Handle invalid type\n        fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output heights\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", h[i]);\n        if(i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 200000) {\n        fprintf(stderr, \"Parameter n must satisfy 1 ≤ n ≤ 200000\\n\");\n        return 1;\n    }\n    if (k < n || k > 1000000000) {\n        fprintf(stderr, \"Parameter k must satisfy n ≤ k ≤ 10^9\\n\");\n        return 1;\n    }\n\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        // Random heights between 1 and 200000\n        for(int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, 200000);\n        }\n    } else if (type == \"same_height\") {\n        // All the same height\n        int height = rnd.next(1, 200000);\n        for(int i = 0; i < n; ++i) {\n            h[i] = height;\n        }\n    } else if (type == \"max_height\") {\n        // All heights are maximum\n        for(int i = 0; i < n; ++i) {\n            h[i] = 200000;\n        }\n    } else if (type == \"min_height\") {\n        // All heights are minimum\n        for(int i = 0; i < n; ++i) {\n            h[i] = 1;\n        }\n    } else if (type == \"ascending\") {\n        // Heights from 1 to 200000, in ascending order\n        for(int i = 0; i < n; ++i) {\n            h[i] = (i % 200000) + 1;\n        }\n        sort(h.begin(), h.end());\n    } else if (type == \"descending\") {\n        // Heights from 200000 down to 1\n        for(int i = 0; i < n; ++i) {\n            h[i] = 200000 - (i % 200000);\n        }\n        sort(h.rbegin(), h.rend());\n    } else if (type == \"one_high_rest_low\") {\n        // One tower with maximum height, rest with minimum height\n        h[0] = 200000;\n        for(int i = 1; i < n; ++i) {\n            h[i] = 1;\n        }\n        shuffle(h.begin(), h.end());\n    } else if (type == \"two_heights\") {\n        // Half towers with one height, half with another\n        int h1 = rnd.next(1, 200000);\n        int h2 = rnd.next(1, 200000);\n        while(h2 == h1) {\n            h2 = rnd.next(1, 200000);\n        }\n        for(int i = 0; i < n; ++i) {\n            if(i % 2 == 0) {\n                h[i] = h1;\n            } else {\n                h[i] = h2;\n            }\n        }\n        shuffle(h.begin(), h.end());\n    } else if (type == \"random_uniform\") {\n        // Heights chosen uniformly randomly between min_h and max_h\n        int min_h = opt<int>(\"min_h\", 1);\n        int max_h = opt<int>(\"max_h\", 200000);\n        if (min_h < 1 || max_h > 200000 || min_h > max_h) {\n            fprintf(stderr, \"Invalid min_h or max_h: must satisfy 1 ≤ min_h ≤ max_h ≤ 200000\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n; ++i) {\n            h[i] = rnd.next(min_h, max_h);\n        }\n    } else if (type == \"random_skewed\") {\n        // Skewed distribution - more low heights\n        for(int i = 0; i < n; ++i) {\n            int prob = rnd.next(1, 100);\n            if(prob <= 80) {\n                h[i] = rnd.next(1, 1000); // Low height\n            } else {\n                h[i] = rnd.next(100000, 200000); // High height\n            }\n        }\n    } else {\n        // Handle invalid type\n        fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output heights\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", h[i]);\n        if(i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, minimal k\n./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type same_height\n./gen -n 1 -k 1 -type max_height\n./gen -n 1 -k 1 -type min_height\n\n# Small n, varying k\n./gen -n 10 -k 10 -type random\n./gen -n 10 -k 10 -type same_height\n./gen -n 10 -k 10 -type two_heights\n\n# Small n, maximum k\n./gen -n 10 -k 1000000000 -type random\n./gen -n 10 -k 1000000000 -type one_high_rest_low\n\n# Medium n, medium k\n./gen -n 1000 -k 10000 -type random\n./gen -n 1000 -k 10000 -type same_height\n./gen -n 1000 -k 10000 -type max_height\n./gen -n 1000 -k 10000 -type min_height\n\n# Medium n, different k\n./gen -n 1000 -k 1000 -type random\n./gen -n 1000 -k 5000 -type ascending\n./gen -n 1000 -k 5000 -type descending\n\n# Large n, minimal k\n./gen -n 200000 -k 200000 -type random\n./gen -n 200000 -k 200000 -type same_height\n./gen -n 200000 -k 200000 -type two_heights\n\n# Large n, maximum k\n./gen -n 200000 -k 1000000000 -type random\n./gen -n 200000 -k 1000000000 -type max_height\n./gen -n 200000 -k 1000000000 -type min_height\n\n# Random skewed heights\n./gen -n 100000 -k 1000000 -type random_skewed\n\n# Random uniform heights with specified min and max\n./gen -n 100000 -k 1000000 -type random_uniform -min_h 1 -max_h 1000\n./gen -n 100000 -k 1000000 -type random_uniform -min_h 100000 -max_h 200000\n\n# One high rest low\n./gen -n 200000 -k 1000000000 -type one_high_rest_low\n\n# Max possible heights\n./gen -n 200000 -k 1000000000 -type max_height\n\n# Ascending heights\n./gen -n 200000 -k 1000000000 -type ascending\n\n# Descending heights\n./gen -n 200000 -k 1000000000 -type descending\n\n# Random with small k\n./gen -n 200000 -k 200000 -type random\n\n# Random with large k\n./gen -n 200000 -k 1000000000 -type random\n\n# Testing k slightly larger than n\n./gen -n 200000 -k 250000 -type random\n\n# Two heights, with maximum difference\n./gen -n 200000 -k 500000 -type two_heights\n\n# Random skewed with more high towers\n./gen -n 200000 -k 1000000000 -type random_skewed\n\n# Random uniform with min_h = max_h\n./gen -n 100000 -k 1000000 -type random_uniform -min_h 12345 -max_h 12345\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:19.134169",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1065/D",
      "title": "D. Three Pieces",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer NN (3≤N≤103≤N≤10) — the size of the chessboard.Each of the next NN lines contains NN integers Ai1,Ai2,…,AiNAi1,Ai2,…,AiN (1≤Aij≤N21≤Aij≤N2) — the numbers written on the squares of the ii-th row of the board.It is guaranteed that all AijAij are pairwise distinct.",
      "output_spec": "OutputThe only line should contain two integers — the number of steps in the best answer and the number of replacement moves in it.",
      "sample_tests": "ExampleInputCopy31 9 38 6 74 2 5OutputCopy12 1",
      "description": "D. Three Pieces\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer NN (3≤N≤103≤N≤10) — the size of the chessboard.Each of the next NN lines contains NN integers Ai1,Ai2,…,AiNAi1,Ai2,…,AiN (1≤Aij≤N21≤Aij≤N2) — the numbers written on the squares of the ii-th row of the board.It is guaranteed that all AijAij are pairwise distinct.\n\nOutputThe only line should contain two integers — the number of steps in the best answer and the number of replacement moves in it.\n\nInputCopy31 9 38 6 74 2 5OutputCopy12 1\n\nInputCopy31 9 38 6 74 2 5\n\nOutputCopy12 1\n\nNoteHere are the steps for the first example (the starting piece is a knight):  Move to (3,2)(3,2)  Move to (1,3)(1,3)  Move to (3,2)(3,2)  Replace the knight with a rook  Move to (3,1)(3,1)  Move to (3,3)(3,3)  Move to (3,2)(3,2)  Move to (2,2)(2,2)  Move to (2,3)(2,3)  Move to (2,1)(2,1)  Move to (1,1)(1,1)  Move to (1,2)(1,2)",
      "solutions": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces",
          "content": "On Thursday, October 11, 2018 at 22:50UTC+8 Educational Codeforces Round 52 (Rated for Div. 2) will start. Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. The penalty for each incorrect submission until the submission with a full solution is 10 minutes. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Roman Roms Glazov, Adilbek adedalic Dalabaev, Vladimir vovuh Petrov, Ivan BledDest Androsov and me.Good luck to all participants!UPD 1: Our friends from Harbour.Space University are proposing you an unprecedented offer of free (and even with a scholarship!) robotics study in Barcelona! Read the details in the post by the link https://codeforces.com/blog/entry/62357UPD 2: I'll be on the community Discord server shortly after the contest to discuss the problems.Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 isaf27 7 263 2 HanwhaEagles 7 340 3 Skywynne 6 251 4 CJYeong 6 273 5 -wawawa8 6 280 Congratulations to the best hackers: Rank Competitor Hack Count 1 Laggy 63:-10 2 Doriath 38 3 BohdanPastuschak 38:-7 4 Kerman 36:-6 5 zoooma13 33:-2 860 successful hacks and 719 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A xiaowuc1 0:01 B xiaowuc1 0:03 C HanwhaEagles 0:07 D isaf27 0:33 E Kyouko 0:19 F mHuman 0:35 G tfg 0:44 UPD 3: Editorial is published",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1829
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces",
          "content": "1065A - Vasya and Chocolate Tutorial1065A - Vasya and ChocolateNumber of chocolate bars Vasya can buy without offer is cnt=⌊sc⌋cnt=⌊sc⌋.Number of \"bundles\" with aa bars x=⌊cnta⌋x=⌊cnta⌋.Then number of additional bars add=x⋅badd=x⋅b.In result, total number of bars is add+cntadd+cnt. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int s, a, b, c;\n int t;\n cin >> t;\n for(int i = 0; i < t; ++i){\n cin >> s >> a >> b >> c;\n\n s /= c;\n int x = s / a;\n s %= a;\n long long res = x * 1LL * (a + b);\n res += s;\n\n cout << res << endl;\n }\n return 0;\n}1065B - Vasya and Isolated Vertices Tutorial1065B - Vasya and Isolated VerticesVasya can decrease number of isolated vertices up to 22 using one edge and pairing them. So minimum number of isolated vertices is max(0,n−2m)max(0,n−2m).To calculate maximum number of isolated vertices let's keep number of non-isolated vertices knowing that each pair connected by edge (i.e. size of clique). Let we have size of clique curcur and remrem edges remained unassigned at current step. If rem=0rem=0 then answer is n−curn−cur. Otherwise we need to increase clique with one vertex. Maximum number of edges we can add to connect this vertex is add=min (rem,cur)add=min (rem,cur). So, subtract it from remrem and increase curcur by one. Repeat this step while remrem greater than zero. Answer is n−curn−cur.One corner case is next: if cur=1cur=1, then answer is nn, not n−curn−cur. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int n;\n long long m;\n cin >> n >> m;\n long long cur = 1;\n long long rem = m;\n while(rem > 0){\n long long d = min(cur, rem);\n rem -= d;\n ++cur;\n }\n assert(rem == 0);\n\n long long res = n;\n if(cur > 1) res = n - cur;\n\n cout << max(0ll, n - m * 2) << ' ' << res << endl;\n return 0;\n}1065C - Make It Equal Tutorial1065C - Make It EqualLet's iterate over height pospos of slice in decreasing order. All we need to know is a number of towers with height more than pospos (name it cc) and sum of its heights sumsum.Current slice on height pospos is good if k≥sum−c⋅posk≥sum−c⋅pos. Let's greedily decrease value pospos while slice on pospos is good keeping correct values cc and sumsum. When we found minimal good slice we can perform it increasing answer by one and \"changing tower heights\" just by setting new value to sumsum equal to c⋅posc⋅pos.Finish algorithm when pospos becomes equal to minimal height of towers and make final slice. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n scanf(\"%d %d\", &n, &k);\n for(int i = 0; i < n; ++i){\n int x;\n scanf(\"%d\", &x);\n h = max(h, x);\n need = min(need, x);\n ++cnt[x];\n }\n\n int pos = N - 1;\n int res = 0;\n long long sum = 0;\n int c = 0;\n while(true){\n long long x = sum - c * 1LL * (pos - 1);\n if(x > k){\n ++res;\n h = pos;\n sum = pos * 1LL * c;\n } \n\n --pos;\n if(pos == need) break;\n c += cnt[pos];\n sum += cnt[pos] * 1LL * pos;\n }\n\n if(h != need) ++res;\n\n cout << res << endl;\n}1065D - Three Pieces Tutorial1065D - Three PiecesThere are a lot of different solutions for the problem. Most of them have the similar structure.The first part is to find the shortest distance between the states (x1,y1,p1)(x1,y1,p1) and (x2,y2,p2)(x2,y2,p2), where xx and yy are the coordinates of the square and pp is the current piece. This can be done with 0-1 bfs, Floyd or Dijkstra. Just represent the triple as a single integer by transforming it to (x⋅n⋅3+y⋅3+p)(x⋅n⋅3+y⋅3+p) and do everything on that graph.The second part is to write some dp to go from ii-th square with piece p1p1 to (i+1)(i+1)-th square with piece p2p2. The value of this dp[n][3]dp[n][3] is a pair (moves, replacements). It is easy to see that you can always choose the minimum of two such pairs while updating.Overall complexity may vary. We believe, O(n4)O(n4) is achievable. However, the particular solution I coded works in O(n6)O(n6). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\nint dy[] = { 1, 2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n scanf(\"%d\", &n);\n forn(i, n) forn(j, n){\n scanf(\"%d\", &a[i][j]);\n --a[i][j];\n pos[a[i][j]] = mp(i, j);\n }\n\n forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n forn(i, M) dist[i][i] = mp(0, 0);\n\n forn(x, n) forn(y, n){\n forn(i, 8){\n int nx = x + dx[i];\n int ny = y + dy[i];\n if (in(nx, ny))\n dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n }\n\n for (int i = -n + 1; i <= n - 1; ++i){\n int nx = x + i;\n int ny = y + i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n ny = y - i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n }\n\n forn(i, n){\n int nx = x;\n int ny = i;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n nx = i;\n ny = y;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n }\n\n forn(i, 3) forn(j, 3){\n if (i != j){\n dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n }\n }\n }\n\n forn(k, M) forn(i, M) forn(j, M)\n dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n\n pt ans = mp(INF, INF);\n ans = min(ans, dp[n * n - 1][0]);\n ans = min(ans, dp[n * n - 1][1]);\n ans = min(ans, dp[n * n - 1][2]);\n\n printf(\"%d %d\\n\", ans.x, ans.y);\n return 0;\n}1065E - Side Transmutations Tutorial1065E - Side TransmutationsLet's take a look at any operation. You can notice that each letter can only go from position ii to n−i−1n−i−1 (00-indexed). Then, doing some operation twice is the same as doing that operation zero times.Now consider some set of operations l1,l2,…,lkl1,l2,…,lk, sorted in increasing order. Actually, they do the following altogether. Replace segment [lk−1..lk)[lk−1..lk) with the reversed segment ((n−lk−1)..(n−lk−1−1)]((n−lk−1)..(n−lk−1−1)] and vice versa. Then replace segment [lk−3..lk−2)[lk−3..lk−2) with the reversed segment ((n−lk−2−1)..(n−lk−3−1)]((n−lk−2−1)..(n−lk−3−1)] and vice versa. And continue until you reach the first pair. Segment [0..l1)[0..l1) might also be included in the answer when the parity is right.Moreover, every subset of segments [0..l1),[l1,l2),…[lk−1,lk)[0..l1),[l1,l2),…[lk−1,lk) is achievable. So for each segment you can either swap it or not. Let's translate it to math language.Let cnticnti be the number of such pairs of strings xx and yy that x≤yx≤y. Why is there such an order? You want to consider only unique strings, thus, you need to pick exactly one of equal strings from each component. Let it be the smallest one.Then for each segment of the set you have cntlencntlen pairs to choose from, where lenlen is the length of that segment.And that part of the formula is:cntb1⋅∏i=1mcntbi−bi−1cntb1⋅∏i=1mcntbi−bi−1.However, the part covered by zero segments is left. There are ALn−2bmALn−2bm possible strings up there.cnticnti is actually a number of all pairs of strings of length ii plus the number of all pairs of equal strings of length ii divided by 22. cnti=AL2i+ALi2cnti=AL2i+ALi2.Overall complexity: O(mlogn)O(mlog⁡n). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n a += b;\n if (a >= MOD)\n a -= MOD;\n return a;\n}\n\nint mul(int a, int b){\n return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n int res = 1;\n while (b){\n if (b & 1)\n res = mul(res, a);\n a = mul(a, a);\n b >>= 1;\n }\n return res;\n}\n\nint cnt(int x){\n int base = binpow(A, x);\n return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n scanf(\"%d%d%d\", &n, &m, &A);\n forn(i, m)\n scanf(\"%d\", &b[i]);\n\n int ans = binpow(A, n - b[m - 1] * 2);\n ans = mul(ans, cnt(b[0]));\n forn(i, m - 1)\n ans = mul(ans, cnt(b[i + 1] - b[i]));\n\n printf(\"%d\\n\", ans);\n return 0;\n}1065F - Up and Down the Tree Tutorial1065F - Up and Down the TreeLet's calculate answer in two steps. At first, let's calculate for each vertex vv drev(v)drev(v) — what we can gain if we must return from subtree of vv in the end. We need only pair of values: minimal possible depth we can acquire to move up from subtree of vv and maximal number of different leaves we can visit. Note, that this two values are independent since we must return from vv and if for some child toto of vv we can return from it, it's profitable to visit toto and return. But if we can't return from toto so we are prohibited to descent to toto. So, drev(v).seconddrev(v).second (number of visited leaves) is just a sum of all drev(to).seconddrev(to).second if drev(to).first≤hvdrev(to).first≤hv. Also note that we can always reorder all children in such way that last visited vertex toto will have minimal drev(to).firstdrev(to).first. So drev(to).firstdrev(to).first (minimal possible depth) is a minimum over all drev(to).firstdrev(to).first.At second, let's calculate d(v)d(v) — maximal number of different leaves we can visit if we don't need to return from subtree of vv. It can be calculated quite easy using array drev(v)drev(v). We just need to choose child toto we will not return from, so from vertex toto we will take value d(to)d(to) and from other childen (which we can return from) value drev(v).seconddrev(v).second.Result complexity is O(n)O(n). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n out << \"[\";\n fore(i, 0, v.size()) {\n if(i) out << \", \";\n out << v[i];\n }\n return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n if(!(cin >> n >> k))\n return false;\n fore(i, 1, n) {\n int p; assert(scanf(\"%d\", &p) == 1);\n p--;\n\n g[p].push_back(i);\n g[i].push_back(p);\n }\n return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n drev[v] = pt(INF, 0);\n for(int to : g[v]) {\n if(to == p) continue;\n\n h[to] = h[v] + 1;\n calcRev(to, v);\n\n if(drev[to].x <= h[v]) {\n drev[v].x = min(drev[v].x, drev[to].x);\n drev[v].y += drev[to].y;\n }\n }\n\n if(p >= 0 && g[v].size() == 1)\n drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n d[v] = (p >= 0 && g[v].size() == 1);\n for(int to : g[v]) {\n if(to == p) continue;\n calcAns(to, v);\n\n int tmp = drev[v].y;\n if(drev[to].x <= h[v])\n tmp -= drev[to].y;\n\n d[v] = max(d[v], tmp + d[to]);\n }\n}\n\ninline void solve() {\n h[0] = 0;\n calcRev(0, -1);\n calcAns(0, -1);\n cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n freopen(\"input.txt\", \"r\", stdin);\n int tt = clock();\n#endif\n cout << fixed << setprecision(15);\n\n if(read()) {\n solve();\n\n#ifdef _DEBUG\n cerr << \"TIME = \" << clock() - tt << endl;\n tt = clock();\n#endif\n }\n return 0;\n}1065G - Fibonacci Suffix Tutorial1065G - Fibonacci SuffixSuppose we added all the suffixes of F(n)F(n) into a trie. Then we can find kk-th suffix by descending the trie, checking the sizes of subtrees to choose where to go on each iteration.The model solution actually does that, but computes the sizes of subtrees without building the whole trie. Recall that if we insert all suffixes of a string into the trie, then the size of subtree of some vertex is equal to the number of occurences of the string denoted by this vertex in the original string.Since in our problem the strings are recurrent, we may use prefix automaton to count the number of occurences. To calculate the number of occurences of string ss in F(x)F(x), let's build prefix function for ss, and an automaton Ap,cAp,c which tells the value of prefix function, if the previous value was pp, and we appended cc to the string (the same approach is used in KMP substring search algorithm). Then, let's build another automaton that will help us work with Fibonacci string: Fp,xFp,x — what will be the value of prefix function, if we append F(x)F(x) to the string? For x=0x=0 and x=1x=1, this automaton can be easily built using Ap,0Ap,0 and Ap,1Ap,1; and for x>1x>1, we may build Fp,xFp,x using the automatons for x−2x−2 and x−1x−1. We also have to keep track of the number of occurences, that can be done with another automaton on fibonacci strings.There is a corner case when we need to stop descending the trie; to handle it, we need to check whether some string is a suffix of F(n)F(n), but that can be easily made by checking if F0,n=|s|F0,n=|s|.Each step in trie forces us to do up to three (depending on your implementation) queries like \"count the number of occurences of some string in F(n)F(n)\", so overall the solution works in O(nm2)O(nm2). Solution (BledDest)#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n z = (int)(s.size());\n p[0] = 0;\n for(int i = 1; i < z; i++)\n {\n int j = p[i - 1];\n while(j > 0 && s[j] != s[i])\n j = p[j - 1];\n if(s[j] == s[i])\n j++;\n p[i] = j;\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n if(i < z && s[i] == char('0' + j))\n A1[i][j] = i + 1;\n else if(i == 0)\n A1[i][j] = 0;\n else\n A1[i][j] = A1[p[i - 1]][j];\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n A3[i][j] = A1[i][j];\n A2[i][j] = (A3[i][j] == z ? 1 : 0);\n }\n for(int i = 2; i <= n; i++)\n for(int j = 0; j <= z; j++)\n {\n A3[j][i] = A3[A3[j][i - 2]][i - 1];\n A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n }\n}\n\nint main()\n{\n cin >> n >> k >> m;\n string cur = \"\";\n for(int i = 0; i < m; i++)\n {\n if(cur != \"\") build(cur);\n li x = 0;\n if(cur != \"\" && A3[0][n] == i)\n x = 1;\n if(k == 1 && x == 1)\n break;\n k -= x;\n build(cur + '0');\n li x1 = A2[0][n];\n if(k > x1)\n {\n cur += '1';\n k -= x1;\n }\n else\n cur += '0';\n }\n cout << cur << endl;\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62411",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1065\\s*D"
          },
          "content_length": 14742
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "is what programmers are looking for",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 15",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 16",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 17",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 18",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int N = inf.readInt(3, 10, \"N\");\n    inf.readEoln();\n    \n    vector<int> numbers;\n    int N2 = N * N;\n    for (int i = 0; i < N; ++i) {\n        vector<int> row = inf.readInts(N, 1, N2);\n        inf.readEoln();\n        numbers.insert(numbers.end(), row.begin(), row.end());\n    }\n    \n    ensuref(numbers.size() == N2, \"Total number of numbers should be N*N\");\n    \n    set<int> unique_numbers(numbers.begin(), numbers.end());\n    ensuref((int)unique_numbers.size() == N2, \"All numbers A_{ij} should be pairwise distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int N = inf.readInt(3, 10, \"N\");\n    inf.readEoln();\n    \n    vector<int> numbers;\n    int N2 = N * N;\n    for (int i = 0; i < N; ++i) {\n        vector<int> row = inf.readInts(N, 1, N2);\n        inf.readEoln();\n        numbers.insert(numbers.end(), row.begin(), row.end());\n    }\n    \n    ensuref(numbers.size() == N2, \"Total number of numbers should be N*N\");\n    \n    set<int> unique_numbers(numbers.begin(), numbers.end());\n    ensuref((int)unique_numbers.size() == N2, \"All numbers A_{ij} should be pairwise distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int N = inf.readInt(3, 10, \"N\");\n    inf.readEoln();\n    \n    vector<int> numbers;\n    int N2 = N * N;\n    for (int i = 0; i < N; ++i) {\n        vector<int> row = inf.readInts(N, 1, N2);\n        inf.readEoln();\n        numbers.insert(numbers.end(), row.begin(), row.end());\n    }\n    \n    ensuref(numbers.size() == N2, \"Total number of numbers should be N*N\");\n    \n    set<int> unique_numbers(numbers.begin(), numbers.end());\n    ensuref((int)unique_numbers.size() == N2, \"All numbers A_{ij} should be pairwise distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> A(N, vector<int>(N));\n\n    if (type == \"random\") {\n        vector<int> nums(N*N);\n        iota(nums.begin(), nums.end(), 1); // nums = [1, 2, ..., N^2]\n        shuffle(nums.begin(), nums.end());\n\n        for (int i = 0; i < N*N; ++i) {\n            A[i/N][i%N] = nums[i];\n        }\n    } else if (type == \"ordered\") {\n        // Fill A with numbers from 1 to N^2 in order\n        for (int i = 0; i < N*N; ++i) {\n            A[i/N][i%N] = i+1;\n        }\n    } else if (type == \"spiral\") {\n        // Fill the board in spiral order with numbers from 1 to N^2\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n        vector<vector<bool>> used(N, vector<bool>(N, false));\n\n        int x = 0, y = 0, d = 0;\n        for (int num = 1; num <= N*N; ++num) {\n            A[x][y] = num;\n            used[x][y] = true;\n\n            int nx = x + dir[d][0];\n            int ny = y + dir[d][1];\n\n            if (nx < 0 || nx >= N || ny < 0 || ny >= N || used[nx][ny]) {\n                d = (d + 1) % 4;\n                nx = x + dir[d][0];\n                ny = y + dir[d][1];\n            }\n            x = nx;\n            y = ny;\n        }\n    } else if (type == \"path\") {\n        // Arrange numbers in a snake-like path\n        int num = 1;\n        for (int i = 0; i < N; ++i) {\n            if (i%2 == 0) {\n                for (int j = 0; j < N; ++j) {\n                    A[i][j] = num++;\n                }\n            } else {\n                for (int j = N-1; j >= 0; --j) {\n                    A[i][j] = num++;\n                }\n            }\n        }\n    } else {\n        // Default case: random\n        vector<int> nums(N*N);\n        iota(nums.begin(), nums.end(), 1); // nums = [1, 2, ..., N^2]\n        shuffle(nums.begin(), nums.end());\n\n        for (int i = 0; i < N*N; ++i) {\n            A[i/N][i%N] = nums[i];\n        }\n    }\n\n    // Output N\n    printf(\"%d\\n\", N);\n\n    // Output the board\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            printf(\"%d\", A[i][j]);\n            if (j + 1 < N) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> A(N, vector<int>(N));\n\n    if (type == \"random\") {\n        vector<int> nums(N*N);\n        iota(nums.begin(), nums.end(), 1); // nums = [1, 2, ..., N^2]\n        shuffle(nums.begin(), nums.end());\n\n        for (int i = 0; i < N*N; ++i) {\n            A[i/N][i%N] = nums[i];\n        }\n    } else if (type == \"ordered\") {\n        // Fill A with numbers from 1 to N^2 in order\n        for (int i = 0; i < N*N; ++i) {\n            A[i/N][i%N] = i+1;\n        }\n    } else if (type == \"spiral\") {\n        // Fill the board in spiral order with numbers from 1 to N^2\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n        vector<vector<bool>> used(N, vector<bool>(N, false));\n\n        int x = 0, y = 0, d = 0;\n        for (int num = 1; num <= N*N; ++num) {\n            A[x][y] = num;\n            used[x][y] = true;\n\n            int nx = x + dir[d][0];\n            int ny = y + dir[d][1];\n\n            if (nx < 0 || nx >= N || ny < 0 || ny >= N || used[nx][ny]) {\n                d = (d + 1) % 4;\n                nx = x + dir[d][0];\n                ny = y + dir[d][1];\n            }\n            x = nx;\n            y = ny;\n        }\n    } else if (type == \"path\") {\n        // Arrange numbers in a snake-like path\n        int num = 1;\n        for (int i = 0; i < N; ++i) {\n            if (i%2 == 0) {\n                for (int j = 0; j < N; ++j) {\n                    A[i][j] = num++;\n                }\n            } else {\n                for (int j = N-1; j >= 0; --j) {\n                    A[i][j] = num++;\n                }\n            }\n        }\n    } else {\n        // Default case: random\n        vector<int> nums(N*N);\n        iota(nums.begin(), nums.end(), 1); // nums = [1, 2, ..., N^2]\n        shuffle(nums.begin(), nums.end());\n\n        for (int i = 0; i < N*N; ++i) {\n            A[i/N][i%N] = nums[i];\n        }\n    }\n\n    // Output N\n    printf(\"%d\\n\", N);\n\n    // Output the board\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            printf(\"%d\", A[i][j]);\n            if (j + 1 < N) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 3 -type ordered\n./gen -n 3 -type spiral\n./gen -n 3 -type path\n\n./gen -n 4 -type random\n./gen -n 4 -type ordered\n./gen -n 4 -type spiral\n./gen -n 4 -type path\n\n./gen -n 5 -type random\n./gen -n 5 -type ordered\n./gen -n 5 -type spiral\n./gen -n 5 -type path\n\n./gen -n 6 -type random\n./gen -n 6 -type ordered\n./gen -n 6 -type spiral\n./gen -n 6 -type path\n\n./gen -n 7 -type random\n./gen -n 7 -type ordered\n./gen -n 7 -type spiral\n./gen -n 7 -type path\n\n./gen -n 8 -type random\n./gen -n 8 -type ordered\n./gen -n 8 -type spiral\n./gen -n 8 -type path\n\n./gen -n 9 -type random\n./gen -n 9 -type ordered\n./gen -n 9 -type spiral\n./gen -n 9 -type path\n\n./gen -n 10 -type random\n./gen -n 10 -type ordered\n./gen -n 10 -type spiral\n./gen -n 10 -type path\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:21.025120",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1065/E",
      "title": "E. Side Transmutations",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers nn, mm and |A||A| (2≤n≤1092≤n≤109, 1≤m≤min(n2,2⋅105)1≤m≤min(n2,2⋅105), 1≤|A|≤1091≤|A|≤109) — the length of the strings, the size of the array bb and the size of the set AA, respectively.The second line contains mm integers b1,b2,…,bmb1,b2,…,bm (1≤bi≤n21≤bi≤n2, b1<b2<⋯<bmb1<b2<⋯<bm).",
      "output_spec": "OutputPrint a single integer — the number of distinct strings of length nn with characters from set AA modulo 998244353998244353.",
      "sample_tests": "ExamplesInputCopy3 1 21OutputCopy6InputCopy9 2 262 3OutputCopy150352234InputCopy12 3 12 5 6OutputCopy1",
      "description": "E. Side Transmutations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers nn, mm and |A||A| (2≤n≤1092≤n≤109, 1≤m≤min(n2,2⋅105)1≤m≤min(n2,2⋅105), 1≤|A|≤1091≤|A|≤109) — the length of the strings, the size of the array bb and the size of the set AA, respectively.The second line contains mm integers b1,b2,…,bmb1,b2,…,bm (1≤bi≤n21≤bi≤n2, b1<b2<⋯<bmb1<b2<⋯<bm).\n\nOutputPrint a single integer — the number of distinct strings of length nn with characters from set AA modulo 998244353998244353.\n\nInputCopy3 1 21OutputCopy6InputCopy9 2 262 3OutputCopy150352234InputCopy12 3 12 5 6OutputCopy1\n\nInputCopy3 1 21\n\nOutputCopy6\n\nInputCopy9 2 262 3\n\nOutputCopy150352234\n\nInputCopy12 3 12 5 6\n\nOutputCopy1\n\nNoteHere are all the distinct strings for the first example. The chosen letters 'a' and 'b' are there just to show that the characters in AA are different.   \"aaa\"  \"aab\" = \"baa\"  \"aba\"  \"abb\" = \"bba\"  \"bab\"  \"bbb\"",
      "solutions": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces",
          "content": "On Thursday, October 11, 2018 at 22:50UTC+8 Educational Codeforces Round 52 (Rated for Div. 2) will start. Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. The penalty for each incorrect submission until the submission with a full solution is 10 minutes. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Roman Roms Glazov, Adilbek adedalic Dalabaev, Vladimir vovuh Petrov, Ivan BledDest Androsov and me.Good luck to all participants!UPD 1: Our friends from Harbour.Space University are proposing you an unprecedented offer of free (and even with a scholarship!) robotics study in Barcelona! Read the details in the post by the link https://codeforces.com/blog/entry/62357UPD 2: I'll be on the community Discord server shortly after the contest to discuss the problems.Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 isaf27 7 263 2 HanwhaEagles 7 340 3 Skywynne 6 251 4 CJYeong 6 273 5 -wawawa8 6 280 Congratulations to the best hackers: Rank Competitor Hack Count 1 Laggy 63:-10 2 Doriath 38 3 BohdanPastuschak 38:-7 4 Kerman 36:-6 5 zoooma13 33:-2 860 successful hacks and 719 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A xiaowuc1 0:01 B xiaowuc1 0:03 C HanwhaEagles 0:07 D isaf27 0:33 E Kyouko 0:19 F mHuman 0:35 G tfg 0:44 UPD 3: Editorial is published",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1829
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces",
          "content": "1065A - Vasya and Chocolate Tutorial1065A - Vasya and ChocolateNumber of chocolate bars Vasya can buy without offer is cnt=⌊sc⌋cnt=⌊sc⌋.Number of \"bundles\" with aa bars x=⌊cnta⌋x=⌊cnta⌋.Then number of additional bars add=x⋅badd=x⋅b.In result, total number of bars is add+cntadd+cnt. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int s, a, b, c;\n int t;\n cin >> t;\n for(int i = 0; i < t; ++i){\n cin >> s >> a >> b >> c;\n\n s /= c;\n int x = s / a;\n s %= a;\n long long res = x * 1LL * (a + b);\n res += s;\n\n cout << res << endl;\n }\n return 0;\n}1065B - Vasya and Isolated Vertices Tutorial1065B - Vasya and Isolated VerticesVasya can decrease number of isolated vertices up to 22 using one edge and pairing them. So minimum number of isolated vertices is max(0,n−2m)max(0,n−2m).To calculate maximum number of isolated vertices let's keep number of non-isolated vertices knowing that each pair connected by edge (i.e. size of clique). Let we have size of clique curcur and remrem edges remained unassigned at current step. If rem=0rem=0 then answer is n−curn−cur. Otherwise we need to increase clique with one vertex. Maximum number of edges we can add to connect this vertex is add=min (rem,cur)add=min (rem,cur). So, subtract it from remrem and increase curcur by one. Repeat this step while remrem greater than zero. Answer is n−curn−cur.One corner case is next: if cur=1cur=1, then answer is nn, not n−curn−cur. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int n;\n long long m;\n cin >> n >> m;\n long long cur = 1;\n long long rem = m;\n while(rem > 0){\n long long d = min(cur, rem);\n rem -= d;\n ++cur;\n }\n assert(rem == 0);\n\n long long res = n;\n if(cur > 1) res = n - cur;\n\n cout << max(0ll, n - m * 2) << ' ' << res << endl;\n return 0;\n}1065C - Make It Equal Tutorial1065C - Make It EqualLet's iterate over height pospos of slice in decreasing order. All we need to know is a number of towers with height more than pospos (name it cc) and sum of its heights sumsum.Current slice on height pospos is good if k≥sum−c⋅posk≥sum−c⋅pos. Let's greedily decrease value pospos while slice on pospos is good keeping correct values cc and sumsum. When we found minimal good slice we can perform it increasing answer by one and \"changing tower heights\" just by setting new value to sumsum equal to c⋅posc⋅pos.Finish algorithm when pospos becomes equal to minimal height of towers and make final slice. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n scanf(\"%d %d\", &n, &k);\n for(int i = 0; i < n; ++i){\n int x;\n scanf(\"%d\", &x);\n h = max(h, x);\n need = min(need, x);\n ++cnt[x];\n }\n\n int pos = N - 1;\n int res = 0;\n long long sum = 0;\n int c = 0;\n while(true){\n long long x = sum - c * 1LL * (pos - 1);\n if(x > k){\n ++res;\n h = pos;\n sum = pos * 1LL * c;\n } \n\n --pos;\n if(pos == need) break;\n c += cnt[pos];\n sum += cnt[pos] * 1LL * pos;\n }\n\n if(h != need) ++res;\n\n cout << res << endl;\n}1065D - Three Pieces Tutorial1065D - Three PiecesThere are a lot of different solutions for the problem. Most of them have the similar structure.The first part is to find the shortest distance between the states (x1,y1,p1)(x1,y1,p1) and (x2,y2,p2)(x2,y2,p2), where xx and yy are the coordinates of the square and pp is the current piece. This can be done with 0-1 bfs, Floyd or Dijkstra. Just represent the triple as a single integer by transforming it to (x⋅n⋅3+y⋅3+p)(x⋅n⋅3+y⋅3+p) and do everything on that graph.The second part is to write some dp to go from ii-th square with piece p1p1 to (i+1)(i+1)-th square with piece p2p2. The value of this dp[n][3]dp[n][3] is a pair (moves, replacements). It is easy to see that you can always choose the minimum of two such pairs while updating.Overall complexity may vary. We believe, O(n4)O(n4) is achievable. However, the particular solution I coded works in O(n6)O(n6). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\nint dy[] = { 1, 2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n scanf(\"%d\", &n);\n forn(i, n) forn(j, n){\n scanf(\"%d\", &a[i][j]);\n --a[i][j];\n pos[a[i][j]] = mp(i, j);\n }\n\n forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n forn(i, M) dist[i][i] = mp(0, 0);\n\n forn(x, n) forn(y, n){\n forn(i, 8){\n int nx = x + dx[i];\n int ny = y + dy[i];\n if (in(nx, ny))\n dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n }\n\n for (int i = -n + 1; i <= n - 1; ++i){\n int nx = x + i;\n int ny = y + i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n ny = y - i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n }\n\n forn(i, n){\n int nx = x;\n int ny = i;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n nx = i;\n ny = y;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n }\n\n forn(i, 3) forn(j, 3){\n if (i != j){\n dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n }\n }\n }\n\n forn(k, M) forn(i, M) forn(j, M)\n dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n\n pt ans = mp(INF, INF);\n ans = min(ans, dp[n * n - 1][0]);\n ans = min(ans, dp[n * n - 1][1]);\n ans = min(ans, dp[n * n - 1][2]);\n\n printf(\"%d %d\\n\", ans.x, ans.y);\n return 0;\n}1065E - Side Transmutations Tutorial1065E - Side TransmutationsLet's take a look at any operation. You can notice that each letter can only go from position ii to n−i−1n−i−1 (00-indexed). Then, doing some operation twice is the same as doing that operation zero times.Now consider some set of operations l1,l2,…,lkl1,l2,…,lk, sorted in increasing order. Actually, they do the following altogether. Replace segment [lk−1..lk)[lk−1..lk) with the reversed segment ((n−lk−1)..(n−lk−1−1)]((n−lk−1)..(n−lk−1−1)] and vice versa. Then replace segment [lk−3..lk−2)[lk−3..lk−2) with the reversed segment ((n−lk−2−1)..(n−lk−3−1)]((n−lk−2−1)..(n−lk−3−1)] and vice versa. And continue until you reach the first pair. Segment [0..l1)[0..l1) might also be included in the answer when the parity is right.Moreover, every subset of segments [0..l1),[l1,l2),…[lk−1,lk)[0..l1),[l1,l2),…[lk−1,lk) is achievable. So for each segment you can either swap it or not. Let's translate it to math language.Let cnticnti be the number of such pairs of strings xx and yy that x≤yx≤y. Why is there such an order? You want to consider only unique strings, thus, you need to pick exactly one of equal strings from each component. Let it be the smallest one.Then for each segment of the set you have cntlencntlen pairs to choose from, where lenlen is the length of that segment.And that part of the formula is:cntb1⋅∏i=1mcntbi−bi−1cntb1⋅∏i=1mcntbi−bi−1.However, the part covered by zero segments is left. There are ALn−2bmALn−2bm possible strings up there.cnticnti is actually a number of all pairs of strings of length ii plus the number of all pairs of equal strings of length ii divided by 22. cnti=AL2i+ALi2cnti=AL2i+ALi2.Overall complexity: O(mlogn)O(mlog⁡n). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n a += b;\n if (a >= MOD)\n a -= MOD;\n return a;\n}\n\nint mul(int a, int b){\n return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n int res = 1;\n while (b){\n if (b & 1)\n res = mul(res, a);\n a = mul(a, a);\n b >>= 1;\n }\n return res;\n}\n\nint cnt(int x){\n int base = binpow(A, x);\n return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n scanf(\"%d%d%d\", &n, &m, &A);\n forn(i, m)\n scanf(\"%d\", &b[i]);\n\n int ans = binpow(A, n - b[m - 1] * 2);\n ans = mul(ans, cnt(b[0]));\n forn(i, m - 1)\n ans = mul(ans, cnt(b[i + 1] - b[i]));\n\n printf(\"%d\\n\", ans);\n return 0;\n}1065F - Up and Down the Tree Tutorial1065F - Up and Down the TreeLet's calculate answer in two steps. At first, let's calculate for each vertex vv drev(v)drev(v) — what we can gain if we must return from subtree of vv in the end. We need only pair of values: minimal possible depth we can acquire to move up from subtree of vv and maximal number of different leaves we can visit. Note, that this two values are independent since we must return from vv and if for some child toto of vv we can return from it, it's profitable to visit toto and return. But if we can't return from toto so we are prohibited to descent to toto. So, drev(v).seconddrev(v).second (number of visited leaves) is just a sum of all drev(to).seconddrev(to).second if drev(to).first≤hvdrev(to).first≤hv. Also note that we can always reorder all children in such way that last visited vertex toto will have minimal drev(to).firstdrev(to).first. So drev(to).firstdrev(to).first (minimal possible depth) is a minimum over all drev(to).firstdrev(to).first.At second, let's calculate d(v)d(v) — maximal number of different leaves we can visit if we don't need to return from subtree of vv. It can be calculated quite easy using array drev(v)drev(v). We just need to choose child toto we will not return from, so from vertex toto we will take value d(to)d(to) and from other childen (which we can return from) value drev(v).seconddrev(v).second.Result complexity is O(n)O(n). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n out << \"[\";\n fore(i, 0, v.size()) {\n if(i) out << \", \";\n out << v[i];\n }\n return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n if(!(cin >> n >> k))\n return false;\n fore(i, 1, n) {\n int p; assert(scanf(\"%d\", &p) == 1);\n p--;\n\n g[p].push_back(i);\n g[i].push_back(p);\n }\n return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n drev[v] = pt(INF, 0);\n for(int to : g[v]) {\n if(to == p) continue;\n\n h[to] = h[v] + 1;\n calcRev(to, v);\n\n if(drev[to].x <= h[v]) {\n drev[v].x = min(drev[v].x, drev[to].x);\n drev[v].y += drev[to].y;\n }\n }\n\n if(p >= 0 && g[v].size() == 1)\n drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n d[v] = (p >= 0 && g[v].size() == 1);\n for(int to : g[v]) {\n if(to == p) continue;\n calcAns(to, v);\n\n int tmp = drev[v].y;\n if(drev[to].x <= h[v])\n tmp -= drev[to].y;\n\n d[v] = max(d[v], tmp + d[to]);\n }\n}\n\ninline void solve() {\n h[0] = 0;\n calcRev(0, -1);\n calcAns(0, -1);\n cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n freopen(\"input.txt\", \"r\", stdin);\n int tt = clock();\n#endif\n cout << fixed << setprecision(15);\n\n if(read()) {\n solve();\n\n#ifdef _DEBUG\n cerr << \"TIME = \" << clock() - tt << endl;\n tt = clock();\n#endif\n }\n return 0;\n}1065G - Fibonacci Suffix Tutorial1065G - Fibonacci SuffixSuppose we added all the suffixes of F(n)F(n) into a trie. Then we can find kk-th suffix by descending the trie, checking the sizes of subtrees to choose where to go on each iteration.The model solution actually does that, but computes the sizes of subtrees without building the whole trie. Recall that if we insert all suffixes of a string into the trie, then the size of subtree of some vertex is equal to the number of occurences of the string denoted by this vertex in the original string.Since in our problem the strings are recurrent, we may use prefix automaton to count the number of occurences. To calculate the number of occurences of string ss in F(x)F(x), let's build prefix function for ss, and an automaton Ap,cAp,c which tells the value of prefix function, if the previous value was pp, and we appended cc to the string (the same approach is used in KMP substring search algorithm). Then, let's build another automaton that will help us work with Fibonacci string: Fp,xFp,x — what will be the value of prefix function, if we append F(x)F(x) to the string? For x=0x=0 and x=1x=1, this automaton can be easily built using Ap,0Ap,0 and Ap,1Ap,1; and for x>1x>1, we may build Fp,xFp,x using the automatons for x−2x−2 and x−1x−1. We also have to keep track of the number of occurences, that can be done with another automaton on fibonacci strings.There is a corner case when we need to stop descending the trie; to handle it, we need to check whether some string is a suffix of F(n)F(n), but that can be easily made by checking if F0,n=|s|F0,n=|s|.Each step in trie forces us to do up to three (depending on your implementation) queries like \"count the number of occurences of some string in F(n)F(n)\", so overall the solution works in O(nm2)O(nm2). Solution (BledDest)#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n z = (int)(s.size());\n p[0] = 0;\n for(int i = 1; i < z; i++)\n {\n int j = p[i - 1];\n while(j > 0 && s[j] != s[i])\n j = p[j - 1];\n if(s[j] == s[i])\n j++;\n p[i] = j;\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n if(i < z && s[i] == char('0' + j))\n A1[i][j] = i + 1;\n else if(i == 0)\n A1[i][j] = 0;\n else\n A1[i][j] = A1[p[i - 1]][j];\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n A3[i][j] = A1[i][j];\n A2[i][j] = (A3[i][j] == z ? 1 : 0);\n }\n for(int i = 2; i <= n; i++)\n for(int j = 0; j <= z; j++)\n {\n A3[j][i] = A3[A3[j][i - 2]][i - 1];\n A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n }\n}\n\nint main()\n{\n cin >> n >> k >> m;\n string cur = \"\";\n for(int i = 0; i < m; i++)\n {\n if(cur != \"\") build(cur);\n li x = 0;\n if(cur != \"\" && A3[0][n] == i)\n x = 1;\n if(k == 1 && x == 1)\n break;\n k -= x;\n build(cur + '0');\n li x1 = A2[0][n];\n if(k > x1)\n {\n cur += '1';\n k -= x1;\n }\n else\n cur += '0';\n }\n cout << cur << endl;\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62411",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1065\\s*E"
          },
          "content_length": 14742
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "is what programmers are looking for",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 15",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 16",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 17",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 18",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readSpace();\n    int m_max = min(200000, n / 2);\n    int m = inf.readInt(1, m_max, \"m\");\n    inf.readSpace();\n    int A_size = inf.readInt(1, 1000000000, \"A_size\");\n    inf.readEoln();\n    \n    vector<int> b = inf.readInts(m, 1, n / 2, \"b_i\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m - 1; i++) {\n        ensuref(b[i] < b[i + 1], \"b_i[%d]=%d is not less than b_i[%d]=%d\", i + 1, b[i], i + 2, b[i + 1]);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readSpace();\n    int m_max = min(200000, n / 2);\n    int m = inf.readInt(1, m_max, \"m\");\n    inf.readSpace();\n    int A_size = inf.readInt(1, 1000000000, \"A_size\");\n    inf.readEoln();\n    \n    vector<int> b = inf.readInts(m, 1, n / 2, \"b_i\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m - 1; i++) {\n        ensuref(b[i] < b[i + 1], \"b_i[%d]=%d is not less than b_i[%d]=%d\", i + 1, b[i], i + 2, b[i + 1]);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readSpace();\n    int m_max = min(200000, n / 2);\n    int m = inf.readInt(1, m_max, \"m\");\n    inf.readSpace();\n    int A_size = inf.readInt(1, 1000000000, \"A_size\");\n    inf.readEoln();\n    \n    vector<int> b = inf.readInts(m, 1, n / 2, \"b_i\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m - 1; i++) {\n        ensuref(b[i] < b[i + 1], \"b_i[%d]=%d is not less than b_i[%d]=%d\", i + 1, b[i], i + 2, b[i + 1]);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read in n, m, A, and type from command line arguments\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int A = opt<int>(\"A\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m is within [1, min(n/2, 2e5)]\n    m = max(1, min(m, min((int)(n/2), 200000)));\n\n    vector<int> b;\n\n    if (type == \"min\") {\n        // b_i are from 1 to m\n        for (int i = 1; i <= m; ++i) {\n            b.push_back(i);\n        }\n    } else if (type == \"max\") {\n        // b_i are from n/2 - m + 1 to n/2\n        int start = n/2 - m + 1;\n        start = max(start, 1); // Ensure start is at least 1\n        for (int i = 0; i < m; ++i) {\n            b.push_back(start + i);\n        }\n    } else if (type == \"consecutive\") {\n        // Randomly select a starting point\n        int max_start = n/2 - m + 1;\n        max_start = max(max_start, 1);\n        int start = rnd.next(1, max_start);\n        for (int i = 0; i < m; ++i) {\n            b.push_back(start + i);\n        }\n    } else {\n        // Randomly generate m distinct integers in [1, n/2], sorted in increasing order\n        set<int> b_set;\n        while ((int)b_set.size() < m) {\n            int val = rnd.next(1, n/2);\n            b_set.insert(val);\n        }\n        b.assign(b_set.begin(), b_set.end());\n        sort(b.begin(), b.end());\n    }\n\n    // Output n, m, A\n    printf(\"%d %d %d\\n\", n, m, A);\n\n    // Output b_i\n    for (size_t i = 0; i < b.size(); ++i) {\n        printf(\"%d%c\", b[i], (i+1 == b.size()) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read in n, m, A, and type from command line arguments\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int A = opt<int>(\"A\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m is within [1, min(n/2, 2e5)]\n    m = max(1, min(m, min((int)(n/2), 200000)));\n\n    vector<int> b;\n\n    if (type == \"min\") {\n        // b_i are from 1 to m\n        for (int i = 1; i <= m; ++i) {\n            b.push_back(i);\n        }\n    } else if (type == \"max\") {\n        // b_i are from n/2 - m + 1 to n/2\n        int start = n/2 - m + 1;\n        start = max(start, 1); // Ensure start is at least 1\n        for (int i = 0; i < m; ++i) {\n            b.push_back(start + i);\n        }\n    } else if (type == \"consecutive\") {\n        // Randomly select a starting point\n        int max_start = n/2 - m + 1;\n        max_start = max(max_start, 1);\n        int start = rnd.next(1, max_start);\n        for (int i = 0; i < m; ++i) {\n            b.push_back(start + i);\n        }\n    } else {\n        // Randomly generate m distinct integers in [1, n/2], sorted in increasing order\n        set<int> b_set;\n        while ((int)b_set.size() < m) {\n            int val = rnd.next(1, n/2);\n            b_set.insert(val);\n        }\n        b.assign(b_set.begin(), b_set.end());\n        sort(b.begin(), b.end());\n    }\n\n    // Output n, m, A\n    printf(\"%d %d %d\\n\", n, m, A);\n\n    // Output b_i\n    for (size_t i = 0; i < b.size(); ++i) {\n        printf(\"%d%c\", b[i], (i+1 == b.size()) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -A 1 -type min\n./gen -n 2 -m 1 -A 1 -type max\n./gen -n 2 -m 1 -A 1 -type random\n\n./gen -n 2 -m 1 -A 1000000000 -type min\n./gen -n 2 -m 1 -A 1000000000 -type max\n./gen -n 2 -m 1 -A 1000000000 -type random\n\n./gen -n 10 -m 5 -A 1 -type min\n./gen -n 10 -m 5 -A 1 -type max\n./gen -n 10 -m 5 -A 1 -type random\n\n./gen -n 10 -m 5 -A 1000000000 -type min\n./gen -n 10 -m 5 -A 1000000000 -type max\n./gen -n 10 -m 5 -A 1000000000 -type random\n./gen -n 10 -m 5 -A 1000000000 -type consecutive\n\n./gen -n 1000 -m 500 -A 100 -type min\n./gen -n 1000 -m 500 -A 100 -type max\n./gen -n 1000 -m 500 -A 100 -type random\n\n./gen -n 1000000 -m 500000 -A 500000 -type consecutive\n./gen -n 1000000 -m 500000 -A 500000 -type random\n\n./gen -n 999999999 -m 200000 -A 999999999 -type random\n./gen -n 999999998 -m 200000 -A 500000000 -type max\n\n./gen -n 1000000000 -m 1 -A 1 -type min\n./gen -n 1000000000 -m 1 -A 1 -type max\n./gen -n 1000000000 -m 1 -A 1 -type random\n\n./gen -n 1000000000 -m 200000 -A 1 -type random\n./gen -n 1000000000 -m 200000 -A 1 -type min\n./gen -n 1000000000 -m 200000 -A 1 -type max\n\n./gen -n 1000000000 -m 200000 -A 1000000000 -type random\n./gen -n 1000000000 -m 200000 -A 1000000000 -type min\n./gen -n 1000000000 -m 200000 -A 1000000000 -type max\n\n./gen -n 100000 -m 100000 -A 1 -type random\n./gen -n 100000 -m 100000 -A 1 -type consecutive\n\n./gen -n 100000 -m 100000 -A 1000000000 -type random\n./gen -n 100000 -m 100000 -A 1000000000 -type consecutive\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:23.004320",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1065/F",
      "title": "F. Up and Down the Tree",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and kk (1≤k<n≤1061≤k<n≤106) — the number of vertices in the tree and the restriction on moving up, respectively.The second line contains n−1n−1 integers p2,p3,…,pnp2,p3,…,pn, where pipi is the parent of vertex ii.It is guaranteed that the input represents a valid tree, rooted at 11.",
      "output_spec": "OutputPrint one integer — the maximum possible number of different leaves you can visit.",
      "sample_tests": "ExamplesInputCopy7 11 1 3 3 4 4OutputCopy4InputCopy8 21 1 2 3 4 5 5OutputCopy2",
      "description": "F. Up and Down the Tree\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and kk (1≤k<n≤1061≤k<n≤106) — the number of vertices in the tree and the restriction on moving up, respectively.The second line contains n−1n−1 integers p2,p3,…,pnp2,p3,…,pn, where pipi is the parent of vertex ii.It is guaranteed that the input represents a valid tree, rooted at 11.\n\nOutputPrint one integer — the maximum possible number of different leaves you can visit.\n\nInputCopy7 11 1 3 3 4 4OutputCopy4InputCopy8 21 1 2 3 4 5 5OutputCopy2\n\nInputCopy7 11 1 3 3 4 4\n\nOutputCopy4\n\nInputCopy8 21 1 2 3 4 5 5\n\nOutputCopy2\n\nNoteThe graph from the first example:   One of the optimal ways is the next one: 1→2→1→5→3→7→4→61→2→1→5→3→7→4→6.The graph from the second example:   One of the optimal ways is the next one: 1→7→5→81→7→5→8. Note that there is no way to move from 66 to 77 or 88 and vice versa.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces",
          "content": "On Thursday, October 11, 2018 at 22:50UTC+8 Educational Codeforces Round 52 (Rated for Div. 2) will start. Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. The penalty for each incorrect submission until the submission with a full solution is 10 minutes. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Roman Roms Glazov, Adilbek adedalic Dalabaev, Vladimir vovuh Petrov, Ivan BledDest Androsov and me.Good luck to all participants!UPD 1: Our friends from Harbour.Space University are proposing you an unprecedented offer of free (and even with a scholarship!) robotics study in Barcelona! Read the details in the post by the link https://codeforces.com/blog/entry/62357UPD 2: I'll be on the community Discord server shortly after the contest to discuss the problems.Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 isaf27 7 263 2 HanwhaEagles 7 340 3 Skywynne 6 251 4 CJYeong 6 273 5 -wawawa8 6 280 Congratulations to the best hackers: Rank Competitor Hack Count 1 Laggy 63:-10 2 Doriath 38 3 BohdanPastuschak 38:-7 4 Kerman 36:-6 5 zoooma13 33:-2 860 successful hacks and 719 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A xiaowuc1 0:01 B xiaowuc1 0:03 C HanwhaEagles 0:07 D isaf27 0:33 E Kyouko 0:19 F mHuman 0:35 G tfg 0:44 UPD 3: Editorial is published",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1829
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces",
          "content": "1065A - Vasya and Chocolate Tutorial1065A - Vasya and ChocolateNumber of chocolate bars Vasya can buy without offer is cnt=⌊sc⌋cnt=⌊sc⌋.Number of \"bundles\" with aa bars x=⌊cnta⌋x=⌊cnta⌋.Then number of additional bars add=x⋅badd=x⋅b.In result, total number of bars is add+cntadd+cnt. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int s, a, b, c;\n int t;\n cin >> t;\n for(int i = 0; i < t; ++i){\n cin >> s >> a >> b >> c;\n\n s /= c;\n int x = s / a;\n s %= a;\n long long res = x * 1LL * (a + b);\n res += s;\n\n cout << res << endl;\n }\n return 0;\n}1065B - Vasya and Isolated Vertices Tutorial1065B - Vasya and Isolated VerticesVasya can decrease number of isolated vertices up to 22 using one edge and pairing them. So minimum number of isolated vertices is max(0,n−2m)max(0,n−2m).To calculate maximum number of isolated vertices let's keep number of non-isolated vertices knowing that each pair connected by edge (i.e. size of clique). Let we have size of clique curcur and remrem edges remained unassigned at current step. If rem=0rem=0 then answer is n−curn−cur. Otherwise we need to increase clique with one vertex. Maximum number of edges we can add to connect this vertex is add=min (rem,cur)add=min (rem,cur). So, subtract it from remrem and increase curcur by one. Repeat this step while remrem greater than zero. Answer is n−curn−cur.One corner case is next: if cur=1cur=1, then answer is nn, not n−curn−cur. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int n;\n long long m;\n cin >> n >> m;\n long long cur = 1;\n long long rem = m;\n while(rem > 0){\n long long d = min(cur, rem);\n rem -= d;\n ++cur;\n }\n assert(rem == 0);\n\n long long res = n;\n if(cur > 1) res = n - cur;\n\n cout << max(0ll, n - m * 2) << ' ' << res << endl;\n return 0;\n}1065C - Make It Equal Tutorial1065C - Make It EqualLet's iterate over height pospos of slice in decreasing order. All we need to know is a number of towers with height more than pospos (name it cc) and sum of its heights sumsum.Current slice on height pospos is good if k≥sum−c⋅posk≥sum−c⋅pos. Let's greedily decrease value pospos while slice on pospos is good keeping correct values cc and sumsum. When we found minimal good slice we can perform it increasing answer by one and \"changing tower heights\" just by setting new value to sumsum equal to c⋅posc⋅pos.Finish algorithm when pospos becomes equal to minimal height of towers and make final slice. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n scanf(\"%d %d\", &n, &k);\n for(int i = 0; i < n; ++i){\n int x;\n scanf(\"%d\", &x);\n h = max(h, x);\n need = min(need, x);\n ++cnt[x];\n }\n\n int pos = N - 1;\n int res = 0;\n long long sum = 0;\n int c = 0;\n while(true){\n long long x = sum - c * 1LL * (pos - 1);\n if(x > k){\n ++res;\n h = pos;\n sum = pos * 1LL * c;\n } \n\n --pos;\n if(pos == need) break;\n c += cnt[pos];\n sum += cnt[pos] * 1LL * pos;\n }\n\n if(h != need) ++res;\n\n cout << res << endl;\n}1065D - Three Pieces Tutorial1065D - Three PiecesThere are a lot of different solutions for the problem. Most of them have the similar structure.The first part is to find the shortest distance between the states (x1,y1,p1)(x1,y1,p1) and (x2,y2,p2)(x2,y2,p2), where xx and yy are the coordinates of the square and pp is the current piece. This can be done with 0-1 bfs, Floyd or Dijkstra. Just represent the triple as a single integer by transforming it to (x⋅n⋅3+y⋅3+p)(x⋅n⋅3+y⋅3+p) and do everything on that graph.The second part is to write some dp to go from ii-th square with piece p1p1 to (i+1)(i+1)-th square with piece p2p2. The value of this dp[n][3]dp[n][3] is a pair (moves, replacements). It is easy to see that you can always choose the minimum of two such pairs while updating.Overall complexity may vary. We believe, O(n4)O(n4) is achievable. However, the particular solution I coded works in O(n6)O(n6). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\nint dy[] = { 1, 2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n scanf(\"%d\", &n);\n forn(i, n) forn(j, n){\n scanf(\"%d\", &a[i][j]);\n --a[i][j];\n pos[a[i][j]] = mp(i, j);\n }\n\n forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n forn(i, M) dist[i][i] = mp(0, 0);\n\n forn(x, n) forn(y, n){\n forn(i, 8){\n int nx = x + dx[i];\n int ny = y + dy[i];\n if (in(nx, ny))\n dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n }\n\n for (int i = -n + 1; i <= n - 1; ++i){\n int nx = x + i;\n int ny = y + i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n ny = y - i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n }\n\n forn(i, n){\n int nx = x;\n int ny = i;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n nx = i;\n ny = y;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n }\n\n forn(i, 3) forn(j, 3){\n if (i != j){\n dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n }\n }\n }\n\n forn(k, M) forn(i, M) forn(j, M)\n dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n\n pt ans = mp(INF, INF);\n ans = min(ans, dp[n * n - 1][0]);\n ans = min(ans, dp[n * n - 1][1]);\n ans = min(ans, dp[n * n - 1][2]);\n\n printf(\"%d %d\\n\", ans.x, ans.y);\n return 0;\n}1065E - Side Transmutations Tutorial1065E - Side TransmutationsLet's take a look at any operation. You can notice that each letter can only go from position ii to n−i−1n−i−1 (00-indexed). Then, doing some operation twice is the same as doing that operation zero times.Now consider some set of operations l1,l2,…,lkl1,l2,…,lk, sorted in increasing order. Actually, they do the following altogether. Replace segment [lk−1..lk)[lk−1..lk) with the reversed segment ((n−lk−1)..(n−lk−1−1)]((n−lk−1)..(n−lk−1−1)] and vice versa. Then replace segment [lk−3..lk−2)[lk−3..lk−2) with the reversed segment ((n−lk−2−1)..(n−lk−3−1)]((n−lk−2−1)..(n−lk−3−1)] and vice versa. And continue until you reach the first pair. Segment [0..l1)[0..l1) might also be included in the answer when the parity is right.Moreover, every subset of segments [0..l1),[l1,l2),…[lk−1,lk)[0..l1),[l1,l2),…[lk−1,lk) is achievable. So for each segment you can either swap it or not. Let's translate it to math language.Let cnticnti be the number of such pairs of strings xx and yy that x≤yx≤y. Why is there such an order? You want to consider only unique strings, thus, you need to pick exactly one of equal strings from each component. Let it be the smallest one.Then for each segment of the set you have cntlencntlen pairs to choose from, where lenlen is the length of that segment.And that part of the formula is:cntb1⋅∏i=1mcntbi−bi−1cntb1⋅∏i=1mcntbi−bi−1.However, the part covered by zero segments is left. There are ALn−2bmALn−2bm possible strings up there.cnticnti is actually a number of all pairs of strings of length ii plus the number of all pairs of equal strings of length ii divided by 22. cnti=AL2i+ALi2cnti=AL2i+ALi2.Overall complexity: O(mlogn)O(mlog⁡n). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n a += b;\n if (a >= MOD)\n a -= MOD;\n return a;\n}\n\nint mul(int a, int b){\n return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n int res = 1;\n while (b){\n if (b & 1)\n res = mul(res, a);\n a = mul(a, a);\n b >>= 1;\n }\n return res;\n}\n\nint cnt(int x){\n int base = binpow(A, x);\n return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n scanf(\"%d%d%d\", &n, &m, &A);\n forn(i, m)\n scanf(\"%d\", &b[i]);\n\n int ans = binpow(A, n - b[m - 1] * 2);\n ans = mul(ans, cnt(b[0]));\n forn(i, m - 1)\n ans = mul(ans, cnt(b[i + 1] - b[i]));\n\n printf(\"%d\\n\", ans);\n return 0;\n}1065F - Up and Down the Tree Tutorial1065F - Up and Down the TreeLet's calculate answer in two steps. At first, let's calculate for each vertex vv drev(v)drev(v) — what we can gain if we must return from subtree of vv in the end. We need only pair of values: minimal possible depth we can acquire to move up from subtree of vv and maximal number of different leaves we can visit. Note, that this two values are independent since we must return from vv and if for some child toto of vv we can return from it, it's profitable to visit toto and return. But if we can't return from toto so we are prohibited to descent to toto. So, drev(v).seconddrev(v).second (number of visited leaves) is just a sum of all drev(to).seconddrev(to).second if drev(to).first≤hvdrev(to).first≤hv. Also note that we can always reorder all children in such way that last visited vertex toto will have minimal drev(to).firstdrev(to).first. So drev(to).firstdrev(to).first (minimal possible depth) is a minimum over all drev(to).firstdrev(to).first.At second, let's calculate d(v)d(v) — maximal number of different leaves we can visit if we don't need to return from subtree of vv. It can be calculated quite easy using array drev(v)drev(v). We just need to choose child toto we will not return from, so from vertex toto we will take value d(to)d(to) and from other childen (which we can return from) value drev(v).seconddrev(v).second.Result complexity is O(n)O(n). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n out << \"[\";\n fore(i, 0, v.size()) {\n if(i) out << \", \";\n out << v[i];\n }\n return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n if(!(cin >> n >> k))\n return false;\n fore(i, 1, n) {\n int p; assert(scanf(\"%d\", &p) == 1);\n p--;\n\n g[p].push_back(i);\n g[i].push_back(p);\n }\n return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n drev[v] = pt(INF, 0);\n for(int to : g[v]) {\n if(to == p) continue;\n\n h[to] = h[v] + 1;\n calcRev(to, v);\n\n if(drev[to].x <= h[v]) {\n drev[v].x = min(drev[v].x, drev[to].x);\n drev[v].y += drev[to].y;\n }\n }\n\n if(p >= 0 && g[v].size() == 1)\n drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n d[v] = (p >= 0 && g[v].size() == 1);\n for(int to : g[v]) {\n if(to == p) continue;\n calcAns(to, v);\n\n int tmp = drev[v].y;\n if(drev[to].x <= h[v])\n tmp -= drev[to].y;\n\n d[v] = max(d[v], tmp + d[to]);\n }\n}\n\ninline void solve() {\n h[0] = 0;\n calcRev(0, -1);\n calcAns(0, -1);\n cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n freopen(\"input.txt\", \"r\", stdin);\n int tt = clock();\n#endif\n cout << fixed << setprecision(15);\n\n if(read()) {\n solve();\n\n#ifdef _DEBUG\n cerr << \"TIME = \" << clock() - tt << endl;\n tt = clock();\n#endif\n }\n return 0;\n}1065G - Fibonacci Suffix Tutorial1065G - Fibonacci SuffixSuppose we added all the suffixes of F(n)F(n) into a trie. Then we can find kk-th suffix by descending the trie, checking the sizes of subtrees to choose where to go on each iteration.The model solution actually does that, but computes the sizes of subtrees without building the whole trie. Recall that if we insert all suffixes of a string into the trie, then the size of subtree of some vertex is equal to the number of occurences of the string denoted by this vertex in the original string.Since in our problem the strings are recurrent, we may use prefix automaton to count the number of occurences. To calculate the number of occurences of string ss in F(x)F(x), let's build prefix function for ss, and an automaton Ap,cAp,c which tells the value of prefix function, if the previous value was pp, and we appended cc to the string (the same approach is used in KMP substring search algorithm). Then, let's build another automaton that will help us work with Fibonacci string: Fp,xFp,x — what will be the value of prefix function, if we append F(x)F(x) to the string? For x=0x=0 and x=1x=1, this automaton can be easily built using Ap,0Ap,0 and Ap,1Ap,1; and for x>1x>1, we may build Fp,xFp,x using the automatons for x−2x−2 and x−1x−1. We also have to keep track of the number of occurences, that can be done with another automaton on fibonacci strings.There is a corner case when we need to stop descending the trie; to handle it, we need to check whether some string is a suffix of F(n)F(n), but that can be easily made by checking if F0,n=|s|F0,n=|s|.Each step in trie forces us to do up to three (depending on your implementation) queries like \"count the number of occurences of some string in F(n)F(n)\", so overall the solution works in O(nm2)O(nm2). Solution (BledDest)#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n z = (int)(s.size());\n p[0] = 0;\n for(int i = 1; i < z; i++)\n {\n int j = p[i - 1];\n while(j > 0 && s[j] != s[i])\n j = p[j - 1];\n if(s[j] == s[i])\n j++;\n p[i] = j;\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n if(i < z && s[i] == char('0' + j))\n A1[i][j] = i + 1;\n else if(i == 0)\n A1[i][j] = 0;\n else\n A1[i][j] = A1[p[i - 1]][j];\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n A3[i][j] = A1[i][j];\n A2[i][j] = (A3[i][j] == z ? 1 : 0);\n }\n for(int i = 2; i <= n; i++)\n for(int j = 0; j <= z; j++)\n {\n A3[j][i] = A3[A3[j][i - 2]][i - 1];\n A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n }\n}\n\nint main()\n{\n cin >> n >> k >> m;\n string cur = \"\";\n for(int i = 0; i < m; i++)\n {\n if(cur != \"\") build(cur);\n li x = 0;\n if(cur != \"\" && A3[0][n] == i)\n x = 1;\n if(k == 1 && x == 1)\n break;\n k -= x;\n build(cur + '0');\n li x1 = A2[0][n];\n if(k > x1)\n {\n cur += '1';\n k -= x1;\n }\n else\n cur += '0';\n }\n cout << cur << endl;\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62411",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1065\\s*F"
          },
          "content_length": 14742
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "is what programmers are looking for",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 15",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 16",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 17",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 18",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        if (visited[v]) {\n            ensuref(false, \"Graph contains a cycle.\");\n        } else {\n            dfs(v, u);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n - 1, 1, n, \"p_i\");\n    inf.readEoln();\n\n    adj.resize(n + 1);\n    visited.resize(n + 1, false);\n\n    for (int i = 2; i <= n; i++) {\n        int u = p[i - 2];\n        int v = i;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfs(1, -1);\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected.\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        if (visited[v]) {\n            ensuref(false, \"Graph contains a cycle.\");\n        } else {\n            dfs(v, u);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n - 1, 1, n, \"p_i\");\n    inf.readEoln();\n\n    adj.resize(n + 1);\n    visited.resize(n + 1, false);\n\n    for (int i = 2; i <= n; i++) {\n        int u = p[i - 2];\n        int v = i;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfs(1, -1);\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected.\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        if (visited[v]) {\n            ensuref(false, \"Graph contains a cycle.\");\n        } else {\n            dfs(v, u);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n - 1, 1, n, \"p_i\");\n    inf.readEoln();\n\n    adj.resize(n + 1);\n    visited.resize(n + 1, false);\n\n    for (int i = 2; i <= n; i++) {\n        int u = p[i - 2];\n        int v = i;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfs(1, -1);\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected.\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> p;\n\nvoid generate_chain(int n) {\n    p.resize(n + 1);\n    for(int i = 2; i <= n; ++i)\n        p[i] = i - 1;\n}\n\nvoid generate_star(int n) {\n    p.resize(n + 1);\n    for(int i = 2; i <= n; ++i)\n        p[i] = 1;\n}\n\nvoid generate_random_tree(int n) {\n    p.resize(n + 1);\n    for(int i = 2; i <= n; ++i)\n        p[i] = rnd.next(1, i - 1);\n}\n\nvoid generate_binary_tree(int n) {\n    p.resize(n + 1);\n    queue<int> q;\n    int cnt = 2;\n    q.push(1);\n    while(cnt <= n) {\n        int u = q.front(); q.pop();\n        int left = cnt++;\n        if(left <= n) {\n            p[left] = u;\n            q.push(left);\n        }\n        int right = cnt++;\n        if(right <= n) {\n            p[right] = u;\n            q.push(right);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if(k < 1 || k >= n) {\n        cerr << \"Error: k must satisfy 1 ≤ k < n\" << endl;\n        return 1;\n    }\n\n    if(type == \"chain\") {\n        generate_chain(n);\n    } else if(type == \"star\") {\n        generate_star(n);\n    } else if(type == \"random\") {\n        generate_random_tree(n);\n    } else if(type == \"binary\") {\n        generate_binary_tree(n);\n    } else {\n        cerr << \"Error: Unknown type '\" << type << \"'\" << endl;\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", p[i], (i == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> p;\n\nvoid generate_chain(int n) {\n    p.resize(n + 1);\n    for(int i = 2; i <= n; ++i)\n        p[i] = i - 1;\n}\n\nvoid generate_star(int n) {\n    p.resize(n + 1);\n    for(int i = 2; i <= n; ++i)\n        p[i] = 1;\n}\n\nvoid generate_random_tree(int n) {\n    p.resize(n + 1);\n    for(int i = 2; i <= n; ++i)\n        p[i] = rnd.next(1, i - 1);\n}\n\nvoid generate_binary_tree(int n) {\n    p.resize(n + 1);\n    queue<int> q;\n    int cnt = 2;\n    q.push(1);\n    while(cnt <= n) {\n        int u = q.front(); q.pop();\n        int left = cnt++;\n        if(left <= n) {\n            p[left] = u;\n            q.push(left);\n        }\n        int right = cnt++;\n        if(right <= n) {\n            p[right] = u;\n            q.push(right);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if(k < 1 || k >= n) {\n        cerr << \"Error: k must satisfy 1 ≤ k < n\" << endl;\n        return 1;\n    }\n\n    if(type == \"chain\") {\n        generate_chain(n);\n    } else if(type == \"star\") {\n        generate_star(n);\n    } else if(type == \"random\") {\n        generate_random_tree(n);\n    } else if(type == \"binary\") {\n        generate_binary_tree(n);\n    } else {\n        cerr << \"Error: Unknown type '\" << type << \"'\" << endl;\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", p[i], (i == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, k=1\n./gen -n 2 -k 1 -type chain\n./gen -n 2 -k 1 -type star\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 1 -type binary\n\n./gen -n 10 -k 1 -type chain\n./gen -n 10 -k 1 -type star\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 1 -type binary\n\n# Medium n, k=1\n./gen -n 100 -k 1 -type chain\n./gen -n 100 -k 1 -type star\n./gen -n 100 -k 1 -type random\n./gen -n 100 -k 1 -type binary\n\n# Medium n, k=2\n./gen -n 100 -k 2 -type chain\n./gen -n 100 -k 2 -type star\n./gen -n 100 -k 2 -type random\n./gen -n 100 -k 2 -type binary\n\n# Medium n, k=n/2\n./gen -n 1000 -k 500 -type chain\n./gen -n 1000 -k 500 -type star\n./gen -n 1000 -k 500 -type random\n./gen -n 1000 -k 500 -type binary\n\n# Large n, k=1\n./gen -n 100000 -k 1 -type chain\n./gen -n 100000 -k 1 -type star\n./gen -n 100000 -k 1 -type random\n./gen -n 100000 -k 1 -type binary\n\n# Large n, k=n-1\n./gen -n 100000 -k 99999 -type chain\n./gen -n 100000 -k 99999 -type star\n./gen -n 100000 -k 99999 -type random\n./gen -n 100000 -k 99999 -type binary\n\n# Maximum n, k=1\n./gen -n 1000000 -k 1 -type chain\n./gen -n 1000000 -k 1 -type star\n./gen -n 1000000 -k 1 -type random\n./gen -n 1000000 -k 1 -type binary\n\n# Maximum n, k=n-1\n./gen -n 1000000 -k 999999 -type chain\n./gen -n 1000000 -k 999999 -type star\n./gen -n 1000000 -k 999999 -type random\n./gen -n 1000000 -k 999999 -type binary\n\n# Edge cases, k=n/2\n./gen -n 1000000 -k 500000 -type chain\n./gen -n 1000000 -k 500000 -type star\n./gen -n 1000000 -k 500000 -type random\n./gen -n 1000000 -k 500000 -type binary\n\n# Small n, k near n\n./gen -n 10 -k 9 -type chain\n./gen -n 10 -k 9 -type star\n./gen -n 10 -k 9 -type random\n./gen -n 10 -k 9 -type binary\n\n# Medium n, k=3\n./gen -n 1000 -k 3 -type chain\n./gen -n 1000 -k 3 -type star\n./gen -n 1000 -k 3 -type random\n./gen -n 1000 -k 3 -type binary\n\n# Large n, k in the middle\n./gen -n 100000 -k 50000 -type chain\n./gen -n 100000 -k 50000 -type star\n./gen -n 100000 -k 50000 -type random\n./gen -n 100000 -k 50000 -type binary\n\n# Random k values\n./gen -n 500000 -k 12345 -type random\n./gen -n 500000 -k 400000 -type star\n./gen -n 500000 -k 250000 -type chain\n./gen -n 500000 -k 1 -type binary\n\n# Balanced tree with maximum leaves\n./gen -n 999999 -k 1 -type binary\n\n# Chain with maximum k\n./gen -n 1000000 -k 999999 -type chain\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:24.760154",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1065/G",
      "title": "G. Fibonacci Suffix",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of the input contains three numbers nn, kk and mm (1≤n,m≤2001≤n,m≤200, 1≤k≤10181≤k≤1018) denoting the index of the Fibonacci string you have to consider, the index of the element of A(F(n))A(F(n)) and the number of characters you have to output, respectively.It is guaranteed that kk does not exceed the length of F(n)F(n).",
      "output_spec": "OutputOutput mm first characters of kk-th element of A(F(n))A(F(n)), or the whole element if its length is less than mm.",
      "sample_tests": "ExamplesInputCopy4 5 3OutputCopy110InputCopy4 3 3OutputCopy1",
      "description": "G. Fibonacci Suffix\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line of the input contains three numbers nn, kk and mm (1≤n,m≤2001≤n,m≤200, 1≤k≤10181≤k≤1018) denoting the index of the Fibonacci string you have to consider, the index of the element of A(F(n))A(F(n)) and the number of characters you have to output, respectively.It is guaranteed that kk does not exceed the length of F(n)F(n).\n\nOutputOutput mm first characters of kk-th element of A(F(n))A(F(n)), or the whole element if its length is less than mm.\n\nInputCopy4 5 3OutputCopy110InputCopy4 3 3OutputCopy1\n\nInputCopy4 5 3\n\nOutputCopy110\n\nInputCopy4 3 3\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces",
          "content": "On Thursday, October 11, 2018 at 22:50UTC+8 Educational Codeforces Round 52 (Rated for Div. 2) will start. Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. The penalty for each incorrect submission until the submission with a full solution is 10 minutes. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Roman Roms Glazov, Adilbek adedalic Dalabaev, Vladimir vovuh Petrov, Ivan BledDest Androsov and me.Good luck to all participants!UPD 1: Our friends from Harbour.Space University are proposing you an unprecedented offer of free (and even with a scholarship!) robotics study in Barcelona! Read the details in the post by the link https://codeforces.com/blog/entry/62357UPD 2: I'll be on the community Discord server shortly after the contest to discuss the problems.Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 isaf27 7 263 2 HanwhaEagles 7 340 3 Skywynne 6 251 4 CJYeong 6 273 5 -wawawa8 6 280 Congratulations to the best hackers: Rank Competitor Hack Count 1 Laggy 63:-10 2 Doriath 38 3 BohdanPastuschak 38:-7 4 Kerman 36:-6 5 zoooma13 33:-2 860 successful hacks and 719 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A xiaowuc1 0:01 B xiaowuc1 0:03 C HanwhaEagles 0:07 D isaf27 0:33 E Kyouko 0:19 F mHuman 0:35 G tfg 0:44 UPD 3: Editorial is published",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62341",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1829
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces",
          "content": "1065A - Vasya and Chocolate Tutorial1065A - Vasya and ChocolateNumber of chocolate bars Vasya can buy without offer is cnt=⌊sc⌋cnt=⌊sc⌋.Number of \"bundles\" with aa bars x=⌊cnta⌋x=⌊cnta⌋.Then number of additional bars add=x⋅badd=x⋅b.In result, total number of bars is add+cntadd+cnt. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int s, a, b, c;\n int t;\n cin >> t;\n for(int i = 0; i < t; ++i){\n cin >> s >> a >> b >> c;\n\n s /= c;\n int x = s / a;\n s %= a;\n long long res = x * 1LL * (a + b);\n res += s;\n\n cout << res << endl;\n }\n return 0;\n}1065B - Vasya and Isolated Vertices Tutorial1065B - Vasya and Isolated VerticesVasya can decrease number of isolated vertices up to 22 using one edge and pairing them. So minimum number of isolated vertices is max(0,n−2m)max(0,n−2m).To calculate maximum number of isolated vertices let's keep number of non-isolated vertices knowing that each pair connected by edge (i.e. size of clique). Let we have size of clique curcur and remrem edges remained unassigned at current step. If rem=0rem=0 then answer is n−curn−cur. Otherwise we need to increase clique with one vertex. Maximum number of edges we can add to connect this vertex is add=min (rem,cur)add=min (rem,cur). So, subtract it from remrem and increase curcur by one. Repeat this step while remrem greater than zero. Answer is n−curn−cur.One corner case is next: if cur=1cur=1, then answer is nn, not n−curn−cur. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n int n;\n long long m;\n cin >> n >> m;\n long long cur = 1;\n long long rem = m;\n while(rem > 0){\n long long d = min(cur, rem);\n rem -= d;\n ++cur;\n }\n assert(rem == 0);\n\n long long res = n;\n if(cur > 1) res = n - cur;\n\n cout << max(0ll, n - m * 2) << ' ' << res << endl;\n return 0;\n}1065C - Make It Equal Tutorial1065C - Make It EqualLet's iterate over height pospos of slice in decreasing order. All we need to know is a number of towers with height more than pospos (name it cc) and sum of its heights sumsum.Current slice on height pospos is good if k≥sum−c⋅posk≥sum−c⋅pos. Let's greedily decrease value pospos while slice on pospos is good keeping correct values cc and sumsum. When we found minimal good slice we can perform it increasing answer by one and \"changing tower heights\" just by setting new value to sumsum equal to c⋅posc⋅pos.Finish algorithm when pospos becomes equal to minimal height of towers and make final slice. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n scanf(\"%d %d\", &n, &k);\n for(int i = 0; i < n; ++i){\n int x;\n scanf(\"%d\", &x);\n h = max(h, x);\n need = min(need, x);\n ++cnt[x];\n }\n\n int pos = N - 1;\n int res = 0;\n long long sum = 0;\n int c = 0;\n while(true){\n long long x = sum - c * 1LL * (pos - 1);\n if(x > k){\n ++res;\n h = pos;\n sum = pos * 1LL * c;\n } \n\n --pos;\n if(pos == need) break;\n c += cnt[pos];\n sum += cnt[pos] * 1LL * pos;\n }\n\n if(h != need) ++res;\n\n cout << res << endl;\n}1065D - Three Pieces Tutorial1065D - Three PiecesThere are a lot of different solutions for the problem. Most of them have the similar structure.The first part is to find the shortest distance between the states (x1,y1,p1)(x1,y1,p1) and (x2,y2,p2)(x2,y2,p2), where xx and yy are the coordinates of the square and pp is the current piece. This can be done with 0-1 bfs, Floyd or Dijkstra. Just represent the triple as a single integer by transforming it to (x⋅n⋅3+y⋅3+p)(x⋅n⋅3+y⋅3+p) and do everything on that graph.The second part is to write some dp to go from ii-th square with piece p1p1 to (i+1)(i+1)-th square with piece p2p2. The value of this dp[n][3]dp[n][3] is a pair (moves, replacements). It is easy to see that you can always choose the minimum of two such pairs while updating.Overall complexity may vary. We believe, O(n4)O(n4) is achievable. However, the particular solution I coded works in O(n6)O(n6). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\nint dy[] = { 1, 2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n scanf(\"%d\", &n);\n forn(i, n) forn(j, n){\n scanf(\"%d\", &a[i][j]);\n --a[i][j];\n pos[a[i][j]] = mp(i, j);\n }\n\n forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n forn(i, M) dist[i][i] = mp(0, 0);\n\n forn(x, n) forn(y, n){\n forn(i, 8){\n int nx = x + dx[i];\n int ny = y + dy[i];\n if (in(nx, ny))\n dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n }\n\n for (int i = -n + 1; i <= n - 1; ++i){\n int nx = x + i;\n int ny = y + i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n ny = y - i;\n if (in(nx, ny))\n dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n }\n\n forn(i, n){\n int nx = x;\n int ny = i;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n nx = i;\n ny = y;\n dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n }\n\n forn(i, 3) forn(j, 3){\n if (i != j){\n dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n }\n }\n }\n\n forn(k, M) forn(i, M) forn(j, M)\n dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n\n pt ans = mp(INF, INF);\n ans = min(ans, dp[n * n - 1][0]);\n ans = min(ans, dp[n * n - 1][1]);\n ans = min(ans, dp[n * n - 1][2]);\n\n printf(\"%d %d\\n\", ans.x, ans.y);\n return 0;\n}1065E - Side Transmutations Tutorial1065E - Side TransmutationsLet's take a look at any operation. You can notice that each letter can only go from position ii to n−i−1n−i−1 (00-indexed). Then, doing some operation twice is the same as doing that operation zero times.Now consider some set of operations l1,l2,…,lkl1,l2,…,lk, sorted in increasing order. Actually, they do the following altogether. Replace segment [lk−1..lk)[lk−1..lk) with the reversed segment ((n−lk−1)..(n−lk−1−1)]((n−lk−1)..(n−lk−1−1)] and vice versa. Then replace segment [lk−3..lk−2)[lk−3..lk−2) with the reversed segment ((n−lk−2−1)..(n−lk−3−1)]((n−lk−2−1)..(n−lk−3−1)] and vice versa. And continue until you reach the first pair. Segment [0..l1)[0..l1) might also be included in the answer when the parity is right.Moreover, every subset of segments [0..l1),[l1,l2),…[lk−1,lk)[0..l1),[l1,l2),…[lk−1,lk) is achievable. So for each segment you can either swap it or not. Let's translate it to math language.Let cnticnti be the number of such pairs of strings xx and yy that x≤yx≤y. Why is there such an order? You want to consider only unique strings, thus, you need to pick exactly one of equal strings from each component. Let it be the smallest one.Then for each segment of the set you have cntlencntlen pairs to choose from, where lenlen is the length of that segment.And that part of the formula is:cntb1⋅∏i=1mcntbi−bi−1cntb1⋅∏i=1mcntbi−bi−1.However, the part covered by zero segments is left. There are ALn−2bmALn−2bm possible strings up there.cnticnti is actually a number of all pairs of strings of length ii plus the number of all pairs of equal strings of length ii divided by 22. cnti=AL2i+ALi2cnti=AL2i+ALi2.Overall complexity: O(mlogn)O(mlog⁡n). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n a += b;\n if (a >= MOD)\n a -= MOD;\n return a;\n}\n\nint mul(int a, int b){\n return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n int res = 1;\n while (b){\n if (b & 1)\n res = mul(res, a);\n a = mul(a, a);\n b >>= 1;\n }\n return res;\n}\n\nint cnt(int x){\n int base = binpow(A, x);\n return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n scanf(\"%d%d%d\", &n, &m, &A);\n forn(i, m)\n scanf(\"%d\", &b[i]);\n\n int ans = binpow(A, n - b[m - 1] * 2);\n ans = mul(ans, cnt(b[0]));\n forn(i, m - 1)\n ans = mul(ans, cnt(b[i + 1] - b[i]));\n\n printf(\"%d\\n\", ans);\n return 0;\n}1065F - Up and Down the Tree Tutorial1065F - Up and Down the TreeLet's calculate answer in two steps. At first, let's calculate for each vertex vv drev(v)drev(v) — what we can gain if we must return from subtree of vv in the end. We need only pair of values: minimal possible depth we can acquire to move up from subtree of vv and maximal number of different leaves we can visit. Note, that this two values are independent since we must return from vv and if for some child toto of vv we can return from it, it's profitable to visit toto and return. But if we can't return from toto so we are prohibited to descent to toto. So, drev(v).seconddrev(v).second (number of visited leaves) is just a sum of all drev(to).seconddrev(to).second if drev(to).first≤hvdrev(to).first≤hv. Also note that we can always reorder all children in such way that last visited vertex toto will have minimal drev(to).firstdrev(to).first. So drev(to).firstdrev(to).first (minimal possible depth) is a minimum over all drev(to).firstdrev(to).first.At second, let's calculate d(v)d(v) — maximal number of different leaves we can visit if we don't need to return from subtree of vv. It can be calculated quite easy using array drev(v)drev(v). We just need to choose child toto we will not return from, so from vertex toto we will take value d(to)d(to) and from other childen (which we can return from) value drev(v).seconddrev(v).second.Result complexity is O(n)O(n). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n out << \"[\";\n fore(i, 0, v.size()) {\n if(i) out << \", \";\n out << v[i];\n }\n return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n if(!(cin >> n >> k))\n return false;\n fore(i, 1, n) {\n int p; assert(scanf(\"%d\", &p) == 1);\n p--;\n\n g[p].push_back(i);\n g[i].push_back(p);\n }\n return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n drev[v] = pt(INF, 0);\n for(int to : g[v]) {\n if(to == p) continue;\n\n h[to] = h[v] + 1;\n calcRev(to, v);\n\n if(drev[to].x <= h[v]) {\n drev[v].x = min(drev[v].x, drev[to].x);\n drev[v].y += drev[to].y;\n }\n }\n\n if(p >= 0 && g[v].size() == 1)\n drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n d[v] = (p >= 0 && g[v].size() == 1);\n for(int to : g[v]) {\n if(to == p) continue;\n calcAns(to, v);\n\n int tmp = drev[v].y;\n if(drev[to].x <= h[v])\n tmp -= drev[to].y;\n\n d[v] = max(d[v], tmp + d[to]);\n }\n}\n\ninline void solve() {\n h[0] = 0;\n calcRev(0, -1);\n calcAns(0, -1);\n cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n freopen(\"input.txt\", \"r\", stdin);\n int tt = clock();\n#endif\n cout << fixed << setprecision(15);\n\n if(read()) {\n solve();\n\n#ifdef _DEBUG\n cerr << \"TIME = \" << clock() - tt << endl;\n tt = clock();\n#endif\n }\n return 0;\n}1065G - Fibonacci Suffix Tutorial1065G - Fibonacci SuffixSuppose we added all the suffixes of F(n)F(n) into a trie. Then we can find kk-th suffix by descending the trie, checking the sizes of subtrees to choose where to go on each iteration.The model solution actually does that, but computes the sizes of subtrees without building the whole trie. Recall that if we insert all suffixes of a string into the trie, then the size of subtree of some vertex is equal to the number of occurences of the string denoted by this vertex in the original string.Since in our problem the strings are recurrent, we may use prefix automaton to count the number of occurences. To calculate the number of occurences of string ss in F(x)F(x), let's build prefix function for ss, and an automaton Ap,cAp,c which tells the value of prefix function, if the previous value was pp, and we appended cc to the string (the same approach is used in KMP substring search algorithm). Then, let's build another automaton that will help us work with Fibonacci string: Fp,xFp,x — what will be the value of prefix function, if we append F(x)F(x) to the string? For x=0x=0 and x=1x=1, this automaton can be easily built using Ap,0Ap,0 and Ap,1Ap,1; and for x>1x>1, we may build Fp,xFp,x using the automatons for x−2x−2 and x−1x−1. We also have to keep track of the number of occurences, that can be done with another automaton on fibonacci strings.There is a corner case when we need to stop descending the trie; to handle it, we need to check whether some string is a suffix of F(n)F(n), but that can be easily made by checking if F0,n=|s|F0,n=|s|.Each step in trie forces us to do up to three (depending on your implementation) queries like \"count the number of occurences of some string in F(n)F(n)\", so overall the solution works in O(nm2)O(nm2). Solution (BledDest)#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n z = (int)(s.size());\n p[0] = 0;\n for(int i = 1; i < z; i++)\n {\n int j = p[i - 1];\n while(j > 0 && s[j] != s[i])\n j = p[j - 1];\n if(s[j] == s[i])\n j++;\n p[i] = j;\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n if(i < z && s[i] == char('0' + j))\n A1[i][j] = i + 1;\n else if(i == 0)\n A1[i][j] = 0;\n else\n A1[i][j] = A1[p[i - 1]][j];\n }\n for(int i = 0; i <= z; i++)\n for(int j = 0; j < 2; j++)\n {\n A3[i][j] = A1[i][j];\n A2[i][j] = (A3[i][j] == z ? 1 : 0);\n }\n for(int i = 2; i <= n; i++)\n for(int j = 0; j <= z; j++)\n {\n A3[j][i] = A3[A3[j][i - 2]][i - 1];\n A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n }\n}\n\nint main()\n{\n cin >> n >> k >> m;\n string cur = \"\";\n for(int i = 0; i < m; i++)\n {\n if(cur != \"\") build(cur);\n li x = 0;\n if(cur != \"\" && A3[0][n] == i)\n x = 1;\n if(k == 1 && x == 1)\n break;\n k -= x;\n build(cur + '0');\n li x1 = A2[0][n];\n if(k > x1)\n {\n cur += '1';\n k -= x1;\n }\n else\n cur += '0';\n }\n cout << cur << endl;\n return 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62411",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1065\\s*G"
          },
          "content_length": 14742
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "is what programmers are looking for",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "10 2\n1 2 3 2 1 6 7 7 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62341",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int s, a, b, c;\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; ++i){\n        cin >> s >> a >> b >> c;\n        \n        s /= c;\n        int x = s / a;\n        s %= a;\n        long long res = x * 1LL * (a + b);\n        res += s;\n        \n        cout << res << endl;\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    long long m;\n    cin >> n >> m;\n    long long cur = 1;\n    long long rem = m;\n    while(rem > 0){\n        long long d = min(cur, rem);\n        rem -= d;\n        ++cur;\n    }\n    assert(rem == 0);\n    \n    long long res = n;\n    if(cur > 1) res = n - cur;\n    \n    cout << max(0ll, n - m * 2) << ' ' << res << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n, k, h;\nint need = int(1e9);\nint cnt[N];\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for(int i = 0; i < n; ++i){\n        int x;\n        scanf(\"%d\", &x);\n        h = max(h, x);\n        need = min(need, x);\n        ++cnt[x];\n    }\n    \n    int pos = N - 1;\n    int res = 0;\n    long long sum = 0;\n    int c = 0;\n    while(true){\n        long long x = sum - c * 1LL * (pos - 1);\n        if(x > k){\n            ++res;\n            h = pos;\n            sum = pos * 1LL * c;\n        }   \n    \n        --pos;\n        if(pos == need) break;\n        c += cnt[pos];\n        sum += cnt[pos] * 1LL * pos;\n    }\n    \n    if(h != need) ++res;\n    \n    cout << res << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<int, int> pt;\n\nconst int N = 12;\nconst int M = 305;\nconst int INF = 1e9;\n\nint n;\nint a[N][N];\npt pos[N * N];\npt dist[M][M];\n\npt operator +(const pt &a, const pt &b){\n    return mp(a.x + b.x, a.y + b.y);\n}\n\nint dx[] = {-2, -1, 1, 2,  2,  1, -1, -2};\nint dy[] = { 1,  2, 2, 1, -1, -2, -2, -1};\n\nbool in(int x, int y){\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\nint get(int x, int y, int p){\n    return x * n * 3 + y * 3 + p;\n}\n\npt dp[N * N][3];\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n) forn(j, n){\n        scanf(\"%d\", &a[i][j]);\n        --a[i][j];\n        pos[a[i][j]] = mp(i, j);\n    }\n    \n    forn(i, M) forn(j, M) dist[i][j] = mp(INF, INF);\n    forn(i, M) dist[i][i] = mp(0, 0);\n    \n    forn(x, n) forn(y, n){\n        forn(i, 8){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (in(nx, ny))\n                dist[get(x, y, 0)][get(nx, ny, 0)] = mp(1, 0);\n        }\n        \n        for (int i = -n + 1; i <= n - 1; ++i){\n            int nx = x + i;\n            int ny = y + i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n            ny = y - i;\n            if (in(nx, ny))\n                dist[get(x, y, 1)][get(nx, ny, 1)] = mp(1, 0);\n        }\n        \n        forn(i, n){\n            int nx = x;\n            int ny = i;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n            nx = i;\n            ny = y;\n            dist[get(x, y, 2)][get(nx, ny, 2)] = mp(1, 0);\n        }\n        \n        forn(i, 3) forn(j, 3){\n            if (i != j){\n                dist[get(x, y, i)][get(x, y, j)] = mp(1, 1);\n            }\n        }\n    }\n    \n    forn(k, M) forn(i, M) forn(j, M)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    \n    forn(i, N * N) forn(j, 3) dp[i][j] = mp(INF, INF);\n    dp[0][0] = dp[0][1] = dp[0][2] = mp(0, 0);\n    forn(i, n * n - 1) forn(j, 3) forn(k, 3)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[get(pos[i].x, pos[i].y, j)][get(pos[i + 1].x, pos[i + 1].y, k)]);\n    \n    pt ans = mp(INF, INF);\n    ans = min(ans, dp[n * n - 1][0]);\n    ans = min(ans, dp[n * n - 1][1]);\n    ans = min(ans, dp[n * n - 1][2]);\n    \n    printf(\"%d %d\\n\", ans.x, ans.y);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\nconst int MOD = 998244353;\n\nint n, m, A;\nint b[N];\n\nint add(int a, int b){\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n    return a;\n}\n\nint mul(int a, int b){\n    return (a * 1ll * b) % MOD;\n}\n\nint binpow(int a, int b){\n    int res = 1;\n    while (b){\n        if (b & 1)\n            res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint cnt(int x){\n    int base = binpow(A, x);\n    return mul(add(mul(base, base), base), (MOD + 1) / 2);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &A);\n    forn(i, m)\n        scanf(\"%d\", &b[i]);\n    \n    int ans = binpow(A, n - b[m - 1] * 2);\n    ans = mul(ans, cnt(b[0]));\n    forn(i, m - 1)\n        ans = mul(ans, cnt(b[i + 1] - b[i]));\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 11",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 12",
          "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream& out, const pair<A, B> &p) {\n    return out << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\ntemplate<class A> ostream& operator <<(ostream& out, const vector<A> &v) {\n    out << \"[\";\n    fore(i, 0, v.size()) {\n        if(i) out << \", \";\n        out << v[i];\n    }\n    return out << \"]\";\n}\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\n\nconst int N = 1000 * 1000 + 555;\n\nint n, k;\nvector<int> g[N];\n\ninline bool read() {\n    if(!(cin >> n >> k))\n        return false;\n    fore(i, 1, n) {\n        int p; assert(scanf(\"%d\", &p) == 1);\n        p--;\n        \n        g[p].push_back(i);\n        g[i].push_back(p);\n    }\n    return true;\n}\n\nint h[N];\npt drev[N];\n\nvoid calcRev(int v, int p) {\n    drev[v] = pt(INF, 0);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        \n        h[to] = h[v] + 1;\n        calcRev(to, v);\n        \n        if(drev[to].x <= h[v]) {\n            drev[v].x = min(drev[v].x, drev[to].x);\n            drev[v].y += drev[to].y;\n        }\n    }\n    \n    if(p >= 0 && g[v].size() == 1)\n        drev[v] = pt(h[v] - k, 1);\n}\n\nint d[N];\n\nvoid calcAns(int v, int p) {\n    d[v] = (p >= 0 && g[v].size() == 1);\n    for(int to : g[v]) {\n        if(to == p) continue;\n        calcAns(to, v);\n        \n        int tmp = drev[v].y;\n        if(drev[to].x <= h[v])\n            tmp -= drev[to].y;\n        \n        d[v] = max(d[v], tmp + d[to]);\n    }\n}\n\ninline void solve() {\n    h[0] = 0;\n    calcRev(0, -1);\n    calcAns(0, -1);\n    cout << d[0] << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    int tt = clock();\n#endif\n    cout << fixed << setprecision(15);\n    \n    if(read()) {\n        solve();\n        \n#ifdef _DEBUG\n        cerr << \"TIME = \" << clock() - tt << endl;\n        tt = clock();\n#endif\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long li;\n\nconst li INF64 = li(1e18);\n\nli add(li x, li y)\n{\n    return min(x + y, INF64);\n}\n\nconst int N = 243;\n\nint A1[N][2];\nli A2[N][N];\nint A3[N][N];\nint n, m;\nli k;\nint z;\nint p[N];\n\nvoid build(const string& s)\n{\n    z = (int)(s.size());\n    p[0] = 0;\n    for(int i = 1; i < z; i++)\n    {\n        int j = p[i - 1];\n        while(j > 0 && s[j] != s[i])\n            j = p[j - 1];\n        if(s[j] == s[i])\n            j++;\n        p[i] = j;\n    }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            if(i < z && s[i] == char('0' + j))\n                A1[i][j] = i + 1;\n            else if(i == 0)\n                A1[i][j] = 0;\n            else\n                A1[i][j] = A1[p[i - 1]][j];\n        }\n    for(int i = 0; i <= z; i++)\n        for(int j = 0; j < 2; j++)\n        {\n            A3[i][j] = A1[i][j];\n            A2[i][j] = (A3[i][j] == z ? 1 : 0);\n        }\n    for(int i = 2; i <= n; i++)\n        for(int j = 0; j <= z; j++)\n        {\n            A3[j][i] = A3[A3[j][i - 2]][i - 1];\n            A2[j][i] = add(A2[j][i - 2], A2[A3[j][i - 2]][i - 1]);\n        }\n}\n\nint main()\n{\n    cin >> n >> k >> m;\n    string cur = \"\";\n    for(int i = 0; i < m; i++)\n    {\n        if(cur != \"\") build(cur);\n        li x = 0;\n        if(cur != \"\" && A3[0][n] == i)\n            x = 1;\n        if(k == 1 && x == 1)\n            break;\n        k -= x;\n        build(cur + '0');\n        li x1 = A2[0][n];\n        if(k > x1)\n        {\n            cur += '1';\n            k -= x1;\n        }\n        else\n            cur += '0';\n    }\n    cout << cur << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 15",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 16",
          "code": "4\n14\t10\t3\t7\n4\t15\t11\t13\n12\t1\t16\t9\n2\t5\t6\t8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 17",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 52 Editorial - Codeforces - Code 18",
          "code": "ceil((SumOfHeight - N * minHeight) / K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62411",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> BigInt; // Store digits in reverse order\n\nBigInt add(const BigInt &a, const BigInt &b) {\n    BigInt res;\n    int carry = 0;\n    int n = max(a.size(), b.size());\n    for (int i = 0; i < n; i++) {\n        int d = carry;\n        if (i < a.size()) d += a[i];\n        if (i < b.size()) d += b[i];\n        res.push_back(d % 10);\n        carry = d / 10;\n    }\n    if (carry) res.push_back(carry);\n    return res;\n}\n\n// Returns -1 if a < k, 0 if a == k, 1 if a > k\nint compare_bigint_longlong(const BigInt &a, long long k) {\n    // Convert k to BigInt\n    BigInt kb;\n    if (k == 0) kb.push_back(0);\n    while (k > 0) {\n        kb.push_back(k % 10);\n        k /= 10;\n    }\n    // Compare sizes\n    if (a.size() > kb.size()) return 1;\n    if (a.size() < kb.size()) return -1;\n    // Sizes are equal\n    for (int i = a.size() - 1; i >= 0; i--) {\n        if (a[i] > kb[i]) return 1;\n        if (a[i] < kb[i]) return -1;\n    }\n    return 0; // Equal\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 1000000000000000000LL, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readEoln();\n    \n    // Compute len(n) as BigInt\n    vector<BigInt> len(n + 1); // len[0..n]\n    len[0] = BigInt(1,1); // length of F(0) is 1\n    len[1] = BigInt(1,1); // length of F(1) is 1\n    for (int i = 2; i <= n; i++) {\n        len[i] = add(len[i-2], len[i-1]);\n    }\n    \n    // Ensure that k ≤ len(n)\n    int cmp = compare_bigint_longlong(len[n], k);\n    ensuref(cmp >= 0, \"k (%lld) must not exceed len(F(n))\", k);\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> BigInt; // Store digits in reverse order\n\nBigInt add(const BigInt &a, const BigInt &b) {\n    BigInt res;\n    int carry = 0;\n    int n = max(a.size(), b.size());\n    for (int i = 0; i < n; i++) {\n        int d = carry;\n        if (i < a.size()) d += a[i];\n        if (i < b.size()) d += b[i];\n        res.push_back(d % 10);\n        carry = d / 10;\n    }\n    if (carry) res.push_back(carry);\n    return res;\n}\n\n// Returns -1 if a < k, 0 if a == k, 1 if a > k\nint compare_bigint_longlong(const BigInt &a, long long k) {\n    // Convert k to BigInt\n    BigInt kb;\n    if (k == 0) kb.push_back(0);\n    while (k > 0) {\n        kb.push_back(k % 10);\n        k /= 10;\n    }\n    // Compare sizes\n    if (a.size() > kb.size()) return 1;\n    if (a.size() < kb.size()) return -1;\n    // Sizes are equal\n    for (int i = a.size() - 1; i >= 0; i--) {\n        if (a[i] > kb[i]) return 1;\n        if (a[i] < kb[i]) return -1;\n    }\n    return 0; // Equal\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 1000000000000000000LL, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readEoln();\n    \n    // Compute len(n) as BigInt\n    vector<BigInt> len(n + 1); // len[0..n]\n    len[0] = BigInt(1,1); // length of F(0) is 1\n    len[1] = BigInt(1,1); // length of F(1) is 1\n    for (int i = 2; i <= n; i++) {\n        len[i] = add(len[i-2], len[i-1]);\n    }\n    \n    // Ensure that k ≤ len(n)\n    int cmp = compare_bigint_longlong(len[n], k);\n    ensuref(cmp >= 0, \"k (%lld) must not exceed len(F(n))\", k);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> BigInt; // Store digits in reverse order\n\nBigInt add(const BigInt &a, const BigInt &b) {\n    BigInt res;\n    int carry = 0;\n    int n = max(a.size(), b.size());\n    for (int i = 0; i < n; i++) {\n        int d = carry;\n        if (i < a.size()) d += a[i];\n        if (i < b.size()) d += b[i];\n        res.push_back(d % 10);\n        carry = d / 10;\n    }\n    if (carry) res.push_back(carry);\n    return res;\n}\n\n// Returns -1 if a < k, 0 if a == k, 1 if a > k\nint compare_bigint_longlong(const BigInt &a, long long k) {\n    // Convert k to BigInt\n    BigInt kb;\n    if (k == 0) kb.push_back(0);\n    while (k > 0) {\n        kb.push_back(k % 10);\n        k /= 10;\n    }\n    // Compare sizes\n    if (a.size() > kb.size()) return 1;\n    if (a.size() < kb.size()) return -1;\n    // Sizes are equal\n    for (int i = a.size() - 1; i >= 0; i--) {\n        if (a[i] > kb[i]) return 1;\n        if (a[i] < kb[i]) return -1;\n    }\n    return 0; // Equal\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 1000000000000000000LL, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readEoln();\n    \n    // Compute len(n) as BigInt\n    vector<BigInt> len(n + 1); // len[0..n]\n    len[0] = BigInt(1,1); // length of F(0) is 1\n    len[1] = BigInt(1,1); // length of F(1) is 1\n    for (int i = 2; i <= n; i++) {\n        len[i] = add(len[i-2], len[i-1]);\n    }\n    \n    // Ensure that k ≤ len(n)\n    int cmp = compare_bigint_longlong(len[n], k);\n    ensuref(cmp >= 0, \"k (%lld) must not exceed len(F(n))\", k);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Function to compute log(exp(a) + exp(b)) without overflow */\ndouble logsumexp(double a, double b) {\n    if (a == -INFINITY) return b;\n    if (b == -INFINITY) return a;\n    if (a > b) {\n        return a + log1p(exp(b - a));\n    } else {\n        return b + log1p(exp(a - b));\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string k_type = opt<string>(\"k\", \"random\"); // Options: \"min\", \"max\", \"random\", \"middle\"\n    string m_type = opt<string>(\"m_type\", \"random\"); // Options: \"min\", \"max\", \"random\", \"middle\"\n    int m = opt<int>(\"m\", -1); // If m is provided directly\n\n    // Compute len_log[0..n], where len_log[i] = log(length of F(i))\n    vector<double> len_log(n + 1);\n    len_log[0] = log(1.0); // Length of F(0) is 1\n    len_log[1] = log(1.0); // Length of F(1) is 1\n\n    for (int i = 2; i <= n; ++i) {\n        len_log[i] = logsumexp(len_log[i - 1], len_log[i - 2]);\n    }\n\n    // Determine k_max, max value of k\n    double log1e18 = log(1e18);\n    long long k_max;\n    if (len_log[n] < log1e18) {\n        // For len_n[n] <= 1e18, we can compute len_n[n] accurately\n        double len_n = exp(len_log[n]);\n        k_max = (long long)(len_n); // len_n >= 1, since F(n) has at least length 1\n    } else {\n        // len_n[n] >= 1e18\n        k_max = 1000000000000000000LL; // 1e18\n    }\n\n    // Generate k\n    long long k;\n    if (k_type == \"min\") {\n        k = 1;\n    } else if (k_type == \"max\") {\n        k = k_max;\n    } else if (k_type == \"middle\") {\n        k = k_max / 2;\n        if (k == 0) k = 1;\n    } else { // k_type == \"random\"\n        k = rnd.next(1LL, k_max);\n    }\n\n    // Generate m\n    if (m == -1) {\n        // m not provided directly\n        if (m_type == \"min\") {\n            m = 1;\n        } else if (m_type == \"max\") {\n            m = 200;\n        } else if (m_type == \"middle\") {\n            m = 100;\n        } else { // m_type == \"random\"\n            m = rnd.next(1, 200);\n        }\n    }\n    else {\n        // m provided directly, ensure it is within constraints\n        ensure(1 <= m && m <= 200);\n    }\n\n    // Output n k m\n    printf(\"%d %lld %d\\n\", n, k, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Function to compute log(exp(a) + exp(b)) without overflow */\ndouble logsumexp(double a, double b) {\n    if (a == -INFINITY) return b;\n    if (b == -INFINITY) return a;\n    if (a > b) {\n        return a + log1p(exp(b - a));\n    } else {\n        return b + log1p(exp(a - b));\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string k_type = opt<string>(\"k\", \"random\"); // Options: \"min\", \"max\", \"random\", \"middle\"\n    string m_type = opt<string>(\"m_type\", \"random\"); // Options: \"min\", \"max\", \"random\", \"middle\"\n    int m = opt<int>(\"m\", -1); // If m is provided directly\n\n    // Compute len_log[0..n], where len_log[i] = log(length of F(i))\n    vector<double> len_log(n + 1);\n    len_log[0] = log(1.0); // Length of F(0) is 1\n    len_log[1] = log(1.0); // Length of F(1) is 1\n\n    for (int i = 2; i <= n; ++i) {\n        len_log[i] = logsumexp(len_log[i - 1], len_log[i - 2]);\n    }\n\n    // Determine k_max, max value of k\n    double log1e18 = log(1e18);\n    long long k_max;\n    if (len_log[n] < log1e18) {\n        // For len_n[n] <= 1e18, we can compute len_n[n] accurately\n        double len_n = exp(len_log[n]);\n        k_max = (long long)(len_n); // len_n >= 1, since F(n) has at least length 1\n    } else {\n        // len_n[n] >= 1e18\n        k_max = 1000000000000000000LL; // 1e18\n    }\n\n    // Generate k\n    long long k;\n    if (k_type == \"min\") {\n        k = 1;\n    } else if (k_type == \"max\") {\n        k = k_max;\n    } else if (k_type == \"middle\") {\n        k = k_max / 2;\n        if (k == 0) k = 1;\n    } else { // k_type == \"random\"\n        k = rnd.next(1LL, k_max);\n    }\n\n    // Generate m\n    if (m == -1) {\n        // m not provided directly\n        if (m_type == \"min\") {\n            m = 1;\n        } else if (m_type == \"max\") {\n            m = 200;\n        } else if (m_type == \"middle\") {\n            m = 100;\n        } else { // m_type == \"random\"\n            m = rnd.next(1, 200);\n        }\n    }\n    else {\n        // m provided directly, ensure it is within constraints\n        ensure(1 <= m && m <= 200);\n    }\n\n    // Output n k m\n    printf(\"%d %lld %d\\n\", n, k, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, small k and m\n./gen -n 1 -k min -m 1\n./gen -n 1 -k max -m 1\n./gen -n 1 -k random -m_type random\n\n# Edge cases for n\n./gen -n 0 -k min -m 1\n./gen -n 0 -k max -m 200\n./gen -n 0 -k random -m_type random\n\n# Medium n\n./gen -n 50 -k min -m 1\n./gen -n 50 -k max -m 200\n./gen -n 50 -k random -m_type random\n\n# Large n, maximum k\n./gen -n 100 -k max -m 200\n./gen -n 150 -k max -m 200\n./gen -n 200 -k max -m 200\n\n# Large n, random k\n./gen -n 100 -k random -m_type random\n./gen -n 150 -k random -m_type random\n./gen -n 200 -k random -m_type random\n\n# Large n, minimum k\n./gen -n 100 -k min -m 1\n./gen -n 150 -k min -m 1\n./gen -n 200 -k min -m 1\n\n# Middle values\n./gen -n 100 -k middle -m_type middle\n./gen -n 150 -k middle -m_type middle\n./gen -n 200 -k middle -m_type middle\n\n# Maximum m\n./gen -n 100 -k random -m 200\n./gen -n 150 -k random -m 200\n./gen -n 200 -k random -m 200\n\n# Minimum m\n./gen -n 100 -k random -m 1\n./gen -n 150 -k random -m 1\n./gen -n 200 -k random -m 1\n\n# Random test cases\n./gen -n 75 -k random -m_type random\n./gen -n 125 -k random -m_type random\n./gen -n 175 -k random -m_type random\n\n# Edge case where n is maximum and k is maximum\n./gen -n 200 -k max -m_type random\n\n# Edge case where n is maximum and k is minimum\n./gen -n 200 -k min -m_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:26.460603",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1066/A",
      "title": "A. Vova and Train",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains one integer tt (1≤t≤1041≤t≤104) — the number of queries.Then tt lines follow. The ii-th line contains four integers Li,vi,li,riLi,vi,li,ri (1≤L,v≤1091≤L,v≤109, 1≤l≤r≤L1≤l≤r≤L) — destination point of the ii-th path, the period of the lantern appearance and the segment occupied by the standing train.",
      "output_spec": "OutputPrint tt lines. The ii-th line should contain one integer — the answer for the ii-th query.",
      "sample_tests": "ExampleInputCopy410 2 3 7100 51 51 511234 1 100 1991000000000 1 1 1000000000OutputCopy3011340",
      "description": "A. Vova and Train\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains one integer tt (1≤t≤1041≤t≤104) — the number of queries.Then tt lines follow. The ii-th line contains four integers Li,vi,li,riLi,vi,li,ri (1≤L,v≤1091≤L,v≤109, 1≤l≤r≤L1≤l≤r≤L) — destination point of the ii-th path, the period of the lantern appearance and the segment occupied by the standing train.\n\nOutputPrint tt lines. The ii-th line should contain one integer — the answer for the ii-th query.\n\nInputCopy410 2 3 7100 51 51 511234 1 100 1991000000000 1 1 1000000000OutputCopy3011340\n\nInputCopy410 2 3 7100 51 51 511234 1 100 1991000000000 1 1 1000000000\n\nOutputCopy3011340\n\nNoteFor the first example query, the answer is 33. There are lanterns at positions 22, 44, 66, 88 and 1010, but Vova didn't see the lanterns at positions 44 and 66 because of the standing train.For the second example query, the answer is 00 because the only lantern is at the point 5151 and there is also a standing train at this point.For the third example query, the answer is 11341134 because there are 12341234 lanterns, but Vova didn't see the lanterns from the position 100100 to the position 199199 inclusive.For the fourth example query, the answer is 00 because the standing train covers the whole path.",
      "solutions": [
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces",
          "content": "1066A - Vova and Train Tutorial1066A - Vova and TrainWhat is the number of lanterns Vova will see from 11 to LL? This number is ⌊Lv⌋⌊Lv⌋. Now we have to subtract the number of lanters in range [l;r][l;r] from this number. This number equals to ⌊rv⌋−⌊l−1v⌋⌊rv⌋−⌊l−1v⌋. So the answer is ⌊Lv⌋⌊Lv⌋ - ⌊rv⌋⌊rv⌋ + ⌊l−1v⌋⌊l−1v⌋. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint t;\n\tcin >> t;\n\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\n\treturn 0;\n}1066B - Heaters Tutorial1066B - HeatersLet's solve this problem greedily. Let lastlast be the last position from the left covered by at least one heater. Initially, lastlast equals -1. While last<n−1last<n−1, lets repeat the following process: firstly, we have to find the rightmost heater in range (max(−1,last−r+1);last+r](max(−1,last−r+1);last+r]. It can be done in time O(n)O(n) because of given constrains or in O(1)O(1) using precalculated prefix values for each ii in range [0;n−1][0;n−1]. If there is no such heater then the answer is -1, otherwise let's set last:=pos+r−1last:=pos+r−1, increase the answer by 11 and repeat the process if last<n−1last<n−1.There is another one solution to this problem. Assume that the initial answer equals to the total number of heaters. Let's calculate an array cntcnt of length nn, where cnticnti means the number of heaters covering the ii-th element. It can be done in O(n2)O(n2). This array will mean that we are switch all the heaters on and we know for each element the number of heaters covers this element. Now if for at least i∈[0,n−1]i∈[0,n−1] holds cnti=0cnti=0 then the answer is -1. Otherwise let's switch useless heaters off. Let's iterate over all heaters from left to right. Let the current heater have position ii. We need to check if it is useless or not. Let's iterate in range [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)] and check if there is at least one element jj in this segment such that cntj=1cntj=1. If there is then the current heater is not useless and we cannot switch it off. Otherwise we can decrease the answer by 11, switch this heater off (decrease cntjcntj for all jj in range [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)]) and continue the process. Solution 1#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n} Solution 2#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n {\n cin >> a[i];\n if (a[i])ans++;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]++;\n }\n forn(i, n)\n if (!cnt[i])\n {\n cout << -1;\n return 0;\n }\n forn(i, n)\n {\n bool fl = true;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n if (cnt[j] == 1)\n {\n fl = false;\n break;\n }\n if (fl && a[i])\n {\n ans--;\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]--;\n }\n }\n cout << ans;\n\n}1066C - Books Queries Tutorial1066C - Books QueriesLet imagine our shelf as an infinite array. Let's carry the rightmost free position from the left of our shelf (let it be ll and initially it equals to 00) and the leftmost free position from the right of our shelf (let it be rr and initially it equals to 00). Also let's carry the array pospos of length 2⋅1052⋅105 where posiposi will be equal to the position in our imaginary array of the book with a number ii.Let's put the first book to the position 00. Also let's save that posidposid (where idid is the number of the first book) equals to 00. How will change ll and rr? ll will become −1−1 and rr will become 11. Now let's process queries one by one. If now we have the query of type 11 with a book with a number idid, then let's set posid:=lposid:=l and set l:=l−1l:=l−1. The query of type 22 can be processed similarly. Now what about queries of type 33? The answer to this query equals to min(|posid−l|,|posid−r|)−1min(|posid−l|,|posid−r|)−1, where |v||v| is the absolute value of vv. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint q;\n\tcin >> q;\n\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}1066D - Boxes Packing Tutorial1066D - Boxes PackingThe first solution is some kind of a straight-forward understanding the problem. Let's do binary search on the answer. So our problem is to find the smallest xx such that the suffix of the array aa starting from the position xx can be packed in boxes. It is easy to see that if we can do it for some xx then we always can do it for x+1x+1. And to find the answer for the fixed xx we have to simulate the process described in the problem statement starting from the position xx. Okay, this is O(nlogn)O(nlog⁡n) solution.The second solution is more interesting than the first one. The approach is to reverse the initial array, simulate the process from the first position of reversed array and then all the objects we can pack are in the best answer and there is no better answer at all.Why it works?Let's take a look on the last box in the best answer if we will go from left to right in the initial array. Let objects in this box be alst1,alst2,…,alstxalst1,alst2,…,alstx. What do we see? ∑i=1xalsti≤k∑i=1xalsti≤k. So all these objects are fit in the last box (obviously). Now if we will iterate over objects from right to left, these objects will fit also! It means that we cannot do worse by such a transform (reversing) at least for the last box.But what will happen if we can put some of the previous objects in this box? Well, it will not make worse for this box, but what about next boxes (previous boxes in straight notation)? Let objects in the penultimate box be a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}. What do we see? These objects are fit in this box (obviously again). What will happen if we will put in the last box one or more objects of this box? Then the left border of objects which we will put in it will not increase because we decrease the number of object in this box. So we can see that for previous boxes this condition is also satisfied.So we can solve the problem with this approach. Time complexity of this solution is O(n)O(n). Solution 1#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n int ans = n - pos + 1;\n int used = 0;\n while(used < m && pos <= n){\n int t = k;\n while(pos <= n && ar[pos] <= t){\n t -= ar[pos++];\n }\n used++;\n }\n return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n ios_base::sync_with_stdio(0);\n cin.tie(0);\n cout.tie(0);\n cin >> n >> m >> k;\n for(int i = 1; i <= n; i++){\n cin >> ar[i];\n }\n int ans = 0;\n int l = 1, r = n;\n while(l <= r){\n int x = (l + r) >> 1;\n if(find(x)){\n ans = max(ans, n - x + 1);\n r = x - 1;\n }else{\n l = x + 1;\n }\n }\n cout << ans << endl;\n} Solution 2#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn 0;\n}1066E - Binary Numbers AND Sum Tutorial1066E - Binary Numbers AND SumTo solve this problem let's take a look which powers of 22 in aa will be affected by powers of 22 in bb. Firstly, let's reverse numbers. Let's carry the current power of 22 (let it be pwpw), the current sum of powers of 22 in aa from the position 00 to the current position inclusive (let it be resres) and the answer is ansans. Initially, pw=1pw=1, res=0res=0 and ans=0ans=0. Let's iterate over all bits of bb from 00 to m−1m−1. Let the current bit in bb have the number ii. Firstly, if i<ni<n and ai=1ai=1 then set res:=res+pwres:=res+pw (in other words, we add to the sum of powers of 22 in aa the current power of 22). If bi=1bi=1 then this bit will add to the answer all the powers of 22 in aa from 00 to ii inclusive (in other words, resres), so if it is, then set ans:=ans+resans:=ans+res. And after all we can set pw:=pw+pwpw:=pw+pw and go on to i+1i+1. And don't forget to take all values modulo 998244353998244353 to avoid overflow. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}1066F - Yet another 2D Walking Tutorial1066F - Yet another 2D WalkingThe main idea is that we don't need more than 22 border points on each level. So if we consider than the point p=(xp,yp)p=(xp,yp) is less than point q=(xq,yq)q=(xq,yq) when px<qxpx<qx or px=qxpx=qx and py>qypy>qy then let's distribute all the points by their levels using std::map or something like it, sort points on each level by the comparator above and remain the first one and the last one on each level. Also let's add the fictive level 00 with the point (0,0)(0,0). It is always true to remain at most 22 points and can be easily proved but this fact is very intuitive I think. Now let's do dynamic programming on the points. dpi,jdpi,j means that now we are at the level ii and stay in the first point (if j=0j=0) or in the last point (if j=1j=1) and we are already visit all the points on the level ii. The value of this dynamic programming is the minimum possible total distance to reach this state. Initially, dp0,0=dp0,1=0dp0,0=dp0,1=0, other values are equal to ∞∞. Let's calculate this dynamic programming in order of increasing levels. Let plvl,0plvl,0 be the first key point at the level lvllvl and plvl,1plvl,1 be the last key point at the level lvllvl. Now if we are at the level lvllvl and the previous level is plvlplvl, these 44 transitions are sufficient to calculate states of dynamic programming on the current level: dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0); dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0); dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1); dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1). There dist(p,q)dist(p,q) means the distance between points pp and qq.Let last level we have be lstlst. After calculating this dynamic programming the answer is min(dplst,0,dplst,1)min(dplst,0,dplst,1). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\n\t\tprv = it.first;\n\t}\n\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\n\treturn 0;\n}",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/62419",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1066\\s*A"
          },
          "content_length": 13887
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 5",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 17",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 18",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 19",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 20",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 21",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 22",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; i++) {\n        long long L_i = inf.readLong(1LL, 1000000000LL, \"L_i\");\n        inf.readSpace();\n        long long v_i = inf.readLong(1LL, 1000000000LL, \"v_i\");\n        inf.readSpace();\n        long long l_i = inf.readLong(1LL, L_i, \"l_i\");\n        inf.readSpace();\n        long long r_i = inf.readLong(l_i, L_i, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; i++) {\n        long long L_i = inf.readLong(1LL, 1000000000LL, \"L_i\");\n        inf.readSpace();\n        long long v_i = inf.readLong(1LL, 1000000000LL, \"v_i\");\n        inf.readSpace();\n        long long l_i = inf.readLong(1LL, L_i, \"l_i\");\n        inf.readSpace();\n        long long r_i = inf.readLong(l_i, L_i, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; i++) {\n        long long L_i = inf.readLong(1LL, 1000000000LL, \"L_i\");\n        inf.readSpace();\n        long long v_i = inf.readLong(1LL, 1000000000LL, \"v_i\");\n        inf.readSpace();\n        long long l_i = inf.readLong(1LL, L_i, \"l_i\");\n        inf.readSpace();\n        long long r_i = inf.readLong(l_i, L_i, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n    long long Lmax = opt<long long>(\"Lmax\", 1000000000LL);\n    long long vmax = opt<long long>(\"vmax\", 1000000000LL);\n\n    // Output t\n    printf(\"%d\\n\", t);\n\n    for(int i = 0; i < t; i++) {\n        long long L_i, v_i, l_i, r_i;\n\n        if (type == \"random_small\") {\n            L_i = rnd.next(1LL, min(Lmax, 100LL));\n            v_i = rnd.next(1LL, min(L_i, 100LL));\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        } else if (type == \"random_large\") {\n            L_i = rnd.next(Lmax / 2, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        } else if (type == \"random\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        } else if (type == \"no_lanterns\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = L_i + rnd.next(1LL, 100000LL); // v_i > L_i, so no lanterns\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        } else if (type == \"all_lanterns_blocked\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            l_i = 1;\n            r_i = L_i; // Standing train covers the entire path\n        } else if (type == \"edge_case1\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = L_i; // v_i equals L_i\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        } else if (type == \"edge_case2\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            l_i = rnd.next(1LL, L_i);\n            r_i = l_i; // l_i equals r_i\n        } else if (type == \"all_lanterns\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            // Ensure the standing train doesn't cover any lantern positions\n            l_i = rnd.next(1LL, L_i);\n            r_i = l_i;\n            if (l_i % v_i == 0) {\n                l_i = (l_i == L_i) ? l_i - 1 : l_i + 1;\n                r_i = l_i;\n            }\n        } else if (type == \"max\") {\n            L_i = Lmax;\n            v_i = min(L_i, vmax);\n            l_i = rnd.next(1LL, L_i);\n            r_i = L_i;\n        } else {\n            // Default random\n            L_i = rnd.next(1LL, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        }\n\n        // Ensure that l_i ≤ r_i ≤ L_i and 1 ≤ l_i ≤ L_i\n        l_i = max(1LL, min(l_i, L_i));\n        r_i = max(l_i, min(r_i, L_i));\n\n        printf(\"%lld %lld %lld %lld\\n\", L_i, v_i, l_i, r_i);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n    long long Lmax = opt<long long>(\"Lmax\", 1000000000LL);\n    long long vmax = opt<long long>(\"vmax\", 1000000000LL);\n\n    // Output t\n    printf(\"%d\\n\", t);\n\n    for(int i = 0; i < t; i++) {\n        long long L_i, v_i, l_i, r_i;\n\n        if (type == \"random_small\") {\n            L_i = rnd.next(1LL, min(Lmax, 100LL));\n            v_i = rnd.next(1LL, min(L_i, 100LL));\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        } else if (type == \"random_large\") {\n            L_i = rnd.next(Lmax / 2, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        } else if (type == \"random\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        } else if (type == \"no_lanterns\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = L_i + rnd.next(1LL, 100000LL); // v_i > L_i, so no lanterns\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        } else if (type == \"all_lanterns_blocked\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            l_i = 1;\n            r_i = L_i; // Standing train covers the entire path\n        } else if (type == \"edge_case1\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = L_i; // v_i equals L_i\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        } else if (type == \"edge_case2\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            l_i = rnd.next(1LL, L_i);\n            r_i = l_i; // l_i equals r_i\n        } else if (type == \"all_lanterns\") {\n            L_i = rnd.next(1LL, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            // Ensure the standing train doesn't cover any lantern positions\n            l_i = rnd.next(1LL, L_i);\n            r_i = l_i;\n            if (l_i % v_i == 0) {\n                l_i = (l_i == L_i) ? l_i - 1 : l_i + 1;\n                r_i = l_i;\n            }\n        } else if (type == \"max\") {\n            L_i = Lmax;\n            v_i = min(L_i, vmax);\n            l_i = rnd.next(1LL, L_i);\n            r_i = L_i;\n        } else {\n            // Default random\n            L_i = rnd.next(1LL, Lmax);\n            v_i = rnd.next(1LL, min(L_i, vmax));\n            l_i = rnd.next(1LL, L_i);\n            r_i = rnd.next(l_i, L_i);\n        }\n\n        // Ensure that l_i ≤ r_i ≤ L_i and 1 ≤ l_i ≤ L_i\n        l_i = max(1LL, min(l_i, L_i));\n        r_i = max(l_i, min(r_i, L_i));\n\n        printf(\"%lld %lld %lld %lld\\n\", L_i, v_i, l_i, r_i);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Generate random small test cases\n./gen -t 10 -type random_small\n\n# Generate random large test cases\n./gen -t 10000 -type random_large\n\n# Generate random test cases\n./gen -t 10000 -type random\n\n# Generate test cases with no lanterns\n./gen -t 10 -type no_lanterns\n\n# Generate test cases where all lanterns are blocked by the standing train\n./gen -t 10 -type all_lanterns_blocked\n\n# Generate edge cases where L_i equals v_i\n./gen -t 10 -type edge_case1\n\n# Generate edge cases where l_i equals r_i\n./gen -t 10 -type edge_case2\n\n# Generate test cases where all lanterns are visible\n./gen -t 10 -type all_lanterns\n\n# Generate maximal test cases\n./gen -t 10000 -type max -Lmax 1000000000 -vmax 1000000000\n\n# Generate more random test cases\n./gen -t 5000 -type random\n./gen -t 5000 -type random\n\n# Generate custom small test cases with specific Lmax and vmax\n./gen -t 1000 -type random_small -Lmax 1000 -vmax 1000\n\n# Generate custom large test cases with specific Lmax and vmax\n./gen -t 1000 -type random_large -Lmax 1000000 -vmax 1000000\n\n# Generate random test cases with small v_i\n./gen -t 1000 -type random -Lmax 1000000 -vmax 100\n\n# Generate random test cases with large v_i\n./gen -t 1000 -type random -Lmax 1000000 -vmax 1000000\n\n# Generate test cases where v_i divides L_i\n./gen -t 10 -type edge_case1 -Lmax 1000000000\n\n# Generate test cases where l_i equals r_i\n./gen -t 10 -type edge_case2 -Lmax 1000000000\n\n# Generate test cases where the standing train covers the entire path\n./gen -t 10 -type all_lanterns_blocked\n\n# Generate test cases where the standing train does not cover any lantern positions\n./gen -t 10 -type all_lanterns\n\n# Generate maximal t with random data\n./gen -t 10000 -type random\n\n# Generate maximal t with maximal L_i and v_i\n./gen -t 10000 -type max -Lmax 1000000000 -vmax 1000000000\n\n# Generate random small t with small L_i and v_i\n./gen -t 100 -type random_small\n\n# Generate random t with mixed types\n./gen -t 1000 -type random\n./gen -t 2000 -type random_small\n./gen -t 2000 -type random_large\n./gen -t 3000 -type random\n./gen -t 2000 -type no_lanterns\n./gen -t 2000 -type all_lanterns_blocked\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:28.469446",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1066/B",
      "title": "B. Heaters",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers nn and rr (1≤n,r≤10001≤n,r≤1000) — the number of elements in the array and the value of heaters.The second line contains nn integers a1,a2,…,ana1,a2,…,an (0≤ai≤10≤ai≤1) — the Vova's house description.",
      "output_spec": "OutputPrint one integer — the minimum number of heaters needed to warm up the whole house or -1 if it is impossible to do it.",
      "sample_tests": "ExamplesInputCopy6 20 1 1 0 0 1OutputCopy3InputCopy5 31 0 0 0 1OutputCopy2InputCopy5 100 0 0 0 0OutputCopy-1InputCopy10 30 0 1 1 0 1 0 0 0 1OutputCopy3",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers nn and rr (1≤n,r≤10001≤n,r≤1000) — the number of elements in the array and the value of heaters.The second line contains nn integers a1,a2,…,ana1,a2,…,an (0≤ai≤10≤ai≤1) — the Vova's house description.\n\nOutputPrint one integer — the minimum number of heaters needed to warm up the whole house or -1 if it is impossible to do it.\n\nInputCopy6 20 1 1 0 0 1OutputCopy3InputCopy5 31 0 0 0 1OutputCopy2InputCopy5 100 0 0 0 0OutputCopy-1InputCopy10 30 0 1 1 0 1 0 0 0 1OutputCopy3\n\nInputCopy6 20 1 1 0 0 1\n\nOutputCopy3\n\nInputCopy5 31 0 0 0 1\n\nOutputCopy2\n\nInputCopy5 100 0 0 0 0\n\nOutputCopy-1\n\nInputCopy10 30 0 1 1 0 1 0 0 0 1\n\nOutputCopy3\n\nNoteIn the first example the heater at the position 22 warms up elements [1;3][1;3], the heater at the position 33 warms up elements [2,4][2,4] and the heater at the position 66 warms up elements [5;6][5;6] so the answer is 33.In the second example the heater at the position 11 warms up elements [1;3][1;3] and the heater at the position 55 warms up elements [3;5][3;5] so the answer is 22.In the third example there are no heaters so the answer is -1.In the fourth example the heater at the position 33 warms up elements [1;5][1;5], the heater at the position 66 warms up elements [4;8][4;8] and the heater at the position 1010 warms up elements [8;10][8;10] so the answer is 33.",
      "solutions": [
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces",
          "content": "1066A - Vova and Train Tutorial1066A - Vova and TrainWhat is the number of lanterns Vova will see from 11 to LL? This number is ⌊Lv⌋⌊Lv⌋. Now we have to subtract the number of lanters in range [l;r][l;r] from this number. This number equals to ⌊rv⌋−⌊l−1v⌋⌊rv⌋−⌊l−1v⌋. So the answer is ⌊Lv⌋⌊Lv⌋ - ⌊rv⌋⌊rv⌋ + ⌊l−1v⌋⌊l−1v⌋. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint t;\n\tcin >> t;\n\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\n\treturn 0;\n}1066B - Heaters Tutorial1066B - HeatersLet's solve this problem greedily. Let lastlast be the last position from the left covered by at least one heater. Initially, lastlast equals -1. While last<n−1last<n−1, lets repeat the following process: firstly, we have to find the rightmost heater in range (max(−1,last−r+1);last+r](max(−1,last−r+1);last+r]. It can be done in time O(n)O(n) because of given constrains or in O(1)O(1) using precalculated prefix values for each ii in range [0;n−1][0;n−1]. If there is no such heater then the answer is -1, otherwise let's set last:=pos+r−1last:=pos+r−1, increase the answer by 11 and repeat the process if last<n−1last<n−1.There is another one solution to this problem. Assume that the initial answer equals to the total number of heaters. Let's calculate an array cntcnt of length nn, where cnticnti means the number of heaters covering the ii-th element. It can be done in O(n2)O(n2). This array will mean that we are switch all the heaters on and we know for each element the number of heaters covers this element. Now if for at least i∈[0,n−1]i∈[0,n−1] holds cnti=0cnti=0 then the answer is -1. Otherwise let's switch useless heaters off. Let's iterate over all heaters from left to right. Let the current heater have position ii. We need to check if it is useless or not. Let's iterate in range [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)] and check if there is at least one element jj in this segment such that cntj=1cntj=1. If there is then the current heater is not useless and we cannot switch it off. Otherwise we can decrease the answer by 11, switch this heater off (decrease cntjcntj for all jj in range [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)]) and continue the process. Solution 1#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n} Solution 2#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n {\n cin >> a[i];\n if (a[i])ans++;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]++;\n }\n forn(i, n)\n if (!cnt[i])\n {\n cout << -1;\n return 0;\n }\n forn(i, n)\n {\n bool fl = true;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n if (cnt[j] == 1)\n {\n fl = false;\n break;\n }\n if (fl && a[i])\n {\n ans--;\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]--;\n }\n }\n cout << ans;\n\n}1066C - Books Queries Tutorial1066C - Books QueriesLet imagine our shelf as an infinite array. Let's carry the rightmost free position from the left of our shelf (let it be ll and initially it equals to 00) and the leftmost free position from the right of our shelf (let it be rr and initially it equals to 00). Also let's carry the array pospos of length 2⋅1052⋅105 where posiposi will be equal to the position in our imaginary array of the book with a number ii.Let's put the first book to the position 00. Also let's save that posidposid (where idid is the number of the first book) equals to 00. How will change ll and rr? ll will become −1−1 and rr will become 11. Now let's process queries one by one. If now we have the query of type 11 with a book with a number idid, then let's set posid:=lposid:=l and set l:=l−1l:=l−1. The query of type 22 can be processed similarly. Now what about queries of type 33? The answer to this query equals to min(|posid−l|,|posid−r|)−1min(|posid−l|,|posid−r|)−1, where |v||v| is the absolute value of vv. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint q;\n\tcin >> q;\n\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}1066D - Boxes Packing Tutorial1066D - Boxes PackingThe first solution is some kind of a straight-forward understanding the problem. Let's do binary search on the answer. So our problem is to find the smallest xx such that the suffix of the array aa starting from the position xx can be packed in boxes. It is easy to see that if we can do it for some xx then we always can do it for x+1x+1. And to find the answer for the fixed xx we have to simulate the process described in the problem statement starting from the position xx. Okay, this is O(nlogn)O(nlog⁡n) solution.The second solution is more interesting than the first one. The approach is to reverse the initial array, simulate the process from the first position of reversed array and then all the objects we can pack are in the best answer and there is no better answer at all.Why it works?Let's take a look on the last box in the best answer if we will go from left to right in the initial array. Let objects in this box be alst1,alst2,…,alstxalst1,alst2,…,alstx. What do we see? ∑i=1xalsti≤k∑i=1xalsti≤k. So all these objects are fit in the last box (obviously). Now if we will iterate over objects from right to left, these objects will fit also! It means that we cannot do worse by such a transform (reversing) at least for the last box.But what will happen if we can put some of the previous objects in this box? Well, it will not make worse for this box, but what about next boxes (previous boxes in straight notation)? Let objects in the penultimate box be a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}. What do we see? These objects are fit in this box (obviously again). What will happen if we will put in the last box one or more objects of this box? Then the left border of objects which we will put in it will not increase because we decrease the number of object in this box. So we can see that for previous boxes this condition is also satisfied.So we can solve the problem with this approach. Time complexity of this solution is O(n)O(n). Solution 1#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n int ans = n - pos + 1;\n int used = 0;\n while(used < m && pos <= n){\n int t = k;\n while(pos <= n && ar[pos] <= t){\n t -= ar[pos++];\n }\n used++;\n }\n return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n ios_base::sync_with_stdio(0);\n cin.tie(0);\n cout.tie(0);\n cin >> n >> m >> k;\n for(int i = 1; i <= n; i++){\n cin >> ar[i];\n }\n int ans = 0;\n int l = 1, r = n;\n while(l <= r){\n int x = (l + r) >> 1;\n if(find(x)){\n ans = max(ans, n - x + 1);\n r = x - 1;\n }else{\n l = x + 1;\n }\n }\n cout << ans << endl;\n} Solution 2#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn 0;\n}1066E - Binary Numbers AND Sum Tutorial1066E - Binary Numbers AND SumTo solve this problem let's take a look which powers of 22 in aa will be affected by powers of 22 in bb. Firstly, let's reverse numbers. Let's carry the current power of 22 (let it be pwpw), the current sum of powers of 22 in aa from the position 00 to the current position inclusive (let it be resres) and the answer is ansans. Initially, pw=1pw=1, res=0res=0 and ans=0ans=0. Let's iterate over all bits of bb from 00 to m−1m−1. Let the current bit in bb have the number ii. Firstly, if i<ni<n and ai=1ai=1 then set res:=res+pwres:=res+pw (in other words, we add to the sum of powers of 22 in aa the current power of 22). If bi=1bi=1 then this bit will add to the answer all the powers of 22 in aa from 00 to ii inclusive (in other words, resres), so if it is, then set ans:=ans+resans:=ans+res. And after all we can set pw:=pw+pwpw:=pw+pw and go on to i+1i+1. And don't forget to take all values modulo 998244353998244353 to avoid overflow. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}1066F - Yet another 2D Walking Tutorial1066F - Yet another 2D WalkingThe main idea is that we don't need more than 22 border points on each level. So if we consider than the point p=(xp,yp)p=(xp,yp) is less than point q=(xq,yq)q=(xq,yq) when px<qxpx<qx or px=qxpx=qx and py>qypy>qy then let's distribute all the points by their levels using std::map or something like it, sort points on each level by the comparator above and remain the first one and the last one on each level. Also let's add the fictive level 00 with the point (0,0)(0,0). It is always true to remain at most 22 points and can be easily proved but this fact is very intuitive I think. Now let's do dynamic programming on the points. dpi,jdpi,j means that now we are at the level ii and stay in the first point (if j=0j=0) or in the last point (if j=1j=1) and we are already visit all the points on the level ii. The value of this dynamic programming is the minimum possible total distance to reach this state. Initially, dp0,0=dp0,1=0dp0,0=dp0,1=0, other values are equal to ∞∞. Let's calculate this dynamic programming in order of increasing levels. Let plvl,0plvl,0 be the first key point at the level lvllvl and plvl,1plvl,1 be the last key point at the level lvllvl. Now if we are at the level lvllvl and the previous level is plvlplvl, these 44 transitions are sufficient to calculate states of dynamic programming on the current level: dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0); dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0); dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1); dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1). There dist(p,q)dist(p,q) means the distance between points pp and qq.Let last level we have be lstlst. After calculating this dynamic programming the answer is min(dplst,0,dplst,1)min(dplst,0,dplst,1). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\n\t\tprv = it.first;\n\t}\n\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62419",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1066\\s*B"
          },
          "content_length": 13887
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 5",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 17",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 18",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 19",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 20",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 21",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 22",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000, \"r\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n, 0);\n\n    if (type == \"random\") {\n        // Randomly assign 0 or 1 to each position\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    } else if (type == \"no_solution\") {\n        // No heaters in the house\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"full_cover\") {\n        // Place heaters optimally to cover the house with minimal heaters\n        int pos = r - 1;\n        while (pos < n) {\n            a[pos] = 1;\n            pos += r * 2 - 1;\n        }\n    } else if (type == \"edge_case\") {\n        // Heaters at the edges of the house\n        a[0] = 1;\n        a[n - 1] = 1;\n        if (n > r) {\n            // Additional heater in the middle if needed\n            a[n / 2] = 1;\n        }\n    } else if (type == \"minimal_heaters\") {\n        // Minimal number of heaters to cover the house\n        int pos = 0;\n        while (pos < n) {\n            int heater_pos = min(pos + r - 1, n - 1);\n            a[heater_pos] = 1;\n            pos = heater_pos + r;\n        }\n    } else if (type == \"maximal_heaters\") {\n        // Place heaters at every possible position (dense placement)\n        for (int i = 0; i < n; ++i) {\n            if (i % r == 0) {\n                a[i] = 1;\n            }\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    }\n\n    // Output n and r\n    printf(\"%d %d\\n\", n, r);\n    // Output the array a_i\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n, 0);\n\n    if (type == \"random\") {\n        // Randomly assign 0 or 1 to each position\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    } else if (type == \"no_solution\") {\n        // No heaters in the house\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"full_cover\") {\n        // Place heaters optimally to cover the house with minimal heaters\n        int pos = r - 1;\n        while (pos < n) {\n            a[pos] = 1;\n            pos += r * 2 - 1;\n        }\n    } else if (type == \"edge_case\") {\n        // Heaters at the edges of the house\n        a[0] = 1;\n        a[n - 1] = 1;\n        if (n > r) {\n            // Additional heater in the middle if needed\n            a[n / 2] = 1;\n        }\n    } else if (type == \"minimal_heaters\") {\n        // Minimal number of heaters to cover the house\n        int pos = 0;\n        while (pos < n) {\n            int heater_pos = min(pos + r - 1, n - 1);\n            a[heater_pos] = 1;\n            pos = heater_pos + r;\n        }\n    } else if (type == \"maximal_heaters\") {\n        // Place heaters at every possible position (dense placement)\n        for (int i = 0; i < n; ++i) {\n            if (i % r == 0) {\n                a[i] = 1;\n            }\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    }\n\n    // Output n and r\n    printf(\"%d %d\\n\", n, r);\n    // Output the array a_i\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -r 1 -type no_solution\n./gen -n 1 -r 1 -type random\n\n./gen -n 10 -r 1 -type minimal_heaters\n./gen -n 10 -r 1 -type full_cover\n./gen -n 10 -r 1 -type edge_case\n./gen -n 10 -r 1 -type random\n\n./gen -n 10 -r 1 -type no_solution\n./gen -n 10 -r 2 -type minimal_heaters\n./gen -n 10 -r 2 -type maximal_heaters\n./gen -n 10 -r 2 -type full_cover\n./gen -n 10 -r 2 -type edge_case\n./gen -n 10 -r 2 -type random\n\n./gen -n 100 -r 5 -type minimal_heaters\n./gen -n 100 -r 5 -type maximal_heaters\n./gen -n 100 -r 5 -type full_cover\n./gen -n 100 -r 5 -type edge_case\n./gen -n 100 -r 5 -type random\n\n./gen -n 100 -r 5 -type no_solution\n./gen -n 100 -r 50 -type minimal_heaters\n./gen -n 100 -r 50 -type maximal_heaters\n./gen -n 100 -r 50 -type full_cover\n./gen -n 100 -r 50 -type random\n\n./gen -n 1000 -r 1 -type minimal_heaters\n./gen -n 1000 -r 1 -type maximal_heaters\n./gen -n 1000 -r 1 -type edge_case\n./gen -n 1000 -r 1 -type random\n\n./gen -n 1000 -r 1 -type no_solution\n./gen -n 1000 -r 1000 -type minimal_heaters\n./gen -n 1000 -r 1000 -type maximal_heaters\n./gen -n 1000 -r 1000 -type random\n./gen -n 1000 -r 1000 -type no_solution\n\n./gen -n 999 -r 500 -type minimal_heaters\n./gen -n 999 -r 500 -type full_cover\n./gen -n 999 -r 500 -type edge_case\n./gen -n 999 -r 500 -type random\n\n./gen -n 1000 -r 2 -type random\n./gen -n 1000 -r 10 -type random\n./gen -n 1000 -r 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:30.244936",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1066/C",
      "title": "C. Books Queries",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains one integer qq (1≤q≤2⋅1051≤q≤2⋅105) — the number of queries.Then qq lines follow. The ii-th line contains the ii-th query in format as in the problem statement. It is guaranteed that queries are always valid (for query type 33, it is guaranteed that the book in each such query is already placed, and for other types, it is guaranteed that the book was not placed before).It is guaranteed that there is at least one query of type 33 in the input.In each query the constraint 1≤id≤2⋅1051≤id≤2⋅105 is met.",
      "output_spec": "OutputPrint answers to queries of the type 33 in order they appear in the input.",
      "sample_tests": "ExamplesInputCopy8L 1R 2R 3? 2L 4? 1L 5? 1OutputCopy112InputCopy10L 100R 100000R 123L 101? 123L 10R 115? 100R 110? 115OutputCopy021",
      "description": "C. Books Queries\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains one integer qq (1≤q≤2⋅1051≤q≤2⋅105) — the number of queries.Then qq lines follow. The ii-th line contains the ii-th query in format as in the problem statement. It is guaranteed that queries are always valid (for query type 33, it is guaranteed that the book in each such query is already placed, and for other types, it is guaranteed that the book was not placed before).It is guaranteed that there is at least one query of type 33 in the input.In each query the constraint 1≤id≤2⋅1051≤id≤2⋅105 is met.\n\nOutputPrint answers to queries of the type 33 in order they appear in the input.\n\nInputCopy8L 1R 2R 3? 2L 4? 1L 5? 1OutputCopy112InputCopy10L 100R 100000R 123L 101? 123L 10R 115? 100R 110? 115OutputCopy021\n\nInputCopy8L 1R 2R 3? 2L 4? 1L 5? 1\n\nOutputCopy112\n\nInputCopy10L 100R 100000R 123L 101? 123L 10R 115? 100R 110? 115\n\nOutputCopy021\n\nNoteLet's take a look at the first example and let's consider queries:   The shelf will look like [1][1];  The shelf will look like [1,2][1,2];  The shelf will look like [1,2,3][1,2,3];  The shelf looks like [1,2,3][1,2,3] so the answer is 11;  The shelf will look like [4,1,2,3][4,1,2,3];  The shelf looks like [4,1,2,3][4,1,2,3] so the answer is 11;  The shelf will look like [5,4,1,2,3][5,4,1,2,3];  The shelf looks like [5,4,1,2,3][5,4,1,2,3] so the answer is 22. Let's take a look at the second example and let's consider queries:   The shelf will look like [100][100];  The shelf will look like [100,100000][100,100000];  The shelf will look like [100,100000,123][100,100000,123];  The shelf will look like [101,100,100000,123][101,100,100000,123];  The shelf looks like [101,100,100000,123][101,100,100000,123] so the answer is 00;  The shelf will look like [10,101,100,100000,123][10,101,100,100000,123];  The shelf will look like [10,101,100,100000,123,115][10,101,100,100000,123,115];  The shelf looks like [10,101,100,100000,123,115][10,101,100,100000,123,115] so the answer is 22;  The shelf will look like [10,101,100,100000,123,115,110][10,101,100,100000,123,115,110];  The shelf looks like [10,101,100,100000,123,115,110][10,101,100,100000,123,115,110] so the answer is 11.",
      "solutions": [
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces",
          "content": "1066A - Vova and Train Tutorial1066A - Vova and TrainWhat is the number of lanterns Vova will see from 11 to LL? This number is ⌊Lv⌋⌊Lv⌋. Now we have to subtract the number of lanters in range [l;r][l;r] from this number. This number equals to ⌊rv⌋−⌊l−1v⌋⌊rv⌋−⌊l−1v⌋. So the answer is ⌊Lv⌋⌊Lv⌋ - ⌊rv⌋⌊rv⌋ + ⌊l−1v⌋⌊l−1v⌋. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint t;\n\tcin >> t;\n\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\n\treturn 0;\n}1066B - Heaters Tutorial1066B - HeatersLet's solve this problem greedily. Let lastlast be the last position from the left covered by at least one heater. Initially, lastlast equals -1. While last<n−1last<n−1, lets repeat the following process: firstly, we have to find the rightmost heater in range (max(−1,last−r+1);last+r](max(−1,last−r+1);last+r]. It can be done in time O(n)O(n) because of given constrains or in O(1)O(1) using precalculated prefix values for each ii in range [0;n−1][0;n−1]. If there is no such heater then the answer is -1, otherwise let's set last:=pos+r−1last:=pos+r−1, increase the answer by 11 and repeat the process if last<n−1last<n−1.There is another one solution to this problem. Assume that the initial answer equals to the total number of heaters. Let's calculate an array cntcnt of length nn, where cnticnti means the number of heaters covering the ii-th element. It can be done in O(n2)O(n2). This array will mean that we are switch all the heaters on and we know for each element the number of heaters covers this element. Now if for at least i∈[0,n−1]i∈[0,n−1] holds cnti=0cnti=0 then the answer is -1. Otherwise let's switch useless heaters off. Let's iterate over all heaters from left to right. Let the current heater have position ii. We need to check if it is useless or not. Let's iterate in range [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)] and check if there is at least one element jj in this segment such that cntj=1cntj=1. If there is then the current heater is not useless and we cannot switch it off. Otherwise we can decrease the answer by 11, switch this heater off (decrease cntjcntj for all jj in range [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)]) and continue the process. Solution 1#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n} Solution 2#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n {\n cin >> a[i];\n if (a[i])ans++;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]++;\n }\n forn(i, n)\n if (!cnt[i])\n {\n cout << -1;\n return 0;\n }\n forn(i, n)\n {\n bool fl = true;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n if (cnt[j] == 1)\n {\n fl = false;\n break;\n }\n if (fl && a[i])\n {\n ans--;\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]--;\n }\n }\n cout << ans;\n\n}1066C - Books Queries Tutorial1066C - Books QueriesLet imagine our shelf as an infinite array. Let's carry the rightmost free position from the left of our shelf (let it be ll and initially it equals to 00) and the leftmost free position from the right of our shelf (let it be rr and initially it equals to 00). Also let's carry the array pospos of length 2⋅1052⋅105 where posiposi will be equal to the position in our imaginary array of the book with a number ii.Let's put the first book to the position 00. Also let's save that posidposid (where idid is the number of the first book) equals to 00. How will change ll and rr? ll will become −1−1 and rr will become 11. Now let's process queries one by one. If now we have the query of type 11 with a book with a number idid, then let's set posid:=lposid:=l and set l:=l−1l:=l−1. The query of type 22 can be processed similarly. Now what about queries of type 33? The answer to this query equals to min(|posid−l|,|posid−r|)−1min(|posid−l|,|posid−r|)−1, where |v||v| is the absolute value of vv. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint q;\n\tcin >> q;\n\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}1066D - Boxes Packing Tutorial1066D - Boxes PackingThe first solution is some kind of a straight-forward understanding the problem. Let's do binary search on the answer. So our problem is to find the smallest xx such that the suffix of the array aa starting from the position xx can be packed in boxes. It is easy to see that if we can do it for some xx then we always can do it for x+1x+1. And to find the answer for the fixed xx we have to simulate the process described in the problem statement starting from the position xx. Okay, this is O(nlogn)O(nlog⁡n) solution.The second solution is more interesting than the first one. The approach is to reverse the initial array, simulate the process from the first position of reversed array and then all the objects we can pack are in the best answer and there is no better answer at all.Why it works?Let's take a look on the last box in the best answer if we will go from left to right in the initial array. Let objects in this box be alst1,alst2,…,alstxalst1,alst2,…,alstx. What do we see? ∑i=1xalsti≤k∑i=1xalsti≤k. So all these objects are fit in the last box (obviously). Now if we will iterate over objects from right to left, these objects will fit also! It means that we cannot do worse by such a transform (reversing) at least for the last box.But what will happen if we can put some of the previous objects in this box? Well, it will not make worse for this box, but what about next boxes (previous boxes in straight notation)? Let objects in the penultimate box be a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}. What do we see? These objects are fit in this box (obviously again). What will happen if we will put in the last box one or more objects of this box? Then the left border of objects which we will put in it will not increase because we decrease the number of object in this box. So we can see that for previous boxes this condition is also satisfied.So we can solve the problem with this approach. Time complexity of this solution is O(n)O(n). Solution 1#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n int ans = n - pos + 1;\n int used = 0;\n while(used < m && pos <= n){\n int t = k;\n while(pos <= n && ar[pos] <= t){\n t -= ar[pos++];\n }\n used++;\n }\n return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n ios_base::sync_with_stdio(0);\n cin.tie(0);\n cout.tie(0);\n cin >> n >> m >> k;\n for(int i = 1; i <= n; i++){\n cin >> ar[i];\n }\n int ans = 0;\n int l = 1, r = n;\n while(l <= r){\n int x = (l + r) >> 1;\n if(find(x)){\n ans = max(ans, n - x + 1);\n r = x - 1;\n }else{\n l = x + 1;\n }\n }\n cout << ans << endl;\n} Solution 2#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn 0;\n}1066E - Binary Numbers AND Sum Tutorial1066E - Binary Numbers AND SumTo solve this problem let's take a look which powers of 22 in aa will be affected by powers of 22 in bb. Firstly, let's reverse numbers. Let's carry the current power of 22 (let it be pwpw), the current sum of powers of 22 in aa from the position 00 to the current position inclusive (let it be resres) and the answer is ansans. Initially, pw=1pw=1, res=0res=0 and ans=0ans=0. Let's iterate over all bits of bb from 00 to m−1m−1. Let the current bit in bb have the number ii. Firstly, if i<ni<n and ai=1ai=1 then set res:=res+pwres:=res+pw (in other words, we add to the sum of powers of 22 in aa the current power of 22). If bi=1bi=1 then this bit will add to the answer all the powers of 22 in aa from 00 to ii inclusive (in other words, resres), so if it is, then set ans:=ans+resans:=ans+res. And after all we can set pw:=pw+pwpw:=pw+pw and go on to i+1i+1. And don't forget to take all values modulo 998244353998244353 to avoid overflow. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}1066F - Yet another 2D Walking Tutorial1066F - Yet another 2D WalkingThe main idea is that we don't need more than 22 border points on each level. So if we consider than the point p=(xp,yp)p=(xp,yp) is less than point q=(xq,yq)q=(xq,yq) when px<qxpx<qx or px=qxpx=qx and py>qypy>qy then let's distribute all the points by their levels using std::map or something like it, sort points on each level by the comparator above and remain the first one and the last one on each level. Also let's add the fictive level 00 with the point (0,0)(0,0). It is always true to remain at most 22 points and can be easily proved but this fact is very intuitive I think. Now let's do dynamic programming on the points. dpi,jdpi,j means that now we are at the level ii and stay in the first point (if j=0j=0) or in the last point (if j=1j=1) and we are already visit all the points on the level ii. The value of this dynamic programming is the minimum possible total distance to reach this state. Initially, dp0,0=dp0,1=0dp0,0=dp0,1=0, other values are equal to ∞∞. Let's calculate this dynamic programming in order of increasing levels. Let plvl,0plvl,0 be the first key point at the level lvllvl and plvl,1plvl,1 be the last key point at the level lvllvl. Now if we are at the level lvllvl and the previous level is plvlplvl, these 44 transitions are sufficient to calculate states of dynamic programming on the current level: dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0); dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0); dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1); dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1). There dist(p,q)dist(p,q) means the distance between points pp and qq.Let last level we have be lstlst. After calculating this dynamic programming the answer is min(dplst,0,dplst,1)min(dplst,0,dplst,1). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\n\t\tprv = it.first;\n\t}\n\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62419",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1066\\s*C"
          },
          "content_length": 13887
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 5",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 17",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 18",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 19",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 20",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 21",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 22",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int q = inf.readInt(1, 2 * 100000, \"q\");\n    inf.readEoln();\n\n    set<int> placed_ids;\n    int query_count = 0;\n\n    for (int i = 0; i < q; ++i) {\n        string op = inf.readToken();\n        ensuref(op == \"L\" || op == \"R\" || op == \"?\", \"Invalid query type '%s' on line %d.\", op.c_str(), i + 2);\n\n        inf.readSpace();\n        int id = inf.readInt(1, 2 * 100000, \"id\");\n        inf.readEoln();\n\n        if (op == \"L\" || op == \"R\") {\n            ensuref(placed_ids.find(id) == placed_ids.end(), \"Book %d is already placed before.\", id);\n            placed_ids.insert(id);\n        } else if (op == \"?\") {\n            ensuref(placed_ids.find(id) != placed_ids.end(), \"Book %d hasn't been placed yet.\", id);\n            query_count++;\n        }\n    }\n\n    ensuref(query_count >= 1, \"There is no query of type '?' in the input.\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int q = inf.readInt(1, 2 * 100000, \"q\");\n    inf.readEoln();\n\n    set<int> placed_ids;\n    int query_count = 0;\n\n    for (int i = 0; i < q; ++i) {\n        string op = inf.readToken();\n        ensuref(op == \"L\" || op == \"R\" || op == \"?\", \"Invalid query type '%s' on line %d.\", op.c_str(), i + 2);\n\n        inf.readSpace();\n        int id = inf.readInt(1, 2 * 100000, \"id\");\n        inf.readEoln();\n\n        if (op == \"L\" || op == \"R\") {\n            ensuref(placed_ids.find(id) == placed_ids.end(), \"Book %d is already placed before.\", id);\n            placed_ids.insert(id);\n        } else if (op == \"?\") {\n            ensuref(placed_ids.find(id) != placed_ids.end(), \"Book %d hasn't been placed yet.\", id);\n            query_count++;\n        }\n    }\n\n    ensuref(query_count >= 1, \"There is no query of type '?' in the input.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int q = inf.readInt(1, 2 * 100000, \"q\");\n    inf.readEoln();\n\n    set<int> placed_ids;\n    int query_count = 0;\n\n    for (int i = 0; i < q; ++i) {\n        string op = inf.readToken();\n        ensuref(op == \"L\" || op == \"R\" || op == \"?\", \"Invalid query type '%s' on line %d.\", op.c_str(), i + 2);\n\n        inf.readSpace();\n        int id = inf.readInt(1, 2 * 100000, \"id\");\n        inf.readEoln();\n\n        if (op == \"L\" || op == \"R\") {\n            ensuref(placed_ids.find(id) == placed_ids.end(), \"Book %d is already placed before.\", id);\n            placed_ids.insert(id);\n        } else if (op == \"?\") {\n            ensuref(placed_ids.find(id) != placed_ids.end(), \"Book %d hasn't been placed yet.\", id);\n            query_count++;\n        }\n    }\n\n    ensuref(query_count >= 1, \"There is no query of type '?' in the input.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int max_id = 200000;\n\n    vector<int> ids(max_id);\n    for (int i = 0; i < max_id; ++i)\n        ids[i] = i + 1;\n    // Shuffle ids\n    shuffle(ids.begin(), ids.end());\n    int id_index = 0;\n\n    set<int> placed_ids; // IDs that have been placed\n    vector<int> placed_ids_vector; // To get random placed ids\n\n    vector<string> queries;\n\n    if (type == \"all_left\") {\n        int query_interval = q / 10;\n        if (query_interval == 0) query_interval = 1;\n        int next_query_at = query_interval;\n\n        // First operation must be an add\n        for (int i = 0; i < q; ++i) {\n            if (i == next_query_at && !placed_ids.empty()) {\n                // Do a type 3 query\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                next_query_at += query_interval;\n            } else {\n                // Do an L id operation\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"L \" + to_string(id));\n            }\n        }\n    } else if (type == \"all_right\") {\n        int query_interval = q / 10;\n        if (query_interval == 0) query_interval = 1;\n        int next_query_at = query_interval;\n\n        // First operation must be an add\n        for (int i = 0; i < q; ++i) {\n            if (i == next_query_at && !placed_ids.empty()) {\n                // Do a type 3 query\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                next_query_at += query_interval;\n            } else {\n                // Do an R id operation\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"R \" + to_string(id));\n            }\n        }\n    } else if (type == \"alternating\") {\n        int query_interval = q / 10;\n        if (query_interval == 0) query_interval = 1;\n        int next_query_at = query_interval;\n\n        bool left = true;\n\n        for (int i = 0; i < q; ++i) {\n            if (i == next_query_at && !placed_ids.empty()) {\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                next_query_at += query_interval;\n            } else {\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                if (left) {\n                    queries.push_back(\"L \" + to_string(id));\n                    left = false;\n                } else {\n                    queries.push_back(\"R \" + to_string(id));\n                    left = true;\n                }\n            }\n        }\n    } else if (type == \"random\") {\n        // Randomly decide query types, ensuring constraints\n        // Make sure at least one query of type 3\n        int num_queries_type3 = 0;\n\n        for (int i = 0; i < q; ++i) {\n            // Determine possible query types\n            vector<int> possible_types;\n\n            if (id_index < max_id) {\n                // We can add new ids\n                possible_types.push_back(1); // L id\n                possible_types.push_back(2); // R id\n            }\n            if (!placed_ids.empty()) {\n                // We can query\n                possible_types.push_back(3); // ? id\n            }\n\n            if (possible_types.empty()) {\n                // No possible operations\n                break;\n            }\n\n            int query_type = possible_types[rnd.next(possible_types.size())];\n            if (i == q - 1 && num_queries_type3 == 0) {\n                // Ensure at least one query of type 3\n                query_type = 3;\n            }\n\n            if (query_type == 1) {\n                // L id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"L \" + to_string(id));\n            } else if (query_type == 2) {\n                // R id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"R \" + to_string(id));\n            } else if (query_type == 3) {\n                // ? id\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                num_queries_type3++;\n            }\n        }\n    } else if (type == \"few_queries\") {\n        // Mostly adding books, very few queries\n        int num_queries_type3 = 0;\n        int max_queries_type3 = max(1, q / 20); // 5% of total queries\n\n        for (int i = 0; i < q; ++i) {\n            // Decide query type\n            if (num_queries_type3 < max_queries_type3 && i % 20 == 0 && !placed_ids.empty()) {\n                // Do a query\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                num_queries_type3++;\n            } else if (rnd.next(2)) {\n                // L id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"L \" + to_string(id));\n            } else {\n                // R id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"R \" + to_string(id));\n            }\n        }\n    } else if (type == \"max_queries\") {\n        // Every query is a type 3 query\n        // First, we need to add at least one book\n        if (q < 2) {\n            // Cannot generate such test case\n            printf(\"1\\nL 1\\n\");\n            return 0;\n        }\n        int id = ids[id_index++];\n        placed_ids.insert(id);\n        placed_ids_vector.push_back(id);\n        queries.push_back(\"L \" + to_string(id));\n\n        for (int i = 1; i < q; ++i) {\n            // Do type 3 queries\n            int idx = rnd.next(placed_ids_vector.size());\n            int id = placed_ids_vector[idx];\n            queries.push_back(\"? \" + to_string(id));\n        }\n    } else if (type == \"edge_positions\") {\n        // Add books to left, then to right, then query for the leftmost and rightmost books\n        // Ensure that we query for books at the edges\n\n        // First add n books to left\n        int n = q / 4; // Number of books to add to left\n        if (n < 1) n = 1;\n        for (int i = 0; i < n; ++i) {\n            int id = ids[id_index++];\n            placed_ids.insert(id);\n            placed_ids_vector.push_back(id);\n            queries.push_back(\"L \" + to_string(id));\n        }\n\n        // Add n books to right\n        for (int i = 0; i < n; ++i) {\n            int id = ids[id_index++];\n            placed_ids.insert(id);\n            placed_ids_vector.push_back(id);\n            queries.push_back(\"R \" + to_string(id));\n        }\n\n        // Query for the leftmost and rightmost books\n        int id_left = placed_ids_vector[0]; // first id placed\n        int id_right = placed_ids_vector[placed_ids_vector.size() - 1]; // last id placed\n\n        queries.push_back(\"? \" + to_string(id_left));\n        queries.push_back(\"? \" + to_string(id_right));\n\n        // Fill the rest of queries\n        int remaining = q - queries.size();\n\n        for (int i = 0; i < remaining; ++i) {\n            int type_choice = rnd.next(3);\n            if (type_choice == 0 && id_index < max_id) {\n                // L id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"L \" + to_string(id));\n            } else if (type_choice == 1 && id_index < max_id) {\n                // R id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"R \" + to_string(id));\n            } else if (!placed_ids.empty()) {\n                // ? id\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n            } else {\n                // No more possible operations\n                break;\n            }\n        }\n    } else {\n        // Unknown type, default to \"random\"\n        // Copy code from \"random\" case\n        int num_queries_type3 = 0;\n\n        for (int i = 0; i < q; ++i) {\n            vector<int> possible_types;\n\n            if (id_index < max_id) {\n                possible_types.push_back(1);\n                possible_types.push_back(2);\n            }\n            if (!placed_ids.empty()) {\n                possible_types.push_back(3);\n            }\n\n            if (possible_types.empty()) {\n                break;\n            }\n\n            int query_type = possible_types[rnd.next(possible_types.size())];\n            if (i == q - 1 && num_queries_type3 == 0) {\n                query_type = 3;\n            }\n\n            if (query_type == 1) {\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"L \" + to_string(id));\n            } else if (query_type == 2) {\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"R \" + to_string(id));\n            } else if (query_type == 3) {\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                num_queries_type3++;\n            }\n        }\n    }\n\n    // Ensure we have exactly q queries\n    while ((int)queries.size() > q) {\n        queries.pop_back();\n    }\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    // Output queries\n    for (size_t i = 0; i < queries.size(); ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int max_id = 200000;\n\n    vector<int> ids(max_id);\n    for (int i = 0; i < max_id; ++i)\n        ids[i] = i + 1;\n    // Shuffle ids\n    shuffle(ids.begin(), ids.end());\n    int id_index = 0;\n\n    set<int> placed_ids; // IDs that have been placed\n    vector<int> placed_ids_vector; // To get random placed ids\n\n    vector<string> queries;\n\n    if (type == \"all_left\") {\n        int query_interval = q / 10;\n        if (query_interval == 0) query_interval = 1;\n        int next_query_at = query_interval;\n\n        // First operation must be an add\n        for (int i = 0; i < q; ++i) {\n            if (i == next_query_at && !placed_ids.empty()) {\n                // Do a type 3 query\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                next_query_at += query_interval;\n            } else {\n                // Do an L id operation\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"L \" + to_string(id));\n            }\n        }\n    } else if (type == \"all_right\") {\n        int query_interval = q / 10;\n        if (query_interval == 0) query_interval = 1;\n        int next_query_at = query_interval;\n\n        // First operation must be an add\n        for (int i = 0; i < q; ++i) {\n            if (i == next_query_at && !placed_ids.empty()) {\n                // Do a type 3 query\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                next_query_at += query_interval;\n            } else {\n                // Do an R id operation\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"R \" + to_string(id));\n            }\n        }\n    } else if (type == \"alternating\") {\n        int query_interval = q / 10;\n        if (query_interval == 0) query_interval = 1;\n        int next_query_at = query_interval;\n\n        bool left = true;\n\n        for (int i = 0; i < q; ++i) {\n            if (i == next_query_at && !placed_ids.empty()) {\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                next_query_at += query_interval;\n            } else {\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                if (left) {\n                    queries.push_back(\"L \" + to_string(id));\n                    left = false;\n                } else {\n                    queries.push_back(\"R \" + to_string(id));\n                    left = true;\n                }\n            }\n        }\n    } else if (type == \"random\") {\n        // Randomly decide query types, ensuring constraints\n        // Make sure at least one query of type 3\n        int num_queries_type3 = 0;\n\n        for (int i = 0; i < q; ++i) {\n            // Determine possible query types\n            vector<int> possible_types;\n\n            if (id_index < max_id) {\n                // We can add new ids\n                possible_types.push_back(1); // L id\n                possible_types.push_back(2); // R id\n            }\n            if (!placed_ids.empty()) {\n                // We can query\n                possible_types.push_back(3); // ? id\n            }\n\n            if (possible_types.empty()) {\n                // No possible operations\n                break;\n            }\n\n            int query_type = possible_types[rnd.next(possible_types.size())];\n            if (i == q - 1 && num_queries_type3 == 0) {\n                // Ensure at least one query of type 3\n                query_type = 3;\n            }\n\n            if (query_type == 1) {\n                // L id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"L \" + to_string(id));\n            } else if (query_type == 2) {\n                // R id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"R \" + to_string(id));\n            } else if (query_type == 3) {\n                // ? id\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                num_queries_type3++;\n            }\n        }\n    } else if (type == \"few_queries\") {\n        // Mostly adding books, very few queries\n        int num_queries_type3 = 0;\n        int max_queries_type3 = max(1, q / 20); // 5% of total queries\n\n        for (int i = 0; i < q; ++i) {\n            // Decide query type\n            if (num_queries_type3 < max_queries_type3 && i % 20 == 0 && !placed_ids.empty()) {\n                // Do a query\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                num_queries_type3++;\n            } else if (rnd.next(2)) {\n                // L id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"L \" + to_string(id));\n            } else {\n                // R id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"R \" + to_string(id));\n            }\n        }\n    } else if (type == \"max_queries\") {\n        // Every query is a type 3 query\n        // First, we need to add at least one book\n        if (q < 2) {\n            // Cannot generate such test case\n            printf(\"1\\nL 1\\n\");\n            return 0;\n        }\n        int id = ids[id_index++];\n        placed_ids.insert(id);\n        placed_ids_vector.push_back(id);\n        queries.push_back(\"L \" + to_string(id));\n\n        for (int i = 1; i < q; ++i) {\n            // Do type 3 queries\n            int idx = rnd.next(placed_ids_vector.size());\n            int id = placed_ids_vector[idx];\n            queries.push_back(\"? \" + to_string(id));\n        }\n    } else if (type == \"edge_positions\") {\n        // Add books to left, then to right, then query for the leftmost and rightmost books\n        // Ensure that we query for books at the edges\n\n        // First add n books to left\n        int n = q / 4; // Number of books to add to left\n        if (n < 1) n = 1;\n        for (int i = 0; i < n; ++i) {\n            int id = ids[id_index++];\n            placed_ids.insert(id);\n            placed_ids_vector.push_back(id);\n            queries.push_back(\"L \" + to_string(id));\n        }\n\n        // Add n books to right\n        for (int i = 0; i < n; ++i) {\n            int id = ids[id_index++];\n            placed_ids.insert(id);\n            placed_ids_vector.push_back(id);\n            queries.push_back(\"R \" + to_string(id));\n        }\n\n        // Query for the leftmost and rightmost books\n        int id_left = placed_ids_vector[0]; // first id placed\n        int id_right = placed_ids_vector[placed_ids_vector.size() - 1]; // last id placed\n\n        queries.push_back(\"? \" + to_string(id_left));\n        queries.push_back(\"? \" + to_string(id_right));\n\n        // Fill the rest of queries\n        int remaining = q - queries.size();\n\n        for (int i = 0; i < remaining; ++i) {\n            int type_choice = rnd.next(3);\n            if (type_choice == 0 && id_index < max_id) {\n                // L id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"L \" + to_string(id));\n            } else if (type_choice == 1 && id_index < max_id) {\n                // R id\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"R \" + to_string(id));\n            } else if (!placed_ids.empty()) {\n                // ? id\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n            } else {\n                // No more possible operations\n                break;\n            }\n        }\n    } else {\n        // Unknown type, default to \"random\"\n        // Copy code from \"random\" case\n        int num_queries_type3 = 0;\n\n        for (int i = 0; i < q; ++i) {\n            vector<int> possible_types;\n\n            if (id_index < max_id) {\n                possible_types.push_back(1);\n                possible_types.push_back(2);\n            }\n            if (!placed_ids.empty()) {\n                possible_types.push_back(3);\n            }\n\n            if (possible_types.empty()) {\n                break;\n            }\n\n            int query_type = possible_types[rnd.next(possible_types.size())];\n            if (i == q - 1 && num_queries_type3 == 0) {\n                query_type = 3;\n            }\n\n            if (query_type == 1) {\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"L \" + to_string(id));\n            } else if (query_type == 2) {\n                int id = ids[id_index++];\n                placed_ids.insert(id);\n                placed_ids_vector.push_back(id);\n                queries.push_back(\"R \" + to_string(id));\n            } else if (query_type == 3) {\n                int idx = rnd.next(placed_ids_vector.size());\n                int id = placed_ids_vector[idx];\n                queries.push_back(\"? \" + to_string(id));\n                num_queries_type3++;\n            }\n        }\n    }\n\n    // Ensure we have exactly q queries\n    while ((int)queries.size() > q) {\n        queries.pop_back();\n    }\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    // Output queries\n    for (size_t i = 0; i < queries.size(); ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -q 8 -type all_left\n./gen -q 8 -type all_right\n./gen -q 8 -type alternating\n./gen -q 8 -type random\n./gen -q 8 -type few_queries\n./gen -q 8 -type max_queries\n./gen -q 8 -type edge_positions\n\n./gen -q 1000 -type all_left\n./gen -q 1000 -type all_right\n./gen -q 1000 -type alternating\n./gen -q 1000 -type random\n./gen -q 1000 -type few_queries\n./gen -q 1000 -type max_queries\n./gen -q 1000 -type edge_positions\n\n./gen -q 10000 -type all_left\n./gen -q 10000 -type all_right\n./gen -q 10000 -type alternating\n./gen -q 10000 -type random\n./gen -q 10000 -type few_queries\n./gen -q 10000 -type max_queries\n./gen -q 10000 -type edge_positions\n\n./gen -q 100000 -type all_left\n./gen -q 100000 -type all_right\n./gen -q 100000 -type alternating\n./gen -q 100000 -type random\n./gen -q 100000 -type few_queries\n./gen -q 100000 -type max_queries\n./gen -q 100000 -type edge_positions\n\n./gen -q 200000 -type all_left\n./gen -q 200000 -type all_right\n./gen -q 200000 -type alternating\n./gen -q 200000 -type random\n./gen -q 200000 -type few_queries\n./gen -q 200000 -type max_queries\n./gen -q 200000 -type edge_positions\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:32.185747",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1066/D",
      "title": "D. Упаковывание в коробки",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка входных данных содержит три целых числа nn, mm и kk (1≤n,m≤2⋅1051≤n,m≤2⋅105, 1≤k≤1091≤k≤109) — количество предметов, количество коробок и размер каждой коробки.Вторая строка входных данных содержит nn целых чисел a1,a2,…,ana1,a2,…,an (1≤ai≤k1≤ai≤k), где aiai равно размеру ii-го предмета.",
      "output_spec": "Выходные данныеВыведите максимальное количество предметов, которые сможет упаковать Максим при помощи алгоритма, описанного в условии задачи.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 2 65 2 1 4 2Выходные данныеСкопировать4Входные данныеСкопировать5 1 44 2 3 4 1Выходные данныеСкопировать1Входные данныеСкопировать5 3 31 2 3 1 1Выходные данныеСкопировать5",
      "description": "D. Упаковывание в коробки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка входных данных содержит три целых числа nn, mm и kk (1≤n,m≤2⋅1051≤n,m≤2⋅105, 1≤k≤1091≤k≤109) — количество предметов, количество коробок и размер каждой коробки.Вторая строка входных данных содержит nn целых чисел a1,a2,…,ana1,a2,…,an (1≤ai≤k1≤ai≤k), где aiai равно размеру ii-го предмета.\n\nВходные данные\n\nВыходные данныеВыведите максимальное количество предметов, которые сможет упаковать Максим при помощи алгоритма, описанного в условии задачи.\n\nВыходные данные\n\nВходные данныеСкопировать5 2 65 2 1 4 2Выходные данныеСкопировать4Входные данныеСкопировать5 1 44 2 3 4 1Выходные данныеСкопировать1Входные данныеСкопировать5 3 31 2 3 1 1Выходные данныеСкопировать5\n\nВходные данныеСкопировать5 2 65 2 1 4 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 1 44 2 3 4 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 3 31 2 3 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере Максим может упаковать только 44 предмета. Сначала он пытается упаковать все 55 предметов. Распределение предметов будет выглядеть как [5],[2,1][5],[2,1]. Максим не может упаковать следующий предмет во вторую коробку и пустых коробок у него не осталось. Затем он выбрасывает первый предмет и распределение предметов будет выглядеть как [2,1],[4,2][2,1],[4,2]. Таким образом, ответ равен 44.Во втором тестовом примере очевидно ,что Максим не может упаковать предметы, начиная с первого, второго, третьего и четвертого (во всех этих случаях распределение предметов выглядит как [4][4]), но он может упаковать последний предмет ([1][1]).В третьем тестовом примере Максим может упаковать все предметы, которые у него есть. Распределение предметов будет выглядеть как [1,2],[3],[1,1][1,2],[3],[1,1].",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces",
          "content": "1066A - Vova and Train Разбор1066A - Вова и поездЧему равно количество фонарей от 11 до LL, которые увидит Вова? Оно равно ⌊Lv⌋⌊Lv⌋. Теперь нам нужно вычесть количество фонарей на отрезке [l;r][l;r] из этого количества. Оно равно ⌊rv⌋−⌊l−1v⌋⌊rv⌋−⌊l−1v⌋. Таким образом, ответ равен ⌊Lv⌋⌊Lv⌋ - ⌊rv⌋⌊rv⌋ + ⌊l−1v⌋⌊l−1v⌋. Решение#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint t;\n\tcin >> t;\n\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\n\treturn 0;\n}1066B - Heaters Разбор1066B - ОбогревателиБудем решать задачу жадно. Пусть lastlast — последняя позиция слева, обогреваемая хотя бы одним обогревателем. Изначально lastlast равно -1. Пока last<n−1last<n−1, будем повторять следующий процесс: сначала нам нужно найти самый правый обогреватель из полуинтервала (max(−1,last−r+1);last+r](max(−1,last−r+1);last+r]. Это можно делать за O(n)O(n) из-за довольно маленьких ограничений, или же за O(1)O(1) при помощи предподсчитанных префиксных значений для каждого ii в отрезке [0;n−1][0;n−1]. Если такого обогревателя не существует, то ответ -1, иначе присвоим last:=pos+r−1last:=pos+r−1, увеличим ответ на 11 и повторим алгоритм, если last<n−1last<n−1.Также есть другое решение этой задачи. Предположим, что изначально ответ равен общему количеству нагревателей. Посчитаем массив cntcnt длины nn, где cnticnti означает количество нагревателей, обогревающих ii-й элемент. Это можно сделать за O(n2)O(n2). Этот массив будет значить, что мы включили все обогреватели и мы знаем для каждого элемента количество обогревателей, покрывающих этот элемент. Теперь если хотя бы для одного i∈[0,n−1]i∈[0,n−1] выполняется cnti=0cnti=0, то ответ равен -1. Иначе давайте выключать бесполезные обогреватели. Пройдем по всем обогревателям слева направо. Пусть текущий обогреватель находится в позиции ii. Мы должны проверить, полезный он или бесполезный. Пройдем в отрезке [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)] и проверим, существует ли хотя бы одна позиция jj в этом отрезке такая, что cntj=1cntj=1. Если такая позиция есть, то текущий обогреватель не является бесполезным и мы не можем выключить его. Иначе мы можем уменьшить ответ на 11, выключить этот обогреватель (уменьшить cntjcntj для всех jj в отрезке [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)]) и продолжить этот процесс. Решение 1#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n} Решение 2#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n {\n cin >> a[i];\n if (a[i])ans++;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]++;\n }\n forn(i, n)\n if (!cnt[i])\n {\n cout << -1;\n return 0;\n }\n forn(i, n)\n {\n bool fl = true;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n if (cnt[j] == 1)\n {\n fl = false;\n break;\n }\n if (fl && a[i])\n {\n ans--;\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]--;\n }\n }\n cout << ans;\n\n}1066C - Books Queries Разбор1066C - Книжные запросыПредставим нашу полку как бесконечный массив. Будем хранить самую правую свободную позицию слева от нашей полки (пусть она равна ll и изначально будет равна 00) и самую левую позицию справа от нашей полки (пусть она равна rr и изначально будет равна 00). Также давайте хранить массив pospos длины 2⋅1052⋅105, где posiposi будет означать, позицию книги с номером ii в нашем воображаемом массиве.Давайте поставим первую книгу в позицию 00. Также давайте сохраним, что posidposid (где idid — это номер первой книги) равно 00. Как изменятся ll и rr? ll станет равно −1−1, а rr станет равно 11. Теперь давайте обрабатывать запросы один за другим. Если к нам поступил запрос типа 11 с книгой с номером idid, тогда давайте присвоим posid:=lposid:=l и присвоим l:=l−1l:=l−1. Запрос типа 22 может быть обработан похожим образом. А что же по поводу запросов типа 33? Ответ на этот запрос равен min(|posid−l|,|posid−r|)−1min(|posid−l|,|posid−r|)−1, где |v||v| это абсолютная величина vv. Решение#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint q;\n\tcin >> q;\n\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}1066D - Boxes Packing Разбор1066D - Упаковывание в коробкиПервое решение — что-то из разряда прямого понимания задачи. Сделаем бинарный поиск по ответу. Таким образом, наша задача — найти такой минимальный xx, что суффикс массива aa, начинающийся с позиции xx может быть упакован в коробки. Легко заметить, что если мы можем сделать это для какого-то xx, то мы всегда это можем сделать это и для x+1x+1. И чтобы найти ответ для фиксированного xx, нам просто необходимо просимулировать процесс, описанный в условии задачи, начиная с позиции xx. Окей, это решение за O(nlogn)O(nlog⁡n).Второе решение является более интересным, чем первое. Подход заключается в том, чтобы развернуть изначальный массив, просимулировать процесс, начиная с первой позиции развернутого массива, и тогда все предметы, которые мы смогли упаковать, являются лучшим ответом, и ответа лучше не существует вообще.Почему это работает?Посмотрим на последнюю коробку в лучшем ответе, если мы будем идти слева направо по изначальному массиву. Пусть предметы в этой коробке alst1,alst2,…,alstxalst1,alst2,…,alstx. Что мы видим? ∑i=1xalsti≤k∑i=1xalsti≤k. Таким образом, все предметы умещаются в последнюю коробку (очевидно). Теперь же, если мы будем идти по предметам справа налево, эти предметы также будут в нее умещаться! Это означает, что мы не можем сделать хуже таким преобразованием (разворотом) хотя бы для последней коробки.Но что случится, если мы можем положить некоторые из предыдущих предметов в эту коробку? Это не сделает хуже для этой коробки, но что по поводу следующих коробок (предыдущих коробок в прямом порядке)? Пусть предметы в предыдущей коробке a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}. Что мы видим? Эти предметы умещаются в эту коробку (опять же очевидно). Что случится, если мы положим в последнюю коробку один или более предметов из этой коробки? Тогда левая граница предметов, которые мы положим в нее, не увеличится, потому что мы уменьшаем количество предметов в этой коробке. Так мы можем увидеть, что для предыдущих коробок это условие тоже будет выполняться.Таким образом мы можем решать данную задачу при помощи этого подхода. Асимптотика решения O(n)O(n). Решение 1#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n int ans = n - pos + 1;\n int used = 0;\n while(used < m && pos <= n){\n int t = k;\n while(pos <= n && ar[pos] <= t){\n t -= ar[pos++];\n }\n used++;\n }\n return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n ios_base::sync_with_stdio(0);\n cin.tie(0);\n cout.tie(0);\n cin >> n >> m >> k;\n for(int i = 1; i <= n; i++){\n cin >> ar[i];\n }\n int ans = 0;\n int l = 1, r = n;\n while(l <= r){\n int x = (l + r) >> 1;\n if(find(x)){\n ans = max(ans, n - x + 1);\n r = x - 1;\n }else{\n l = x + 1;\n }\n }\n cout << ans << endl;\n} Решение 2#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn 0;\n}1066E - Binary Numbers AND Sum Разбор1066E - Сумма AND двоичных чиселЧтобы решить эту задачу, посмотрим на то, какие степени 22 в aa будут задеты степенями 22 в bb. Сначала перевернем числа. Будем хранить текущую степень 22 (пусть это будет pwpw), текущую сумму степеней 22 в aa с позиции 00 до текущей позиции включительно (пусть это будет resres) и ответ будет равен ansans. Изначально pw=1pw=1, res=0res=0 и ans=0ans=0. Пройдем по всем битам bb от 00 до m−1m−1. Пусть текущий бит bb имеет номер ii. Сначала, если i<ni<n и ai=1ai=1, присвоим res:=res+pwres:=res+pw (другими словами, добавим к сумме степеней 22 в aa текущую степень 22). Если bi=1bi=1, то этот бит добавит к ответу сумму степеней 22 в aa от 00 до ii включительно (другими словами, resres), так что если он равен единице, то присвоим ans:=ans+resans:=ans+res. И после всего мы можем присвоить pw:=pw+pwpw:=pw+pw и перейти к i+1i+1. И нужно не забывать брать все значения по модулю 998244353998244353, чтобы избежать переполнения. Решение#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}1066F - Yet another 2D Walking Разбор1066F - Очередная ходьба в 2DОсновная идея заключается в том, что нам не нужно хранить больше 22 граничных точек на каждом уровне. Таким образом, если представить, что точка p=(xp,yp)p=(xp,yp) меньше точки q=(xq,yq)q=(xq,yq), когда px<qxpx<qx или px=qxpx=qx и py>qypy>qy, то давайте распределим все точки по их уровням, используя std::map или что-нибудь подобное, отсортируем точки на каждом уровне при помощи компаратора, описанного выше и оставим первую и последнюю точку на каждом уровне. Также давайте добавим фиктивный уровень 00, содержащий точку (0,0)(0,0). Всегда верно оставлять не более 22 точек и это может быть легко доказано, но этот факт, я думаю, достаточно интуитивен. Теперь давайте считать динамическое программирование на точках. Пусть dpi,jdpi,j значит, что сейчас мы находимся на уровне ii и стоим в первой точке (если j=0j=0) или в последней точке (если j=1j=1) и мы уже посетили все точки на уровне ii. Значение динамического программирования — минимально возможная суммарная дистанция, чтобы достичь этого состояния. Изначально dp0,0=dp0,1=0dp0,0=dp0,1=0, остальные значения равны ∞∞. Давайте считать это динамическое программирование в порядке увеличения уровней. Пусть plvl,0plvl,0 — это первая ключевая точка на уровне lvllvl, а plvl,1plvl,1 — последняя ключевая точка на уровне lvllvl. Теперь же если мы находимся на уровне lvllvl, а предыдущий уровень — plvlplvl, этих 44 переходов достаточно, чтобы посчитать состояния динамического программирования на текущем уровне: dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0); dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0); dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1); dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1). Здесь dist(p,q)dist(p,q) означает дистанцию между точками pp и qq.Пусть последний уровень, который у нас есть, равен lstlst. После подсчета динамического программирования ответ равен min(dplst,0,dplst,1)min(dplst,0,dplst,1). Решение#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\n\t\tprv = it.first;\n\t}\n\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\n\treturn 0;\n}",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/62419",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1066\\s*D"
          },
          "content_length": 14229
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 5",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 6",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 17",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 18",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 19",
          "code": "if (ask == 'L'){\n\n            book_id.add(0, id);\n        }\n        if (ask == 'R'){\n            book_id.add(id);\n        }\n        if (ask == '?') {\n            System.out.println(Math.abs(Math.min(book_id.indexOf(id),book_id.size()-book_id.indexOf(id)-1)));\n        }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 20",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 21",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 22",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #515 (Div. 3) - Codeforces - Code 23",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, k, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, k, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, k, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, k);\n        }\n    } else if (type == \"maxsize\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = k;\n        }\n    } else if (type == \"minsize\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = k - (i % k);\n            if (a[i] == 0) a[i] = 1;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1 + (i % k);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = k;\n            else\n                a[i] = 1;\n        }\n    } else if (type == \"hardcase1\") {\n        int threshold = n / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < threshold)\n                a[i] = k;\n            else\n                a[i] = 1;\n        }\n    } else if (type == \"hardcase2\") {\n        long long total_capacity = 1LL * m * k;\n        long long total_size = 0;\n        for (int i = 0; i < n; ++i) {\n            if (total_size + k <= total_capacity)\n                a[i] = k;\n            else\n                a[i] = rnd.next(1, k);\n            total_size += a[i];\n        }\n    } else if (type == \"alloneswithlastk\") {\n        for (int i = 0; i < n -1; ++i) {\n            a[i] = 1;\n        }\n        a[n-1] = k;\n    } else {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, k);\n        }\n    }\n\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, k);\n        }\n    } else if (type == \"maxsize\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = k;\n        }\n    } else if (type == \"minsize\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = k - (i % k);\n            if (a[i] == 0) a[i] = 1;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1 + (i % k);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = k;\n            else\n                a[i] = 1;\n        }\n    } else if (type == \"hardcase1\") {\n        int threshold = n / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < threshold)\n                a[i] = k;\n            else\n                a[i] = 1;\n        }\n    } else if (type == \"hardcase2\") {\n        long long total_capacity = 1LL * m * k;\n        long long total_size = 0;\n        for (int i = 0; i < n; ++i) {\n            if (total_size + k <= total_capacity)\n                a[i] = k;\n            else\n                a[i] = rnd.next(1, k);\n            total_size += a[i];\n        }\n    } else if (type == \"alloneswithlastk\") {\n        for (int i = 0; i < n -1; ++i) {\n            a[i] = 1;\n        }\n        a[n-1] = k;\n    } else {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, k);\n        }\n    }\n\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -type random\n./gen -n 5 -m 2 -k 6 -type random\n./gen -n 5 -m 1 -k 4 -type random\n./gen -n 5 -m 3 -k 3 -type random\n./gen -n 10 -m 5 -k 10 -type maxsize\n./gen -n 10 -m 5 -k 10 -type minsize\n./gen -n 10 -m 5 -k 10 -type alternating\n./gen -n 10 -m 5 -k 10 -type increasing\n./gen -n 10 -m 5 -k 10 -type decreasing\n./gen -n 1000 -m 500 -k 1000000000 -type random\n./gen -n 10000 -m 5000 -k 1000000000 -type random\n./gen -n 100000 -m 50000 -k 1000000000 -type random\n./gen -n 200000 -m 200000 -k 1000000000 -type random\n./gen -n 200000 -m 200000 -k 1000000000 -type maxsize\n./gen -n 200000 -m 200000 -k 1000000000 -type minsize\n./gen -n 200000 -m 200000 -k 1000000000 -type decreasing\n./gen -n 200000 -m 200000 -k 1000000000 -type increasing\n./gen -n 200000 -m 200000 -k 1000000000 -type alternating\n./gen -n 100000 -m 100000 -k 5 -type random\n./gen -n 100000 -m 100000 -k 1 -type minsize\n./gen -n 100000 -m 100000 -k 10 -type hardcase1\n./gen -n 100000 -m 100000 -k 1000000000 -type hardcase2\n./gen -n 200000 -m 200000 -k 1000000000 -type hardcase1\n./gen -n 200000 -m 200000 -k 1000000000 -type hardcase2\n./gen -n 200000 -m 1 -k 1000000000 -type random\n./gen -n 200000 -m 1 -k 1 -type minsize\n./gen -n 200000 -m 1 -k 1 -type maxsize\n./gen -n 200000 -m 100000 -k 2 -type alloneswithlastk\n./gen -n 100000 -m 50000 -k 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:33.930544",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1066/E",
      "title": "E. Binary Numbers AND Sum",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers nn and mm (1≤n,m≤2⋅1051≤n,m≤2⋅105) — the length of aa and the length of bb correspondingly.The second line of the input contains one huge integer aa. It is guaranteed that this number consists of exactly nn zeroes and ones and the first digit is always 11.The third line of the input contains one huge integer bb. It is guaranteed that this number consists of exactly mm zeroes and ones and the first digit is always 11.",
      "output_spec": "OutputPrint the answer to this problem in decimal notation modulo 998244353998244353.",
      "sample_tests": "ExamplesInputCopy4 410101101OutputCopy12InputCopy4 5100110101OutputCopy11",
      "description": "E. Binary Numbers AND Sum\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers nn and mm (1≤n,m≤2⋅1051≤n,m≤2⋅105) — the length of aa and the length of bb correspondingly.The second line of the input contains one huge integer aa. It is guaranteed that this number consists of exactly nn zeroes and ones and the first digit is always 11.The third line of the input contains one huge integer bb. It is guaranteed that this number consists of exactly mm zeroes and ones and the first digit is always 11.\n\nOutputPrint the answer to this problem in decimal notation modulo 998244353998244353.\n\nInputCopy4 410101101OutputCopy12InputCopy4 5100110101OutputCopy11\n\nInputCopy4 410101101\n\nOutputCopy12\n\nInputCopy4 5100110101\n\nOutputCopy11\n\nNoteThe algorithm for the first example:   add to the answer 10102 & 11012=10002=81010102 & 11012=10002=810 and set b:=110b:=110;  add to the answer 10102 & 1102=102=21010102 & 1102=102=210 and set b:=11b:=11;  add to the answer 10102 & 112=102=21010102 & 112=102=210 and set b:=1b:=1;  add to the answer 10102 & 12=02=01010102 & 12=02=010 and set b:=0b:=0. So the answer is 8+2+2+0=128+2+2+0=12.The algorithm for the second example:   add to the answer 10012 & 101012=12=11010012 & 101012=12=110 and set b:=1010b:=1010;  add to the answer 10012 & 10102=10002=81010012 & 10102=10002=810 and set b:=101b:=101;  add to the answer 10012 & 1012=12=11010012 & 1012=12=110 and set b:=10b:=10;  add to the answer 10012 & 102=02=01010012 & 102=02=010 and set b:=1b:=1;  add to the answer 10012 & 12=12=11010012 & 12=12=110 and set b:=0b:=0. So the answer is 1+8+1+0+1=111+8+1+0+1=11.",
      "solutions": [
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces",
          "content": "1066A - Vova and Train Tutorial1066A - Vova and TrainWhat is the number of lanterns Vova will see from 11 to LL? This number is ⌊Lv⌋⌊Lv⌋. Now we have to subtract the number of lanters in range [l;r][l;r] from this number. This number equals to ⌊rv⌋−⌊l−1v⌋⌊rv⌋−⌊l−1v⌋. So the answer is ⌊Lv⌋⌊Lv⌋ - ⌊rv⌋⌊rv⌋ + ⌊l−1v⌋⌊l−1v⌋. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint t;\n\tcin >> t;\n\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\n\treturn 0;\n}1066B - Heaters Tutorial1066B - HeatersLet's solve this problem greedily. Let lastlast be the last position from the left covered by at least one heater. Initially, lastlast equals -1. While last<n−1last<n−1, lets repeat the following process: firstly, we have to find the rightmost heater in range (max(−1,last−r+1);last+r](max(−1,last−r+1);last+r]. It can be done in time O(n)O(n) because of given constrains or in O(1)O(1) using precalculated prefix values for each ii in range [0;n−1][0;n−1]. If there is no such heater then the answer is -1, otherwise let's set last:=pos+r−1last:=pos+r−1, increase the answer by 11 and repeat the process if last<n−1last<n−1.There is another one solution to this problem. Assume that the initial answer equals to the total number of heaters. Let's calculate an array cntcnt of length nn, where cnticnti means the number of heaters covering the ii-th element. It can be done in O(n2)O(n2). This array will mean that we are switch all the heaters on and we know for each element the number of heaters covers this element. Now if for at least i∈[0,n−1]i∈[0,n−1] holds cnti=0cnti=0 then the answer is -1. Otherwise let's switch useless heaters off. Let's iterate over all heaters from left to right. Let the current heater have position ii. We need to check if it is useless or not. Let's iterate in range [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)] and check if there is at least one element jj in this segment such that cntj=1cntj=1. If there is then the current heater is not useless and we cannot switch it off. Otherwise we can decrease the answer by 11, switch this heater off (decrease cntjcntj for all jj in range [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)]) and continue the process. Solution 1#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n} Solution 2#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n {\n cin >> a[i];\n if (a[i])ans++;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]++;\n }\n forn(i, n)\n if (!cnt[i])\n {\n cout << -1;\n return 0;\n }\n forn(i, n)\n {\n bool fl = true;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n if (cnt[j] == 1)\n {\n fl = false;\n break;\n }\n if (fl && a[i])\n {\n ans--;\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]--;\n }\n }\n cout << ans;\n\n}1066C - Books Queries Tutorial1066C - Books QueriesLet imagine our shelf as an infinite array. Let's carry the rightmost free position from the left of our shelf (let it be ll and initially it equals to 00) and the leftmost free position from the right of our shelf (let it be rr and initially it equals to 00). Also let's carry the array pospos of length 2⋅1052⋅105 where posiposi will be equal to the position in our imaginary array of the book with a number ii.Let's put the first book to the position 00. Also let's save that posidposid (where idid is the number of the first book) equals to 00. How will change ll and rr? ll will become −1−1 and rr will become 11. Now let's process queries one by one. If now we have the query of type 11 with a book with a number idid, then let's set posid:=lposid:=l and set l:=l−1l:=l−1. The query of type 22 can be processed similarly. Now what about queries of type 33? The answer to this query equals to min(|posid−l|,|posid−r|)−1min(|posid−l|,|posid−r|)−1, where |v||v| is the absolute value of vv. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint q;\n\tcin >> q;\n\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}1066D - Boxes Packing Tutorial1066D - Boxes PackingThe first solution is some kind of a straight-forward understanding the problem. Let's do binary search on the answer. So our problem is to find the smallest xx such that the suffix of the array aa starting from the position xx can be packed in boxes. It is easy to see that if we can do it for some xx then we always can do it for x+1x+1. And to find the answer for the fixed xx we have to simulate the process described in the problem statement starting from the position xx. Okay, this is O(nlogn)O(nlog⁡n) solution.The second solution is more interesting than the first one. The approach is to reverse the initial array, simulate the process from the first position of reversed array and then all the objects we can pack are in the best answer and there is no better answer at all.Why it works?Let's take a look on the last box in the best answer if we will go from left to right in the initial array. Let objects in this box be alst1,alst2,…,alstxalst1,alst2,…,alstx. What do we see? ∑i=1xalsti≤k∑i=1xalsti≤k. So all these objects are fit in the last box (obviously). Now if we will iterate over objects from right to left, these objects will fit also! It means that we cannot do worse by such a transform (reversing) at least for the last box.But what will happen if we can put some of the previous objects in this box? Well, it will not make worse for this box, but what about next boxes (previous boxes in straight notation)? Let objects in the penultimate box be a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}. What do we see? These objects are fit in this box (obviously again). What will happen if we will put in the last box one or more objects of this box? Then the left border of objects which we will put in it will not increase because we decrease the number of object in this box. So we can see that for previous boxes this condition is also satisfied.So we can solve the problem with this approach. Time complexity of this solution is O(n)O(n). Solution 1#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n int ans = n - pos + 1;\n int used = 0;\n while(used < m && pos <= n){\n int t = k;\n while(pos <= n && ar[pos] <= t){\n t -= ar[pos++];\n }\n used++;\n }\n return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n ios_base::sync_with_stdio(0);\n cin.tie(0);\n cout.tie(0);\n cin >> n >> m >> k;\n for(int i = 1; i <= n; i++){\n cin >> ar[i];\n }\n int ans = 0;\n int l = 1, r = n;\n while(l <= r){\n int x = (l + r) >> 1;\n if(find(x)){\n ans = max(ans, n - x + 1);\n r = x - 1;\n }else{\n l = x + 1;\n }\n }\n cout << ans << endl;\n} Solution 2#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn 0;\n}1066E - Binary Numbers AND Sum Tutorial1066E - Binary Numbers AND SumTo solve this problem let's take a look which powers of 22 in aa will be affected by powers of 22 in bb. Firstly, let's reverse numbers. Let's carry the current power of 22 (let it be pwpw), the current sum of powers of 22 in aa from the position 00 to the current position inclusive (let it be resres) and the answer is ansans. Initially, pw=1pw=1, res=0res=0 and ans=0ans=0. Let's iterate over all bits of bb from 00 to m−1m−1. Let the current bit in bb have the number ii. Firstly, if i<ni<n and ai=1ai=1 then set res:=res+pwres:=res+pw (in other words, we add to the sum of powers of 22 in aa the current power of 22). If bi=1bi=1 then this bit will add to the answer all the powers of 22 in aa from 00 to ii inclusive (in other words, resres), so if it is, then set ans:=ans+resans:=ans+res. And after all we can set pw:=pw+pwpw:=pw+pw and go on to i+1i+1. And don't forget to take all values modulo 998244353998244353 to avoid overflow. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}1066F - Yet another 2D Walking Tutorial1066F - Yet another 2D WalkingThe main idea is that we don't need more than 22 border points on each level. So if we consider than the point p=(xp,yp)p=(xp,yp) is less than point q=(xq,yq)q=(xq,yq) when px<qxpx<qx or px=qxpx=qx and py>qypy>qy then let's distribute all the points by their levels using std::map or something like it, sort points on each level by the comparator above and remain the first one and the last one on each level. Also let's add the fictive level 00 with the point (0,0)(0,0). It is always true to remain at most 22 points and can be easily proved but this fact is very intuitive I think. Now let's do dynamic programming on the points. dpi,jdpi,j means that now we are at the level ii and stay in the first point (if j=0j=0) or in the last point (if j=1j=1) and we are already visit all the points on the level ii. The value of this dynamic programming is the minimum possible total distance to reach this state. Initially, dp0,0=dp0,1=0dp0,0=dp0,1=0, other values are equal to ∞∞. Let's calculate this dynamic programming in order of increasing levels. Let plvl,0plvl,0 be the first key point at the level lvllvl and plvl,1plvl,1 be the last key point at the level lvllvl. Now if we are at the level lvllvl and the previous level is plvlplvl, these 44 transitions are sufficient to calculate states of dynamic programming on the current level: dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0); dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0); dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1); dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1). There dist(p,q)dist(p,q) means the distance between points pp and qq.Let last level we have be lstlst. After calculating this dynamic programming the answer is min(dplst,0,dplst,1)min(dplst,0,dplst,1). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\n\t\tprv = it.first;\n\t}\n\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62419",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1066\\s*E"
          },
          "content_length": 13887
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 5",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 17",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 18",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 19",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 20",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 21",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 22",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    // Read a\n    string a_regex;\n    if (n == 1) {\n        a_regex = \"1\";\n    } else {\n        a_regex = \"1[01]{\" + to_string(n - 1) + \"}\";\n    }\n\n    string a = inf.readToken(a_regex, \"a\");\n    inf.readEoln();\n\n    // Read b\n    string b_regex;\n    if (m == 1) {\n        b_regex = \"1\";\n    } else {\n        b_regex = \"1[01]{\" + to_string(m - 1) + \"}\";\n    }\n\n    string b = inf.readToken(b_regex, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    // Read a\n    string a_regex;\n    if (n == 1) {\n        a_regex = \"1\";\n    } else {\n        a_regex = \"1[01]{\" + to_string(n - 1) + \"}\";\n    }\n\n    string a = inf.readToken(a_regex, \"a\");\n    inf.readEoln();\n\n    // Read b\n    string b_regex;\n    if (m == 1) {\n        b_regex = \"1\";\n    } else {\n        b_regex = \"1[01]{\" + to_string(m - 1) + \"}\";\n    }\n\n    string b = inf.readToken(b_regex, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    // Read a\n    string a_regex;\n    if (n == 1) {\n        a_regex = \"1\";\n    } else {\n        a_regex = \"1[01]{\" + to_string(n - 1) + \"}\";\n    }\n\n    string a = inf.readToken(a_regex, \"a\");\n    inf.readEoln();\n\n    // Read b\n    string b_regex;\n    if (m == 1) {\n        b_regex = \"1\";\n    } else {\n        b_regex = \"1[01]{\" + to_string(m - 1) + \"}\";\n    }\n\n    string b = inf.readToken(b_regex, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_binary_string(int length, string pattern_type) {\n    string s;\n    if (pattern_type == \"all_ones\") {\n        s = string(length, '1');\n    } else if (pattern_type == \"all_zeros\") {\n        s = '1' + string(length - 1, '0'); // since first digit must be '1', rest are '0's\n    } else if (pattern_type == \"alternating\") {\n        s = \"\";\n        for (int i = 0; i < length; ++i) {\n            s += ((i % 2 == 0) ? '1' : '0');\n        }\n    } else if (pattern_type == \"random\") {\n        s = \"\";\n        s += '1'; // first digit is always '1'\n        for (int i = 1; i < length; ++i) {\n            s += rnd.next(0,1) + '0';\n        }\n    } else if (pattern_type == \"palindrome\") {\n        // Generate a palindrome starting with '1'\n        int half = (length + 1) / 2;\n        s = \"\";\n        s += '1'; // first digit is always '1'\n        for (int i = 1; i < half; ++i) {\n            s += rnd.next(0,1) + '0';\n        }\n        string t = s.substr(0, length/2);\n        reverse(t.begin(), t.end());\n        s += t;\n    } else {\n        // default to random\n        s = \"\";\n        s += '1'; // first digit is always '1'\n        for (int i = 1; i < length; ++i) {\n            s += rnd.next(0,1) + '0';\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string a_pattern = opt<string>(\"a_pattern\", \"random\");\n    string b_pattern = opt<string>(\"b_pattern\", \"random\");\n\n    // Ensure that n ≥ 1 and m ≥ 1\n    ensure(n >= 1 && n <= 200000);\n    ensure(m >= 1 && m <= 200000);\n\n    string a = generate_binary_string(n, a_pattern);\n    string b = generate_binary_string(m, b_pattern);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output 'a' and 'b'\n    printf(\"%s\\n%s\\n\", a.c_str(), b.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_binary_string(int length, string pattern_type) {\n    string s;\n    if (pattern_type == \"all_ones\") {\n        s = string(length, '1');\n    } else if (pattern_type == \"all_zeros\") {\n        s = '1' + string(length - 1, '0'); // since first digit must be '1', rest are '0's\n    } else if (pattern_type == \"alternating\") {\n        s = \"\";\n        for (int i = 0; i < length; ++i) {\n            s += ((i % 2 == 0) ? '1' : '0');\n        }\n    } else if (pattern_type == \"random\") {\n        s = \"\";\n        s += '1'; // first digit is always '1'\n        for (int i = 1; i < length; ++i) {\n            s += rnd.next(0,1) + '0';\n        }\n    } else if (pattern_type == \"palindrome\") {\n        // Generate a palindrome starting with '1'\n        int half = (length + 1) / 2;\n        s = \"\";\n        s += '1'; // first digit is always '1'\n        for (int i = 1; i < half; ++i) {\n            s += rnd.next(0,1) + '0';\n        }\n        string t = s.substr(0, length/2);\n        reverse(t.begin(), t.end());\n        s += t;\n    } else {\n        // default to random\n        s = \"\";\n        s += '1'; // first digit is always '1'\n        for (int i = 1; i < length; ++i) {\n            s += rnd.next(0,1) + '0';\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string a_pattern = opt<string>(\"a_pattern\", \"random\");\n    string b_pattern = opt<string>(\"b_pattern\", \"random\");\n\n    // Ensure that n ≥ 1 and m ≥ 1\n    ensure(n >= 1 && n <= 200000);\n    ensure(m >= 1 && m <= 200000);\n\n    string a = generate_binary_string(n, a_pattern);\n    string b = generate_binary_string(m, b_pattern);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output 'a' and 'b'\n    printf(\"%s\\n%s\\n\", a.c_str(), b.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -a_pattern all_ones -b_pattern all_ones\n./gen -n 1 -m 1 -a_pattern all_zeros -b_pattern all_zeros\n./gen -n 1 -m 1 -a_pattern random -b_pattern random\n\n./gen -n 10 -m 10 -a_pattern all_ones -b_pattern all_ones\n./gen -n 10 -m 10 -a_pattern all_zeros -b_pattern all_zeros\n./gen -n 10 -m 10 -a_pattern alternating -b_pattern alternating\n./gen -n 10 -m 10 -a_pattern random -b_pattern random\n\n./gen -n 100 -m 100 -a_pattern all_ones -b_pattern alternating\n./gen -n 100 -m 100 -a_pattern alternating -b_pattern all_zeros\n./gen -n 100 -m 100 -a_pattern palindrome -b_pattern palindrome\n./gen -n 100 -m 100 -a_pattern random -b_pattern random\n\n./gen -n 1000 -m 1000 -a_pattern all_ones -b_pattern random\n./gen -n 1000 -m 1000 -a_pattern random -b_pattern all_zeros\n./gen -n 1000 -m 500 -a_pattern random -b_pattern random\n./gen -n 500 -m 1000 -a_pattern random -b_pattern random\n\n./gen -n 200000 -m 200000 -a_pattern all_ones -b_pattern all_ones\n./gen -n 200000 -m 200000 -a_pattern all_zeros -b_pattern all_zeros\n./gen -n 200000 -m 200000 -a_pattern random -b_pattern random\n\n./gen -n 200000 -m 1 -a_pattern random -b_pattern random\n./gen -n 1 -m 200000 -a_pattern random -b_pattern random\n\n./gen -n 200000 -m 200000 -a_pattern alternating -b_pattern alternating\n./gen -n 200000 -m 200000 -a_pattern palindrome -b_pattern palindrome\n\n./gen -n 200000 -m 200000 -a_pattern alternating -b_pattern random\n./gen -n 200000 -m 200000 -a_pattern random -b_pattern alternating\n\n./gen -n 200000 -m 200000 -a_pattern all_ones -b_pattern random\n./gen -n 200000 -m 200000 -a_pattern random -b_pattern all_ones\n\n./gen -n 200000 -m 200000 -a_pattern all_zeros -b_pattern random\n./gen -n 200000 -m 200000 -a_pattern random -b_pattern all_zeros\n\n./gen -n 200000 -m 100000 -a_pattern random -b_pattern random\n./gen -n 100000 -m 200000 -a_pattern random -b_pattern random\n\n./gen -n 200000 -m 200000 -a_pattern random -b_pattern random\n\n./gen -n 100000 -m 100000 -a_pattern random -b_pattern random\n\n./gen -n 99999 -m 100000 -a_pattern random -b_pattern random\n\n./gen -n 100000 -m 1 -a_pattern random -b_pattern all_ones\n\n./gen -n 1 -m 100000 -a_pattern all_ones -b_pattern random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:35.693082",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1066/F",
      "title": "F. Yet another 2D Walking",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains one integer nn (1≤n≤2⋅1051≤n≤2⋅105) — the number of key points.Each of the next nn lines contains two integers xixi, yiyi (0≤xi,yi≤1090≤xi,yi≤109) — xx-coordinate of the key point pipi and yy-coordinate of the key point pipi. It is guaranteed that all the points are distinct and the point (0,0)(0,0) is not in this set.",
      "output_spec": "OutputPrint one integer — the minimum possible total distance Maksim has to travel if he needs to visit all key points in a way described above.",
      "sample_tests": "ExamplesInputCopy82 21 42 33 13 41 14 31 2OutputCopy15InputCopy52 11 02 03 20 3OutputCopy9",
      "description": "F. Yet another 2D Walking\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains one integer nn (1≤n≤2⋅1051≤n≤2⋅105) — the number of key points.Each of the next nn lines contains two integers xixi, yiyi (0≤xi,yi≤1090≤xi,yi≤109) — xx-coordinate of the key point pipi and yy-coordinate of the key point pipi. It is guaranteed that all the points are distinct and the point (0,0)(0,0) is not in this set.\n\nOutputPrint one integer — the minimum possible total distance Maksim has to travel if he needs to visit all key points in a way described above.\n\nInputCopy82 21 42 33 13 41 14 31 2OutputCopy15InputCopy52 11 02 03 20 3OutputCopy9\n\nInputCopy82 21 42 33 13 41 14 31 2\n\nOutputCopy15\n\nInputCopy52 11 02 03 20 3\n\nOutputCopy9\n\nNoteThe picture corresponding to the first example: There is one of the possible answers of length 1515.The picture corresponding to the second example: There is one of the possible answers of length 99.",
      "solutions": [
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces",
          "content": "1066A - Vova and Train Tutorial1066A - Vova and TrainWhat is the number of lanterns Vova will see from 11 to LL? This number is ⌊Lv⌋⌊Lv⌋. Now we have to subtract the number of lanters in range [l;r][l;r] from this number. This number equals to ⌊rv⌋−⌊l−1v⌋⌊rv⌋−⌊l−1v⌋. So the answer is ⌊Lv⌋⌊Lv⌋ - ⌊rv⌋⌊rv⌋ + ⌊l−1v⌋⌊l−1v⌋. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint t;\n\tcin >> t;\n\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\n\treturn 0;\n}1066B - Heaters Tutorial1066B - HeatersLet's solve this problem greedily. Let lastlast be the last position from the left covered by at least one heater. Initially, lastlast equals -1. While last<n−1last<n−1, lets repeat the following process: firstly, we have to find the rightmost heater in range (max(−1,last−r+1);last+r](max(−1,last−r+1);last+r]. It can be done in time O(n)O(n) because of given constrains or in O(1)O(1) using precalculated prefix values for each ii in range [0;n−1][0;n−1]. If there is no such heater then the answer is -1, otherwise let's set last:=pos+r−1last:=pos+r−1, increase the answer by 11 and repeat the process if last<n−1last<n−1.There is another one solution to this problem. Assume that the initial answer equals to the total number of heaters. Let's calculate an array cntcnt of length nn, where cnticnti means the number of heaters covering the ii-th element. It can be done in O(n2)O(n2). This array will mean that we are switch all the heaters on and we know for each element the number of heaters covers this element. Now if for at least i∈[0,n−1]i∈[0,n−1] holds cnti=0cnti=0 then the answer is -1. Otherwise let's switch useless heaters off. Let's iterate over all heaters from left to right. Let the current heater have position ii. We need to check if it is useless or not. Let's iterate in range [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)] and check if there is at least one element jj in this segment such that cntj=1cntj=1. If there is then the current heater is not useless and we cannot switch it off. Otherwise we can decrease the answer by 11, switch this heater off (decrease cntjcntj for all jj in range [max(0,i−r+1),min(n−1,i+r−1)][max(0,i−r+1),min(n−1,i+r−1)]) and continue the process. Solution 1#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n} Solution 2#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n {\n cin >> a[i];\n if (a[i])ans++;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]++;\n }\n forn(i, n)\n if (!cnt[i])\n {\n cout << -1;\n return 0;\n }\n forn(i, n)\n {\n bool fl = true;\n if (a[i])\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n if (cnt[j] == 1)\n {\n fl = false;\n break;\n }\n if (fl && a[i])\n {\n ans--;\n for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n cnt[j]--;\n }\n }\n cout << ans;\n\n}1066C - Books Queries Tutorial1066C - Books QueriesLet imagine our shelf as an infinite array. Let's carry the rightmost free position from the left of our shelf (let it be ll and initially it equals to 00) and the leftmost free position from the right of our shelf (let it be rr and initially it equals to 00). Also let's carry the array pospos of length 2⋅1052⋅105 where posiposi will be equal to the position in our imaginary array of the book with a number ii.Let's put the first book to the position 00. Also let's save that posidposid (where idid is the number of the first book) equals to 00. How will change ll and rr? ll will become −1−1 and rr will become 11. Now let's process queries one by one. If now we have the query of type 11 with a book with a number idid, then let's set posid:=lposid:=l and set l:=l−1l:=l−1. The query of type 22 can be processed similarly. Now what about queries of type 33? The answer to this query equals to min(|posid−l|,|posid−r|)−1min(|posid−l|,|posid−r|)−1, where |v||v| is the absolute value of vv. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint q;\n\tcin >> q;\n\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}1066D - Boxes Packing Tutorial1066D - Boxes PackingThe first solution is some kind of a straight-forward understanding the problem. Let's do binary search on the answer. So our problem is to find the smallest xx such that the suffix of the array aa starting from the position xx can be packed in boxes. It is easy to see that if we can do it for some xx then we always can do it for x+1x+1. And to find the answer for the fixed xx we have to simulate the process described in the problem statement starting from the position xx. Okay, this is O(nlogn)O(nlog⁡n) solution.The second solution is more interesting than the first one. The approach is to reverse the initial array, simulate the process from the first position of reversed array and then all the objects we can pack are in the best answer and there is no better answer at all.Why it works?Let's take a look on the last box in the best answer if we will go from left to right in the initial array. Let objects in this box be alst1,alst2,…,alstxalst1,alst2,…,alstx. What do we see? ∑i=1xalsti≤k∑i=1xalsti≤k. So all these objects are fit in the last box (obviously). Now if we will iterate over objects from right to left, these objects will fit also! It means that we cannot do worse by such a transform (reversing) at least for the last box.But what will happen if we can put some of the previous objects in this box? Well, it will not make worse for this box, but what about next boxes (previous boxes in straight notation)? Let objects in the penultimate box be a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}a_{prev_1}, a_{prev_2}, \\dots, a_{prev_y}}. What do we see? These objects are fit in this box (obviously again). What will happen if we will put in the last box one or more objects of this box? Then the left border of objects which we will put in it will not increase because we decrease the number of object in this box. So we can see that for previous boxes this condition is also satisfied.So we can solve the problem with this approach. Time complexity of this solution is O(n)O(n). Solution 1#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n int ans = n - pos + 1;\n int used = 0;\n while(used < m && pos <= n){\n int t = k;\n while(pos <= n && ar[pos] <= t){\n t -= ar[pos++];\n }\n used++;\n }\n return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n ios_base::sync_with_stdio(0);\n cin.tie(0);\n cout.tie(0);\n cin >> n >> m >> k;\n for(int i = 1; i <= n; i++){\n cin >> ar[i];\n }\n int ans = 0;\n int l = 1, r = n;\n while(l <= r){\n int x = (l + r) >> 1;\n if(find(x)){\n ans = max(ans, n - x + 1);\n r = x - 1;\n }else{\n l = x + 1;\n }\n }\n cout << ans << endl;\n} Solution 2#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn 0;\n}1066E - Binary Numbers AND Sum Tutorial1066E - Binary Numbers AND SumTo solve this problem let's take a look which powers of 22 in aa will be affected by powers of 22 in bb. Firstly, let's reverse numbers. Let's carry the current power of 22 (let it be pwpw), the current sum of powers of 22 in aa from the position 00 to the current position inclusive (let it be resres) and the answer is ansans. Initially, pw=1pw=1, res=0res=0 and ans=0ans=0. Let's iterate over all bits of bb from 00 to m−1m−1. Let the current bit in bb have the number ii. Firstly, if i<ni<n and ai=1ai=1 then set res:=res+pwres:=res+pw (in other words, we add to the sum of powers of 22 in aa the current power of 22). If bi=1bi=1 then this bit will add to the answer all the powers of 22 in aa from 00 to ii inclusive (in other words, resres), so if it is, then set ans:=ans+resans:=ans+res. And after all we can set pw:=pw+pwpw:=pw+pw and go on to i+1i+1. And don't forget to take all values modulo 998244353998244353 to avoid overflow. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}1066F - Yet another 2D Walking Tutorial1066F - Yet another 2D WalkingThe main idea is that we don't need more than 22 border points on each level. So if we consider than the point p=(xp,yp)p=(xp,yp) is less than point q=(xq,yq)q=(xq,yq) when px<qxpx<qx or px=qxpx=qx and py>qypy>qy then let's distribute all the points by their levels using std::map or something like it, sort points on each level by the comparator above and remain the first one and the last one on each level. Also let's add the fictive level 00 with the point (0,0)(0,0). It is always true to remain at most 22 points and can be easily proved but this fact is very intuitive I think. Now let's do dynamic programming on the points. dpi,jdpi,j means that now we are at the level ii and stay in the first point (if j=0j=0) or in the last point (if j=1j=1) and we are already visit all the points on the level ii. The value of this dynamic programming is the minimum possible total distance to reach this state. Initially, dp0,0=dp0,1=0dp0,0=dp0,1=0, other values are equal to ∞∞. Let's calculate this dynamic programming in order of increasing levels. Let plvl,0plvl,0 be the first key point at the level lvllvl and plvl,1plvl,1 be the last key point at the level lvllvl. Now if we are at the level lvllvl and the previous level is plvlplvl, these 44 transitions are sufficient to calculate states of dynamic programming on the current level: dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,0+dist(pplvl,0,plvl,1)+dist(plvl,1,plvl,0); dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0)dplvl,0=min(dplvl,0,dpplvl,1+dist(pplvl,1,plvl,1)+dist(plvl,1,plvl,0); dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,0+dist(pplvl,0,plvl,0)+dist(plvl,0,plvl,1); dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1)dplvl,1=min(dplvl,1,dpplvl,1+dist(pplvl,1,plvl,0)+dist(plvl,0,plvl,1). There dist(p,q)dist(p,q) means the distance between points pp and qq.Let last level we have be lstlst. After calculating this dynamic programming the answer is min(dplst,0,dplst,1)min(dplst,0,dplst,1). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\n\t\tprv = it.first;\n\t}\n\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62419",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1066\\s*F"
          },
          "content_length": 13887
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, r;\n\tcin >> n >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tint last = -1;\n\twhile (last < n - 1) {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i > max(-1, last - r + 1); --i) {\n\t\t\tif (a[i] == 1 && i - r <= last) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t++ans;\n\t\tlast = pos + r - 1;\n\t}\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 5",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 6",
          "code": "#include <vector>\n#include <iostream>\n\n#define forn(i,n) for (int i=0; i<int(n); i++)\n\nusing namespace std;\n\nconst int N = 2e5;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n, r; cin >> n >> r;\n\tvector<int> a(n);\n\tvector<int> cnt(n);\n\tint ans = 0;\n\tforn(i, n)\n        {\n            cin >> a[i];\n            if (a[i])ans++;\n            if (a[i])\n                for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                    cnt[j]++;\n        }\n    forn(i, n)\n        if (!cnt[i])\n        {\n            cout << -1;\n            return 0;\n        }\n    forn(i, n)\n    {\n        bool fl = true;\n        if (a[i])\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                if (cnt[j] == 1)\n                {\n                    fl = false;\n                    break;\n                }\n        if (fl && a[i])\n        {\n            ans--;\n            for (int j = max(0, i - r + 1); j < min(n, i + r); ++j)\n                cnt[j]--;\n        }\n    }\n    cout << ans;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 200 * 1000 + 11;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\t\n\tvector<int> pos(M);\n\tint curl = 0;\n\tint curr = 0;\n\t\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring type;\n\t\tint id;\n\t\tcin >> type >> id;\n\t\tif (i == 0) {\n\t\t\tpos[id] = curl;\n\t\t\t--curl;\n\t\t\t++curr;\n\t\t} else {\n\t\t\tif (type == \"L\") {\n\t\t\t\tpos[id] = curl;\n\t\t\t\t--curl;\n\t\t\t} else if (type == \"R\") {\n\t\t\t\tpos[id] = curr;\n\t\t\t\t++curr;\n\t\t\t} else {\n\t\t\t\tcout << min(abs(pos[id] - curl), abs(pos[id] - curr)) - 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 2e5 + 10;\n\nint ar[MAX];\nint n, m, k;\n\nint find(int pos){\n    int ans = n - pos + 1;\n    int used = 0;\n    while(used < m && pos <= n){\n        int t = k;\n        while(pos <= n && ar[pos] <= t){\n            t -= ar[pos++];\n        }\n        used++;\n    }\n    return pos == n + 1 ? ans : 0;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 1; i <= n; i++){\n        cin >> ar[i];\n    }\n    int ans = 0;\n    int l = 1, r = n;\n    while(l <= r){\n        int x = (l + r) >> 1;\n        if(find(x)){\n            ans = max(ans, n - x + 1);\n            r = x - 1;\n        }else{\n            l = x + 1;\n        }\n    }\n    cout << ans << endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\treverse(a.begin(), a.end());\n\tint rem = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (rem - a[i] < 0) {\n\t\t\tif (m == 0) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t--m;\n\t\t\t\trem = k - a[i];\n\t\t\t}\n\t\t} else {\n\t\t\trem -= a[i];\n\t\t}\n\t}\n\t\n\tcout << n << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 13",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 14",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a < 0) a += MOD;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tstring s, t;\n\tcin >> s >> t;\n\t\n\tint pw = 1;\n\tint res = 0;\n\tint ans = 0;\n\t\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (i < n && s[n - i - 1] == '1') {\n\t\t\tres = add(res, pw);\n\t\t}\n\t\tif (t[m - i - 1] == '1') {\n\t\t\tans = add(ans, res);\n\t\t}\n\t\tpw = add(pw, pw);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long INF64 = 1e18;\n\nlong long dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tmap<int, vector<pair<int, int>>> pts;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tpts[max(x, y)].push_back(make_pair(x, y));\n\t}\n\tpts[0].push_back(make_pair(0, 0));\n\t\n\tfor (auto &it : pts) {\n\t\tsort(it.second.begin(), it.second.end(), [&](pair<int, int> a, pair<int, int> &b) {\n\t\t\tif (a.first == b.first)\n\t\t\t\treturn a.second > b.second;\n\t\t\treturn a.first < b.first;\n\t\t});\n\t}\n\t\n\tvector<vector<long long>> dp(int(pts.size()) + 1, vector<long long>(2, INF64));\n\tdp[0][0] = dp[0][1] = 0;\n\t\n\tint lvl = 0;\n\tint prv = 0;\n\tfor (auto &it : pts) {\n\t\t++lvl;\n\t\t\n\t\tpair<int, int> curl = it.second[0];\n\t\tpair<int, int> curr = it.second.back();\n\t\t\n\t\tpair<int, int> prvl = pts[prv][0];\n\t\tpair<int, int> prvr = pts[prv].back();\n\t\t\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][0] + dist(prvl, curr) + dist(curl, curr));\n\t\tdp[lvl][0] = min(dp[lvl][0], dp[lvl - 1][1] + dist(prvr, curr) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][0] + dist(prvl, curl) + dist(curl, curr));\n\t\tdp[lvl][1] = min(dp[lvl][1], dp[lvl - 1][1] + dist(prvr, curl) + dist(curl, curr));\n\t\t\n\t\tprv = it.first;\n\t}\n\t\n\tcout << min(dp[lvl][0], dp[lvl][1]) << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 17",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 18",
          "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 1010\nint n,r;\nint a[N];\nint main()\n{\n    cin>>n>>r;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>a[i];\n    }\n    int ans=0;\n    int last_warmed_pos=0;//初始最后加热点\n    while(last_warmed_pos<n)\n    {\n        int next_h_pos=-1;\n        //这里这个条件用来限定h的范围//如果在最后加热点右侧没有合适的h 那就只能在其左侧找且不能为上一个所选h\n        for(int i=n;i>=max(0,last_warmed_pos-r+1);i--)\n        {\n            if(a[i]==1&&i-r<=last_warmed_pos)//找到最右端的h使加热范围覆盖进入last_warmed_pos\n            //注意这里的i-r<=last_warmed_pos 所找h的最左未加热部分要确保已加热\n            //等价于i-r+1<=last_warmed_pos+1 所找h的最左加热起点要小于等于下一个加热点\n            //而不是i-r+1<=last_warmed_pos 错误！！！\n            {\n                next_h_pos=i;\n                //cout<<\"next h:\"<<next_h_pos<<endl;\n                break;\n            }\n        }\n        if(next_h_pos==-1)\n        {\n            ans=-1;\n            break;//找不到符合的h\n        }\n        ans++;\n        last_warmed_pos=next_h_pos+r-1;//更新最后加热点\n    }\n    cout<<ans<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 19",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 20",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\nLL MOD = 998244353;\nconst int N = 524288;\ndouble PI = acos(-1);\nstruct comp {\n\tdouble re, im;\n\tcomp operator*(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re * a.re - im * a.im;\n\t\tret.im = re * a.im + im * a.re;\n\t\treturn ret;\n\t}\n\tcomp operator+(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re + a.re;\n\t\tret.im = im + a.im;\n\t\treturn ret;\n\t}\n\tcomp operator-(const comp& a){\n\t\tcomp ret;\n\t\tret.re = re - a.re;\n\t\tret.im = im - a.im;\n\t\treturn ret;\n\t}\n};\nint getord(int x){\n\tint ret = 0;\n\twhile ((1 << ret) < x) {\n\t\tret++;\n\t}\n\treturn ret;\n}\ncomp tmp[N];\ncomp A[N];\ncomp B[N];\nvoid fft(comp* ar, int n, int mode) {\n\tif (n == 1) return;\n\tcomp base;\n\tbase.re = cos(2*PI/n);\n\tbase.im = sin(2*PI/n);\n\tif (mode) base.im *= -1;\n\tcomp cur;\n\tcur.re = 1;\n\tcur.im = 0;\n\tint dnc = n/2;\n\tfor (int i = 0; i < dnc; i++) {\n\t\ttmp[i] = ar[i*2 + 1];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i] = ar[i*2];\n\t}\n\tfor (int i = 0; i < dnc; i++) {\n\t\tar[i+dnc] = tmp[i];\n\t}\n\tfft(ar, dnc, mode);\n\tfft(ar + dnc, dnc, mode);\n\tfor (int i = 0; i < dnc; i++) {\n\t\tcomp ta = ar[i];\n\t\tcomp tb = ar[i+dnc] * cur;\n\t\tar[i] = ta + tb;\n\t\tar[i+dnc] = ta - tb;\n\t\tcur = cur * base;\n\t}\n}\nchar str1[200005];\nchar str2[200005];\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str1);\n\tscanf(\"%s\", str2);\n\tint L = (1 << getord(n+m+2));\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i].re = A[i].im = 0;\n\t\tB[i].re = B[i].im = 0;\n\t}\n\tLL mul = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (str1[n-i-1] == '1') {\n\t\t\tA[n-i-1 + 1].re = mul;\n\t\t}\n\t\tmul = (mul*2)%MOD;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str2[i] == '1') {\n\t\t\tB[m-i-1 + 1].re = 1;\n\t\t}\n\t}\n\tfft(A, L, 0);\n\tfft(B, L, 0);\n\tfor (int i = 0; i < L; i++) {\n\t\tA[i] = A[i] * B[i];\n\t}\n\tfft(A, L, 1);\n\tLL ans = 0;\n\tfor (int i = n + 1; i < L; i++) {\n\t\tLL tmp = fmod((A[i].re + 0.5) / L, MOD);\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 21",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #515 (Div. 3) Editorial - Codeforces - Code 22",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define mem(dp,a) memset(dp,a,sizeof dp)\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define repb(i,a,b) for(ll i=a;i>=b;i--)\n#define pb(x) push_back(x)\n#define sl(a) scanf(\"%lld\",&a)\n#define si(a) scanf(\"%d\",&a)\nll INF=1ll<<60;\nll MOD=1000000007;\n\nint main()\n{\n\tll n,k;sl(n);sl(k);\n\tll a[n];\n\trep(i,0,n)\n\tsl(a[i]);\n\tll last=-1;\n\trep(i,0,k)\n\t{\n\t\tif(a[i]==1)\n\t\tlast=i;\n\t}\n\tll c=0,cant=0;\n\tif(last!=-1)\n\t\tc=1;\n\telse\n\t\tcant=1;\n\twhile(last+k<n)\n\t{\n\t\tll start=last+1,end=last+2*k;\n\t\trep(i,start,end)\n\t\t{\n\t\t\tif(a[i]==1)\n\t\t\tlast=i;\n\t\t}\n\t\tif(last==start-1)\n                {\n                        cant=1;\n                        break;\n                }\n\t\telse\n\t\t\tc++;\n\t}\n\tcant==0 ? cout<<c<<endl : cout<<-1<<endl;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62419",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 1000000000, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000000, \"y_i\");\n        inf.readEoln();\n\n        ensuref(!(xi == 0 && yi == 0), \"Key point (%d, %d) cannot be (0, 0)\", xi, yi);\n        ensuref(points.insert({xi, yi}).second, \"Key point (%d, %d) occurs more than once\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 1000000000, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000000, \"y_i\");\n        inf.readEoln();\n\n        ensuref(!(xi == 0 && yi == 0), \"Key point (%d, %d) cannot be (0, 0)\", xi, yi);\n        ensuref(points.insert({xi, yi}).second, \"Key point (%d, %d) occurs more than once\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 1000000000, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000000, \"y_i\");\n        inf.readEoln();\n\n        ensuref(!(xi == 0 && yi == 0), \"Key point (%d, %d) cannot be (0, 0)\", xi, yi);\n        ensuref(points.insert({xi, yi}).second, \"Key point (%d, %d) occurs more than once\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces n distinct points (x_i, y_i) in the range [0, maxCoord],\n  excluding (0, 0). The output format:\n    1) First line: n\n    2) Next n lines: each line has two integers x_i, y_i\n\n  Usage (examples):\n    ./gen -n 10 -type random\n    ./gen -n 5 -type lineX\n    ./gen -n 8 -type corner -maxCoord 10\n\n  Supported \"type\":\n    1) random  -- random points anywhere in [0, maxCoord].\n    2) lineX   -- all points with x > 0, y = 0 (forming a horizontal line).\n    3) lineY   -- all points with x = 0, y > 0 (forming a vertical line).\n    4) diag    -- points of the form (k, k) with k > 0.\n    5) corner  -- half of the points on x-axis, half on y-axis (excluding (0,0)).\n    6) small   -- random points in a smaller region [0, min(maxCoord, 1000)].\n    7) large   -- random points near maxCoord (e.g. in [maxCoord - 10000, maxCoord]).\n    8) levels  -- random points grouped by \"levels\" max(x, y) = 1,2,... up to some random limit.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Number of points to generate:\n    int n = opt<int>(\"n\");\n    // Type of generation:\n    string type = opt<string>(\"type\", \"random\");\n    // Maximum coordinate allowed:\n    long long maxCoord = opt<long long>(\"maxCoord\", 1000000000LL);\n\n    // A container to store generated points;\n    // we'll ensure they are distinct and not (0,0).\n    set<pair<long long, long long>> used;\n\n    auto addPoint = [&](long long x, long long y) {\n        if (x == 0 && y == 0) return; // skip (0,0)\n        used.insert({x, y});\n    };\n\n    // Helper function to generate random in [L, R]\n    auto rndLL = [&](long long L, long long R) {\n        // testlib's rnd.next(long long n) generates in [0, n-1]\n        // so we use it carefully for [L, R].\n        // We assume L <= R.\n        long long len = R - L + 1;\n        long long val = rnd.next(len); // in [0, len-1]\n        return L + val;\n    };\n\n    if (type == \"lineX\") {\n        // All points will be on y=0, x>0\n        // We'll simply pick x = 1..n (or up to n).\n        // If n might exceed maxCoord, we clamp to maxCoord.\n        long long limit = min<long long>(n, maxCoord);\n        for (int i = 1; i <= limit; i++) {\n            addPoint(i, 0);\n            if ((int)used.size() == n) break;\n        }\n    }\n    else if (type == \"lineY\") {\n        // All points will be on x=0, y>0\n        // We'll pick y = 1..n (or up to n).\n        long long limit = min<long long>(n, maxCoord);\n        for (int i = 1; i <= limit; i++) {\n            addPoint(0, i);\n            if ((int)used.size() == n) break;\n        }\n    }\n    else if (type == \"diag\") {\n        // Points of the form (k, k), k >= 1\n        // If n might exceed maxCoord, clamp it.\n        long long limit = min<long long>(n, maxCoord);\n        for (int i = 1; i <= limit; i++) {\n            addPoint(i, i);\n            if ((int)used.size() == n) break;\n        }\n    }\n    else if (type == \"corner\") {\n        // Either on x-axis or y-axis, skipping (0,0).\n        // We'll produce about half on each axis.\n        // If n is odd, one extra point goes to x-axis for instance.\n        int half = n / 2;\n        // x-axis from 1..half or up to maxCoord\n        long long limit = min<long long>(half, maxCoord);\n        for (int i = 1; i <= limit; i++) {\n            addPoint(i, 0);\n        }\n        // y-axis from 1..(n - half)\n        long long remaining = n - (int)used.size();\n        long long limit2 = min<long long>(remaining, maxCoord);\n        for (int i = 1; i <= limit2; i++) {\n            addPoint(0, i);\n        }\n        // If still not enough, just random fill\n        while ((int)used.size() < n) {\n            long long x = rndLL(1, maxCoord);\n            addPoint(x, 0);\n            if ((int)used.size() < n) {\n                long long y = rndLL(1, maxCoord);\n                addPoint(0, y);\n            }\n        }\n    }\n    else if (type == \"small\") {\n        // Random but in [0, min(maxCoord, 1000]]\n        long long bound = min<long long>(maxCoord, 1000LL);\n        while ((int)used.size() < n) {\n            long long x = rndLL(0, bound);\n            long long y = rndLL(0, bound);\n            addPoint(x, y);\n        }\n    }\n    else if (type == \"large\") {\n        // Random but near maxCoord, e.g., in [max(0, maxCoord - 10000), maxCoord]\n        long long low = 0;\n        if (maxCoord >= 10000) {\n            low = maxCoord - 10000;\n        }\n        while ((int)used.size() < n) {\n            long long x = rndLL(low, maxCoord);\n            long long y = rndLL(low, maxCoord);\n            addPoint(x, y);\n        }\n    }\n    else if (type == \"levels\") {\n        // We'll create random \"levels\" up to some smaller limit\n        // because if we pick large random levels up to 10^9,\n        // it's effectively random. Let's pick up to 100 or so.\n        // Then for each level L in [1..someRand], pick some random points.\n        // We do not attempt perfect distribution, just a mix.\n\n        // We'll assume we can produce n up to what we can handle.\n        // We'll keep generating until we have n points, across levels 1..someRand.\n        // someRand is up to min(1000, maxCoord).\n        long long maxLevel = min<long long>(1000LL, maxCoord);\n        int totalLevels = rnd.next(1, (int)maxLevel); // pick how many levels\n        // Generate points level by level\n        // level i means max(x, y) = i\n        // We'll pick random x,y such that max(x,y) = i\n        // That means x in [0, i], y in [0, i], and either x=i or y=i\n        while ((int)used.size() < n) {\n            int level = rnd.next(1, totalLevels);\n            long long x = rndLL(0, level);\n            long long y = rndLL(0, level);\n            // ensure max(x,y)=level\n            if (x < level && y < level) {\n                // forcibly set either x=level or y=level\n                if (rnd.next(2) == 0) x = level; \n                else y = level;\n            } else {\n                if (max(x,y) < level) {\n                    // force it\n                    if (rnd.next(2) == 0) x = level; \n                    else y = level;\n                }\n            }\n            addPoint(x,y);\n        }\n    }\n    else {\n        // Default: type == \"random\"\n        // Random points anywhere in [0, maxCoord].\n        while ((int)used.size() < n) {\n            long long x = rndLL(0, maxCoord);\n            long long y = rndLL(0, maxCoord);\n            addPoint(x, y);\n        }\n    }\n\n    // Now we have n distinct points in \"used\".\n    // Output them.\n    cout << n << \"\\n\";\n    for (auto &pt : used) {\n        cout << pt.first << \" \" << pt.second << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces n distinct points (x_i, y_i) in the range [0, maxCoord],\n  excluding (0, 0). The output format:\n    1) First line: n\n    2) Next n lines: each line has two integers x_i, y_i\n\n  Usage (examples):\n    ./gen -n 10 -type random\n    ./gen -n 5 -type lineX\n    ./gen -n 8 -type corner -maxCoord 10\n\n  Supported \"type\":\n    1) random  -- random points anywhere in [0, maxCoord].\n    2) lineX   -- all points with x > 0, y = 0 (forming a horizontal line).\n    3) lineY   -- all points with x = 0, y > 0 (forming a vertical line).\n    4) diag    -- points of the form (k, k) with k > 0.\n    5) corner  -- half of the points on x-axis, half on y-axis (excluding (0,0)).\n    6) small   -- random points in a smaller region [0, min(maxCoord, 1000)].\n    7) large   -- random points near maxCoord (e.g. in [maxCoord - 10000, maxCoord]).\n    8) levels  -- random points grouped by \"levels\" max(x, y) = 1,2,... up to some random limit.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Number of points to generate:\n    int n = opt<int>(\"n\");\n    // Type of generation:\n    string type = opt<string>(\"type\", \"random\");\n    // Maximum coordinate allowed:\n    long long maxCoord = opt<long long>(\"maxCoord\", 1000000000LL);\n\n    // A container to store generated points;\n    // we'll ensure they are distinct and not (0,0).\n    set<pair<long long, long long>> used;\n\n    auto addPoint = [&](long long x, long long y) {\n        if (x == 0 && y == 0) return; // skip (0,0)\n        used.insert({x, y});\n    };\n\n    // Helper function to generate random in [L, R]\n    auto rndLL = [&](long long L, long long R) {\n        // testlib's rnd.next(long long n) generates in [0, n-1]\n        // so we use it carefully for [L, R].\n        // We assume L <= R.\n        long long len = R - L + 1;\n        long long val = rnd.next(len); // in [0, len-1]\n        return L + val;\n    };\n\n    if (type == \"lineX\") {\n        // All points will be on y=0, x>0\n        // We'll simply pick x = 1..n (or up to n).\n        // If n might exceed maxCoord, we clamp to maxCoord.\n        long long limit = min<long long>(n, maxCoord);\n        for (int i = 1; i <= limit; i++) {\n            addPoint(i, 0);\n            if ((int)used.size() == n) break;\n        }\n    }\n    else if (type == \"lineY\") {\n        // All points will be on x=0, y>0\n        // We'll pick y = 1..n (or up to n).\n        long long limit = min<long long>(n, maxCoord);\n        for (int i = 1; i <= limit; i++) {\n            addPoint(0, i);\n            if ((int)used.size() == n) break;\n        }\n    }\n    else if (type == \"diag\") {\n        // Points of the form (k, k), k >= 1\n        // If n might exceed maxCoord, clamp it.\n        long long limit = min<long long>(n, maxCoord);\n        for (int i = 1; i <= limit; i++) {\n            addPoint(i, i);\n            if ((int)used.size() == n) break;\n        }\n    }\n    else if (type == \"corner\") {\n        // Either on x-axis or y-axis, skipping (0,0).\n        // We'll produce about half on each axis.\n        // If n is odd, one extra point goes to x-axis for instance.\n        int half = n / 2;\n        // x-axis from 1..half or up to maxCoord\n        long long limit = min<long long>(half, maxCoord);\n        for (int i = 1; i <= limit; i++) {\n            addPoint(i, 0);\n        }\n        // y-axis from 1..(n - half)\n        long long remaining = n - (int)used.size();\n        long long limit2 = min<long long>(remaining, maxCoord);\n        for (int i = 1; i <= limit2; i++) {\n            addPoint(0, i);\n        }\n        // If still not enough, just random fill\n        while ((int)used.size() < n) {\n            long long x = rndLL(1, maxCoord);\n            addPoint(x, 0);\n            if ((int)used.size() < n) {\n                long long y = rndLL(1, maxCoord);\n                addPoint(0, y);\n            }\n        }\n    }\n    else if (type == \"small\") {\n        // Random but in [0, min(maxCoord, 1000]]\n        long long bound = min<long long>(maxCoord, 1000LL);\n        while ((int)used.size() < n) {\n            long long x = rndLL(0, bound);\n            long long y = rndLL(0, bound);\n            addPoint(x, y);\n        }\n    }\n    else if (type == \"large\") {\n        // Random but near maxCoord, e.g., in [max(0, maxCoord - 10000), maxCoord]\n        long long low = 0;\n        if (maxCoord >= 10000) {\n            low = maxCoord - 10000;\n        }\n        while ((int)used.size() < n) {\n            long long x = rndLL(low, maxCoord);\n            long long y = rndLL(low, maxCoord);\n            addPoint(x, y);\n        }\n    }\n    else if (type == \"levels\") {\n        // We'll create random \"levels\" up to some smaller limit\n        // because if we pick large random levels up to 10^9,\n        // it's effectively random. Let's pick up to 100 or so.\n        // Then for each level L in [1..someRand], pick some random points.\n        // We do not attempt perfect distribution, just a mix.\n\n        // We'll assume we can produce n up to what we can handle.\n        // We'll keep generating until we have n points, across levels 1..someRand.\n        // someRand is up to min(1000, maxCoord).\n        long long maxLevel = min<long long>(1000LL, maxCoord);\n        int totalLevels = rnd.next(1, (int)maxLevel); // pick how many levels\n        // Generate points level by level\n        // level i means max(x, y) = i\n        // We'll pick random x,y such that max(x,y) = i\n        // That means x in [0, i], y in [0, i], and either x=i or y=i\n        while ((int)used.size() < n) {\n            int level = rnd.next(1, totalLevels);\n            long long x = rndLL(0, level);\n            long long y = rndLL(0, level);\n            // ensure max(x,y)=level\n            if (x < level && y < level) {\n                // forcibly set either x=level or y=level\n                if (rnd.next(2) == 0) x = level; \n                else y = level;\n            } else {\n                if (max(x,y) < level) {\n                    // force it\n                    if (rnd.next(2) == 0) x = level; \n                    else y = level;\n                }\n            }\n            addPoint(x,y);\n        }\n    }\n    else {\n        // Default: type == \"random\"\n        // Random points anywhere in [0, maxCoord].\n        while ((int)used.size() < n) {\n            long long x = rndLL(0, maxCoord);\n            long long y = rndLL(0, maxCoord);\n            addPoint(x, y);\n        }\n    }\n\n    // Now we have n distinct points in \"used\".\n    // Output them.\n    cout << n << \"\\n\";\n    for (auto &pt : used) {\n        cout << pt.first << \" \" << pt.second << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20 distinct commands to run this generator.\n# Each command prints one test case (to stdout). No output redirection is shown.\n\n# 1. A minimal test of size 1, random\n./gen -n 1 -type random\n\n# 2. A small test of size 5 in \"lineX\" pattern\n./gen -n 5 -type lineX\n\n# 3. A small test of size 5 in \"lineY\" pattern\n./gen -n 5 -type lineY\n\n# 4. A test of size 5 with \"diag\" pattern\n./gen -n 5 -type diag\n\n# 5. A small random test of size 10\n./gen -n 10 -type random\n\n# 6. A test of size 8 in \"corner\" style\n./gen -n 8 -type corner\n\n# 7. A test of size 10, exploring \"levels\"\n./gen -n 10 -type levels\n\n# 8. A test of size 12, \"small\" region\n./gen -n 12 -type small\n\n# 9. A test of size 12, \"large\" region; tries near 10^9\n./gen -n 12 -type large\n\n# 10. A bigger random test with n=50, default maxCoord=10^9\n./gen -n 50 -type random\n\n# 11. A bigger \"corner\" test with n=50\n./gen -n 50 -type corner\n\n# 12. A bigger \"levels\" test with n=50\n./gen -n 50 -type levels\n\n# 13. A test with n=100, \"lineX\"\n./gen -n 100 -type lineX\n\n# 14. A test with n=100, \"lineY\"\n./gen -n 100 -type lineY\n\n# 15. A test with n=100, \"diag\"\n./gen -n 100 -type diag\n\n# 16. A test with n=100, \"small\"\n./gen -n 100 -type small\n\n# 17. A random test with n=1000\n./gen -n 1000 -type random\n\n# 18. A large-level test with n=1000, \"levels\"\n./gen -n 1000 -type levels\n\n# 19. A large test with n=10000, \"random\"\n./gen -n 10000 -type random\n\n# 20. An even larger test with n=50000, \"large\"\n./gen -n 50000 -type large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:37.472345",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1067/A",
      "title": "A. Array Without Local Maximums",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputFirst line of input contains one integer nn (2≤n≤1052≤n≤105) — size of the array.Second line of input contains nn integers aiai — elements of array. Either ai=−1ai=−1 or 1≤ai≤2001≤ai≤200. ai=−1ai=−1 means that ii-th element can't be read.",
      "output_spec": "OutputPrint number of ways to restore the array modulo 998244353998244353.",
      "sample_tests": "ExamplesInputCopy31 -1 2OutputCopy1InputCopy2-1 -1OutputCopy200",
      "description": "A. Array Without Local Maximums\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of input contains one integer nn (2≤n≤1052≤n≤105) — size of the array.Second line of input contains nn integers aiai — elements of array. Either ai=−1ai=−1 or 1≤ai≤2001≤ai≤200. ai=−1ai=−1 means that ii-th element can't be read.\n\nOutputPrint number of ways to restore the array modulo 998244353998244353.\n\nInputCopy31 -1 2OutputCopy1InputCopy2-1 -1OutputCopy200\n\nInputCopy31 -1 2\n\nOutputCopy1\n\nInputCopy2-1 -1\n\nOutputCopy200\n\nNoteIn the first example, only possible value of a2a2 is 22.In the second example, a1=a2a1=a2 so there are 200200 different values because all restored elements should be integers between 11 and 200200.",
      "solutions": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces",
          "content": "I would like to invite you to participate in the rated Codeforces Round #518. Date and time of the round: Wednesday, October 24, 2018 at 18:05. The round was postponed from October 23 to October 24 because of the ICPC Indian Online Qualifier. This is the first competition I proposed. I hope you will enjoy it. The round will have 6 tasks for the second division and 5 tasks for first (3 problems are common). The contest will last for 2 hours. Tasks for you were prepared by Alexey kristevalex Kristev and Alexey Um_nik Danilyuk. Also thanks for: Nikolay KAN Kalinin and Ildar 300iq Gainullin for help in preparing the problems; Ivan isaf27 Safonov и Oleg Merkurev Merkurev for testing the round; Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon platforms. I would like to express a special gratitude to Um_nik for the help throughout the process of preparing the round and also for patience for my stupid questions. slight lyrical digressionAfter a lot of stupid questions... -Um_nik: The general rule is \"I'm not stupid\" This round is a thanks-round for support from Mail.Ru during the 8-year campaign!Scoring distribution will be announced later. I wish you a high rating and looking forward to see you at the competition!I'll be on the community Discord server shortly after the contest to discuss the problems.UPD: scoring distribution div1: 500 1000 1750 2250 2500 div2: 500 1250 1500 2250 2750 3500UPD2: edtorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62614",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1430
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces",
          "content": "1068A - BirthdayTo get LL new coins irrespective of the Ivan's collection he must get not less than L+KL+K coins as a present. Therefore each friend should gift at least X=⌈L+KM⌉X=⌈L+KM⌉ coins. But it may be not possible for all friends to gift XX coins if X⋅M>NX⋅M>N. Complexity is O(1)O(1). 1068B - LCM[a,b]a=b(a,b)[a,b]a=b(a,b), here (a,b)(a,b) is greatest common divisor. Let's see how many different values can have c=(a,b)c=(a,b). All values cc that divides bb are reachable if a=ca=c and every value of (a,b)(a,b) divides bb. So answer is number of divisors of bb. It can be calculated in O(b√)O(b) time. 1068C - Colored RooksLet's put rooks with color ii just on line number ii. Then, obviously, for any color the set of rooks of this color would be connected. Let's put rooks on positions (i,i)(i,i) for ii from 11 to nn. After that for any color there is a rook of this color on a board and for any two different colors aa bb union of set of rooks of color aa and set of rooks of color bb wouldn't be connected. And for final step we can do the following for every pair of harmonizing colors aa bb: let jj be index of first column without rooks, put rooks on cells (j,aj,a) and (j,bj,b). After that for colors aa bb union of set of rooks of color aa and set of rooks of color bb would become connected and for other pairs the connectedness doesn't change.Total number of rooks is n+2⋅mn+2⋅m. 1067A - Array Without Local Maximums Let's find solution with complexity O(n⋅a2)O(n⋅a2). We can count dp[prefix][a][flag]dp[prefix][a][flag] — quantity of ways to restore element from 11 to prefpref with last element equalls to aa, flag=0flag=0 means that previous element is less then the last or last element is first, flag=1flag=1 — the opposite. So dp[pref][a][0]=∑a−1i=1(dp[pref−1][i][1]+dp[pref−1][i][0])dp[pref][a][0]=∑i=1a−1(dp[pref−1][i][1]+dp[pref−1][i][0]), dp[pref][a][1]=dp[pref−1][a][0]+∑200i=adp[pref−1][i][1]dp[pref][a][1]=dp[pref−1][a][0]+∑i=a200dp[pref−1][i][1].Now let's count prefix_sums[a][flag]=∑ai=1dp[pref][i][flag]prefix_sums[a][flag]=∑i=1adp[pref][i][flag] on each prefix before counting all dp[pref]dp[pref], so we can recalculate dp in O(1) time.Complexity is O(n⋅a)O(n⋅a). 1067B - MultihedgehogSolution 1: Firstly let's find all vertices with degree 11. Now we can delete them and all, verticies which were incident to them must became verticies with degree 11. And also for each new veretice with degree 11 we must have already deleted not less then 33 verticies. If initial graph was kk-multihedgehog, after deleting vertices with degree 11 it would became k−1k−1-multihedgehog.It could be realised using bfs starting from all initial vertices with degree 11.Complexity is O(n)O(n).Solution 2: First of all let's find diametr of the graph. After that we can find middle vertex in diameter and check if it is a center of kk-multihedgehog using simple dfs.Complexity is O(n)O(n). 1067C - KnightsIf after some loops of the process we will have two neighboring lines with length xx total complexity of knights would be not less than O(x24)O(x24).In this construction:00 — initial placement.1,21,2 — added knights. Would be two neighboring lines with length O(2⋅n3)O(2⋅n3) so total complexity of knights would be O((2⋅n3)24)=O(n29)O((2⋅n3)24)=O(n29).The possible way to facilitate the invention this (or over) solutions is to write process modeling.Bonus: Solve this problem with complexity O(n26)O(n26). 1067D - Computer GameLet's denote max(bipi)max(bipi) as MM. Independent of our strategy we cannot get more than MM in one second (in expected value). But if we could upgrade one quest, we would upgrade the quest which maximizes bipibipi and then try to complete only this quest each second, thus getting +M+M to expected value each second. Therefore, our strategy looks like this: try to complete quests in some order, once we complete one quest we will always get +M+M to expected value each second.This observation leads to DP solution. Once we have one quest completed we already know what we will get, so interesting states are only those in which no quests are completed yet. Then it is not important what quests we tried to complete before, the only important parameter is remaining time.dpt+1=max(pi(ai+tM)+(1−pi)dpt)dpt+1=max(pi(ai+tM)+(1−pi)dpt).If we succeed then we will get aiai as a reward and for remaining tt seconds we will get MM each second, otherwise we get nothing and now only tt seconds left. This solution works in O(nT)O(nT) time which is too slow.We can slightly rewrite the formula for transition: dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai)dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai).Now we can see that we take maximum value of functions pi⋅x+piaipi⋅x+piai in point xt=tM−dptxt=tM−dpt. We can build convex hull on these lines thus getting O(nlogn+Tlogn)O(nlog⁡n+Tlog⁡n) solution.But that's not all. We can actually prove that xt≤xt+1xt≤xt+1 or, after some substitutions and simplifications, dpt+1−dpt≤Mdpt+1−dpt≤M. This we will prove by actual meaning of dptdpt. Take optimal solution for t+1t+1 seconds and do the same for tt seconds, except that we don't have last second, so we will just drop our action. But we can't gain more than MM in one second, so this drop cannot decrease answer more than MM. Thus the inequality is proven.This means that we only move right along over convex hull, so for each line there will be consecutive seconds in which we are using that line. If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster.Let's start with learning how to make many DP transitions (when we are staying on one line for the whole time). It is more clear using first formula for DP transition: dpt+1=pi(ai+tM)+(1−pi)dptdpt+1=pi(ai+tM)+(1−pi)dpt (we don't have max now because we already know which line to use). We can see that to get vector (dpt+1t+11)T(dpt+1t+11)T from vector (dptt1)T(dptt1)T we can apply linear transformation i.e. multiply by some matrix:⎛⎝⎜dpt+1t+11⎞⎠⎟=⎛⎝⎜1−pi00piM10piai11⎞⎠⎟⎛⎝⎜dptt1⎞⎠⎟(dpt+1t+11)=(1−pipiMpiai011001)(dptt1)To apply it kk times just use binary exponentiation to get kk-th power of transition matrix.To determine how long we actually have to stay on given line we will use binary search on answer. We know for which value of xx we should move to the next line and we know that xx increases with each second, so we can try to stay on given line for some time and see if we should actually change the line.This is already O(n(logn+log2T))O(n(log⁡n+log2⁡T)) solution, but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time.Final complexity is O(n(logn+logT))O(n(log⁡n+log⁡T)) 1067E - Random Forest RankI'll try to explain how to come up with this solution rather than just state the fact. For those who are more interested in getting AC, here is your fact: rank of a forest is twice the size of maximal matching.When we see expected value, we usually want to somehow rewrite the thing under the expected value, apply linearity of expectation and then calculate some independent values. But that's not the case: rank behave strangely and we cannot rewrite it as sum of something, at least I don't know any such solutions (if you do, please write them in the comments). So it looks like we are forced to understand what rank is.The rank of a matrix is a size of its largest non-vanishing minor. But our matrix is symmetric, maybe we can look only at symmetric minors (in a sense that we use the same set of rows and columns)? This is actually true but it is just a fact from linear algebra (seems to be not very well known) and has little to do with our problem, so I'll drop its proof and if someone is interested, ask me in comments.Why do we like symmetric minors? Because they correspond to induced subgraphs of our graph. And all induced subgraphs of a forest are forests too! So let's study when a forest has full rank.To do it, let's calculate determinant of its matrix. Matrix has full rank iff its determinant is non-zero. Let's write a determinant as a sum over all permutations.detA=∑π∏ni=1AiπidetA=∑π∏i=1nAiπiIf Aiπi≠0Aiπi≠0 then we have edge (i,πi)(i,πi) in our forest. Each permutation is a product of independent cycles. So to have non-zero product ∏ni=1Aiπi∏i=1nAiπi all the permutation cycles should be cycles in the forest. But forests have no cycles without repeating vertices! Well, actually they do: each edge generate one cycle of length 22. And that's all, there are no other cycles in forest (11 vertex is not a cycle, because we don't have self-loops). To have non-zero product ∏ni=1Aiπi∏i=1nAiπi all cycles of permutation must have length 22 and correspond to edges of forest. So we can divide all vertices in pairs, and in each pair there is an edge. That's the definition of perfect matching. Why can't they still result in zero sum? Because if there is a perfect matching in a forest then it is unique, so we actually have no more than one non-zero summand.OK, forest has full rank is equivalent to forest has perfect matching. Suppose that mm is the size of maximal matching of a forest. Then no its induced subgraph of size strictly greater than 2m2m can have perfect matching. And there is a subgraph of size exactly 2m2m which does have perfect matching: the ends of edges in maximal matching.Cool, we have proven the fact from the beginning. If you just want AC, continue reading from here. Now we have to calculate expected size of maximal matching. That sound much easier: we already have a linear DP which calculates maximal matching, and its values are exactly sizes of current maximal matching. To remind: dp[v][taken]dp[v][taken] is a size of maximal matching in subtree rooted at vv where boolean flag takentaken means did we already cover vertex vv or is it still free. All we have to do is to change the value stored in DP for expected value and also calculate probabilities to actually be in state with given flag takentaken.Complexity — O(n)O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62688",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1067\\s*A"
          },
          "content_length": 10105
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 1",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 2",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 3",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 4",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 5",
          "code": "-1 200 -1 200 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 6",
          "code": "Participant's output -501767591",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 1",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 2",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 3",
          "code": "After that we can find middle vertex in diameter and check if it is a center of k-multihedgehog using simple dfs.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidNumber(const string& s, int& x) {\n    if (s.empty())\n        return false;\n    if (s.size() > 3)\n        return false; // Max number is 200\n    for (char c : s) {\n        if (!isdigit(c))\n            return false;\n    }\n    if (s[0] == '0')\n        return false; // Leading zeros are not allowed\n    x = stoi(s);\n    if (x < 1 || x > 200)\n        return false;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000);\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken();\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n        if (s == \"-1\") {\n            // OK\n            continue;\n        }\n        int x;\n        if (isValidNumber(s, x)) {\n            // OK\n        } else {\n            ensuref(false, \"a[%d] is invalid\", i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidNumber(const string& s, int& x) {\n    if (s.empty())\n        return false;\n    if (s.size() > 3)\n        return false; // Max number is 200\n    for (char c : s) {\n        if (!isdigit(c))\n            return false;\n    }\n    if (s[0] == '0')\n        return false; // Leading zeros are not allowed\n    x = stoi(s);\n    if (x < 1 || x > 200)\n        return false;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000);\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken();\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n        if (s == \"-1\") {\n            // OK\n            continue;\n        }\n        int x;\n        if (isValidNumber(s, x)) {\n            // OK\n        } else {\n            ensuref(false, \"a[%d] is invalid\", i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidNumber(const string& s, int& x) {\n    if (s.empty())\n        return false;\n    if (s.size() > 3)\n        return false; // Max number is 200\n    for (char c : s) {\n        if (!isdigit(c))\n            return false;\n    }\n    if (s[0] == '0')\n        return false; // Leading zeros are not allowed\n    x = stoi(s);\n    if (x < 1 || x > 200)\n        return false;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000);\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken();\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n        if (s == \"-1\") {\n            // OK\n            continue;\n        }\n        int x;\n        if (isValidNumber(s, x)) {\n            // OK\n        } else {\n            ensuref(false, \"a[%d] is invalid\", i);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n + 2, -1); // use 1-based indexing, pad with extra elements for easy indexing\n    const int MIN_VAL = 1;\n    const int MAX_VAL = 200;\n\n    if (type == \"random\") {\n        // Generate an array with random values\n        int val = rnd.next(MIN_VAL, MAX_VAL);\n        for (int i = 1; i <= n; ++i) {\n            a[i] = val;\n        }\n\n        // Randomly set some positions to -1\n        for (int i = 1; i <= n; ++i) {\n            if (rnd.next(0, 1)) {\n                a[i] = -1;\n            }\n        }\n\n    } else if (type == \"all_neg1\") {\n        // All elements are -1\n        for (int i = 1; i <= n; ++i) {\n            a[i] = -1;\n        }\n\n    } else if (type == \"no_neg1\") {\n        // Generate an array with random values satisfying the constraints\n        a[1] = rnd.next(MIN_VAL, MAX_VAL);\n        for (int i = 2; i <= n; ++i) {\n            int minVal = a[i - 1]; // since a[i - 1] ≤ a[i] for i = 2\n            int maxVal = MAX_VAL;\n            a[i] = rnd.next(minVal, maxVal);\n\n            if (i < n) {\n                // For positions 2 to n - 1, ensure a_i ≤ max(a_{i-1}, a_{i+1})\n                // Since a_{i+1} is unknown yet, use MAX_VAL\n                int maxAllowed = max(a[i - 1], MAX_VAL);\n                if (a[i] > maxAllowed) {\n                    a[i] = maxAllowed;\n                }\n            }\n        }\n        // Ensure a_n ≤ a_{n - 1}\n        if (a[n] > a[n - 1]) {\n            a[n] = a[n - 1];\n        }\n\n    } else if (type == \"alternate_neg1\") {\n        // Alternate elements are -1\n        a[1] = rnd.next(MIN_VAL, MAX_VAL);\n        for (int i = 2; i <= n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = -1;\n            } else {\n                // Ensure constraints\n                int minVal = a[i - 1];\n                int maxVal = MAX_VAL;\n                if (i < n) {\n                    maxVal = max(a[i - 1], MAX_VAL);\n                }\n                a[i] = rnd.next(minVal, maxVal);\n            }\n        }\n        if (n % 2 == 0 && a[n - 1] != -1) {\n            // Ensure a_n ≤ a_{n - 1}\n            a[n] = rnd.next(MIN_VAL, a[n - 1]);\n        } else {\n            a[n] = -1;\n        }\n\n    } else if (type == \"max_ways\") {\n        // Maximize the number of ways\n        // Set all elements to -1\n        for (int i = 1; i <= n; ++i) {\n            a[i] = -1;\n        }\n\n    } else if (type == \"min_ways\") {\n        // Minimize the number of ways\n        // Set a[1] = MIN_VAL, a[n] = MIN_VAL, rest are -1\n        a[1] = MIN_VAL;\n        a[n] = MIN_VAL;\n        for (int i = 2; i < n; ++i) {\n            a[i] = -1;\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate an impossible case\n        if (n < 3) {\n            // Cannot generate impossible case for n < 3\n            n = 3;\n        }\n        a[1] = MAX_VAL;\n        a[2] = -1;\n        a[3] = MIN_VAL;\n        for (int i = 4; i <= n; ++i) {\n            a[i] = -1;\n        }\n\n    } else if (type == \"small_n\") {\n        // n is small, generate various cases\n        n = 2;\n        a[1] = rnd.next(MIN_VAL, MAX_VAL);\n        a[2] = rnd.next(a[1], MAX_VAL);\n\n    } else if (type == \"max_n\") {\n        // n is maximum, generate large test case\n        n = 100000;\n        // All elements are -1\n        for (int i = 1; i <= n; ++i) {\n            a[i] = -1;\n        }\n\n    } else {\n        // Default to random values\n        for (int i = 1; i <= n; ++i) {\n            a[i] = rnd.next(MIN_VAL, MAX_VAL);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        if (i > 1) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n + 2, -1); // use 1-based indexing, pad with extra elements for easy indexing\n    const int MIN_VAL = 1;\n    const int MAX_VAL = 200;\n\n    if (type == \"random\") {\n        // Generate an array with random values\n        int val = rnd.next(MIN_VAL, MAX_VAL);\n        for (int i = 1; i <= n; ++i) {\n            a[i] = val;\n        }\n\n        // Randomly set some positions to -1\n        for (int i = 1; i <= n; ++i) {\n            if (rnd.next(0, 1)) {\n                a[i] = -1;\n            }\n        }\n\n    } else if (type == \"all_neg1\") {\n        // All elements are -1\n        for (int i = 1; i <= n; ++i) {\n            a[i] = -1;\n        }\n\n    } else if (type == \"no_neg1\") {\n        // Generate an array with random values satisfying the constraints\n        a[1] = rnd.next(MIN_VAL, MAX_VAL);\n        for (int i = 2; i <= n; ++i) {\n            int minVal = a[i - 1]; // since a[i - 1] ≤ a[i] for i = 2\n            int maxVal = MAX_VAL;\n            a[i] = rnd.next(minVal, maxVal);\n\n            if (i < n) {\n                // For positions 2 to n - 1, ensure a_i ≤ max(a_{i-1}, a_{i+1})\n                // Since a_{i+1} is unknown yet, use MAX_VAL\n                int maxAllowed = max(a[i - 1], MAX_VAL);\n                if (a[i] > maxAllowed) {\n                    a[i] = maxAllowed;\n                }\n            }\n        }\n        // Ensure a_n ≤ a_{n - 1}\n        if (a[n] > a[n - 1]) {\n            a[n] = a[n - 1];\n        }\n\n    } else if (type == \"alternate_neg1\") {\n        // Alternate elements are -1\n        a[1] = rnd.next(MIN_VAL, MAX_VAL);\n        for (int i = 2; i <= n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = -1;\n            } else {\n                // Ensure constraints\n                int minVal = a[i - 1];\n                int maxVal = MAX_VAL;\n                if (i < n) {\n                    maxVal = max(a[i - 1], MAX_VAL);\n                }\n                a[i] = rnd.next(minVal, maxVal);\n            }\n        }\n        if (n % 2 == 0 && a[n - 1] != -1) {\n            // Ensure a_n ≤ a_{n - 1}\n            a[n] = rnd.next(MIN_VAL, a[n - 1]);\n        } else {\n            a[n] = -1;\n        }\n\n    } else if (type == \"max_ways\") {\n        // Maximize the number of ways\n        // Set all elements to -1\n        for (int i = 1; i <= n; ++i) {\n            a[i] = -1;\n        }\n\n    } else if (type == \"min_ways\") {\n        // Minimize the number of ways\n        // Set a[1] = MIN_VAL, a[n] = MIN_VAL, rest are -1\n        a[1] = MIN_VAL;\n        a[n] = MIN_VAL;\n        for (int i = 2; i < n; ++i) {\n            a[i] = -1;\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate an impossible case\n        if (n < 3) {\n            // Cannot generate impossible case for n < 3\n            n = 3;\n        }\n        a[1] = MAX_VAL;\n        a[2] = -1;\n        a[3] = MIN_VAL;\n        for (int i = 4; i <= n; ++i) {\n            a[i] = -1;\n        }\n\n    } else if (type == \"small_n\") {\n        // n is small, generate various cases\n        n = 2;\n        a[1] = rnd.next(MIN_VAL, MAX_VAL);\n        a[2] = rnd.next(a[1], MAX_VAL);\n\n    } else if (type == \"max_n\") {\n        // n is maximum, generate large test case\n        n = 100000;\n        // All elements are -1\n        for (int i = 1; i <= n; ++i) {\n            a[i] = -1;\n        }\n\n    } else {\n        // Default to random values\n        for (int i = 1; i <= n; ++i) {\n            a[i] = rnd.next(MIN_VAL, MAX_VAL);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        if (i > 1) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type small_n\n./gen -n 3 -type impossible\n\n./gen -n 10 -type random\n./gen -n 10 -type all_neg1\n./gen -n 10 -type alternate_neg1\n./gen -n 10 -type min_ways\n./gen -n 10 -type max_ways\n\n./gen -n 100 -type random\n./gen -n 100 -type all_neg1\n./gen -n 100 -type no_neg1\n./gen -n 100 -type max_ways\n./gen -n 100 -type min_ways\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_neg1\n./gen -n 1000 -type alternate_neg1\n./gen -n 1000 -type max_ways\n\n./gen -n 10000 -type random\n./gen -n 10000 -type all_neg1\n./gen -n 10000 -type no_neg1\n./gen -n 10000 -type min_ways\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_neg1\n./gen -n 100000 -type max_n\n./gen -n 100000 -type min_ways\n./gen -n 100000 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:39.083589",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1067/B",
      "title": "B. Multihedgehog",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of input contains 22 integers nn, kk (1≤n≤1051≤n≤105, 1≤k≤1091≤k≤109) — number of vertices and hedgehog parameter.Next n−1n−1 lines contains two integers uu vv (1≤u,v≤n;u≠v1≤u,v≤n;u≠v) — indices of vertices connected by edge.It is guaranteed that given graph is a tree.",
      "output_spec": "OutputPrint \"Yes\" (without quotes), if given graph is kk-multihedgehog, and \"No\" (without quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy14 21 42 43 44 1310 511 512 514 55 136 78 613 69 6OutputCopyYesInputCopy3 11 32 3OutputCopyNo",
      "description": "B. Multihedgehog\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of input contains 22 integers nn, kk (1≤n≤1051≤n≤105, 1≤k≤1091≤k≤109) — number of vertices and hedgehog parameter.Next n−1n−1 lines contains two integers uu vv (1≤u,v≤n;u≠v1≤u,v≤n;u≠v) — indices of vertices connected by edge.It is guaranteed that given graph is a tree.\n\nOutputPrint \"Yes\" (without quotes), if given graph is kk-multihedgehog, and \"No\" (without quotes) otherwise.\n\nInputCopy14 21 42 43 44 1310 511 512 514 55 136 78 613 69 6OutputCopyYesInputCopy3 11 32 3OutputCopyNo\n\nInputCopy14 21 42 43 44 1310 511 512 514 55 136 78 613 69 6\n\nOutputCopyYes\n\nInputCopy3 11 32 3\n\nOutputCopyNo\n\nNote2-multihedgehog from the first example looks like this:Its center is vertex 1313. Hedgehogs created on last step are: [4 (center), 1, 2, 3], [6 (center), 7, 8, 9], [5 (center), 10, 11, 12, 13].Tree from second example is not a hedgehog because degree of center should be at least 33.",
      "solutions": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces",
          "content": "I would like to invite you to participate in the rated Codeforces Round #518. Date and time of the round: Wednesday, October 24, 2018 at 18:05. The round was postponed from October 23 to October 24 because of the ICPC Indian Online Qualifier. This is the first competition I proposed. I hope you will enjoy it. The round will have 6 tasks for the second division and 5 tasks for first (3 problems are common). The contest will last for 2 hours. Tasks for you were prepared by Alexey kristevalex Kristev and Alexey Um_nik Danilyuk. Also thanks for: Nikolay KAN Kalinin and Ildar 300iq Gainullin for help in preparing the problems; Ivan isaf27 Safonov и Oleg Merkurev Merkurev for testing the round; Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon platforms. I would like to express a special gratitude to Um_nik for the help throughout the process of preparing the round and also for patience for my stupid questions. slight lyrical digressionAfter a lot of stupid questions... -Um_nik: The general rule is \"I'm not stupid\" This round is a thanks-round for support from Mail.Ru during the 8-year campaign!Scoring distribution will be announced later. I wish you a high rating and looking forward to see you at the competition!I'll be on the community Discord server shortly after the contest to discuss the problems.UPD: scoring distribution div1: 500 1000 1750 2250 2500 div2: 500 1250 1500 2250 2750 3500UPD2: edtorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62614",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1430
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces",
          "content": "1068A - BirthdayTo get LL new coins irrespective of the Ivan's collection he must get not less than L+KL+K coins as a present. Therefore each friend should gift at least X=⌈L+KM⌉X=⌈L+KM⌉ coins. But it may be not possible for all friends to gift XX coins if X⋅M>NX⋅M>N. Complexity is O(1)O(1). 1068B - LCM[a,b]a=b(a,b)[a,b]a=b(a,b), here (a,b)(a,b) is greatest common divisor. Let's see how many different values can have c=(a,b)c=(a,b). All values cc that divides bb are reachable if a=ca=c and every value of (a,b)(a,b) divides bb. So answer is number of divisors of bb. It can be calculated in O(b√)O(b) time. 1068C - Colored RooksLet's put rooks with color ii just on line number ii. Then, obviously, for any color the set of rooks of this color would be connected. Let's put rooks on positions (i,i)(i,i) for ii from 11 to nn. After that for any color there is a rook of this color on a board and for any two different colors aa bb union of set of rooks of color aa and set of rooks of color bb wouldn't be connected. And for final step we can do the following for every pair of harmonizing colors aa bb: let jj be index of first column without rooks, put rooks on cells (j,aj,a) and (j,bj,b). After that for colors aa bb union of set of rooks of color aa and set of rooks of color bb would become connected and for other pairs the connectedness doesn't change.Total number of rooks is n+2⋅mn+2⋅m. 1067A - Array Without Local Maximums Let's find solution with complexity O(n⋅a2)O(n⋅a2). We can count dp[prefix][a][flag]dp[prefix][a][flag] — quantity of ways to restore element from 11 to prefpref with last element equalls to aa, flag=0flag=0 means that previous element is less then the last or last element is first, flag=1flag=1 — the opposite. So dp[pref][a][0]=∑a−1i=1(dp[pref−1][i][1]+dp[pref−1][i][0])dp[pref][a][0]=∑i=1a−1(dp[pref−1][i][1]+dp[pref−1][i][0]), dp[pref][a][1]=dp[pref−1][a][0]+∑200i=adp[pref−1][i][1]dp[pref][a][1]=dp[pref−1][a][0]+∑i=a200dp[pref−1][i][1].Now let's count prefix_sums[a][flag]=∑ai=1dp[pref][i][flag]prefix_sums[a][flag]=∑i=1adp[pref][i][flag] on each prefix before counting all dp[pref]dp[pref], so we can recalculate dp in O(1) time.Complexity is O(n⋅a)O(n⋅a). 1067B - MultihedgehogSolution 1: Firstly let's find all vertices with degree 11. Now we can delete them and all, verticies which were incident to them must became verticies with degree 11. And also for each new veretice with degree 11 we must have already deleted not less then 33 verticies. If initial graph was kk-multihedgehog, after deleting vertices with degree 11 it would became k−1k−1-multihedgehog.It could be realised using bfs starting from all initial vertices with degree 11.Complexity is O(n)O(n).Solution 2: First of all let's find diametr of the graph. After that we can find middle vertex in diameter and check if it is a center of kk-multihedgehog using simple dfs.Complexity is O(n)O(n). 1067C - KnightsIf after some loops of the process we will have two neighboring lines with length xx total complexity of knights would be not less than O(x24)O(x24).In this construction:00 — initial placement.1,21,2 — added knights. Would be two neighboring lines with length O(2⋅n3)O(2⋅n3) so total complexity of knights would be O((2⋅n3)24)=O(n29)O((2⋅n3)24)=O(n29).The possible way to facilitate the invention this (or over) solutions is to write process modeling.Bonus: Solve this problem with complexity O(n26)O(n26). 1067D - Computer GameLet's denote max(bipi)max(bipi) as MM. Independent of our strategy we cannot get more than MM in one second (in expected value). But if we could upgrade one quest, we would upgrade the quest which maximizes bipibipi and then try to complete only this quest each second, thus getting +M+M to expected value each second. Therefore, our strategy looks like this: try to complete quests in some order, once we complete one quest we will always get +M+M to expected value each second.This observation leads to DP solution. Once we have one quest completed we already know what we will get, so interesting states are only those in which no quests are completed yet. Then it is not important what quests we tried to complete before, the only important parameter is remaining time.dpt+1=max(pi(ai+tM)+(1−pi)dpt)dpt+1=max(pi(ai+tM)+(1−pi)dpt).If we succeed then we will get aiai as a reward and for remaining tt seconds we will get MM each second, otherwise we get nothing and now only tt seconds left. This solution works in O(nT)O(nT) time which is too slow.We can slightly rewrite the formula for transition: dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai)dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai).Now we can see that we take maximum value of functions pi⋅x+piaipi⋅x+piai in point xt=tM−dptxt=tM−dpt. We can build convex hull on these lines thus getting O(nlogn+Tlogn)O(nlog⁡n+Tlog⁡n) solution.But that's not all. We can actually prove that xt≤xt+1xt≤xt+1 or, after some substitutions and simplifications, dpt+1−dpt≤Mdpt+1−dpt≤M. This we will prove by actual meaning of dptdpt. Take optimal solution for t+1t+1 seconds and do the same for tt seconds, except that we don't have last second, so we will just drop our action. But we can't gain more than MM in one second, so this drop cannot decrease answer more than MM. Thus the inequality is proven.This means that we only move right along over convex hull, so for each line there will be consecutive seconds in which we are using that line. If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster.Let's start with learning how to make many DP transitions (when we are staying on one line for the whole time). It is more clear using first formula for DP transition: dpt+1=pi(ai+tM)+(1−pi)dptdpt+1=pi(ai+tM)+(1−pi)dpt (we don't have max now because we already know which line to use). We can see that to get vector (dpt+1t+11)T(dpt+1t+11)T from vector (dptt1)T(dptt1)T we can apply linear transformation i.e. multiply by some matrix:⎛⎝⎜dpt+1t+11⎞⎠⎟=⎛⎝⎜1−pi00piM10piai11⎞⎠⎟⎛⎝⎜dptt1⎞⎠⎟(dpt+1t+11)=(1−pipiMpiai011001)(dptt1)To apply it kk times just use binary exponentiation to get kk-th power of transition matrix.To determine how long we actually have to stay on given line we will use binary search on answer. We know for which value of xx we should move to the next line and we know that xx increases with each second, so we can try to stay on given line for some time and see if we should actually change the line.This is already O(n(logn+log2T))O(n(log⁡n+log2⁡T)) solution, but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time.Final complexity is O(n(logn+logT))O(n(log⁡n+log⁡T)) 1067E - Random Forest RankI'll try to explain how to come up with this solution rather than just state the fact. For those who are more interested in getting AC, here is your fact: rank of a forest is twice the size of maximal matching.When we see expected value, we usually want to somehow rewrite the thing under the expected value, apply linearity of expectation and then calculate some independent values. But that's not the case: rank behave strangely and we cannot rewrite it as sum of something, at least I don't know any such solutions (if you do, please write them in the comments). So it looks like we are forced to understand what rank is.The rank of a matrix is a size of its largest non-vanishing minor. But our matrix is symmetric, maybe we can look only at symmetric minors (in a sense that we use the same set of rows and columns)? This is actually true but it is just a fact from linear algebra (seems to be not very well known) and has little to do with our problem, so I'll drop its proof and if someone is interested, ask me in comments.Why do we like symmetric minors? Because they correspond to induced subgraphs of our graph. And all induced subgraphs of a forest are forests too! So let's study when a forest has full rank.To do it, let's calculate determinant of its matrix. Matrix has full rank iff its determinant is non-zero. Let's write a determinant as a sum over all permutations.detA=∑π∏ni=1AiπidetA=∑π∏i=1nAiπiIf Aiπi≠0Aiπi≠0 then we have edge (i,πi)(i,πi) in our forest. Each permutation is a product of independent cycles. So to have non-zero product ∏ni=1Aiπi∏i=1nAiπi all the permutation cycles should be cycles in the forest. But forests have no cycles without repeating vertices! Well, actually they do: each edge generate one cycle of length 22. And that's all, there are no other cycles in forest (11 vertex is not a cycle, because we don't have self-loops). To have non-zero product ∏ni=1Aiπi∏i=1nAiπi all cycles of permutation must have length 22 and correspond to edges of forest. So we can divide all vertices in pairs, and in each pair there is an edge. That's the definition of perfect matching. Why can't they still result in zero sum? Because if there is a perfect matching in a forest then it is unique, so we actually have no more than one non-zero summand.OK, forest has full rank is equivalent to forest has perfect matching. Suppose that mm is the size of maximal matching of a forest. Then no its induced subgraph of size strictly greater than 2m2m can have perfect matching. And there is a subgraph of size exactly 2m2m which does have perfect matching: the ends of edges in maximal matching.Cool, we have proven the fact from the beginning. If you just want AC, continue reading from here. Now we have to calculate expected size of maximal matching. That sound much easier: we already have a linear DP which calculates maximal matching, and its values are exactly sizes of current maximal matching. To remind: dp[v][taken]dp[v][taken] is a size of maximal matching in subtree rooted at vv where boolean flag takentaken means did we already cover vertex vv or is it still free. All we have to do is to change the value stored in DP for expected value and also calculate probabilities to actually be in state with given flag takentaken.Complexity — O(n)O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62688",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1067\\s*B"
          },
          "content_length": 10105
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 1",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 2",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 3",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 4",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 5",
          "code": "-1 200 -1 200 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 6",
          "code": "Participant's output -501767591",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 1",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 2",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 3",
          "code": "After that we can find middle vertex in diameter and check if it is a center of k-multihedgehog using simple dfs.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint parent[MAX_N + 1];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nbool unite(int u, int v) {\n    int fu = find(u);\n    int fv = find(v);\n    if (fu == fv)\n        return false; // cycle detected\n    parent[fu] = fv;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_\" + vtos(i+1));\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_\" + vtos(i+1));\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d: u and v must be different, but u = v = %d\", i+1, u);\n        if (!unite(u, v)) {\n            ensuref(false, \"Graph contains a cycle due to edge %d connecting %d and %d\", i+1, u, v);\n        } else {\n            components--;\n        }\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint parent[MAX_N + 1];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nbool unite(int u, int v) {\n    int fu = find(u);\n    int fv = find(v);\n    if (fu == fv)\n        return false; // cycle detected\n    parent[fu] = fv;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_\" + vtos(i+1));\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_\" + vtos(i+1));\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d: u and v must be different, but u = v = %d\", i+1, u);\n        if (!unite(u, v)) {\n            ensuref(false, \"Graph contains a cycle due to edge %d connecting %d and %d\", i+1, u, v);\n        } else {\n            components--;\n        }\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint parent[MAX_N + 1];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nbool unite(int u, int v) {\n    int fu = find(u);\n    int fv = find(v);\n    if (fu == fv)\n        return false; // cycle detected\n    parent[fu] = fv;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u_\" + vtos(i+1));\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_\" + vtos(i+1));\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d: u and v must be different, but u = v = %d\", i+1, u);\n        if (!unite(u, v)) {\n            ensuref(false, \"Graph contains a cycle due to edge %d connecting %d and %d\", i+1, u, v);\n        } else {\n            components--;\n        }\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"valid\");\n\n    if (type == \"valid\") {\n        // Generate a valid k-multihedgehog\n\n        // We need to generate a k-multihedgehog with depth k\n        // We will build the tree level by level\n        // Each center node will have degree at least 3\n        int d = 3; // Degree of centers\n\n        // Calculate the number of nodes needed for given k and d\n        // Total nodes N = 1 + 9 * (2^k -1)\n        // Adjusted for d:\n        // total_nodes = 1 + d^2 * ((d -1)^{k} -1) / (d -2)\n\n        // For d=3:\n        // total_nodes = 1 + 9*(2^k -1)\n        int total_nodes = 1 + d * d * (pow(d -1, k) -1) / (d -2);\n\n        if (total_nodes > n) {\n            // Decrease k or adjust accordingly\n            // For simplicity, let's limit k to fit n\n            // Compute maximum k such that total_nodes <= n\n            k = 0;\n            while (true) {\n                int required_nodes = 1 + d * d * (pow(d -1, k) -1) / (d -2);\n                if (required_nodes > n)\n                    break;\n                k++;\n            }\n            k--; // k is now the maximum possible\n        }\n\n        vector<pair<int, int>> edges;\n        int node_id = 1;\n        queue<int> centers;\n        centers.push(node_id++); // Root center\n\n        for (int level = 1; level <= k; level++) {\n            int num_centers = centers.size();\n            queue<int> next_centers;\n            while (num_centers--) {\n                int parent_center = centers.front();\n                centers.pop();\n\n                // Create d leaves or hedgehogs\n                for (int i = 0; i < d; i++) {\n                    if (node_id > n) break;\n\n                    int new_center = node_id++;\n                    edges.push_back({parent_center, new_center});\n\n                    if (level < k) {\n                        // Next level centers\n                        next_centers.push(new_center);\n                    }\n\n                    // Attach (d -1) leaves to new_center\n                    for (int j = 0; j < d -1; j++) {\n                        if (node_id > n) break;\n                        edges.push_back({new_center, node_id++});\n                    }\n                }\n            }\n            centers = next_centers;\n        }\n\n        // Output n\n        printf(\"%d %d\\n\", node_id -1, k);\n        // Output edges\n        for (auto& edge : edges) {\n            printf(\"%d %d\\n\", edge.first, edge.second);\n        }\n\n    } else if (type == \"invalid_center_degree\") {\n        // Generate an invalid tree, where centers have degree less than 3\n        // For simplicity, generate a star with center degree 2\n        if (n < 3) n = 3;\n        printf(\"%d %d\\n\", n, k);\n\n        // Center node 1\n        for (int i = 2; i <= n; i++) {\n            printf(\"%d %d\\n\", 1, i);\n        }\n\n    } else if (type == \"invalid_depth\") {\n        // Generate a valid hedgehog but with depth less than k\n        // We construct a k' -multihedgehog where k' < k\n        // Set smaller k'\n        int k_prime = k -1;\n        if (k_prime < 1) k_prime = 1;\n\n        int d = 3; // Degree of centers\n\n        vector<pair<int, int>> edges;\n        int node_id = 1;\n        queue<int> centers;\n        centers.push(node_id++); // Root center\n\n        for (int level = 1; level <= k_prime; level++) {\n            int num_centers = centers.size();\n            queue<int> next_centers;\n            while (num_centers--) {\n                int parent_center = centers.front();\n                centers.pop();\n\n                // Create d leaves or hedgehogs\n                for (int i = 0; i < d; i++) {\n                    if (node_id > n) break;\n\n                    int new_center = node_id++;\n                    edges.push_back({parent_center, new_center});\n\n                    if (level < k_prime) {\n                        // Next level centers\n                        next_centers.push(new_center);\n                    }\n\n                    // Attach (d -1) leaves to new_center\n                    for (int j = 0; j < d -1; j++) {\n                        if (node_id > n) break;\n                        edges.push_back({new_center, node_id++});\n                    }\n                }\n            }\n            centers = next_centers;\n        }\n\n        // Output n\n        printf(\"%d %d\\n\", node_id -1, k);\n        // Output edges\n        for (auto& edge : edges) {\n            printf(\"%d %d\\n\", edge.first, edge.second);\n        }\n\n    } else if (type == \"random_tree\") {\n        // Generate a random tree of n nodes\n        printf(\"%d %d\\n\", n, k);\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) {\n            nodes[i] = i +1;\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        for (int i = 1; i < n; ++i) {\n            int u = nodes[i];\n            int v = nodes[rnd.next(0, i-1)];\n            printf(\"%d %d\\n\", u, v);\n        }\n\n    } else {\n        // Default: Output a random valid k-multihedgehog\n        // Same as \"valid\" type\n        // For brevity, we can call the valid case code here\n        // ... (same as the \"valid\" case)\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"valid\");\n\n    if (type == \"valid\") {\n        // Generate a valid k-multihedgehog\n\n        // We need to generate a k-multihedgehog with depth k\n        // We will build the tree level by level\n        // Each center node will have degree at least 3\n        int d = 3; // Degree of centers\n\n        // Calculate the number of nodes needed for given k and d\n        // Total nodes N = 1 + 9 * (2^k -1)\n        // Adjusted for d:\n        // total_nodes = 1 + d^2 * ((d -1)^{k} -1) / (d -2)\n\n        // For d=3:\n        // total_nodes = 1 + 9*(2^k -1)\n        int total_nodes = 1 + d * d * (pow(d -1, k) -1) / (d -2);\n\n        if (total_nodes > n) {\n            // Decrease k or adjust accordingly\n            // For simplicity, let's limit k to fit n\n            // Compute maximum k such that total_nodes <= n\n            k = 0;\n            while (true) {\n                int required_nodes = 1 + d * d * (pow(d -1, k) -1) / (d -2);\n                if (required_nodes > n)\n                    break;\n                k++;\n            }\n            k--; // k is now the maximum possible\n        }\n\n        vector<pair<int, int>> edges;\n        int node_id = 1;\n        queue<int> centers;\n        centers.push(node_id++); // Root center\n\n        for (int level = 1; level <= k; level++) {\n            int num_centers = centers.size();\n            queue<int> next_centers;\n            while (num_centers--) {\n                int parent_center = centers.front();\n                centers.pop();\n\n                // Create d leaves or hedgehogs\n                for (int i = 0; i < d; i++) {\n                    if (node_id > n) break;\n\n                    int new_center = node_id++;\n                    edges.push_back({parent_center, new_center});\n\n                    if (level < k) {\n                        // Next level centers\n                        next_centers.push(new_center);\n                    }\n\n                    // Attach (d -1) leaves to new_center\n                    for (int j = 0; j < d -1; j++) {\n                        if (node_id > n) break;\n                        edges.push_back({new_center, node_id++});\n                    }\n                }\n            }\n            centers = next_centers;\n        }\n\n        // Output n\n        printf(\"%d %d\\n\", node_id -1, k);\n        // Output edges\n        for (auto& edge : edges) {\n            printf(\"%d %d\\n\", edge.first, edge.second);\n        }\n\n    } else if (type == \"invalid_center_degree\") {\n        // Generate an invalid tree, where centers have degree less than 3\n        // For simplicity, generate a star with center degree 2\n        if (n < 3) n = 3;\n        printf(\"%d %d\\n\", n, k);\n\n        // Center node 1\n        for (int i = 2; i <= n; i++) {\n            printf(\"%d %d\\n\", 1, i);\n        }\n\n    } else if (type == \"invalid_depth\") {\n        // Generate a valid hedgehog but with depth less than k\n        // We construct a k' -multihedgehog where k' < k\n        // Set smaller k'\n        int k_prime = k -1;\n        if (k_prime < 1) k_prime = 1;\n\n        int d = 3; // Degree of centers\n\n        vector<pair<int, int>> edges;\n        int node_id = 1;\n        queue<int> centers;\n        centers.push(node_id++); // Root center\n\n        for (int level = 1; level <= k_prime; level++) {\n            int num_centers = centers.size();\n            queue<int> next_centers;\n            while (num_centers--) {\n                int parent_center = centers.front();\n                centers.pop();\n\n                // Create d leaves or hedgehogs\n                for (int i = 0; i < d; i++) {\n                    if (node_id > n) break;\n\n                    int new_center = node_id++;\n                    edges.push_back({parent_center, new_center});\n\n                    if (level < k_prime) {\n                        // Next level centers\n                        next_centers.push(new_center);\n                    }\n\n                    // Attach (d -1) leaves to new_center\n                    for (int j = 0; j < d -1; j++) {\n                        if (node_id > n) break;\n                        edges.push_back({new_center, node_id++});\n                    }\n                }\n            }\n            centers = next_centers;\n        }\n\n        // Output n\n        printf(\"%d %d\\n\", node_id -1, k);\n        // Output edges\n        for (auto& edge : edges) {\n            printf(\"%d %d\\n\", edge.first, edge.second);\n        }\n\n    } else if (type == \"random_tree\") {\n        // Generate a random tree of n nodes\n        printf(\"%d %d\\n\", n, k);\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) {\n            nodes[i] = i +1;\n        }\n        shuffle(nodes.begin(), nodes.end());\n\n        for (int i = 1; i < n; ++i) {\n            int u = nodes[i];\n            int v = nodes[rnd.next(0, i-1)];\n            printf(\"%d %d\\n\", u, v);\n        }\n\n    } else {\n        // Default: Output a random valid k-multihedgehog\n        // Same as \"valid\" type\n        // For brevity, we can call the valid case code here\n        // ... (same as the \"valid\" case)\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Valid k-multihedgehogs with varying n and k\n./gen -n 10 -k 1 -type valid\n./gen -n 28 -k 2 -type valid\n./gen -n 64 -k 3 -type valid\n./gen -n 100 -k 4 -type valid\n./gen -n 1000 -k 5 -type valid\n./gen -n 10000 -k 6 -type valid\n./gen -n 100000 -k 7 -type valid\n\n# Valid k-multihedgehog with maximum possible k for n=1e5\n./gen -n 100000 -k 13 -type valid\n\n# Invalid trees where the center does not have degree at least 3\n./gen -n 10 -k 1 -type invalid_center_degree\n./gen -n 20 -k 2 -type invalid_center_degree\n./gen -n 100 -k 3 -type invalid_center_degree\n./gen -n 1000 -k 4 -type invalid_center_degree\n\n# Invalid trees where the depth is less than k\n./gen -n 50 -k 5 -type invalid_depth\n./gen -n 100 -k 10 -type invalid_depth\n./gen -n 1000 -k 15 -type invalid_depth\n\n# Random trees that are unlikely to be k-multihedgehogs\n./gen -n 10 -k 1 -type random_tree\n./gen -n 100 -k 2 -type random_tree\n./gen -n 1000 -k 3 -type random_tree\n./gen -n 10000 -k 4 -type random_tree\n./gen -n 100000 -k 5 -type random_tree\n\n# Edge case with minimum n\n./gen -n 1 -k 1 -type valid\n\n# Edge case with maximum n and k=1\n./gen -n 100000 -k 1 -type valid\n\n# Invalid tree with k larger than possible\n./gen -n 1000 -k 20 -type invalid_depth\n\n# Valid k-multihedgehogs with different degrees (not implemented in code above, for illustrative purposes)\n# The code would need to be extended to support varying degrees.\n# ./gen -n 10000 -k 4 -type valid -d 4\n# ./gen -n 50000 -k 5 -type valid -d 5\n\n# Mix of valid and invalid cases to cover various scenarios\n./gen -n 500 -k 2 -type valid\n./gen -n 500 -k 5 -type invalid_depth\n./gen -n 500 -k 3 -type invalid_center_degree\n./gen -n 500 -k 4 -type random_tree\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:40.668167",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1067/C",
      "title": "C. Knights",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of input contains one integer nn (1≤n≤1031≤n≤103) — number of knights in the initial placement.",
      "output_spec": "OutputPrint nn lines. Each line should contain 22 numbers xixi and yiyi (−109≤xi,yi≤109−109≤xi,yi≤109) — coordinates of ii-th knight. For all i≠ji≠j, (xi,yi)≠(xj,yj)(xi,yi)≠(xj,yj) should hold. In other words, all knights should be in different cells.It is guaranteed that the solution exists.",
      "sample_tests": "ExamplesInputCopy4OutputCopy1 13 11 54 4InputCopy7OutputCopy2 11 24 15 22 65 76 6",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line of input contains one integer nn (1≤n≤1031≤n≤103) — number of knights in the initial placement.\n\nOutputPrint nn lines. Each line should contain 22 numbers xixi and yiyi (−109≤xi,yi≤109−109≤xi,yi≤109) — coordinates of ii-th knight. For all i≠ji≠j, (xi,yi)≠(xj,yj)(xi,yi)≠(xj,yj) should hold. In other words, all knights should be in different cells.It is guaranteed that the solution exists.\n\nInputCopy4OutputCopy1 13 11 54 4InputCopy7OutputCopy2 11 24 15 22 65 76 6\n\nOutputCopy1 13 11 54 4\n\nOutputCopy2 11 24 15 22 65 76 6\n\nNoteLet's look at second example:Green zeroes are initial knights. Cell (3,3)(3,3) is under attack of 44 knights in cells (1,2)(1,2), (2,1)(2,1), (4,1)(4,1) and (5,2)(5,2), therefore Ivan will place a knight in this cell. Cell (4,5)(4,5) is initially attacked by only 33 knights in cells (2,6)(2,6), (5,7)(5,7) and (6,6)(6,6). But new knight in cell (3,3)(3,3) also attacks cell (4,5)(4,5), now it is attacked by 44 knights and Ivan will place another knight in this cell. There are no more free cells which are attacked by 44 or more knights, so the process stops. There are 99 knights in the end, which is not less than ⌊7210⌋=4⌊7210⌋=4.",
      "solutions": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces",
          "content": "I would like to invite you to participate in the rated Codeforces Round #518. Date and time of the round: Wednesday, October 24, 2018 at 18:05. The round was postponed from October 23 to October 24 because of the ICPC Indian Online Qualifier. This is the first competition I proposed. I hope you will enjoy it. The round will have 6 tasks for the second division and 5 tasks for first (3 problems are common). The contest will last for 2 hours. Tasks for you were prepared by Alexey kristevalex Kristev and Alexey Um_nik Danilyuk. Also thanks for: Nikolay KAN Kalinin and Ildar 300iq Gainullin for help in preparing the problems; Ivan isaf27 Safonov и Oleg Merkurev Merkurev for testing the round; Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon platforms. I would like to express a special gratitude to Um_nik for the help throughout the process of preparing the round and also for patience for my stupid questions. slight lyrical digressionAfter a lot of stupid questions... -Um_nik: The general rule is \"I'm not stupid\" This round is a thanks-round for support from Mail.Ru during the 8-year campaign!Scoring distribution will be announced later. I wish you a high rating and looking forward to see you at the competition!I'll be on the community Discord server shortly after the contest to discuss the problems.UPD: scoring distribution div1: 500 1000 1750 2250 2500 div2: 500 1250 1500 2250 2750 3500UPD2: edtorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62614",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1430
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces",
          "content": "1068A - BirthdayTo get LL new coins irrespective of the Ivan's collection he must get not less than L+KL+K coins as a present. Therefore each friend should gift at least X=⌈L+KM⌉X=⌈L+KM⌉ coins. But it may be not possible for all friends to gift XX coins if X⋅M>NX⋅M>N. Complexity is O(1)O(1). 1068B - LCM[a,b]a=b(a,b)[a,b]a=b(a,b), here (a,b)(a,b) is greatest common divisor. Let's see how many different values can have c=(a,b)c=(a,b). All values cc that divides bb are reachable if a=ca=c and every value of (a,b)(a,b) divides bb. So answer is number of divisors of bb. It can be calculated in O(b√)O(b) time. 1068C - Colored RooksLet's put rooks with color ii just on line number ii. Then, obviously, for any color the set of rooks of this color would be connected. Let's put rooks on positions (i,i)(i,i) for ii from 11 to nn. After that for any color there is a rook of this color on a board and for any two different colors aa bb union of set of rooks of color aa and set of rooks of color bb wouldn't be connected. And for final step we can do the following for every pair of harmonizing colors aa bb: let jj be index of first column without rooks, put rooks on cells (j,aj,a) and (j,bj,b). After that for colors aa bb union of set of rooks of color aa and set of rooks of color bb would become connected and for other pairs the connectedness doesn't change.Total number of rooks is n+2⋅mn+2⋅m. 1067A - Array Without Local Maximums Let's find solution with complexity O(n⋅a2)O(n⋅a2). We can count dp[prefix][a][flag]dp[prefix][a][flag] — quantity of ways to restore element from 11 to prefpref with last element equalls to aa, flag=0flag=0 means that previous element is less then the last or last element is first, flag=1flag=1 — the opposite. So dp[pref][a][0]=∑a−1i=1(dp[pref−1][i][1]+dp[pref−1][i][0])dp[pref][a][0]=∑i=1a−1(dp[pref−1][i][1]+dp[pref−1][i][0]), dp[pref][a][1]=dp[pref−1][a][0]+∑200i=adp[pref−1][i][1]dp[pref][a][1]=dp[pref−1][a][0]+∑i=a200dp[pref−1][i][1].Now let's count prefix_sums[a][flag]=∑ai=1dp[pref][i][flag]prefix_sums[a][flag]=∑i=1adp[pref][i][flag] on each prefix before counting all dp[pref]dp[pref], so we can recalculate dp in O(1) time.Complexity is O(n⋅a)O(n⋅a). 1067B - MultihedgehogSolution 1: Firstly let's find all vertices with degree 11. Now we can delete them and all, verticies which were incident to them must became verticies with degree 11. And also for each new veretice with degree 11 we must have already deleted not less then 33 verticies. If initial graph was kk-multihedgehog, after deleting vertices with degree 11 it would became k−1k−1-multihedgehog.It could be realised using bfs starting from all initial vertices with degree 11.Complexity is O(n)O(n).Solution 2: First of all let's find diametr of the graph. After that we can find middle vertex in diameter and check if it is a center of kk-multihedgehog using simple dfs.Complexity is O(n)O(n). 1067C - KnightsIf after some loops of the process we will have two neighboring lines with length xx total complexity of knights would be not less than O(x24)O(x24).In this construction:00 — initial placement.1,21,2 — added knights. Would be two neighboring lines with length O(2⋅n3)O(2⋅n3) so total complexity of knights would be O((2⋅n3)24)=O(n29)O((2⋅n3)24)=O(n29).The possible way to facilitate the invention this (or over) solutions is to write process modeling.Bonus: Solve this problem with complexity O(n26)O(n26). 1067D - Computer GameLet's denote max(bipi)max(bipi) as MM. Independent of our strategy we cannot get more than MM in one second (in expected value). But if we could upgrade one quest, we would upgrade the quest which maximizes bipibipi and then try to complete only this quest each second, thus getting +M+M to expected value each second. Therefore, our strategy looks like this: try to complete quests in some order, once we complete one quest we will always get +M+M to expected value each second.This observation leads to DP solution. Once we have one quest completed we already know what we will get, so interesting states are only those in which no quests are completed yet. Then it is not important what quests we tried to complete before, the only important parameter is remaining time.dpt+1=max(pi(ai+tM)+(1−pi)dpt)dpt+1=max(pi(ai+tM)+(1−pi)dpt).If we succeed then we will get aiai as a reward and for remaining tt seconds we will get MM each second, otherwise we get nothing and now only tt seconds left. This solution works in O(nT)O(nT) time which is too slow.We can slightly rewrite the formula for transition: dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai)dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai).Now we can see that we take maximum value of functions pi⋅x+piaipi⋅x+piai in point xt=tM−dptxt=tM−dpt. We can build convex hull on these lines thus getting O(nlogn+Tlogn)O(nlog⁡n+Tlog⁡n) solution.But that's not all. We can actually prove that xt≤xt+1xt≤xt+1 or, after some substitutions and simplifications, dpt+1−dpt≤Mdpt+1−dpt≤M. This we will prove by actual meaning of dptdpt. Take optimal solution for t+1t+1 seconds and do the same for tt seconds, except that we don't have last second, so we will just drop our action. But we can't gain more than MM in one second, so this drop cannot decrease answer more than MM. Thus the inequality is proven.This means that we only move right along over convex hull, so for each line there will be consecutive seconds in which we are using that line. If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster.Let's start with learning how to make many DP transitions (when we are staying on one line for the whole time). It is more clear using first formula for DP transition: dpt+1=pi(ai+tM)+(1−pi)dptdpt+1=pi(ai+tM)+(1−pi)dpt (we don't have max now because we already know which line to use). We can see that to get vector (dpt+1t+11)T(dpt+1t+11)T from vector (dptt1)T(dptt1)T we can apply linear transformation i.e. multiply by some matrix:⎛⎝⎜dpt+1t+11⎞⎠⎟=⎛⎝⎜1−pi00piM10piai11⎞⎠⎟⎛⎝⎜dptt1⎞⎠⎟(dpt+1t+11)=(1−pipiMpiai011001)(dptt1)To apply it kk times just use binary exponentiation to get kk-th power of transition matrix.To determine how long we actually have to stay on given line we will use binary search on answer. We know for which value of xx we should move to the next line and we know that xx increases with each second, so we can try to stay on given line for some time and see if we should actually change the line.This is already O(n(logn+log2T))O(n(log⁡n+log2⁡T)) solution, but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time.Final complexity is O(n(logn+logT))O(n(log⁡n+log⁡T)) 1067E - Random Forest RankI'll try to explain how to come up with this solution rather than just state the fact. For those who are more interested in getting AC, here is your fact: rank of a forest is twice the size of maximal matching.When we see expected value, we usually want to somehow rewrite the thing under the expected value, apply linearity of expectation and then calculate some independent values. But that's not the case: rank behave strangely and we cannot rewrite it as sum of something, at least I don't know any such solutions (if you do, please write them in the comments). So it looks like we are forced to understand what rank is.The rank of a matrix is a size of its largest non-vanishing minor. But our matrix is symmetric, maybe we can look only at symmetric minors (in a sense that we use the same set of rows and columns)? This is actually true but it is just a fact from linear algebra (seems to be not very well known) and has little to do with our problem, so I'll drop its proof and if someone is interested, ask me in comments.Why do we like symmetric minors? Because they correspond to induced subgraphs of our graph. And all induced subgraphs of a forest are forests too! So let's study when a forest has full rank.To do it, let's calculate determinant of its matrix. Matrix has full rank iff its determinant is non-zero. Let's write a determinant as a sum over all permutations.detA=∑π∏ni=1AiπidetA=∑π∏i=1nAiπiIf Aiπi≠0Aiπi≠0 then we have edge (i,πi)(i,πi) in our forest. Each permutation is a product of independent cycles. So to have non-zero product ∏ni=1Aiπi∏i=1nAiπi all the permutation cycles should be cycles in the forest. But forests have no cycles without repeating vertices! Well, actually they do: each edge generate one cycle of length 22. And that's all, there are no other cycles in forest (11 vertex is not a cycle, because we don't have self-loops). To have non-zero product ∏ni=1Aiπi∏i=1nAiπi all cycles of permutation must have length 22 and correspond to edges of forest. So we can divide all vertices in pairs, and in each pair there is an edge. That's the definition of perfect matching. Why can't they still result in zero sum? Because if there is a perfect matching in a forest then it is unique, so we actually have no more than one non-zero summand.OK, forest has full rank is equivalent to forest has perfect matching. Suppose that mm is the size of maximal matching of a forest. Then no its induced subgraph of size strictly greater than 2m2m can have perfect matching. And there is a subgraph of size exactly 2m2m which does have perfect matching: the ends of edges in maximal matching.Cool, we have proven the fact from the beginning. If you just want AC, continue reading from here. Now we have to calculate expected size of maximal matching. That sound much easier: we already have a linear DP which calculates maximal matching, and its values are exactly sizes of current maximal matching. To remind: dp[v][taken]dp[v][taken] is a size of maximal matching in subtree rooted at vv where boolean flag takentaken means did we already cover vertex vv or is it still free. All we have to do is to change the value stored in DP for expected value and also calculate probabilities to actually be in state with given flag takentaken.Complexity — O(n)O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62688",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1067\\s*C"
          },
          "content_length": 10105
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 1",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 2",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 3",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 4",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 5",
          "code": "-1 200 -1 200 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 6",
          "code": "Participant's output -501767591",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 1",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 2",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 3",
          "code": "After that we can find middle vertex in diameter and check if it is a center of k-multihedgehog using simple dfs.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[8] = {2, 2, -2, -2, 1, 1, -1, -1};\nconst int dy[8] = {1, -1, 1, -1, 2, -2, 2, -2};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n from the input file\n    int n = inf.readInt(1, 1000);\n\n    // Read n positions from the contestant's output\n    vector<pair<int, int>> initialKnights;\n    set<pair<int, int>> knightPositions;\n\n    for (int i = 0; i < n; i++) {\n        int x = ouf.readInt(-1000000000, 1000000000, format(\"x[%d]\", i + 1).c_str());\n        int y = ouf.readInt(-1000000000, 1000000000, format(\"y[%d]\", i + 1).c_str());\n        pair<int, int> pos = make_pair(x, y);\n        if (knightPositions.count(pos) > 0) {\n            ouf.quitf(_wa, \"Duplicate knight position (%d, %d) found at index %d\", x, y, i + 1);\n        }\n        knightPositions.insert(pos);\n        initialKnights.push_back(pos);\n    }\n\n    // Simulate the process\n    set<pair<int, int>> knights = knightPositions;\n    map<pair<int, int>, int> attackCount;\n\n    // Initialize attack counts from initial knights\n    for (auto k : knights) {\n        for (int dir = 0; dir < 8; ++dir) {\n            int nx = k.first + dx[dir];\n            int ny = k.second + dy[dir];\n            pair<int, int> pos = make_pair(nx, ny);\n            if (knights.count(pos) == 0) {\n                attackCount[pos]++;\n            }\n        }\n    }\n\n    queue<pair<int, int>> q;\n    // Find initial positions where new knights will be placed\n    for (auto &p : attackCount) {\n        if (p.second >= 4 && knights.count(p.first) == 0) {\n            q.push(p.first);\n            knights.insert(p.first);\n        }\n    }\n\n    // Process the queue\n    while (!q.empty()) {\n        pair<int, int> k = q.front();\n        q.pop();\n        // For this new knight, update attack counts\n        for (int dir = 0; dir < 8; ++dir) {\n            int nx = k.first + dx[dir];\n            int ny = k.second + dy[dir];\n            pair<int, int> pos = make_pair(nx, ny);\n            if (knights.count(pos) == 0) {\n                attackCount[pos]++;\n                if (attackCount[pos] == 4) {\n                    // New knight needs to be added\n                    q.push(pos);\n                    knights.insert(pos);\n                }\n            }\n        }\n    }\n\n    // Check if the final number of knights meets the requirement\n    int totalKnights = knights.size();\n    int requiredKnights = (n * n) / 10;\n\n    if (totalKnights >= requiredKnights) {\n        quitf(_ok, \"Final number of knights: %d (required: %d)\", totalKnights, requiredKnights);\n    } else {\n        quitf(_wa, \"Final number of knights is too small: %d (required: %d)\", totalKnights, requiredKnights);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // 1. Register the generator\n    registerGen(argc, argv, 1);\n\n    // 2. Read parameters\n    //    We'll allow the user to specify:\n    //      - \"n\": an integer in [1..1000], default 10\n    //      - \"type\": a string with default \"random\"\n    //\n    //    If \"type\" is set to a particular corner case, we will override n.\n    //    Otherwise, if type==\"random\", and n is not set or out of range,\n    //    we'll pick n randomly in [1..1000].\n\n    int n = opt<int>(\"n\", 10);\n    string t = opt<string>(\"type\", \"random\");\n\n    // 3. Decide the final value of n based on \"type\" and any constraints\n    if (t == \"corner1\") {\n        // smallest possible n\n        n = 1;\n    } \n    else if (t == \"corner2\") {\n        // very small n\n        n = 2;\n    }\n    else if (t == \"corner5\") {\n        // a slightly larger small test\n        n = 5;\n    }\n    else if (t == \"corner999\") {\n        // large edge, just under 1000\n        n = 999;\n    }\n    else if (t == \"corner1000\") {\n        // largest possible n\n        n = 1000;\n    }\n    else if (t == \"random\") {\n        // if user-supplied n is out of [1..1000], choose randomly\n        if (n < 1 || n > 1000) {\n            n = rnd.next(1, 1000);\n        }\n    }\n    else {\n        // If none of the above, just clamp n into [1..1000].\n        // This ensures we always produce valid n.\n        n = max(1, min(n, 1000));\n    }\n\n    // 4. Output the test (which, for this problem, is just a single integer n)\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // 1. Register the generator\n    registerGen(argc, argv, 1);\n\n    // 2. Read parameters\n    //    We'll allow the user to specify:\n    //      - \"n\": an integer in [1..1000], default 10\n    //      - \"type\": a string with default \"random\"\n    //\n    //    If \"type\" is set to a particular corner case, we will override n.\n    //    Otherwise, if type==\"random\", and n is not set or out of range,\n    //    we'll pick n randomly in [1..1000].\n\n    int n = opt<int>(\"n\", 10);\n    string t = opt<string>(\"type\", \"random\");\n\n    // 3. Decide the final value of n based on \"type\" and any constraints\n    if (t == \"corner1\") {\n        // smallest possible n\n        n = 1;\n    } \n    else if (t == \"corner2\") {\n        // very small n\n        n = 2;\n    }\n    else if (t == \"corner5\") {\n        // a slightly larger small test\n        n = 5;\n    }\n    else if (t == \"corner999\") {\n        // large edge, just under 1000\n        n = 999;\n    }\n    else if (t == \"corner1000\") {\n        // largest possible n\n        n = 1000;\n    }\n    else if (t == \"random\") {\n        // if user-supplied n is out of [1..1000], choose randomly\n        if (n < 1 || n > 1000) {\n            n = rnd.next(1, 1000);\n        }\n    }\n    else {\n        // If none of the above, just clamp n into [1..1000].\n        // This ensures we always produce valid n.\n        n = max(1, min(n, 1000));\n    }\n\n    // 4. Output the test (which, for this problem, is just a single integer n)\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands for producing a variety of test inputs.\n# Each command prints a single integer n.  In a real contest environment,\n# each command would typically be run to generate one separate test file.\n\n# Corner cases (very small and bounds)\n./gen -type corner1\n./gen -type corner2\n./gen -type corner5\n./gen -type corner999\n./gen -type corner1000\n\n# Directly specifying n for small and medium values\n./gen -n 1\n./gen -n 2\n./gen -n 4\n./gen -n 7\n./gen -n 10\n./gen -n 13\n./gen -n 42\n./gen -n 50\n./gen -n 100\n./gen -n 256\n./gen -n 512\n./gen -n 777\n./gen -n 999\n./gen -n 1000\n\n# Random in [1..1000] (we pass large or invalid n to trigger random reset)\n./gen -type random -n 2000\n./gen -type random -n -5\n./gen -type random\n./gen -type random\n./gen -type random\n\n# More explicit random with valid n\n# (If we give a valid n here, it will just respect it unless we do out-of-bound.)\n./gen -type random -n 123\n./gen -type random -n 999\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:42.882321",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1067/D",
      "title": "Problem 1067/D",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long t = inf.readLong(1LL, 10000000000LL, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int a_i = inf.readInt(1, 100000000, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(a_i + 1, 100000000, \"b_i\");\n        inf.readSpace();\n        string s = inf.readToken();\n        // Validate s\n        ensuref(s.size() >= 3 && s.size() <= 11, \"Invalid p_i format\");\n        ensuref(s.substr(0,2) == \"0.\", \"p_i must start with 0.\");\n        int decimal_digits = s.size() - 2;\n        ensuref(decimal_digits <= 9, \"p_i must have at most 9 decimal digits\");\n        string decimal_part = s.substr(2);\n        ensuref(decimal_digits > 0, \"p_i must have digits after decimal point\");\n        bool has_non_zero_digit = false;\n        for (char c : decimal_part) {\n            ensuref(c >= '0' && c <= '9', \"p_i must contain only digits after decimal point\");\n            if (c != '0') has_non_zero_digit = true;\n        }\n        ensuref(has_non_zero_digit, \"p_i must be greater than 0\");\n        double p_i = atof(s.c_str());\n        ensuref(p_i > 0.0 && p_i < 1.0, \"p_i must be between 0 and 1 exclusive\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long t = inf.readLong(1LL, 10000000000LL, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int a_i = inf.readInt(1, 100000000, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(a_i + 1, 100000000, \"b_i\");\n        inf.readSpace();\n        string s = inf.readToken();\n        // Validate s\n        ensuref(s.size() >= 3 && s.size() <= 11, \"Invalid p_i format\");\n        ensuref(s.substr(0,2) == \"0.\", \"p_i must start with 0.\");\n        int decimal_digits = s.size() - 2;\n        ensuref(decimal_digits <= 9, \"p_i must have at most 9 decimal digits\");\n        string decimal_part = s.substr(2);\n        ensuref(decimal_digits > 0, \"p_i must have digits after decimal point\");\n        bool has_non_zero_digit = false;\n        for (char c : decimal_part) {\n            ensuref(c >= '0' && c <= '9', \"p_i must contain only digits after decimal point\");\n            if (c != '0') has_non_zero_digit = true;\n        }\n        ensuref(has_non_zero_digit, \"p_i must be greater than 0\");\n        double p_i = atof(s.c_str());\n        ensuref(p_i > 0.0 && p_i < 1.0, \"p_i must be between 0 and 1 exclusive\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long t = inf.readLong(1LL, 10000000000LL, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int a_i = inf.readInt(1, 100000000, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(a_i + 1, 100000000, \"b_i\");\n        inf.readSpace();\n        string s = inf.readToken();\n        // Validate s\n        ensuref(s.size() >= 3 && s.size() <= 11, \"Invalid p_i format\");\n        ensuref(s.substr(0,2) == \"0.\", \"p_i must start with 0.\");\n        int decimal_digits = s.size() - 2;\n        ensuref(decimal_digits <= 9, \"p_i must have at most 9 decimal digits\");\n        string decimal_part = s.substr(2);\n        ensuref(decimal_digits > 0, \"p_i must have digits after decimal point\");\n        bool has_non_zero_digit = false;\n        for (char c : decimal_part) {\n            ensuref(c >= '0' && c <= '9', \"p_i must contain only digits after decimal point\");\n            if (c != '0') has_non_zero_digit = true;\n        }\n        ensuref(has_non_zero_digit, \"p_i must be greater than 0\");\n        double p_i = atof(s.c_str());\n        ensuref(p_i > 0.0 && p_i < 1.0, \"p_i must be between 0 and 1 exclusive\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long t = opt<long long>(\"t\");\n    string type = opt(\"type\", \"random\");\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Invalid n: %d\\n\", n);\n        exit(1);\n    }\n    if (t < 1 || t > 10000000000LL) {\n        fprintf(stderr, \"Invalid t: %lld\\n\", t);\n        exit(1);\n    }\n\n    if (type == \"random\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = rnd.next(1, int(1e8 - 1));\n            int b_i = rnd.next(a_i + 1, int(1e8));\n            double p_i = rnd.next(1e-9, 1 - 1e-9);\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"max_p\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = rnd.next(1, int(1e8 - 1));\n            int b_i = rnd.next(a_i + 1, int(1e8));\n            double p_i = 1.0 - rnd.next(0.0, 1e-9);\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            if (p_i >= 1.0) p_i = 1.0 - 1e-9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"min_p\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = rnd.next(1, int(1e8 - 1));\n            int b_i = rnd.next(a_i + 1, int(1e8));\n            double p_i = rnd.next(0.0, 1e-9);\n            p_i = ceil(p_i * 1e9) / 1e9;\n            if (p_i <= 0.0) p_i = 1e-9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"max_diff\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = 1;\n            int b_i = int(1e8);\n            double p_i = rnd.next(1e-9, 1 - 1e-9);\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"min_diff\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = rnd.next(1, int(1e8 - 1));\n            int b_i = a_i + 1;\n            double p_i = rnd.next(1e-9, 1 - 1e-9);\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"equal_rewards\") {\n        int a_i = rnd.next(1, int(1e8 - 1));\n        int b_i = rnd.next(a_i + 1, int(1e8));\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            double p_i = rnd.next(1e-9, 1 - 1e-9);\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"one_good_quest\") {\n        printf(\"%d %lld\\n\", n, t);\n        int good_index = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            int a_i, b_i;\n            double p_i;\n            if (i == good_index) {\n                a_i = int(1e8 - 1);\n                b_i = int(1e8);\n                p_i = 1.0 - 1e-9;\n            } else {\n                a_i = 1;\n                b_i = 2;\n                p_i = 1e-9;\n            }\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"one_bad_quest\") {\n        printf(\"%d %lld\\n\", n, t);\n        int bad_index = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            int a_i, b_i;\n            double p_i;\n            if (i == bad_index) {\n                a_i = 1;\n                b_i = 2;\n                p_i = 1e-9;\n            } else {\n                a_i = int(1e8 - 1);\n                b_i = int(1e8);\n                p_i = 1.0 - 1e-9;\n            }\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"decimal_p\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = rnd.next(1, int(1e8 - 1));\n            int b_i = rnd.next(a_i + 1, int(1e8));\n            long long p_numerator = rnd.next(1LL, 999999999LL);\n            double p_i = p_numerator / 1e9;\n            p_i = min(p_i, 1.0 - 1e-9);\n            p_i = max(p_i, 1e-9);\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long t = opt<long long>(\"t\");\n    string type = opt(\"type\", \"random\");\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Invalid n: %d\\n\", n);\n        exit(1);\n    }\n    if (t < 1 || t > 10000000000LL) {\n        fprintf(stderr, \"Invalid t: %lld\\n\", t);\n        exit(1);\n    }\n\n    if (type == \"random\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = rnd.next(1, int(1e8 - 1));\n            int b_i = rnd.next(a_i + 1, int(1e8));\n            double p_i = rnd.next(1e-9, 1 - 1e-9);\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"max_p\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = rnd.next(1, int(1e8 - 1));\n            int b_i = rnd.next(a_i + 1, int(1e8));\n            double p_i = 1.0 - rnd.next(0.0, 1e-9);\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            if (p_i >= 1.0) p_i = 1.0 - 1e-9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"min_p\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = rnd.next(1, int(1e8 - 1));\n            int b_i = rnd.next(a_i + 1, int(1e8));\n            double p_i = rnd.next(0.0, 1e-9);\n            p_i = ceil(p_i * 1e9) / 1e9;\n            if (p_i <= 0.0) p_i = 1e-9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"max_diff\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = 1;\n            int b_i = int(1e8);\n            double p_i = rnd.next(1e-9, 1 - 1e-9);\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"min_diff\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = rnd.next(1, int(1e8 - 1));\n            int b_i = a_i + 1;\n            double p_i = rnd.next(1e-9, 1 - 1e-9);\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"equal_rewards\") {\n        int a_i = rnd.next(1, int(1e8 - 1));\n        int b_i = rnd.next(a_i + 1, int(1e8));\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            double p_i = rnd.next(1e-9, 1 - 1e-9);\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"one_good_quest\") {\n        printf(\"%d %lld\\n\", n, t);\n        int good_index = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            int a_i, b_i;\n            double p_i;\n            if (i == good_index) {\n                a_i = int(1e8 - 1);\n                b_i = int(1e8);\n                p_i = 1.0 - 1e-9;\n            } else {\n                a_i = 1;\n                b_i = 2;\n                p_i = 1e-9;\n            }\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"one_bad_quest\") {\n        printf(\"%d %lld\\n\", n, t);\n        int bad_index = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            int a_i, b_i;\n            double p_i;\n            if (i == bad_index) {\n                a_i = 1;\n                b_i = 2;\n                p_i = 1e-9;\n            } else {\n                a_i = int(1e8 - 1);\n                b_i = int(1e8);\n                p_i = 1.0 - 1e-9;\n            }\n            p_i = floor(p_i * 1e9 + 0.5) / 1e9;\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else if (type == \"decimal_p\") {\n        printf(\"%d %lld\\n\", n, t);\n        for (int i = 0; i < n; ++i) {\n            int a_i = rnd.next(1, int(1e8 - 1));\n            int b_i = rnd.next(a_i + 1, int(1e8));\n            long long p_numerator = rnd.next(1LL, 999999999LL);\n            double p_i = p_numerator / 1e9;\n            p_i = min(p_i, 1.0 - 1e-9);\n            p_i = max(p_i, 1e-9);\n            printf(\"%d %d %.9f\\n\", a_i, b_i, p_i);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -t 10 -type random\n./gen -n 100 -t 1000 -type random\n./gen -n 1000 -t 100000 -type random\n./gen -n 10000 -t 1000000 -type random\n./gen -n 100000 -t 10000000000 -type random\n\n./gen -n 100000 -t 10000000000 -type max_p\n./gen -n 100000 -t 10000000000 -type min_p\n./gen -n 100000 -t 10000000000 -type max_diff\n./gen -n 100000 -t 10000000000 -type min_diff\n./gen -n 100000 -t 10000000000 -type equal_rewards\n./gen -n 100000 -t 10000000000 -type one_good_quest\n./gen -n 100000 -t 10000000000 -type one_bad_quest\n./gen -n 100000 -t 10000000000 -type decimal_p\n\n./gen -n 1 -t 1 -type random\n./gen -n 1 -t 10000000000 -type random\n./gen -n 100000 -t 1 -type random\n\n./gen -n 10 -t 1 -type max_p\n./gen -n 10 -t 1 -type min_p\n./gen -n 10 -t 1 -type max_diff\n./gen -n 10 -t 1 -type min_diff\n\n./gen -n 50000 -t 5000000000 -type random\n./gen -n 99999 -t 9999999999 -type equal_rewards\n\n./gen -n 100000 -t 10000000000 -type decimal_p\n./gen -n 100000 -t 1 -type one_good_quest\n./gen -n 100000 -t 1 -type one_bad_quest\n\n./gen -n 2 -t 2 -type random\n./gen -n 10 -t 1 -type decimal_p\n\n./gen -n 1000 -t 10000000000 -type max_p\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:44.997099",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1067/E",
      "title": "E. Random Forest Rank",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputFirst line of input contains nn (1≤n≤5⋅1051≤n≤5⋅105) — number of vertices.Next n−1n−1 lines contains two integers uu vv (1≤u,v≤n;u≠v1≤u,v≤n;u≠v) — indices of vertices connected by edge.It is guaranteed that given graph is a tree.",
      "output_spec": "OutputPrint one integer — answer to the problem.",
      "sample_tests": "ExamplesInputCopy31 22 3OutputCopy6InputCopy41 21 31 4OutputCopy14InputCopy41 22 33 4OutputCopy18",
      "description": "E. Random Forest Rank\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of input contains nn (1≤n≤5⋅1051≤n≤5⋅105) — number of vertices.Next n−1n−1 lines contains two integers uu vv (1≤u,v≤n;u≠v1≤u,v≤n;u≠v) — indices of vertices connected by edge.It is guaranteed that given graph is a tree.\n\nOutputPrint one integer — answer to the problem.\n\nInputCopy31 22 3OutputCopy6InputCopy41 21 31 4OutputCopy14InputCopy41 22 33 4OutputCopy18\n\nInputCopy31 22 3\n\nOutputCopy6\n\nInputCopy41 21 31 4\n\nOutputCopy14\n\nInputCopy41 22 33 4\n\nOutputCopy18",
      "solutions": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces",
          "content": "I would like to invite you to participate in the rated Codeforces Round #518. Date and time of the round: Wednesday, October 24, 2018 at 18:05. The round was postponed from October 23 to October 24 because of the ICPC Indian Online Qualifier. This is the first competition I proposed. I hope you will enjoy it. The round will have 6 tasks for the second division and 5 tasks for first (3 problems are common). The contest will last for 2 hours. Tasks for you were prepared by Alexey kristevalex Kristev and Alexey Um_nik Danilyuk. Also thanks for: Nikolay KAN Kalinin and Ildar 300iq Gainullin for help in preparing the problems; Ivan isaf27 Safonov и Oleg Merkurev Merkurev for testing the round; Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon platforms. I would like to express a special gratitude to Um_nik for the help throughout the process of preparing the round and also for patience for my stupid questions. slight lyrical digressionAfter a lot of stupid questions... -Um_nik: The general rule is \"I'm not stupid\" This round is a thanks-round for support from Mail.Ru during the 8-year campaign!Scoring distribution will be announced later. I wish you a high rating and looking forward to see you at the competition!I'll be on the community Discord server shortly after the contest to discuss the problems.UPD: scoring distribution div1: 500 1000 1750 2250 2500 div2: 500 1250 1500 2250 2750 3500UPD2: edtorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62614",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1430
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces",
          "content": "1068A - BirthdayTo get LL new coins irrespective of the Ivan's collection he must get not less than L+KL+K coins as a present. Therefore each friend should gift at least X=⌈L+KM⌉X=⌈L+KM⌉ coins. But it may be not possible for all friends to gift XX coins if X⋅M>NX⋅M>N. Complexity is O(1)O(1). 1068B - LCM[a,b]a=b(a,b)[a,b]a=b(a,b), here (a,b)(a,b) is greatest common divisor. Let's see how many different values can have c=(a,b)c=(a,b). All values cc that divides bb are reachable if a=ca=c and every value of (a,b)(a,b) divides bb. So answer is number of divisors of bb. It can be calculated in O(b√)O(b) time. 1068C - Colored RooksLet's put rooks with color ii just on line number ii. Then, obviously, for any color the set of rooks of this color would be connected. Let's put rooks on positions (i,i)(i,i) for ii from 11 to nn. After that for any color there is a rook of this color on a board and for any two different colors aa bb union of set of rooks of color aa and set of rooks of color bb wouldn't be connected. And for final step we can do the following for every pair of harmonizing colors aa bb: let jj be index of first column without rooks, put rooks on cells (j,aj,a) and (j,bj,b). After that for colors aa bb union of set of rooks of color aa and set of rooks of color bb would become connected and for other pairs the connectedness doesn't change.Total number of rooks is n+2⋅mn+2⋅m. 1067A - Array Without Local Maximums Let's find solution with complexity O(n⋅a2)O(n⋅a2). We can count dp[prefix][a][flag]dp[prefix][a][flag] — quantity of ways to restore element from 11 to prefpref with last element equalls to aa, flag=0flag=0 means that previous element is less then the last or last element is first, flag=1flag=1 — the opposite. So dp[pref][a][0]=∑a−1i=1(dp[pref−1][i][1]+dp[pref−1][i][0])dp[pref][a][0]=∑i=1a−1(dp[pref−1][i][1]+dp[pref−1][i][0]), dp[pref][a][1]=dp[pref−1][a][0]+∑200i=adp[pref−1][i][1]dp[pref][a][1]=dp[pref−1][a][0]+∑i=a200dp[pref−1][i][1].Now let's count prefix_sums[a][flag]=∑ai=1dp[pref][i][flag]prefix_sums[a][flag]=∑i=1adp[pref][i][flag] on each prefix before counting all dp[pref]dp[pref], so we can recalculate dp in O(1) time.Complexity is O(n⋅a)O(n⋅a). 1067B - MultihedgehogSolution 1: Firstly let's find all vertices with degree 11. Now we can delete them and all, verticies which were incident to them must became verticies with degree 11. And also for each new veretice with degree 11 we must have already deleted not less then 33 verticies. If initial graph was kk-multihedgehog, after deleting vertices with degree 11 it would became k−1k−1-multihedgehog.It could be realised using bfs starting from all initial vertices with degree 11.Complexity is O(n)O(n).Solution 2: First of all let's find diametr of the graph. After that we can find middle vertex in diameter and check if it is a center of kk-multihedgehog using simple dfs.Complexity is O(n)O(n). 1067C - KnightsIf after some loops of the process we will have two neighboring lines with length xx total complexity of knights would be not less than O(x24)O(x24).In this construction:00 — initial placement.1,21,2 — added knights. Would be two neighboring lines with length O(2⋅n3)O(2⋅n3) so total complexity of knights would be O((2⋅n3)24)=O(n29)O((2⋅n3)24)=O(n29).The possible way to facilitate the invention this (or over) solutions is to write process modeling.Bonus: Solve this problem with complexity O(n26)O(n26). 1067D - Computer GameLet's denote max(bipi)max(bipi) as MM. Independent of our strategy we cannot get more than MM in one second (in expected value). But if we could upgrade one quest, we would upgrade the quest which maximizes bipibipi and then try to complete only this quest each second, thus getting +M+M to expected value each second. Therefore, our strategy looks like this: try to complete quests in some order, once we complete one quest we will always get +M+M to expected value each second.This observation leads to DP solution. Once we have one quest completed we already know what we will get, so interesting states are only those in which no quests are completed yet. Then it is not important what quests we tried to complete before, the only important parameter is remaining time.dpt+1=max(pi(ai+tM)+(1−pi)dpt)dpt+1=max(pi(ai+tM)+(1−pi)dpt).If we succeed then we will get aiai as a reward and for remaining tt seconds we will get MM each second, otherwise we get nothing and now only tt seconds left. This solution works in O(nT)O(nT) time which is too slow.We can slightly rewrite the formula for transition: dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai)dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai).Now we can see that we take maximum value of functions pi⋅x+piaipi⋅x+piai in point xt=tM−dptxt=tM−dpt. We can build convex hull on these lines thus getting O(nlogn+Tlogn)O(nlog⁡n+Tlog⁡n) solution.But that's not all. We can actually prove that xt≤xt+1xt≤xt+1 or, after some substitutions and simplifications, dpt+1−dpt≤Mdpt+1−dpt≤M. This we will prove by actual meaning of dptdpt. Take optimal solution for t+1t+1 seconds and do the same for tt seconds, except that we don't have last second, so we will just drop our action. But we can't gain more than MM in one second, so this drop cannot decrease answer more than MM. Thus the inequality is proven.This means that we only move right along over convex hull, so for each line there will be consecutive seconds in which we are using that line. If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster.Let's start with learning how to make many DP transitions (when we are staying on one line for the whole time). It is more clear using first formula for DP transition: dpt+1=pi(ai+tM)+(1−pi)dptdpt+1=pi(ai+tM)+(1−pi)dpt (we don't have max now because we already know which line to use). We can see that to get vector (dpt+1t+11)T(dpt+1t+11)T from vector (dptt1)T(dptt1)T we can apply linear transformation i.e. multiply by some matrix:⎛⎝⎜dpt+1t+11⎞⎠⎟=⎛⎝⎜1−pi00piM10piai11⎞⎠⎟⎛⎝⎜dptt1⎞⎠⎟(dpt+1t+11)=(1−pipiMpiai011001)(dptt1)To apply it kk times just use binary exponentiation to get kk-th power of transition matrix.To determine how long we actually have to stay on given line we will use binary search on answer. We know for which value of xx we should move to the next line and we know that xx increases with each second, so we can try to stay on given line for some time and see if we should actually change the line.This is already O(n(logn+log2T))O(n(log⁡n+log2⁡T)) solution, but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time.Final complexity is O(n(logn+logT))O(n(log⁡n+log⁡T)) 1067E - Random Forest RankI'll try to explain how to come up with this solution rather than just state the fact. For those who are more interested in getting AC, here is your fact: rank of a forest is twice the size of maximal matching.When we see expected value, we usually want to somehow rewrite the thing under the expected value, apply linearity of expectation and then calculate some independent values. But that's not the case: rank behave strangely and we cannot rewrite it as sum of something, at least I don't know any such solutions (if you do, please write them in the comments). So it looks like we are forced to understand what rank is.The rank of a matrix is a size of its largest non-vanishing minor. But our matrix is symmetric, maybe we can look only at symmetric minors (in a sense that we use the same set of rows and columns)? This is actually true but it is just a fact from linear algebra (seems to be not very well known) and has little to do with our problem, so I'll drop its proof and if someone is interested, ask me in comments.Why do we like symmetric minors? Because they correspond to induced subgraphs of our graph. And all induced subgraphs of a forest are forests too! So let's study when a forest has full rank.To do it, let's calculate determinant of its matrix. Matrix has full rank iff its determinant is non-zero. Let's write a determinant as a sum over all permutations.detA=∑π∏ni=1AiπidetA=∑π∏i=1nAiπiIf Aiπi≠0Aiπi≠0 then we have edge (i,πi)(i,πi) in our forest. Each permutation is a product of independent cycles. So to have non-zero product ∏ni=1Aiπi∏i=1nAiπi all the permutation cycles should be cycles in the forest. But forests have no cycles without repeating vertices! Well, actually they do: each edge generate one cycle of length 22. And that's all, there are no other cycles in forest (11 vertex is not a cycle, because we don't have self-loops). To have non-zero product ∏ni=1Aiπi∏i=1nAiπi all cycles of permutation must have length 22 and correspond to edges of forest. So we can divide all vertices in pairs, and in each pair there is an edge. That's the definition of perfect matching. Why can't they still result in zero sum? Because if there is a perfect matching in a forest then it is unique, so we actually have no more than one non-zero summand.OK, forest has full rank is equivalent to forest has perfect matching. Suppose that mm is the size of maximal matching of a forest. Then no its induced subgraph of size strictly greater than 2m2m can have perfect matching. And there is a subgraph of size exactly 2m2m which does have perfect matching: the ends of edges in maximal matching.Cool, we have proven the fact from the beginning. If you just want AC, continue reading from here. Now we have to calculate expected size of maximal matching. That sound much easier: we already have a linear DP which calculates maximal matching, and its values are exactly sizes of current maximal matching. To remind: dp[v][taken]dp[v][taken] is a size of maximal matching in subtree rooted at vv where boolean flag takentaken means did we already cover vertex vv or is it still free. All we have to do is to change the value stored in DP for expected value and also calculate probabilities to actually be in state with given flag takentaken.Complexity — O(n)O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62688",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1067\\s*E"
          },
          "content_length": 10105
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 1",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 2",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 3",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 4",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 5",
          "code": "-1 200 -1 200 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 6",
          "code": "Participant's output -501767591",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 1",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 2",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 3",
          "code": "After that we can find middle vertex in diameter and check if it is a center of k-multihedgehog using simple dfs.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 500000 + 5;\n\nint parent[MAXN];\nint rank_arr[MAXN];\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    ensuref(a != b, \"Graph is not a tree (contains cycle)\");\n    if (rank_arr[a] < rank_arr[b])\n        swap(a, b);\n    parent[b] = a;\n    if (rank_arr[a] == rank_arr[b])\n        rank_arr[a]++;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n        rank_arr[i] = 1;\n    }\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Self-loop detected at edge %d (%d, %d)\", i + 1, u, v);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edges.find({a, b}) == edges.end(), \"Multiple edges between %d and %d\", a, b);\n        edges.insert({a, b});\n\n        union_sets(u, v);\n    }\n\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find_set(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 500000 + 5;\n\nint parent[MAXN];\nint rank_arr[MAXN];\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    ensuref(a != b, \"Graph is not a tree (contains cycle)\");\n    if (rank_arr[a] < rank_arr[b])\n        swap(a, b);\n    parent[b] = a;\n    if (rank_arr[a] == rank_arr[b])\n        rank_arr[a]++;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n        rank_arr[i] = 1;\n    }\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Self-loop detected at edge %d (%d, %d)\", i + 1, u, v);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edges.find({a, b}) == edges.end(), \"Multiple edges between %d and %d\", a, b);\n        edges.insert({a, b});\n\n        union_sets(u, v);\n    }\n\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find_set(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 500000 + 5;\n\nint parent[MAXN];\nint rank_arr[MAXN];\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    ensuref(a != b, \"Graph is not a tree (contains cycle)\");\n    if (rank_arr[a] < rank_arr[b])\n        swap(a, b);\n    parent[b] = a;\n    if (rank_arr[a] == rank_arr[b])\n        rank_arr[a]++;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n        rank_arr[i] = 1;\n    }\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Self-loop detected at edge %d (%d, %d)\", i + 1, u, v);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edges.find({a, b}) == edges.end(), \"Multiple edges between %d and %d\", a, b);\n        edges.insert({a, b});\n\n        union_sets(u, v);\n    }\n\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find_set(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"chain\") {\n        /* Construct a chain */\n        for(int i = 1; i < n; ++i)\n            p[i] = i - 1;\n    } else if (type == \"star\") {\n        /* Construct a star */\n        for(int i = 1; i < n; ++i)\n            p[i] = 0;\n    } else if (type == \"binary\") {\n        /* Construct a complete binary tree */\n        for(int i = 1; i < n; ++i)\n            p[i] = (i - 1) / 2;\n    } else if (type == \"skewed\") {\n        /* Construct a skewed tree (all nodes connected in a chain) */\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(max(0, i - 5), i - 1);\n    } else {\n        /* Random tree */\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(i);\n    }\n\n    /* output n */\n    printf(\"%d\\n\", n);\n\n    /* shuffle vertices */\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i)\n        perm[i] = i + 1;  // nodes are numbered from 1 to n\n    shuffle(perm.begin(), perm.end());\n\n    /* create edges using shuffled nodes */\n    vector<pair<int,int>> edges;\n    for(int i = 1; i < n; ++i) {\n        edges.emplace_back(perm[i], perm[p[i]]);\n    }\n\n    /* shuffle edges */\n    shuffle(edges.begin(), edges.end());\n\n    /* output edges */\n    for(auto& edge : edges)\n        printf(\"%d %d\\n\", edge.first, edge.second);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"chain\") {\n        /* Construct a chain */\n        for(int i = 1; i < n; ++i)\n            p[i] = i - 1;\n    } else if (type == \"star\") {\n        /* Construct a star */\n        for(int i = 1; i < n; ++i)\n            p[i] = 0;\n    } else if (type == \"binary\") {\n        /* Construct a complete binary tree */\n        for(int i = 1; i < n; ++i)\n            p[i] = (i - 1) / 2;\n    } else if (type == \"skewed\") {\n        /* Construct a skewed tree (all nodes connected in a chain) */\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(max(0, i - 5), i - 1);\n    } else {\n        /* Random tree */\n        for(int i = 1; i < n; ++i)\n            p[i] = rnd.next(i);\n    }\n\n    /* output n */\n    printf(\"%d\\n\", n);\n\n    /* shuffle vertices */\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i)\n        perm[i] = i + 1;  // nodes are numbered from 1 to n\n    shuffle(perm.begin(), perm.end());\n\n    /* create edges using shuffled nodes */\n    vector<pair<int,int>> edges;\n    for(int i = 1; i < n; ++i) {\n        edges.emplace_back(perm[i], perm[p[i]]);\n    }\n\n    /* shuffle edges */\n    shuffle(edges.begin(), edges.end());\n\n    /* output edges */\n    for(auto& edge : edges)\n        printf(\"%d %d\\n\", edge.first, edge.second);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type chain\n./gen -n 1 -type star\n./gen -n 1 -type binary\n./gen -n 1 -type random\n\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type binary\n./gen -n 2 -type random\n\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type binary\n./gen -n 3 -type random\n\n./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type binary\n./gen -n 5 -type skewed\n./gen -n 5 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type binary\n./gen -n 10 -type skewed\n./gen -n 10 -type random\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type binary\n./gen -n 100 -type skewed\n./gen -n 100 -type random\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type binary\n./gen -n 1000 -type skewed\n./gen -n 1000 -type random\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type binary\n./gen -n 100000 -type skewed\n./gen -n 100000 -type random\n\n./gen -n 500000 -type chain\n./gen -n 500000 -type star\n./gen -n 500000 -type binary\n./gen -n 500000 -type skewed\n./gen -n 500000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:47.209686",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1068/A",
      "title": "A. Birthday",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of input contains 4 integers NN, MM, KK, LL (1≤K≤N≤10181≤K≤N≤1018; 1≤M,L≤10181≤M,L≤1018) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.",
      "output_spec": "OutputPrint one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print \"-1\" (without quotes).",
      "sample_tests": "ExamplesInputCopy20 15 2 3OutputCopy1InputCopy10 11 2 4OutputCopy-1",
      "description": "A. Birthday\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line of input contains 4 integers NN, MM, KK, LL (1≤K≤N≤10181≤K≤N≤1018; 1≤M,L≤10181≤M,L≤1018) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.\n\nOutputPrint one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print \"-1\" (without quotes).\n\nInputCopy20 15 2 3OutputCopy1InputCopy10 11 2 4OutputCopy-1\n\nInputCopy20 15 2 3\n\nOutputCopy1\n\nInputCopy10 11 2 4\n\nOutputCopy-1\n\nNoteIn the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.",
      "solutions": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces",
          "content": "I would like to invite you to participate in the rated Codeforces Round #518. Date and time of the round: Wednesday, October 24, 2018 at 18:05. The round was postponed from October 23 to October 24 because of the ICPC Indian Online Qualifier. This is the first competition I proposed. I hope you will enjoy it. The round will have 6 tasks for the second division and 5 tasks for first (3 problems are common). The contest will last for 2 hours. Tasks for you were prepared by Alexey kristevalex Kristev and Alexey Um_nik Danilyuk. Also thanks for: Nikolay KAN Kalinin and Ildar 300iq Gainullin for help in preparing the problems; Ivan isaf27 Safonov и Oleg Merkurev Merkurev for testing the round; Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon platforms. I would like to express a special gratitude to Um_nik for the help throughout the process of preparing the round and also for patience for my stupid questions. slight lyrical digressionAfter a lot of stupid questions... -Um_nik: The general rule is \"I'm not stupid\" This round is a thanks-round for support from Mail.Ru during the 8-year campaign!Scoring distribution will be announced later. I wish you a high rating and looking forward to see you at the competition!I'll be on the community Discord server shortly after the contest to discuss the problems.UPD: scoring distribution div1: 500 1000 1750 2250 2500 div2: 500 1250 1500 2250 2750 3500UPD2: edtorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62614",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1430
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces",
          "content": "1068A - BirthdayTo get LL new coins irrespective of the Ivan's collection he must get not less than L+KL+K coins as a present. Therefore each friend should gift at least X=⌈L+KM⌉X=⌈L+KM⌉ coins. But it may be not possible for all friends to gift XX coins if X⋅M>NX⋅M>N. Complexity is O(1)O(1). 1068B - LCM[a,b]a=b(a,b)[a,b]a=b(a,b), here (a,b)(a,b) is greatest common divisor. Let's see how many different values can have c=(a,b)c=(a,b). All values cc that divides bb are reachable if a=ca=c and every value of (a,b)(a,b) divides bb. So answer is number of divisors of bb. It can be calculated in O(b√)O(b) time. 1068C - Colored RooksLet's put rooks with color ii just on line number ii. Then, obviously, for any color the set of rooks of this color would be connected. Let's put rooks on positions (i,i)(i,i) for ii from 11 to nn. After that for any color there is a rook of this color on a board and for any two different colors aa bb union of set of rooks of color aa and set of rooks of color bb wouldn't be connected. And for final step we can do the following for every pair of harmonizing colors aa bb: let jj be index of first column without rooks, put rooks on cells (j,aj,a) and (j,bj,b). After that for colors aa bb union of set of rooks of color aa and set of rooks of color bb would become connected and for other pairs the connectedness doesn't change.Total number of rooks is n+2⋅mn+2⋅m. 1067A - Array Without Local Maximums Let's find solution with complexity O(n⋅a2)O(n⋅a2). We can count dp[prefix][a][flag]dp[prefix][a][flag] — quantity of ways to restore element from 11 to prefpref with last element equalls to aa, flag=0flag=0 means that previous element is less then the last or last element is first, flag=1flag=1 — the opposite. So dp[pref][a][0]=∑a−1i=1(dp[pref−1][i][1]+dp[pref−1][i][0])dp[pref][a][0]=∑i=1a−1(dp[pref−1][i][1]+dp[pref−1][i][0]), dp[pref][a][1]=dp[pref−1][a][0]+∑200i=adp[pref−1][i][1]dp[pref][a][1]=dp[pref−1][a][0]+∑i=a200dp[pref−1][i][1].Now let's count prefix_sums[a][flag]=∑ai=1dp[pref][i][flag]prefix_sums[a][flag]=∑i=1adp[pref][i][flag] on each prefix before counting all dp[pref]dp[pref], so we can recalculate dp in O(1) time.Complexity is O(n⋅a)O(n⋅a). 1067B - MultihedgehogSolution 1: Firstly let's find all vertices with degree 11. Now we can delete them and all, verticies which were incident to them must became verticies with degree 11. And also for each new veretice with degree 11 we must have already deleted not less then 33 verticies. If initial graph was kk-multihedgehog, after deleting vertices with degree 11 it would became k−1k−1-multihedgehog.It could be realised using bfs starting from all initial vertices with degree 11.Complexity is O(n)O(n).Solution 2: First of all let's find diametr of the graph. After that we can find middle vertex in diameter and check if it is a center of kk-multihedgehog using simple dfs.Complexity is O(n)O(n). 1067C - KnightsIf after some loops of the process we will have two neighboring lines with length xx total complexity of knights would be not less than O(x24)O(x24).In this construction:00 — initial placement.1,21,2 — added knights. Would be two neighboring lines with length O(2⋅n3)O(2⋅n3) so total complexity of knights would be O((2⋅n3)24)=O(n29)O((2⋅n3)24)=O(n29).The possible way to facilitate the invention this (or over) solutions is to write process modeling.Bonus: Solve this problem with complexity O(n26)O(n26). 1067D - Computer GameLet's denote max(bipi)max(bipi) as MM. Independent of our strategy we cannot get more than MM in one second (in expected value). But if we could upgrade one quest, we would upgrade the quest which maximizes bipibipi and then try to complete only this quest each second, thus getting +M+M to expected value each second. Therefore, our strategy looks like this: try to complete quests in some order, once we complete one quest we will always get +M+M to expected value each second.This observation leads to DP solution. Once we have one quest completed we already know what we will get, so interesting states are only those in which no quests are completed yet. Then it is not important what quests we tried to complete before, the only important parameter is remaining time.dpt+1=max(pi(ai+tM)+(1−pi)dpt)dpt+1=max(pi(ai+tM)+(1−pi)dpt).If we succeed then we will get aiai as a reward and for remaining tt seconds we will get MM each second, otherwise we get nothing and now only tt seconds left. This solution works in O(nT)O(nT) time which is too slow.We can slightly rewrite the formula for transition: dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai)dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai).Now we can see that we take maximum value of functions pi⋅x+piaipi⋅x+piai in point xt=tM−dptxt=tM−dpt. We can build convex hull on these lines thus getting O(nlogn+Tlogn)O(nlog⁡n+Tlog⁡n) solution.But that's not all. We can actually prove that xt≤xt+1xt≤xt+1 or, after some substitutions and simplifications, dpt+1−dpt≤Mdpt+1−dpt≤M. This we will prove by actual meaning of dptdpt. Take optimal solution for t+1t+1 seconds and do the same for tt seconds, except that we don't have last second, so we will just drop our action. But we can't gain more than MM in one second, so this drop cannot decrease answer more than MM. Thus the inequality is proven.This means that we only move right along over convex hull, so for each line there will be consecutive seconds in which we are using that line. If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster.Let's start with learning how to make many DP transitions (when we are staying on one line for the whole time). It is more clear using first formula for DP transition: dpt+1=pi(ai+tM)+(1−pi)dptdpt+1=pi(ai+tM)+(1−pi)dpt (we don't have max now because we already know which line to use). We can see that to get vector (dpt+1t+11)T(dpt+1t+11)T from vector (dptt1)T(dptt1)T we can apply linear transformation i.e. multiply by some matrix:⎛⎝⎜dpt+1t+11⎞⎠⎟=⎛⎝⎜1−pi00piM10piai11⎞⎠⎟⎛⎝⎜dptt1⎞⎠⎟(dpt+1t+11)=(1−pipiMpiai011001)(dptt1)To apply it kk times just use binary exponentiation to get kk-th power of transition matrix.To determine how long we actually have to stay on given line we will use binary search on answer. We know for which value of xx we should move to the next line and we know that xx increases with each second, so we can try to stay on given line for some time and see if we should actually change the line.This is already O(n(logn+log2T))O(n(log⁡n+log2⁡T)) solution, but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time.Final complexity is O(n(logn+logT))O(n(log⁡n+log⁡T)) 1067E - Random Forest RankI'll try to explain how to come up with this solution rather than just state the fact. For those who are more interested in getting AC, here is your fact: rank of a forest is twice the size of maximal matching.When we see expected value, we usually want to somehow rewrite the thing under the expected value, apply linearity of expectation and then calculate some independent values. But that's not the case: rank behave strangely and we cannot rewrite it as sum of something, at least I don't know any such solutions (if you do, please write them in the comments). So it looks like we are forced to understand what rank is.The rank of a matrix is a size of its largest non-vanishing minor. But our matrix is symmetric, maybe we can look only at symmetric minors (in a sense that we use the same set of rows and columns)? This is actually true but it is just a fact from linear algebra (seems to be not very well known) and has little to do with our problem, so I'll drop its proof and if someone is interested, ask me in comments.Why do we like symmetric minors? Because they correspond to induced subgraphs of our graph. And all induced subgraphs of a forest are forests too! So let's study when a forest has full rank.To do it, let's calculate determinant of its matrix. Matrix has full rank iff its determinant is non-zero. Let's write a determinant as a sum over all permutations.detA=∑π∏ni=1AiπidetA=∑π∏i=1nAiπiIf Aiπi≠0Aiπi≠0 then we have edge (i,πi)(i,πi) in our forest. Each permutation is a product of independent cycles. So to have non-zero product ∏ni=1Aiπi∏i=1nAiπi all the permutation cycles should be cycles in the forest. But forests have no cycles without repeating vertices! Well, actually they do: each edge generate one cycle of length 22. And that's all, there are no other cycles in forest (11 vertex is not a cycle, because we don't have self-loops). To have non-zero product ∏ni=1Aiπi∏i=1nAiπi all cycles of permutation must have length 22 and correspond to edges of forest. So we can divide all vertices in pairs, and in each pair there is an edge. That's the definition of perfect matching. Why can't they still result in zero sum? Because if there is a perfect matching in a forest then it is unique, so we actually have no more than one non-zero summand.OK, forest has full rank is equivalent to forest has perfect matching. Suppose that mm is the size of maximal matching of a forest. Then no its induced subgraph of size strictly greater than 2m2m can have perfect matching. And there is a subgraph of size exactly 2m2m which does have perfect matching: the ends of edges in maximal matching.Cool, we have proven the fact from the beginning. If you just want AC, continue reading from here. Now we have to calculate expected size of maximal matching. That sound much easier: we already have a linear DP which calculates maximal matching, and its values are exactly sizes of current maximal matching. To remind: dp[v][taken]dp[v][taken] is a size of maximal matching in subtree rooted at vv where boolean flag takentaken means did we already cover vertex vv or is it still free. All we have to do is to change the value stored in DP for expected value and also calculate probabilities to actually be in state with given flag takentaken.Complexity — O(n)O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62688",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1068\\s*A"
          },
          "content_length": 10105
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 1",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 2",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 3",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 4",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 5",
          "code": "-1 200 -1 200 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 6",
          "code": "Participant's output -501767591",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 1",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 2",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 3",
          "code": "After that we can find middle vertex in diameter and check if it is a center of k-multihedgehog using simple dfs.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long N = inf.readLong(1LL, 1000000000000000000LL, \"N\");\n    inf.readSpace();\n    long long M = inf.readLong(1LL, 1000000000000000000LL, \"M\");\n    inf.readSpace();\n    long long K = inf.readLong(1LL, N, \"K\");\n    inf.readSpace();\n    long long L = inf.readLong(1LL, 1000000000000000000LL, \"L\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long N = inf.readLong(1LL, 1000000000000000000LL, \"N\");\n    inf.readSpace();\n    long long M = inf.readLong(1LL, 1000000000000000000LL, \"M\");\n    inf.readSpace();\n    long long K = inf.readLong(1LL, N, \"K\");\n    inf.readSpace();\n    long long L = inf.readLong(1LL, 1000000000000000000LL, \"L\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long N = inf.readLong(1LL, 1000000000000000000LL, \"N\");\n    inf.readSpace();\n    long long M = inf.readLong(1LL, 1000000000000000000LL, \"M\");\n    inf.readSpace();\n    long long K = inf.readLong(1LL, N, \"K\");\n    inf.readSpace();\n    long long L = inf.readLong(1LL, 1000000000000000000LL, \"L\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long N = opt<long long>(\"N\", 0);\n    long long M = opt<long long>(\"M\", 0);\n    long long K = opt<long long>(\"K\", 0);\n    long long L = opt<long long>(\"L\", 0);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (N == 0) N = rnd.next(1LL, (long long)(1e18));\n        if (K == 0) K = rnd.next(1LL, N);\n        if (M == 0) M = rnd.next(1LL, (long long)(1e18));\n        if (L == 0) L = rnd.next(1LL, (long long)(1e18));\n    } else if (type == \"max_values\") {\n        N = (long long)(1e18);\n        K = rnd.next(1LL, N);\n        M = (long long)(1e18);\n        L = rnd.next(1LL, N - K);\n    } else if (type == \"min_values\") {\n        N = 1;\n        K = 1;\n        M = 1;\n        L = 1;\n    } else if (type == \"impossible\") {\n        N = rnd.next(1LL, (long long)(1e18));\n        K = rnd.next(1LL, N);\n        M = rnd.next(1LL, (long long)(1e18));\n        L = N - K + rnd.next(1LL, N); // Make it impossible to satisfy L\n    } else if (type == \"edge_k_equals_n\") {\n        N = rnd.next(1LL, (long long)(1e18));\n        K = N;\n        M = rnd.next(1LL, (long long)(1e18));\n        L = rnd.next(1LL, (long long)(1e18));\n    } else if (type == \"edge_k_equals_n_minus_one\") {\n        N = rnd.next(2LL, (long long)(1e18));\n        K = N - 1;\n        M = rnd.next(1LL, (long long)(1e18));\n        L = rnd.next(1LL, (long long)(1e18));\n    } else if (type == \"edge_m_equals_one\") {\n        if (N == 0) N = rnd.next(1LL, (long long)(1e18));\n        if (K == 0) K = rnd.next(1LL, N);\n        M = 1;\n        if (L == 0) L = rnd.next(1LL, (long long)(1e18));\n    } else {\n        // Default random\n        if (N == 0) N = rnd.next(1LL, (long long)(1e18));\n        if (K == 0) K = rnd.next(1LL, N);\n        if (M == 0) M = rnd.next(1LL, (long long)(1e18));\n        if (L == 0) L = rnd.next(1LL, (long long)(1e18));\n    }\n\n    // Ensure constraints\n    if (K > N) K = N;\n    if (K < 1) K = 1;\n    if (N < 1) N = 1;\n    if (M < 1) M = 1;\n    if (L < 1) L = 1;\n    if (N > (long long)(1e18)) N = (long long)(1e18);\n    if (K > (long long)(1e18)) K = (long long)(1e18);\n    if (M > (long long)(1e18)) M = (long long)(1e18);\n    if (L > (long long)(1e18)) L = (long long)(1e18);\n\n    printf(\"%lld %lld %lld %lld\\n\", N, M, K, L);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long N = opt<long long>(\"N\", 0);\n    long long M = opt<long long>(\"M\", 0);\n    long long K = opt<long long>(\"K\", 0);\n    long long L = opt<long long>(\"L\", 0);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (N == 0) N = rnd.next(1LL, (long long)(1e18));\n        if (K == 0) K = rnd.next(1LL, N);\n        if (M == 0) M = rnd.next(1LL, (long long)(1e18));\n        if (L == 0) L = rnd.next(1LL, (long long)(1e18));\n    } else if (type == \"max_values\") {\n        N = (long long)(1e18);\n        K = rnd.next(1LL, N);\n        M = (long long)(1e18);\n        L = rnd.next(1LL, N - K);\n    } else if (type == \"min_values\") {\n        N = 1;\n        K = 1;\n        M = 1;\n        L = 1;\n    } else if (type == \"impossible\") {\n        N = rnd.next(1LL, (long long)(1e18));\n        K = rnd.next(1LL, N);\n        M = rnd.next(1LL, (long long)(1e18));\n        L = N - K + rnd.next(1LL, N); // Make it impossible to satisfy L\n    } else if (type == \"edge_k_equals_n\") {\n        N = rnd.next(1LL, (long long)(1e18));\n        K = N;\n        M = rnd.next(1LL, (long long)(1e18));\n        L = rnd.next(1LL, (long long)(1e18));\n    } else if (type == \"edge_k_equals_n_minus_one\") {\n        N = rnd.next(2LL, (long long)(1e18));\n        K = N - 1;\n        M = rnd.next(1LL, (long long)(1e18));\n        L = rnd.next(1LL, (long long)(1e18));\n    } else if (type == \"edge_m_equals_one\") {\n        if (N == 0) N = rnd.next(1LL, (long long)(1e18));\n        if (K == 0) K = rnd.next(1LL, N);\n        M = 1;\n        if (L == 0) L = rnd.next(1LL, (long long)(1e18));\n    } else {\n        // Default random\n        if (N == 0) N = rnd.next(1LL, (long long)(1e18));\n        if (K == 0) K = rnd.next(1LL, N);\n        if (M == 0) M = rnd.next(1LL, (long long)(1e18));\n        if (L == 0) L = rnd.next(1LL, (long long)(1e18));\n    }\n\n    // Ensure constraints\n    if (K > N) K = N;\n    if (K < 1) K = 1;\n    if (N < 1) N = 1;\n    if (M < 1) M = 1;\n    if (L < 1) L = 1;\n    if (N > (long long)(1e18)) N = (long long)(1e18);\n    if (K > (long long)(1e18)) K = (long long)(1e18);\n    if (M > (long long)(1e18)) M = (long long)(1e18);\n    if (L > (long long)(1e18)) L = (long long)(1e18);\n\n    printf(\"%lld %lld %lld %lld\\n\", N, M, K, L);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -N 10 -M 5 -K 2 -L 3\n./gen -N 15 -M 3 -K 5 -L 6\n\n# Edge cases where K equals N\n./gen -N 100 -K 100 -M 5 -L 10 -type edge_k_equals_n\n./gen -N 1e18 -K 1e18 -M 1e18 -L 1e18 -type edge_k_equals_n\n\n# Edge cases where K equals N - 1\n./gen -N 1000 -K 999 -M 10 -L 1 -type edge_k_equals_n_minus_one\n./gen -N 1e18 -K 999999999999999999 -M 1000000 -L 1 -type edge_k_equals_n_minus_one\n\n# Edge case where M equals 1\n./gen -N 1000 -K 200 -M 1 -L 300 -type edge_m_equals_one\n./gen -N 1e18 -K 500000000000000000 -L 600000000000000000 -type edge_m_equals_one\n\n# Impossible cases\n./gen -type impossible\n./gen -N 100 -K 50 -M 10 -L 100 -type impossible\n\n# Maximum values\n./gen -type max_values\n./gen -N 1e18 -M 1e18 -K 500000000000000000 -L 500000000000000000 -type max_values\n\n# Minimum values\n./gen -type min_values\n./gen -N 1 -M 1 -K 1 -L 1 -type min_values\n\n# Large random test cases\n./gen -N 1000000000000 -M 1000000 -K 500000000000 -L 600000000000\n./gen -N 1e18 -M 1e17 -K 5e17 -L 1e17\n\n# Random test cases with no parameters (will generate random values)\n./gen\n./gen -type random\n\n# Test cases where L is zero (should not happen because L ≥ 1)\n./gen -N 1000 -M 10 -K 500 -L 0\n./gen -N 1e18 -M 1e18 -K 1e18 -L 0\n\n# Test cases where K is zero (should not happen because K ≥ 1)\n./gen -N 1000 -M 10 -K 0 -L 100\n./gen -N 1e18 -M 1e18 -K 0 -L 1e18\n\n# Edge case where N = K + L - 1 (impossible case)\n./gen -N 100 -K 50 -L 51 -M 10\n\n# Test cases with large M\n./gen -N 100000 -M 100000 -K 50000 -L 50000\n./gen -N 1e18 -M 1e18 -K 50000000000000000 -L 50000000000000000\n\n# Test case with N just enough to satisfy K + L\n./gen -N 150 -K 50 -L 100 -M 1\n\n# Edge cases where N is small\n./gen -N 1 -K 1 -M 1 -L 1\n./gen -N 2 -K 1 -M 1 -L 1\n\n# Test cases with maximum L\n./gen -N 1000000 -K 500000 -M 10 -L 500000\n./gen -N 1e18 -K 1e17 -M 1e5 -L 9e17\n\n# Additional random test cases\n./gen -N 50000 -K 25000 -M 500 -L 26000\n./gen -N 1000000 -K 500000 -M 1000 -L 500000\n\n# Edge case where N is less than K + L\n./gen -N 100 -K 60 -L 50 -M 10 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:49.349139",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1068/B",
      "title": "B. НОК",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеЕдинственная строка ввода содержит одно число bb (1≤b≤1010)(1≤b≤1010).",
      "output_spec": "Выходные данныеВыведите одно число: количество различных значений выражения из условия.",
      "sample_tests": "ПримерыВходные данныеСкопировать1Выходные данныеСкопировать1Входные данныеСкопировать2Выходные данныеСкопировать2",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеЕдинственная строка ввода содержит одно число bb (1≤b≤1010)(1≤b≤1010).\n\nВходные данные\n\nВыходные данныеВыведите одно число: количество различных значений выражения из условия.\n\nВыходные данные\n\nВходные данныеСкопировать1Выходные данныеСкопировать1Входные данныеСкопировать2Выходные данныеСкопировать2\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере [a,1]=a[a,1]=a, следовательно [a,b]a[a,b]a всегда равно 11.Во втором примере [a,2][a,2] может быть равно aa или 2⋅a2⋅a, в зависимости от четности aa. [a,b]a[a,b]a может принимать два значения: 11 и 22.",
      "solutions": [
        {
          "title": "Codeforces Round #518 [спасибо, Mail.Ru!] — анонс раунда - Codeforces",
          "content": "Приглашаю Вас поучаствовать в рейтинговом Codeforces Round #518. Дата и время проведения раунда: среда, 24 октября 2018 г. в 19:35. Раунд был перенесен с 23 октября на 24 в связи с проведением в это же время ICPC Indian Online Qualifier.Это первое соревнование, предложенное мной. Надеюсь, что оно вам понравится.На раунде будет 6 задач для второго дивизиона и 5 задач для первого (3 задачи общие). Контест будет длиться 2 часа.Задачи для вас составляли Алексей kristevalex Кристев и Алексей Um_nik Данилюк. Также большое спасибо:Николаю KAN Калинину и Ильдару 300iq Гайнуллинину за помощь в подготовке задач; Ивану isaf27 Сафонову и Олегу Merkurev Меркурьеву за тестирование раунда; Михаилу MikeMirzayanov Мирзаянову за платформы Codeforces и Polygon.Хочется выразить отдельную благодарность Um_nik за помощь на протяжении всего процесса подготовки раунда, а также терпимость к моим глупым вопросам. небольшое лирическое отступлениеПосле большого количества глупых вопросов...-Um_nik: Общее правило звучит как \"я не тупой\"Как вы заметили, этот раунд проводится в честь компании Mail.Ru, значительно поддержавшей Codeforces по случаю 8-летия платформы. Вот несколько слов от MikeMirzayanov:Большое спасибо Mail.Ru за поддержку Codeforces! Мы являемся партнёрами уже много лет, и было особенно приятно получить поздравления от старых друзей. Мне кажется, Mail.Ru — чемпион мира среди компаний по организации различных интересных соревнований для любителей программирования. Вот список (уверен, неполный) активностей Mail.Ru, которые могут быть интересны аудитории Codeforces: Mail.Ru Cup — новое соревнование по спортивному программированию (совместно с Codeforces!), открытое как для студентов, так и для профессиональных разработчиков; Технокубок — олимпиада по программированию для учеников 8-11 классов из России и стран СНГ (совместно с Codeforces!); Russian AI Cup (RAIC) — открытое соревнование по программированию искусственного интеллекта игровых стратегий (совместно с Codeforces!); Mini AI Cups (Mini AIC) — мини-клон чемпионата Russian AI Cup, площадка соревнований по искусственному интеллекту, связанных с написанием ботов для игр; Machine Learning Boot Camp (ML Boot Camp) — онлайн-чемпионат по машинному обучению и анализу данных; HighLoad Cup (HLC) — соревнование разработчиков высоконагруженных систем. Кроме этого Mail.Ru запустило большое количество образовательных инициатив, я сам неоднократно смотрел записи лекций на YouTube с занятий Техносферы и других проектов.Еще раз спасибо за поздравление. Надеюсь на долгосрочное и плодотворное сотрудничество!Разбалловка будет объявлена ближе к началу контеста. Желаю высокого рейтинга и жду вас на соревновании!Я буду на Codeforces Discord server в течение некоторого времени после раунда для обсуждения задач.UPD: разбалловка div1: 500 1000 1750 2250 2500 div2: 500 1250 1500 2250 2750 3500UPD2: опубликован разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62614",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2882
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces",
          "content": "1068A - BirthdayTo get LL new coins irrespective of the Ivan's collection he must get not less than L+KL+K coins as a present. Therefore each friend should gift at least X=⌈L+KM⌉X=⌈L+KM⌉ coins. But it may be not possible for all friends to gift XX coins if X⋅M>NX⋅M>N. Complexity is O(1)O(1). 1068B - LCM[a,b]a=b(a,b)[a,b]a=b(a,b), here (a,b)(a,b) is greatest common divisor. Let's see how many different values can have c=(a,b)c=(a,b). All values cc that divides bb are reachable if a=ca=c and every value of (a,b)(a,b) divides bb. So answer is number of divisors of bb. It can be calculated in O(b√)O(b) time. 1068C - Colored RooksLet's put rooks with color ii just on line number ii. Then, obviously, for any color the set of rooks of this color would be connected. Let's put rooks on positions (i,i)(i,i) for ii from 11 to nn. After that for any color there is a rook of this color on a board and for any two different colors aa bb union of set of rooks of color aa and set of rooks of color bb wouldn't be connected. And for final step we can do the following for every pair of harmonizing colors aa bb: let jj be index of first column without rooks, put rooks on cells (j,aj,a) and (j,bj,b). After that for colors aa bb union of set of rooks of color aa and set of rooks of color bb would become connected and for other pairs the connectedness doesn't change.Total number of rooks is n+2⋅mn+2⋅m. 1067A - Array Without Local Maximums Let's find solution with complexity O(n⋅a2)O(n⋅a2). We can count dp[prefix][a][flag]dp[prefix][a][flag] — quantity of ways to restore element from 11 to prefpref with last element equalls to aa, flag=0flag=0 means that previous element is less then the last or last element is first, flag=1flag=1 — the opposite. So dp[pref][a][0]=∑a−1i=1(dp[pref−1][i][1]+dp[pref−1][i][0])dp[pref][a][0]=∑i=1a−1(dp[pref−1][i][1]+dp[pref−1][i][0]), dp[pref][a][1]=dp[pref−1][a][0]+∑200i=adp[pref−1][i][1]dp[pref][a][1]=dp[pref−1][a][0]+∑i=a200dp[pref−1][i][1].Now let's count prefix_sums[a][flag]=∑ai=1dp[pref][i][flag]prefix_sums[a][flag]=∑i=1adp[pref][i][flag] on each prefix before counting all dp[pref]dp[pref], so we can recalculate dp in O(1) time.Complexity is O(n⋅a)O(n⋅a). 1067B - MultihedgehogSolution 1: Firstly let's find all vertices with degree 11. Now we can delete them and all, verticies which were incident to them must became verticies with degree 11. And also for each new veretice with degree 11 we must have already deleted not less then 33 verticies. If initial graph was kk-multihedgehog, after deleting vertices with degree 11 it would became k−1k−1-multihedgehog.It could be realised using bfs starting from all initial vertices with degree 11.Complexity is O(n)O(n).Solution 2: First of all let's find diametr of the graph. After that we can find middle vertex in diameter and check if it is a center of kk-multihedgehog using simple dfs.Complexity is O(n)O(n). Tutorial is loading... Tutorial is loading... 1067E - Random Forest RankI'll try to explain how to come up with this solution rather than just state the fact. For those who are more interested in getting AC, here is your fact: rank of a forest is twice the size of maximal matching.When we see expected value, we usually want to somehow rewrite the thing under the expected value, apply linearity of expectation and then calculate some independent values. But that's not the case: rank behave strangely and we cannot rewrite it as sum of something, at least I don't know any such solutions (if you do, please write them in the comments). So it looks like we are forced to understand what rank is.The rank of a matrix is a size of its largest non-vanishing minor. But our matrix is symmetric, maybe we can look only at symmetric minors (in a sense that we use the same set of rows and columns)? This is actually true but it is just a fact from linear algebra (seems to be not very well known) and has little to do with our problem, so I'll drop its proof and if someone is interested, ask me in comments.Why do we like symmetric minors? Because they correspond to induced subgraphs of our graph. And all induced subgraphs of a forest are forests too! So let's study when a forest has full rank.To do it, let's calculate determinant of its matrix. Matrix has full rank iff its determinant is non-zero. Let's write a determinant as a sum over all permutations.detA=∑π∏ni=1AiπidetA=∑π∏i=1nAiπiIf Aiπi≠0Aiπi≠0 then we have edge (i,πi)(i,πi) in our forest. Each permutation is a product of independent cycles. So to have non-zero product ∏ni=1Aiπi∏i=1nAiπi all the permutation cycles should be cycles in the forest. But forests have no cycles without repeating vertices! Well, actually they do: each edge generate one cycle of length 22. And that's all, there are no other cycles in forest (11 vertex is not a cycle, because we don't have self-loops). To have non-zero product ∏ni=1Aiπi∏i=1nAiπi all cycles of permutation must have length 22 and correspond to edges of forest. So we can divide all vertices in pairs, and in each pair there is an edge. That's the definition of perfect matching. Why can't they still result in zero sum? Because if there is a perfect matching in a forest then it is unique, so we actually have no more than one non-zero summand.OK, forest has full rank is equivalent to forest has perfect matching. Suppose that mm is the size of maximal matching of a forest. Then no its induced subgraph of size strictly greater than 2m2m can have perfect matching. And there is a subgraph of size exactly 2m2m which does have perfect matching: the ends of edges in maximal matching.Cool, we have proven the fact from the beginning. If you just want AC, continue reading from here. Now we have to calculate expected size of maximal matching. That sound much easier: we already have a linear DP which calculates maximal matching, and its values are exactly sizes of current maximal matching. To remind: dp[v][taken]dp[v][taken] is a size of maximal matching in subtree rooted at vv where boolean flag takentaken means did we already cover vertex vv or is it still free. All we have to do is to change the value stored in DP for expected value and also calculate probabilities to actually be in state with given flag takentaken.Complexity — O(n)O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62688",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1068\\s*B"
          },
          "content_length": 6270
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #518 [спасибо, Mail.Ru!] — анонс раунда - Codeforces - Code 1",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [спасибо, Mail.Ru!] — анонс раунда - Codeforces - Code 2",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [спасибо, Mail.Ru!] — анонс раунда - Codeforces - Code 3",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [спасибо, Mail.Ru!] — анонс раунда - Codeforces - Code 4",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [спасибо, Mail.Ru!] — анонс раунда - Codeforces - Code 5",
          "code": "-1 200 -1 200 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [спасибо, Mail.Ru!] — анонс раунда - Codeforces - Code 6",
          "code": "Participant's output -501767591",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 1",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 2",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 3",
          "code": "After that we can find middle vertex in diameter and check if it is a center of k-multihedgehog using simple dfs.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long b = inf.readLong(1LL, 10000000000LL, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long b = inf.readLong(1LL, 10000000000LL, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long b = inf.readLong(1LL, 10000000000LL, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* \n   A helper function to check primality for numbers up to 1e6.\n   We'll only use it for quick prime checks when type=\"prime\". \n   For b <= 1e6, a simple sqrt check is enough for a generator.\n*/\nbool isPrime(long long x) {\n    if (x < 2) return false;\n    if (x < 4) return true;\n    if (x % 2 == 0) return (x == 2);\n    for (long long i = 3; i * i <= x; i += 2) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the test type (defaults to \"random\").\n    string type = opt<string>(\"type\", \"random\");\n\n    // We will generate one integer b per run, in [1..1e10].\n    long long b = 1;\n\n    if (type == \"one\") {\n        // minimal\n        b = 1;\n    }\n    else if (type == \"max\") {\n        // maximum within the constraint\n        b = 10000000000LL; \n    }\n    else if (type == \"small\") {\n        // small range random\n        b = rnd.next(1LL, 100LL); \n    }\n    else if (type == \"prime\") {\n        // Generate a prime up to 1e6\n        bool found = false;\n        for (int attempt = 0; attempt < 50 && !found; attempt++) {\n            long long cand = rnd.next(2LL, 1000000LL);\n            if (isPrime(cand)) {\n                b = cand;\n                found = true;\n            }\n        }\n        // If we didn't find one, pick from a small prime list\n        if (!found) {\n            vector<long long> fallback = {2,3,5,7,11,13,17,19,23,29,31,\n                                          37,41,43,47,53,59,61,67,71};\n            b = fallback[rnd.next((int)fallback.size())];\n        }\n    }\n    else if (type == \"pow2\") {\n        // All powers of 2 up to 1e10\n        // 2^33 = 8589934592 <= 1e10, 2^34 = 17179869184 > 1e10\n        vector<long long> p2;\n        long long val = 1;\n        while (val <= 10000000000LL) {\n            p2.push_back(val);\n            val <<= 1;\n        }\n        b = p2[rnd.next((int)p2.size())];\n    }\n    else if (type == \"composite\") {\n        // Generate a random composite <= 1e10 by picking two factors\n        // up to 1e5. We'll try multiple times to ensure we land <= 1e10.\n        for (int attempt = 0; attempt < 100; attempt++) {\n            long long x = rnd.next(2LL, 100000LL);\n            long long y = rnd.next(2LL, 100000LL);\n            long long prod = x * y;\n            if (prod <= 10000000000LL) {\n                b = prod;\n                break;\n            }\n        }\n        // If we fail, just pick something known composite and small.\n        if (b == 1) {\n            b = 10000; // 10000 is composite and < 1e10\n        }\n    }\n    else if (type == \"tricky1\") {\n        // A perfect square below 1e10. For example, 99999^2 = 9999800001.\n        b = 99999LL * 99999LL;\n    }\n    else if (type == \"tricky2\") {\n        // Product of first several primes: 2*3*5*7*11 = 2310\n        b = 2310;\n    }\n    else {\n        // random in [1..1e10]\n        b = rnd.next(1LL, 10000000000LL);\n    }\n\n    // Output the single integer b\n    cout << b << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* \n   A helper function to check primality for numbers up to 1e6.\n   We'll only use it for quick prime checks when type=\"prime\". \n   For b <= 1e6, a simple sqrt check is enough for a generator.\n*/\nbool isPrime(long long x) {\n    if (x < 2) return false;\n    if (x < 4) return true;\n    if (x % 2 == 0) return (x == 2);\n    for (long long i = 3; i * i <= x; i += 2) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the test type (defaults to \"random\").\n    string type = opt<string>(\"type\", \"random\");\n\n    // We will generate one integer b per run, in [1..1e10].\n    long long b = 1;\n\n    if (type == \"one\") {\n        // minimal\n        b = 1;\n    }\n    else if (type == \"max\") {\n        // maximum within the constraint\n        b = 10000000000LL; \n    }\n    else if (type == \"small\") {\n        // small range random\n        b = rnd.next(1LL, 100LL); \n    }\n    else if (type == \"prime\") {\n        // Generate a prime up to 1e6\n        bool found = false;\n        for (int attempt = 0; attempt < 50 && !found; attempt++) {\n            long long cand = rnd.next(2LL, 1000000LL);\n            if (isPrime(cand)) {\n                b = cand;\n                found = true;\n            }\n        }\n        // If we didn't find one, pick from a small prime list\n        if (!found) {\n            vector<long long> fallback = {2,3,5,7,11,13,17,19,23,29,31,\n                                          37,41,43,47,53,59,61,67,71};\n            b = fallback[rnd.next((int)fallback.size())];\n        }\n    }\n    else if (type == \"pow2\") {\n        // All powers of 2 up to 1e10\n        // 2^33 = 8589934592 <= 1e10, 2^34 = 17179869184 > 1e10\n        vector<long long> p2;\n        long long val = 1;\n        while (val <= 10000000000LL) {\n            p2.push_back(val);\n            val <<= 1;\n        }\n        b = p2[rnd.next((int)p2.size())];\n    }\n    else if (type == \"composite\") {\n        // Generate a random composite <= 1e10 by picking two factors\n        // up to 1e5. We'll try multiple times to ensure we land <= 1e10.\n        for (int attempt = 0; attempt < 100; attempt++) {\n            long long x = rnd.next(2LL, 100000LL);\n            long long y = rnd.next(2LL, 100000LL);\n            long long prod = x * y;\n            if (prod <= 10000000000LL) {\n                b = prod;\n                break;\n            }\n        }\n        // If we fail, just pick something known composite and small.\n        if (b == 1) {\n            b = 10000; // 10000 is composite and < 1e10\n        }\n    }\n    else if (type == \"tricky1\") {\n        // A perfect square below 1e10. For example, 99999^2 = 9999800001.\n        b = 99999LL * 99999LL;\n    }\n    else if (type == \"tricky2\") {\n        // Product of first several primes: 2*3*5*7*11 = 2310\n        b = 2310;\n    }\n    else {\n        // random in [1..1e10]\n        b = rnd.next(1LL, 10000000000LL);\n    }\n\n    // Output the single integer b\n    cout << b << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are 20 distinct commands to produce various test cases.\n# Each run prints exactly one integer b. No output redirection is used.\n\n./gen -type one\n./gen -type max\n./gen -type small\n./gen -type small\n./gen -type prime\n./gen -type prime\n./gen -type pow2\n./gen -type composite\n./gen -type tricky1\n./gen -type tricky2\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type composite\n./gen -type composite\n./gen -type prime\n./gen -type pow2\n./gen -type small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:50.906833",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1068/C",
      "title": "C. Colored Rooks",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains 22 integers nn, mm (1≤n≤1001≤n≤100, 0≤m≤min(1000,n(n−1)2)0≤m≤min(1000,n(n−1)2)) — number of colors and number of pairs of colors which harmonize with each other.In next mm lines pairs of colors which harmonize with each other are listed. Colors are numbered from 11 to nn. It is guaranteed that no pair occurs twice in this list.",
      "output_spec": "OutputPrint nn blocks, ii-th of them describes rooks of ii-th color.In the first line of block print one number aiai (1≤ai≤50001≤ai≤5000) — number of rooks of color ii. In each of next aiai lines print two integers xx and yy (1≤x,y≤1091≤x,y≤109) — coordinates of the next rook.All rooks must be on different cells.Total number of rooks must not exceed 50005000.It is guaranteed that the solution exists.",
      "sample_tests": "ExamplesInputCopy3 21 22 3OutputCopy23 41 441 22 22 45 415 1InputCopy3 31 22 33 1OutputCopy11 111 211 3InputCopy3 11 3OutputCopy11 112 213 1",
      "description": "C. Colored Rooks\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains 22 integers nn, mm (1≤n≤1001≤n≤100, 0≤m≤min(1000,n(n−1)2)0≤m≤min(1000,n(n−1)2)) — number of colors and number of pairs of colors which harmonize with each other.In next mm lines pairs of colors which harmonize with each other are listed. Colors are numbered from 11 to nn. It is guaranteed that no pair occurs twice in this list.\n\nOutputPrint nn blocks, ii-th of them describes rooks of ii-th color.In the first line of block print one number aiai (1≤ai≤50001≤ai≤5000) — number of rooks of color ii. In each of next aiai lines print two integers xx and yy (1≤x,y≤1091≤x,y≤109) — coordinates of the next rook.All rooks must be on different cells.Total number of rooks must not exceed 50005000.It is guaranteed that the solution exists.\n\nInputCopy3 21 22 3OutputCopy23 41 441 22 22 45 415 1InputCopy3 31 22 33 1OutputCopy11 111 211 3InputCopy3 11 3OutputCopy11 112 213 1\n\nInputCopy3 21 22 3\n\nOutputCopy23 41 441 22 22 45 415 1\n\nInputCopy3 31 22 33 1\n\nOutputCopy11 111 211 3\n\nInputCopy3 11 3\n\nOutputCopy11 112 213 1\n\nNoteRooks arrangements for all three examples (red is color 11, green is color 22 and blue is color 33).",
      "solutions": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces",
          "content": "I would like to invite you to participate in the rated Codeforces Round #518. Date and time of the round: Wednesday, October 24, 2018 at 18:05. The round was postponed from October 23 to October 24 because of the ICPC Indian Online Qualifier. This is the first competition I proposed. I hope you will enjoy it. The round will have 6 tasks for the second division and 5 tasks for first (3 problems are common). The contest will last for 2 hours. Tasks for you were prepared by Alexey kristevalex Kristev and Alexey Um_nik Danilyuk. Also thanks for: Nikolay KAN Kalinin and Ildar 300iq Gainullin for help in preparing the problems; Ivan isaf27 Safonov и Oleg Merkurev Merkurev for testing the round; Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon platforms. I would like to express a special gratitude to Um_nik for the help throughout the process of preparing the round and also for patience for my stupid questions. slight lyrical digressionAfter a lot of stupid questions... -Um_nik: The general rule is \"I'm not stupid\" This round is a thanks-round for support from Mail.Ru during the 8-year campaign!Scoring distribution will be announced later. I wish you a high rating and looking forward to see you at the competition!I'll be on the community Discord server shortly after the contest to discuss the problems.UPD: scoring distribution div1: 500 1000 1750 2250 2500 div2: 500 1250 1500 2250 2750 3500UPD2: edtorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62614",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1430
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces",
          "content": "1068A - BirthdayTo get LL new coins irrespective of the Ivan's collection he must get not less than L+KL+K coins as a present. Therefore each friend should gift at least X=⌈L+KM⌉X=⌈L+KM⌉ coins. But it may be not possible for all friends to gift XX coins if X⋅M>NX⋅M>N. Complexity is O(1)O(1). 1068B - LCM[a,b]a=b(a,b)[a,b]a=b(a,b), here (a,b)(a,b) is greatest common divisor. Let's see how many different values can have c=(a,b)c=(a,b). All values cc that divides bb are reachable if a=ca=c and every value of (a,b)(a,b) divides bb. So answer is number of divisors of bb. It can be calculated in O(b√)O(b) time. 1068C - Colored RooksLet's put rooks with color ii just on line number ii. Then, obviously, for any color the set of rooks of this color would be connected. Let's put rooks on positions (i,i)(i,i) for ii from 11 to nn. After that for any color there is a rook of this color on a board and for any two different colors aa bb union of set of rooks of color aa and set of rooks of color bb wouldn't be connected. And for final step we can do the following for every pair of harmonizing colors aa bb: let jj be index of first column without rooks, put rooks on cells (j,aj,a) and (j,bj,b). After that for colors aa bb union of set of rooks of color aa and set of rooks of color bb would become connected and for other pairs the connectedness doesn't change.Total number of rooks is n+2⋅mn+2⋅m. 1067A - Array Without Local Maximums Let's find solution with complexity O(n⋅a2)O(n⋅a2). We can count dp[prefix][a][flag]dp[prefix][a][flag] — quantity of ways to restore element from 11 to prefpref with last element equalls to aa, flag=0flag=0 means that previous element is less then the last or last element is first, flag=1flag=1 — the opposite. So dp[pref][a][0]=∑a−1i=1(dp[pref−1][i][1]+dp[pref−1][i][0])dp[pref][a][0]=∑i=1a−1(dp[pref−1][i][1]+dp[pref−1][i][0]), dp[pref][a][1]=dp[pref−1][a][0]+∑200i=adp[pref−1][i][1]dp[pref][a][1]=dp[pref−1][a][0]+∑i=a200dp[pref−1][i][1].Now let's count prefix_sums[a][flag]=∑ai=1dp[pref][i][flag]prefix_sums[a][flag]=∑i=1adp[pref][i][flag] on each prefix before counting all dp[pref]dp[pref], so we can recalculate dp in O(1) time.Complexity is O(n⋅a)O(n⋅a). 1067B - MultihedgehogSolution 1: Firstly let's find all vertices with degree 11. Now we can delete them and all, verticies which were incident to them must became verticies with degree 11. And also for each new veretice with degree 11 we must have already deleted not less then 33 verticies. If initial graph was kk-multihedgehog, after deleting vertices with degree 11 it would became k−1k−1-multihedgehog.It could be realised using bfs starting from all initial vertices with degree 11.Complexity is O(n)O(n).Solution 2: First of all let's find diametr of the graph. After that we can find middle vertex in diameter and check if it is a center of kk-multihedgehog using simple dfs.Complexity is O(n)O(n). 1067C - KnightsIf after some loops of the process we will have two neighboring lines with length xx total complexity of knights would be not less than O(x24)O(x24).In this construction:00 — initial placement.1,21,2 — added knights. Would be two neighboring lines with length O(2⋅n3)O(2⋅n3) so total complexity of knights would be O((2⋅n3)24)=O(n29)O((2⋅n3)24)=O(n29).The possible way to facilitate the invention this (or over) solutions is to write process modeling.Bonus: Solve this problem with complexity O(n26)O(n26). 1067D - Computer GameLet's denote max(bipi)max(bipi) as MM. Independent of our strategy we cannot get more than MM in one second (in expected value). But if we could upgrade one quest, we would upgrade the quest which maximizes bipibipi and then try to complete only this quest each second, thus getting +M+M to expected value each second. Therefore, our strategy looks like this: try to complete quests in some order, once we complete one quest we will always get +M+M to expected value each second.This observation leads to DP solution. Once we have one quest completed we already know what we will get, so interesting states are only those in which no quests are completed yet. Then it is not important what quests we tried to complete before, the only important parameter is remaining time.dpt+1=max(pi(ai+tM)+(1−pi)dpt)dpt+1=max(pi(ai+tM)+(1−pi)dpt).If we succeed then we will get aiai as a reward and for remaining tt seconds we will get MM each second, otherwise we get nothing and now only tt seconds left. This solution works in O(nT)O(nT) time which is too slow.We can slightly rewrite the formula for transition: dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai)dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai).Now we can see that we take maximum value of functions pi⋅x+piaipi⋅x+piai in point xt=tM−dptxt=tM−dpt. We can build convex hull on these lines thus getting O(nlogn+Tlogn)O(nlog⁡n+Tlog⁡n) solution.But that's not all. We can actually prove that xt≤xt+1xt≤xt+1 or, after some substitutions and simplifications, dpt+1−dpt≤Mdpt+1−dpt≤M. This we will prove by actual meaning of dptdpt. Take optimal solution for t+1t+1 seconds and do the same for tt seconds, except that we don't have last second, so we will just drop our action. But we can't gain more than MM in one second, so this drop cannot decrease answer more than MM. Thus the inequality is proven.This means that we only move right along over convex hull, so for each line there will be consecutive seconds in which we are using that line. If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster.Let's start with learning how to make many DP transitions (when we are staying on one line for the whole time). It is more clear using first formula for DP transition: dpt+1=pi(ai+tM)+(1−pi)dptdpt+1=pi(ai+tM)+(1−pi)dpt (we don't have max now because we already know which line to use). We can see that to get vector (dpt+1t+11)T(dpt+1t+11)T from vector (dptt1)T(dptt1)T we can apply linear transformation i.e. multiply by some matrix:⎛⎝⎜dpt+1t+11⎞⎠⎟=⎛⎝⎜1−pi00piM10piai11⎞⎠⎟⎛⎝⎜dptt1⎞⎠⎟(dpt+1t+11)=(1−pipiMpiai011001)(dptt1)To apply it kk times just use binary exponentiation to get kk-th power of transition matrix.To determine how long we actually have to stay on given line we will use binary search on answer. We know for which value of xx we should move to the next line and we know that xx increases with each second, so we can try to stay on given line for some time and see if we should actually change the line.This is already O(n(logn+log2T))O(n(log⁡n+log2⁡T)) solution, but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time.Final complexity is O(n(logn+logT))O(n(log⁡n+log⁡T)) 1067E - Random Forest RankI'll try to explain how to come up with this solution rather than just state the fact. For those who are more interested in getting AC, here is your fact: rank of a forest is twice the size of maximal matching.When we see expected value, we usually want to somehow rewrite the thing under the expected value, apply linearity of expectation and then calculate some independent values. But that's not the case: rank behave strangely and we cannot rewrite it as sum of something, at least I don't know any such solutions (if you do, please write them in the comments). So it looks like we are forced to understand what rank is.The rank of a matrix is a size of its largest non-vanishing minor. But our matrix is symmetric, maybe we can look only at symmetric minors (in a sense that we use the same set of rows and columns)? This is actually true but it is just a fact from linear algebra (seems to be not very well known) and has little to do with our problem, so I'll drop its proof and if someone is interested, ask me in comments.Why do we like symmetric minors? Because they correspond to induced subgraphs of our graph. And all induced subgraphs of a forest are forests too! So let's study when a forest has full rank.To do it, let's calculate determinant of its matrix. Matrix has full rank iff its determinant is non-zero. Let's write a determinant as a sum over all permutations.detA=∑π∏ni=1AiπidetA=∑π∏i=1nAiπiIf Aiπi≠0Aiπi≠0 then we have edge (i,πi)(i,πi) in our forest. Each permutation is a product of independent cycles. So to have non-zero product ∏ni=1Aiπi∏i=1nAiπi all the permutation cycles should be cycles in the forest. But forests have no cycles without repeating vertices! Well, actually they do: each edge generate one cycle of length 22. And that's all, there are no other cycles in forest (11 vertex is not a cycle, because we don't have self-loops). To have non-zero product ∏ni=1Aiπi∏i=1nAiπi all cycles of permutation must have length 22 and correspond to edges of forest. So we can divide all vertices in pairs, and in each pair there is an edge. That's the definition of perfect matching. Why can't they still result in zero sum? Because if there is a perfect matching in a forest then it is unique, so we actually have no more than one non-zero summand.OK, forest has full rank is equivalent to forest has perfect matching. Suppose that mm is the size of maximal matching of a forest. Then no its induced subgraph of size strictly greater than 2m2m can have perfect matching. And there is a subgraph of size exactly 2m2m which does have perfect matching: the ends of edges in maximal matching.Cool, we have proven the fact from the beginning. If you just want AC, continue reading from here. Now we have to calculate expected size of maximal matching. That sound much easier: we already have a linear DP which calculates maximal matching, and its values are exactly sizes of current maximal matching. To remind: dp[v][taken]dp[v][taken] is a size of maximal matching in subtree rooted at vv where boolean flag takentaken means did we already cover vertex vv or is it still free. All we have to do is to change the value stored in DP for expected value and also calculate probabilities to actually be in state with given flag takentaken.Complexity — O(n)O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62688",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1068\\s*C"
          },
          "content_length": 10105
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 1",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 2",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 3",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 4",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 5",
          "code": "-1 200 -1 200 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 6",
          "code": "Participant's output -501767591",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 1",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 2",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 3",
          "code": "After that we can find middle vertex in diameter and check if it is a center of k-multihedgehog using simple dfs.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int max_m = min(1000, n*(n-1)/2);\n    int m = inf.readInt(0, max_m, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"No loops allowed: u_i (%d) == v_i (%d)\", u, v);\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(pairs.count({a, b}) == 0, \"Pair (%d, %d) occurs more than once\", a, b);\n        pairs.insert({a, b});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int max_m = min(1000, n*(n-1)/2);\n    int m = inf.readInt(0, max_m, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"No loops allowed: u_i (%d) == v_i (%d)\", u, v);\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(pairs.count({a, b}) == 0, \"Pair (%d, %d) occurs more than once\", a, b);\n        pairs.insert({a, b});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int max_m = min(1000, n*(n-1)/2);\n    int m = inf.readInt(0, max_m, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"No loops allowed: u_i (%d) == v_i (%d)\", u, v);\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(pairs.count({a, b}) == 0, \"Pair (%d, %d) occurs more than once\", a, b);\n        pairs.insert({a, b});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 100;\nconst int MAX_ROOKS = 5000;\nconst int MAX_COORD = 1e9;\n\nint n, m;\nbool harmonize[MAX_N + 1][MAX_N + 1];\nvector<int> per_color_rook_indices[MAX_N + 1];\nvector<int> rook_color;\nvector<pair<int, int>> rook_positions;\nmap<pair<int, int>, int> position_to_index;\nmap<int, vector<int>> x_coord_to_rook_indices;\nmap<int, vector<int>> y_coord_to_rook_indices;\n\nint find_set(int v, vector<int>& parent) {\n    if (parent[v] == v)\n        return v;\n    return parent[v] = find_set(parent[v], parent);\n}\n\nvoid union_sets(int a, int b, vector<int>& parent) {\n    a = find_set(a, parent);\n    b = find_set(b, parent);\n    if (a != b)\n        parent[b] = a;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read input from inf\n    n = inf.readInt(1, 100, \"n\");\n    m = inf.readInt(0, min(1000, n * (n - 1) / 2), \"m\");\n    memset(harmonize, false, sizeof(harmonize));\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        int v = inf.readInt(1, n, \"v\");\n        if (u == v)\n            inf.quitf(_fail, \"Color cannot harmonize with itself.\");\n        harmonize[u][v] = harmonize[v][u] = true;\n    }\n    \n    // Read output from ouf\n    int total_rooks = 0;\n    set<pair<int, int>> positions_set;\n    for (int c = 1; c <= n; ++c) {\n        if (ouf.eof())\n            ouf.quitf(_wa, \"Unexpected end of file when reading color %d.\", c);\n        int a_c = ouf.readInt(1, 5000, format(\"a[%d]\", c).c_str());\n        if (a_c < 1)\n            ouf.quitf(_wa, \"No rook of color %d.\", c);\n        total_rooks += a_c;\n        if (total_rooks > MAX_ROOKS)\n            ouf.quitf(_wa, \"Total number of rooks exceeds 5000.\");\n        for (int i = 0; i < a_c; ++i) {\n            int x = ouf.readInt(1, MAX_COORD, format(\"x[%d][%d]\", c, i + 1).c_str());\n            int y = ouf.readInt(1, MAX_COORD, format(\"y[%d][%d]\", c, i + 1).c_str());\n            pair<int, int> pos = make_pair(x, y);\n            if (positions_set.count(pos))\n                ouf.quitf(_wa, \"Rook at position (%d, %d) appears multiple times.\", x, y);\n            positions_set.insert(pos);\n            int rook_index = rook_positions.size();\n            rook_positions.push_back(pos);\n            rook_color.push_back(c);\n            position_to_index[pos] = rook_index;\n            x_coord_to_rook_indices[x].push_back(rook_index);\n            y_coord_to_rook_indices[y].push_back(rook_index);\n            per_color_rook_indices[c].push_back(rook_index);\n        }\n    }\n    \n    // Check per-color connectivity\n    for (int c = 1; c <= n; ++c) {\n        vector<int>& rook_indices = per_color_rook_indices[c];\n        int num_rooks = rook_indices.size();\n        vector<int> parent(num_rooks);\n        map<int, int> index_mapping; // Map from global rook index to local index\n        for (int i = 0; i < num_rooks; ++i) {\n            parent[i] = i;\n            index_mapping[rook_indices[i]] = i;\n        }\n        // Union rooks that share x coordinate\n        for (auto& entry : x_coord_to_rook_indices) {\n            int x = entry.first;\n            vector<int>& indices = entry.second;\n            vector<int> color_indices;\n            for (int idx : indices) {\n                if (rook_color[idx] == c)\n                    color_indices.push_back(idx);\n            }\n            for (size_t i = 1; i < color_indices.size(); ++i) {\n                int u = index_mapping[color_indices[0]];\n                int v = index_mapping[color_indices[i]];\n                union_sets(u, v, parent);\n            }\n        }\n        // Union rooks that share y coordinate\n        for (auto& entry : y_coord_to_rook_indices) {\n            int y = entry.first;\n            vector<int>& indices = entry.second;\n            vector<int> color_indices;\n            for (int idx : indices) {\n                if (rook_color[idx] == c)\n                    color_indices.push_back(idx);\n            }\n            for (size_t i = 1; i < color_indices.size(); ++i) {\n                int u = index_mapping[color_indices[0]];\n                int v = index_mapping[color_indices[i]];\n                union_sets(u, v, parent);\n            }\n        }\n        // Check if all rooks are in the same connected component\n        int root = find_set(0, parent);\n        for (int i = 1; i < num_rooks; ++i) {\n            if (find_set(i, parent) != root)\n                ouf.quitf(_wa, \"Rooks of color %d are not connected.\", c);\n        }\n    }\n    \n    // Check pairs of colors\n    for (int a = 1; a <= n; ++a) {\n        for (int b = a + 1; b <= n; ++b) {\n            vector<int> rook_indices;\n            for (int idx : per_color_rook_indices[a])\n                rook_indices.push_back(idx);\n            for (int idx : per_color_rook_indices[b])\n                rook_indices.push_back(idx);\n            int num_rooks = rook_indices.size();\n            vector<int> parent(num_rooks);\n            for (int i = 0; i < num_rooks; ++i)\n                parent[i] = i;\n            map<pair<int, int>, vector<int>> coord_to_indices;\n            // Union rooks that share x coordinate\n            for (int i = 0; i < num_rooks; ++i) {\n                int idx = rook_indices[i];\n                int x = rook_positions[idx].first;\n                coord_to_indices[make_pair(x, 0)].push_back(i);\n            }\n            for (auto& entry : coord_to_indices) {\n                vector<int>& indices = entry.second;\n                for (size_t i = 1; i < indices.size(); ++i)\n                    union_sets(indices[0], indices[i], parent);\n            }\n            coord_to_indices.clear();\n            // Union rooks that share y coordinate\n            for (int i = 0; i < num_rooks; ++i) {\n                int idx = rook_indices[i];\n                int y = rook_positions[idx].second;\n                coord_to_indices[make_pair(y, 1)].push_back(i);\n            }\n            for (auto& entry : coord_to_indices) {\n                vector<int>& indices = entry.second;\n                for (size_t i = 1; i < indices.size(); ++i)\n                    union_sets(indices[0], indices[i], parent);\n            }\n            // Count connected components\n            set<int> components;\n            for (int i = 0; i < num_rooks; ++i)\n                components.insert(find_set(i, parent));\n            bool should_be_connected = harmonize[a][b];\n            if (should_be_connected && components.size() > 1)\n                ouf.quitf(_wa, \"Rooks of colors %d and %d, which harmonize, are not connected.\", a, b);\n            if (!should_be_connected && components.size() == 1)\n                ouf.quitf(_wa, \"Rooks of colors %d and %d, which do not harmonize, are connected.\", a, b);\n        }\n    }\n    \n    quitf(_ok, \"Solution is correct.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int m;\n    vector<pair<int,int>> harmonizing_pairs;\n\n    if (type == \"complete\") {\n        m = min(1000, n*(n-1)/2);\n        for (int i = 1; i <= n && (int)harmonizing_pairs.size() < m; ++i) {\n            for (int j = i + 1; j <= n && (int)harmonizing_pairs.size() < m; ++j) {\n                harmonizing_pairs.push_back({i, j});\n            }\n        }\n    } else if (type == \"empty\") {\n        m = 0;\n    } else if (type == \"line\") {\n        m = n - 1;\n        for (int i = 1; i < n; ++i) {\n            harmonizing_pairs.push_back({i, i+1});\n        }\n    } else if (type == \"star\") {\n        m = n - 1;\n        for (int i = 2; i <= n; ++i) {\n            harmonizing_pairs.push_back({1, i});\n        }\n    } else if (type == \"cycle\") {\n        if (n >= 3) {\n            m = n;\n            for (int i = 1; i <= n; ++i) {\n                harmonizing_pairs.push_back({i, i % n + 1});\n            }\n        } else {\n            m = n - 1;\n            for (int i = 1; i < n; ++i) {\n                harmonizing_pairs.push_back({i, i+1});\n            }\n        }\n    } else { // \"random\"\n        int max_m = min(1000, n*(n-1)/2);\n        m = opt<int>(\"m\", rnd.next(0, max_m));\n        set<pair<int,int>> pairs_set;\n        while ((int)pairs_set.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a,b);\n            pairs_set.insert({a,b});\n        }\n        harmonizing_pairs.assign(pairs_set.begin(), pairs_set.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output m pairs\n    for (auto p : harmonizing_pairs) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int m;\n    vector<pair<int,int>> harmonizing_pairs;\n\n    if (type == \"complete\") {\n        m = min(1000, n*(n-1)/2);\n        for (int i = 1; i <= n && (int)harmonizing_pairs.size() < m; ++i) {\n            for (int j = i + 1; j <= n && (int)harmonizing_pairs.size() < m; ++j) {\n                harmonizing_pairs.push_back({i, j});\n            }\n        }\n    } else if (type == \"empty\") {\n        m = 0;\n    } else if (type == \"line\") {\n        m = n - 1;\n        for (int i = 1; i < n; ++i) {\n            harmonizing_pairs.push_back({i, i+1});\n        }\n    } else if (type == \"star\") {\n        m = n - 1;\n        for (int i = 2; i <= n; ++i) {\n            harmonizing_pairs.push_back({1, i});\n        }\n    } else if (type == \"cycle\") {\n        if (n >= 3) {\n            m = n;\n            for (int i = 1; i <= n; ++i) {\n                harmonizing_pairs.push_back({i, i % n + 1});\n            }\n        } else {\n            m = n - 1;\n            for (int i = 1; i < n; ++i) {\n                harmonizing_pairs.push_back({i, i+1});\n            }\n        }\n    } else { // \"random\"\n        int max_m = min(1000, n*(n-1)/2);\n        m = opt<int>(\"m\", rnd.next(0, max_m));\n        set<pair<int,int>> pairs_set;\n        while ((int)pairs_set.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a,b);\n            pairs_set.insert({a,b});\n        }\n        harmonizing_pairs.assign(pairs_set.begin(), pairs_set.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output m pairs\n    for (auto p : harmonizing_pairs) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type empty\n./gen -n 1 -type complete\n./gen -n 2 -type empty\n./gen -n 2 -type complete\n./gen -n 3 -type line\n./gen -n 3 -type star\n./gen -n 3 -type cycle\n./gen -n 3 -type random -m 1\n./gen -n 5 -type complete\n./gen -n 5 -type empty\n./gen -n 5 -type random -m 0\n./gen -n 5 -type random -m 10\n./gen -n 10 -type line\n./gen -n 10 -type star\n./gen -n 20 -type random -m 50\n./gen -n 50 -type complete\n./gen -n 50 -type random -m 500\n./gen -n 50 -type empty\n./gen -n 100 -type random -m 1000\n./gen -n 100 -type empty\n./gen -n 100 -type line\n./gen -n 100 -type star\n./gen -n 100 -type cycle\n./gen -n 100 -type random\n./gen -n 99 -type random -m 990\n./gen -n 100 -type random -m 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:53.035879",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1068/D",
      "title": "D. Array Without Local Maximums",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputFirst line of input contains one integer nn (2≤n≤1052≤n≤105) — size of the array.Second line of input contains nn integers aiai — elements of array. Either ai=−1ai=−1 or 1≤ai≤2001≤ai≤200. ai=−1ai=−1 means that ii-th element can't be read.",
      "output_spec": "OutputPrint number of ways to restore the array modulo 998244353998244353.",
      "sample_tests": "ExamplesInputCopy31 -1 2OutputCopy1InputCopy2-1 -1OutputCopy200",
      "description": "D. Array Without Local Maximums\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of input contains one integer nn (2≤n≤1052≤n≤105) — size of the array.Second line of input contains nn integers aiai — elements of array. Either ai=−1ai=−1 or 1≤ai≤2001≤ai≤200. ai=−1ai=−1 means that ii-th element can't be read.\n\nOutputPrint number of ways to restore the array modulo 998244353998244353.\n\nInputCopy31 -1 2OutputCopy1InputCopy2-1 -1OutputCopy200\n\nInputCopy31 -1 2\n\nOutputCopy1\n\nInputCopy2-1 -1\n\nOutputCopy200\n\nNoteIn the first example, only possible value of a2a2 is 22.In the second example, a1=a2a1=a2 so there are 200200 different values because all restored elements should be integers between 11 and 200200.",
      "solutions": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces",
          "content": "I would like to invite you to participate in the rated Codeforces Round #518. Date and time of the round: Wednesday, October 24, 2018 at 18:05. The round was postponed from October 23 to October 24 because of the ICPC Indian Online Qualifier. This is the first competition I proposed. I hope you will enjoy it. The round will have 6 tasks for the second division and 5 tasks for first (3 problems are common). The contest will last for 2 hours. Tasks for you were prepared by Alexey kristevalex Kristev and Alexey Um_nik Danilyuk. Also thanks for: Nikolay KAN Kalinin and Ildar 300iq Gainullin for help in preparing the problems; Ivan isaf27 Safonov и Oleg Merkurev Merkurev for testing the round; Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon platforms. I would like to express a special gratitude to Um_nik for the help throughout the process of preparing the round and also for patience for my stupid questions. slight lyrical digressionAfter a lot of stupid questions... -Um_nik: The general rule is \"I'm not stupid\" This round is a thanks-round for support from Mail.Ru during the 8-year campaign!Scoring distribution will be announced later. I wish you a high rating and looking forward to see you at the competition!I'll be on the community Discord server shortly after the contest to discuss the problems.UPD: scoring distribution div1: 500 1000 1750 2250 2500 div2: 500 1250 1500 2250 2750 3500UPD2: edtorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62614",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1430
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces",
          "content": "1068A - BirthdayTo get LL new coins irrespective of the Ivan's collection he must get not less than L+KL+K coins as a present. Therefore each friend should gift at least X=⌈L+KM⌉X=⌈L+KM⌉ coins. But it may be not possible for all friends to gift XX coins if X⋅M>NX⋅M>N. Complexity is O(1)O(1). 1068B - LCM[a,b]a=b(a,b)[a,b]a=b(a,b), here (a,b)(a,b) is greatest common divisor. Let's see how many different values can have c=(a,b)c=(a,b). All values cc that divides bb are reachable if a=ca=c and every value of (a,b)(a,b) divides bb. So answer is number of divisors of bb. It can be calculated in O(b√)O(b) time. 1068C - Colored RooksLet's put rooks with color ii just on line number ii. Then, obviously, for any color the set of rooks of this color would be connected. Let's put rooks on positions (i,i)(i,i) for ii from 11 to nn. After that for any color there is a rook of this color on a board and for any two different colors aa bb union of set of rooks of color aa and set of rooks of color bb wouldn't be connected. And for final step we can do the following for every pair of harmonizing colors aa bb: let jj be index of first column without rooks, put rooks on cells (j,aj,a) and (j,bj,b). After that for colors aa bb union of set of rooks of color aa and set of rooks of color bb would become connected and for other pairs the connectedness doesn't change.Total number of rooks is n+2⋅mn+2⋅m. 1067A - Array Without Local Maximums Let's find solution with complexity O(n⋅a2)O(n⋅a2). We can count dp[prefix][a][flag]dp[prefix][a][flag] — quantity of ways to restore element from 11 to prefpref with last element equalls to aa, flag=0flag=0 means that previous element is less then the last or last element is first, flag=1flag=1 — the opposite. So dp[pref][a][0]=∑a−1i=1(dp[pref−1][i][1]+dp[pref−1][i][0])dp[pref][a][0]=∑i=1a−1(dp[pref−1][i][1]+dp[pref−1][i][0]), dp[pref][a][1]=dp[pref−1][a][0]+∑200i=adp[pref−1][i][1]dp[pref][a][1]=dp[pref−1][a][0]+∑i=a200dp[pref−1][i][1].Now let's count prefix_sums[a][flag]=∑ai=1dp[pref][i][flag]prefix_sums[a][flag]=∑i=1adp[pref][i][flag] on each prefix before counting all dp[pref]dp[pref], so we can recalculate dp in O(1) time.Complexity is O(n⋅a)O(n⋅a). 1067B - MultihedgehogSolution 1: Firstly let's find all vertices with degree 11. Now we can delete them and all, verticies which were incident to them must became verticies with degree 11. And also for each new veretice with degree 11 we must have already deleted not less then 33 verticies. If initial graph was kk-multihedgehog, after deleting vertices with degree 11 it would became k−1k−1-multihedgehog.It could be realised using bfs starting from all initial vertices with degree 11.Complexity is O(n)O(n).Solution 2: First of all let's find diametr of the graph. After that we can find middle vertex in diameter and check if it is a center of kk-multihedgehog using simple dfs.Complexity is O(n)O(n). 1067C - KnightsIf after some loops of the process we will have two neighboring lines with length xx total complexity of knights would be not less than O(x24)O(x24).In this construction:00 — initial placement.1,21,2 — added knights. Would be two neighboring lines with length O(2⋅n3)O(2⋅n3) so total complexity of knights would be O((2⋅n3)24)=O(n29)O((2⋅n3)24)=O(n29).The possible way to facilitate the invention this (or over) solutions is to write process modeling.Bonus: Solve this problem with complexity O(n26)O(n26). 1067D - Computer GameLet's denote max(bipi)max(bipi) as MM. Independent of our strategy we cannot get more than MM in one second (in expected value). But if we could upgrade one quest, we would upgrade the quest which maximizes bipibipi and then try to complete only this quest each second, thus getting +M+M to expected value each second. Therefore, our strategy looks like this: try to complete quests in some order, once we complete one quest we will always get +M+M to expected value each second.This observation leads to DP solution. Once we have one quest completed we already know what we will get, so interesting states are only those in which no quests are completed yet. Then it is not important what quests we tried to complete before, the only important parameter is remaining time.dpt+1=max(pi(ai+tM)+(1−pi)dpt)dpt+1=max(pi(ai+tM)+(1−pi)dpt).If we succeed then we will get aiai as a reward and for remaining tt seconds we will get MM each second, otherwise we get nothing and now only tt seconds left. This solution works in O(nT)O(nT) time which is too slow.We can slightly rewrite the formula for transition: dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai)dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai).Now we can see that we take maximum value of functions pi⋅x+piaipi⋅x+piai in point xt=tM−dptxt=tM−dpt. We can build convex hull on these lines thus getting O(nlogn+Tlogn)O(nlog⁡n+Tlog⁡n) solution.But that's not all. We can actually prove that xt≤xt+1xt≤xt+1 or, after some substitutions and simplifications, dpt+1−dpt≤Mdpt+1−dpt≤M. This we will prove by actual meaning of dptdpt. Take optimal solution for t+1t+1 seconds and do the same for tt seconds, except that we don't have last second, so we will just drop our action. But we can't gain more than MM in one second, so this drop cannot decrease answer more than MM. Thus the inequality is proven.This means that we only move right along over convex hull, so for each line there will be consecutive seconds in which we are using that line. If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster.Let's start with learning how to make many DP transitions (when we are staying on one line for the whole time). It is more clear using first formula for DP transition: dpt+1=pi(ai+tM)+(1−pi)dptdpt+1=pi(ai+tM)+(1−pi)dpt (we don't have max now because we already know which line to use). We can see that to get vector (dpt+1t+11)T(dpt+1t+11)T from vector (dptt1)T(dptt1)T we can apply linear transformation i.e. multiply by some matrix:⎛⎝⎜dpt+1t+11⎞⎠⎟=⎛⎝⎜1−pi00piM10piai11⎞⎠⎟⎛⎝⎜dptt1⎞⎠⎟(dpt+1t+11)=(1−pipiMpiai011001)(dptt1)To apply it kk times just use binary exponentiation to get kk-th power of transition matrix.To determine how long we actually have to stay on given line we will use binary search on answer. We know for which value of xx we should move to the next line and we know that xx increases with each second, so we can try to stay on given line for some time and see if we should actually change the line.This is already O(n(logn+log2T))O(n(log⁡n+log2⁡T)) solution, but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time.Final complexity is O(n(logn+logT))O(n(log⁡n+log⁡T)) 1067E - Random Forest RankI'll try to explain how to come up with this solution rather than just state the fact. For those who are more interested in getting AC, here is your fact: rank of a forest is twice the size of maximal matching.When we see expected value, we usually want to somehow rewrite the thing under the expected value, apply linearity of expectation and then calculate some independent values. But that's not the case: rank behave strangely and we cannot rewrite it as sum of something, at least I don't know any such solutions (if you do, please write them in the comments). So it looks like we are forced to understand what rank is.The rank of a matrix is a size of its largest non-vanishing minor. But our matrix is symmetric, maybe we can look only at symmetric minors (in a sense that we use the same set of rows and columns)? This is actually true but it is just a fact from linear algebra (seems to be not very well known) and has little to do with our problem, so I'll drop its proof and if someone is interested, ask me in comments.Why do we like symmetric minors? Because they correspond to induced subgraphs of our graph. And all induced subgraphs of a forest are forests too! So let's study when a forest has full rank.To do it, let's calculate determinant of its matrix. Matrix has full rank iff its determinant is non-zero. Let's write a determinant as a sum over all permutations.detA=∑π∏ni=1AiπidetA=∑π∏i=1nAiπiIf Aiπi≠0Aiπi≠0 then we have edge (i,πi)(i,πi) in our forest. Each permutation is a product of independent cycles. So to have non-zero product ∏ni=1Aiπi∏i=1nAiπi all the permutation cycles should be cycles in the forest. But forests have no cycles without repeating vertices! Well, actually they do: each edge generate one cycle of length 22. And that's all, there are no other cycles in forest (11 vertex is not a cycle, because we don't have self-loops). To have non-zero product ∏ni=1Aiπi∏i=1nAiπi all cycles of permutation must have length 22 and correspond to edges of forest. So we can divide all vertices in pairs, and in each pair there is an edge. That's the definition of perfect matching. Why can't they still result in zero sum? Because if there is a perfect matching in a forest then it is unique, so we actually have no more than one non-zero summand.OK, forest has full rank is equivalent to forest has perfect matching. Suppose that mm is the size of maximal matching of a forest. Then no its induced subgraph of size strictly greater than 2m2m can have perfect matching. And there is a subgraph of size exactly 2m2m which does have perfect matching: the ends of edges in maximal matching.Cool, we have proven the fact from the beginning. If you just want AC, continue reading from here. Now we have to calculate expected size of maximal matching. That sound much easier: we already have a linear DP which calculates maximal matching, and its values are exactly sizes of current maximal matching. To remind: dp[v][taken]dp[v][taken] is a size of maximal matching in subtree rooted at vv where boolean flag takentaken means did we already cover vertex vv or is it still free. All we have to do is to change the value stored in DP for expected value and also calculate probabilities to actually be in state with given flag takentaken.Complexity — O(n)O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62688",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1068 和字母"
          },
          "content_length": 10105
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 1",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 2",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 3",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 4",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 5",
          "code": "-1 200 -1 200 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 6",
          "code": "Participant's output -501767591",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 1",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 2",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 3",
          "code": "After that we can find middle vertex in diameter and check if it is a center of k-multihedgehog using simple dfs.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1, 200, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int x = a[i];\n        ensuref(x == -1 || (1 <= x && x <= 200), \"a[%d] = %d is invalid\", i+1, x);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1, 200, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int x = a[i];\n        ensuref(x == -1 || (1 <= x && x <= 200), \"a[%d] = %d is invalid\", i+1, x);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1, 200, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int x = a[i];\n        ensuref(x == -1 || (1 <= x && x <= 200), \"a[%d] = %d is invalid\", i+1, x);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if(n < 2 || n > 100000) {\n        fprintf(stderr, \"Error: n should be between 2 and 1e5 inclusive.\\n\");\n        return 1;\n    }\n\n    vector<int> a(n);\n\n    if(type == \"random\") {\n        double p = opt<double>(\"p\", 0.5);\n        if(p < 0.0 || p > 1.0) {\n            fprintf(stderr, \"Error: p should be between 0 and 1 inclusive.\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n; ++i) {\n            if(rnd.next(0.0, 1.0) < p) {\n                a[i] = -1;\n            } else {\n                a[i] = rnd.next(1, 200);\n            }\n        }\n    } else if(type == \"all_minus_ones\") {\n        fill(a.begin(), a.end(), -1);\n    } else if(type == \"no_minus_ones\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 200);\n    } else if(type == \"edge_minus_ones\") {\n        a[0] = -1;\n        a[n-1] = -1;\n        for(int i = 1; i < n-1; ++i)\n            a[i] = rnd.next(1, 200);\n    } else if(type == \"max_values\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 200;\n    } else if(type == \"min_values\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if(type == \"alternating_minus_ones\") {\n        for(int i = 0; i < n; ++i) {\n            if(i%2 == 0)\n                a[i] = -1;\n            else\n                a[i] = rnd.next(1, 200);\n        }\n    } else if(type == \"some_minus_ones\") {\n        int k = opt<int>(\"k\", n/2); // number of -1s\n        if(k < 0 || k > n) {\n            fprintf(stderr, \"Error: k should be between 0 and n inclusive.\\n\");\n            return 1;\n        }\n        set<int> positions;\n        while((int)positions.size() < k) {\n            positions.insert(rnd.next(0, n-1));\n        }\n        for(int i = 0; i < n; ++i) {\n            if(positions.count(i))\n                a[i] = -1;\n            else\n                a[i] = rnd.next(1, 200);\n        }\n    } else {\n        // Default to random\n        double p = opt<double>(\"p\", 0.5);\n        if(p < 0.0 || p > 1.0) {\n            fprintf(stderr, \"Error: p should be between 0 and 1 inclusive.\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n; ++i) {\n            if(rnd.next(0.0, 1.0) < p)\n                a[i] = -1;\n            else\n                a[i] = rnd.next(1, 200);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the array\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if(n < 2 || n > 100000) {\n        fprintf(stderr, \"Error: n should be between 2 and 1e5 inclusive.\\n\");\n        return 1;\n    }\n\n    vector<int> a(n);\n\n    if(type == \"random\") {\n        double p = opt<double>(\"p\", 0.5);\n        if(p < 0.0 || p > 1.0) {\n            fprintf(stderr, \"Error: p should be between 0 and 1 inclusive.\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n; ++i) {\n            if(rnd.next(0.0, 1.0) < p) {\n                a[i] = -1;\n            } else {\n                a[i] = rnd.next(1, 200);\n            }\n        }\n    } else if(type == \"all_minus_ones\") {\n        fill(a.begin(), a.end(), -1);\n    } else if(type == \"no_minus_ones\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 200);\n    } else if(type == \"edge_minus_ones\") {\n        a[0] = -1;\n        a[n-1] = -1;\n        for(int i = 1; i < n-1; ++i)\n            a[i] = rnd.next(1, 200);\n    } else if(type == \"max_values\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 200;\n    } else if(type == \"min_values\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if(type == \"alternating_minus_ones\") {\n        for(int i = 0; i < n; ++i) {\n            if(i%2 == 0)\n                a[i] = -1;\n            else\n                a[i] = rnd.next(1, 200);\n        }\n    } else if(type == \"some_minus_ones\") {\n        int k = opt<int>(\"k\", n/2); // number of -1s\n        if(k < 0 || k > n) {\n            fprintf(stderr, \"Error: k should be between 0 and n inclusive.\\n\");\n            return 1;\n        }\n        set<int> positions;\n        while((int)positions.size() < k) {\n            positions.insert(rnd.next(0, n-1));\n        }\n        for(int i = 0; i < n; ++i) {\n            if(positions.count(i))\n                a[i] = -1;\n            else\n                a[i] = rnd.next(1, 200);\n        }\n    } else {\n        // Default to random\n        double p = opt<double>(\"p\", 0.5);\n        if(p < 0.0 || p > 1.0) {\n            fprintf(stderr, \"Error: p should be between 0 and 1 inclusive.\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n; ++i) {\n            if(rnd.next(0.0, 1.0) < p)\n                a[i] = -1;\n            else\n                a[i] = rnd.next(1, 200);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the array\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type no_minus_ones\n./gen -n 2 -type all_minus_ones\n./gen -n 2 -type edge_minus_ones\n./gen -n 2 -type random -p 0.5\n\n./gen -n 3 -type some_minus_ones -k 0\n./gen -n 3 -type some_minus_ones -k 1\n./gen -n 3 -type some_minus_ones -k 2\n./gen -n 3 -type some_minus_ones -k 3\n\n./gen -n 10 -type alternating_minus_ones\n./gen -n 10 -type max_values\n./gen -n 10 -type min_values\n\n./gen -n 50 -type random -p 0.2\n./gen -n 50 -type random -p 0.8\n\n./gen -n 100 -type random\n./gen -n 100 -type random -p 0.1\n./gen -n 100 -type random -p 0.9\n\n./gen -n 1000 -type all_minus_ones\n./gen -n 1000 -type no_minus_ones\n./gen -n 1000 -type random -p 0.5\n\n./gen -n 10000 -type some_minus_ones -k 5000\n./gen -n 10000 -type some_minus_ones -k 0\n./gen -n 10000 -type some_minus_ones -k 10000\n\n./gen -n 50000 -type alternating_minus_ones\n./gen -n 50000 -type edge_minus_ones\n\n./gen -n 100000 -type all_minus_ones\n./gen -n 100000 -type no_minus_ones\n./gen -n 100000 -type random -p 0.5\n./gen -n 100000 -type random -p 0.1\n./gen -n 100000 -type random -p 0.9\n\n./gen -n 100000 -type max_values\n./gen -n 100000 -type min_values\n\n./gen -n 100000 -type some_minus_ones -k 10000\n./gen -n 100000 -type some_minus_ones -k 90000\n\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:55.126626",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1068/E",
      "title": "E. Multihedgehog",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of input contains 22 integers nn, kk (1≤n≤1051≤n≤105, 1≤k≤1091≤k≤109) — number of vertices and hedgehog parameter.Next n−1n−1 lines contains two integers uu vv (1≤u,v≤n;u≠v1≤u,v≤n;u≠v) — indices of vertices connected by edge.It is guaranteed that given graph is a tree.",
      "output_spec": "OutputPrint \"Yes\" (without quotes), if given graph is kk-multihedgehog, and \"No\" (without quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy14 21 42 43 44 1310 511 512 514 55 136 78 613 69 6OutputCopyYesInputCopy3 11 32 3OutputCopyNo",
      "description": "E. Multihedgehog\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of input contains 22 integers nn, kk (1≤n≤1051≤n≤105, 1≤k≤1091≤k≤109) — number of vertices and hedgehog parameter.Next n−1n−1 lines contains two integers uu vv (1≤u,v≤n;u≠v1≤u,v≤n;u≠v) — indices of vertices connected by edge.It is guaranteed that given graph is a tree.\n\nOutputPrint \"Yes\" (without quotes), if given graph is kk-multihedgehog, and \"No\" (without quotes) otherwise.\n\nInputCopy14 21 42 43 44 1310 511 512 514 55 136 78 613 69 6OutputCopyYesInputCopy3 11 32 3OutputCopyNo\n\nInputCopy14 21 42 43 44 1310 511 512 514 55 136 78 613 69 6\n\nOutputCopyYes\n\nInputCopy3 11 32 3\n\nOutputCopyNo\n\nNote2-multihedgehog from the first example looks like this:Its center is vertex 1313. Hedgehogs created on last step are: [4 (center), 1, 2, 3], [6 (center), 7, 8, 9], [5 (center), 10, 11, 12, 13].Tree from second example is not a hedgehog because degree of center should be at least 33.",
      "solutions": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces",
          "content": "I would like to invite you to participate in the rated Codeforces Round #518. Date and time of the round: Wednesday, October 24, 2018 at 18:05. The round was postponed from October 23 to October 24 because of the ICPC Indian Online Qualifier. This is the first competition I proposed. I hope you will enjoy it. The round will have 6 tasks for the second division and 5 tasks for first (3 problems are common). The contest will last for 2 hours. Tasks for you were prepared by Alexey kristevalex Kristev and Alexey Um_nik Danilyuk. Also thanks for: Nikolay KAN Kalinin and Ildar 300iq Gainullin for help in preparing the problems; Ivan isaf27 Safonov и Oleg Merkurev Merkurev for testing the round; Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon platforms. I would like to express a special gratitude to Um_nik for the help throughout the process of preparing the round and also for patience for my stupid questions. slight lyrical digressionAfter a lot of stupid questions... -Um_nik: The general rule is \"I'm not stupid\" This round is a thanks-round for support from Mail.Ru during the 8-year campaign!Scoring distribution will be announced later. I wish you a high rating and looking forward to see you at the competition!I'll be on the community Discord server shortly after the contest to discuss the problems.UPD: scoring distribution div1: 500 1000 1750 2250 2500 div2: 500 1250 1500 2250 2750 3500UPD2: edtorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62614",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1430
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces",
          "content": "1068A - BirthdayTo get LL new coins irrespective of the Ivan's collection he must get not less than L+KL+K coins as a present. Therefore each friend should gift at least X=⌈L+KM⌉X=⌈L+KM⌉ coins. But it may be not possible for all friends to gift XX coins if X⋅M>NX⋅M>N. Complexity is O(1)O(1). 1068B - LCM[a,b]a=b(a,b)[a,b]a=b(a,b), here (a,b)(a,b) is greatest common divisor. Let's see how many different values can have c=(a,b)c=(a,b). All values cc that divides bb are reachable if a=ca=c and every value of (a,b)(a,b) divides bb. So answer is number of divisors of bb. It can be calculated in O(b√)O(b) time. 1068C - Colored RooksLet's put rooks with color ii just on line number ii. Then, obviously, for any color the set of rooks of this color would be connected. Let's put rooks on positions (i,i)(i,i) for ii from 11 to nn. After that for any color there is a rook of this color on a board and for any two different colors aa bb union of set of rooks of color aa and set of rooks of color bb wouldn't be connected. And for final step we can do the following for every pair of harmonizing colors aa bb: let jj be index of first column without rooks, put rooks on cells (j,aj,a) and (j,bj,b). After that for colors aa bb union of set of rooks of color aa and set of rooks of color bb would become connected and for other pairs the connectedness doesn't change.Total number of rooks is n+2⋅mn+2⋅m. 1067A - Array Without Local Maximums Let's find solution with complexity O(n⋅a2)O(n⋅a2). We can count dp[prefix][a][flag]dp[prefix][a][flag] — quantity of ways to restore element from 11 to prefpref with last element equalls to aa, flag=0flag=0 means that previous element is less then the last or last element is first, flag=1flag=1 — the opposite. So dp[pref][a][0]=∑a−1i=1(dp[pref−1][i][1]+dp[pref−1][i][0])dp[pref][a][0]=∑i=1a−1(dp[pref−1][i][1]+dp[pref−1][i][0]), dp[pref][a][1]=dp[pref−1][a][0]+∑200i=adp[pref−1][i][1]dp[pref][a][1]=dp[pref−1][a][0]+∑i=a200dp[pref−1][i][1].Now let's count prefix_sums[a][flag]=∑ai=1dp[pref][i][flag]prefix_sums[a][flag]=∑i=1adp[pref][i][flag] on each prefix before counting all dp[pref]dp[pref], so we can recalculate dp in O(1) time.Complexity is O(n⋅a)O(n⋅a). 1067B - MultihedgehogSolution 1: Firstly let's find all vertices with degree 11. Now we can delete them and all, verticies which were incident to them must became verticies with degree 11. And also for each new veretice with degree 11 we must have already deleted not less then 33 verticies. If initial graph was kk-multihedgehog, after deleting vertices with degree 11 it would became k−1k−1-multihedgehog.It could be realised using bfs starting from all initial vertices with degree 11.Complexity is O(n)O(n).Solution 2: First of all let's find diametr of the graph. After that we can find middle vertex in diameter and check if it is a center of kk-multihedgehog using simple dfs.Complexity is O(n)O(n). 1067C - KnightsIf after some loops of the process we will have two neighboring lines with length xx total complexity of knights would be not less than O(x24)O(x24).In this construction:00 — initial placement.1,21,2 — added knights. Would be two neighboring lines with length O(2⋅n3)O(2⋅n3) so total complexity of knights would be O((2⋅n3)24)=O(n29)O((2⋅n3)24)=O(n29).The possible way to facilitate the invention this (or over) solutions is to write process modeling.Bonus: Solve this problem with complexity O(n26)O(n26). 1067D - Computer GameLet's denote max(bipi)max(bipi) as MM. Independent of our strategy we cannot get more than MM in one second (in expected value). But if we could upgrade one quest, we would upgrade the quest which maximizes bipibipi and then try to complete only this quest each second, thus getting +M+M to expected value each second. Therefore, our strategy looks like this: try to complete quests in some order, once we complete one quest we will always get +M+M to expected value each second.This observation leads to DP solution. Once we have one quest completed we already know what we will get, so interesting states are only those in which no quests are completed yet. Then it is not important what quests we tried to complete before, the only important parameter is remaining time.dpt+1=max(pi(ai+tM)+(1−pi)dpt)dpt+1=max(pi(ai+tM)+(1−pi)dpt).If we succeed then we will get aiai as a reward and for remaining tt seconds we will get MM each second, otherwise we get nothing and now only tt seconds left. This solution works in O(nT)O(nT) time which is too slow.We can slightly rewrite the formula for transition: dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai)dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai).Now we can see that we take maximum value of functions pi⋅x+piaipi⋅x+piai in point xt=tM−dptxt=tM−dpt. We can build convex hull on these lines thus getting O(nlogn+Tlogn)O(nlog⁡n+Tlog⁡n) solution.But that's not all. We can actually prove that xt≤xt+1xt≤xt+1 or, after some substitutions and simplifications, dpt+1−dpt≤Mdpt+1−dpt≤M. This we will prove by actual meaning of dptdpt. Take optimal solution for t+1t+1 seconds and do the same for tt seconds, except that we don't have last second, so we will just drop our action. But we can't gain more than MM in one second, so this drop cannot decrease answer more than MM. Thus the inequality is proven.This means that we only move right along over convex hull, so for each line there will be consecutive seconds in which we are using that line. If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster.Let's start with learning how to make many DP transitions (when we are staying on one line for the whole time). It is more clear using first formula for DP transition: dpt+1=pi(ai+tM)+(1−pi)dptdpt+1=pi(ai+tM)+(1−pi)dpt (we don't have max now because we already know which line to use). We can see that to get vector (dpt+1t+11)T(dpt+1t+11)T from vector (dptt1)T(dptt1)T we can apply linear transformation i.e. multiply by some matrix:⎛⎝⎜dpt+1t+11⎞⎠⎟=⎛⎝⎜1−pi00piM10piai11⎞⎠⎟⎛⎝⎜dptt1⎞⎠⎟(dpt+1t+11)=(1−pipiMpiai011001)(dptt1)To apply it kk times just use binary exponentiation to get kk-th power of transition matrix.To determine how long we actually have to stay on given line we will use binary search on answer. We know for which value of xx we should move to the next line and we know that xx increases with each second, so we can try to stay on given line for some time and see if we should actually change the line.This is already O(n(logn+log2T))O(n(log⁡n+log2⁡T)) solution, but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time.Final complexity is O(n(logn+logT))O(n(log⁡n+log⁡T)) 1067E - Random Forest RankI'll try to explain how to come up with this solution rather than just state the fact. For those who are more interested in getting AC, here is your fact: rank of a forest is twice the size of maximal matching.When we see expected value, we usually want to somehow rewrite the thing under the expected value, apply linearity of expectation and then calculate some independent values. But that's not the case: rank behave strangely and we cannot rewrite it as sum of something, at least I don't know any such solutions (if you do, please write them in the comments). So it looks like we are forced to understand what rank is.The rank of a matrix is a size of its largest non-vanishing minor. But our matrix is symmetric, maybe we can look only at symmetric minors (in a sense that we use the same set of rows and columns)? This is actually true but it is just a fact from linear algebra (seems to be not very well known) and has little to do with our problem, so I'll drop its proof and if someone is interested, ask me in comments.Why do we like symmetric minors? Because they correspond to induced subgraphs of our graph. And all induced subgraphs of a forest are forests too! So let's study when a forest has full rank.To do it, let's calculate determinant of its matrix. Matrix has full rank iff its determinant is non-zero. Let's write a determinant as a sum over all permutations.detA=∑π∏ni=1AiπidetA=∑π∏i=1nAiπiIf Aiπi≠0Aiπi≠0 then we have edge (i,πi)(i,πi) in our forest. Each permutation is a product of independent cycles. So to have non-zero product ∏ni=1Aiπi∏i=1nAiπi all the permutation cycles should be cycles in the forest. But forests have no cycles without repeating vertices! Well, actually they do: each edge generate one cycle of length 22. And that's all, there are no other cycles in forest (11 vertex is not a cycle, because we don't have self-loops). To have non-zero product ∏ni=1Aiπi∏i=1nAiπi all cycles of permutation must have length 22 and correspond to edges of forest. So we can divide all vertices in pairs, and in each pair there is an edge. That's the definition of perfect matching. Why can't they still result in zero sum? Because if there is a perfect matching in a forest then it is unique, so we actually have no more than one non-zero summand.OK, forest has full rank is equivalent to forest has perfect matching. Suppose that mm is the size of maximal matching of a forest. Then no its induced subgraph of size strictly greater than 2m2m can have perfect matching. And there is a subgraph of size exactly 2m2m which does have perfect matching: the ends of edges in maximal matching.Cool, we have proven the fact from the beginning. If you just want AC, continue reading from here. Now we have to calculate expected size of maximal matching. That sound much easier: we already have a linear DP which calculates maximal matching, and its values are exactly sizes of current maximal matching. To remind: dp[v][taken]dp[v][taken] is a size of maximal matching in subtree rooted at vv where boolean flag takentaken means did we already cover vertex vv or is it still free. All we have to do is to change the value stored in DP for expected value and also calculate probabilities to actually be in state with given flag takentaken.Complexity — O(n)O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62688",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1068 和字母"
          },
          "content_length": 10105
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 1",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 2",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 3",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 4",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 5",
          "code": "-1 200 -1 200 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 6",
          "code": "Participant's output -501767591",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 1",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 2",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 3",
          "code": "After that we can find middle vertex in diameter and check if it is a center of k-multihedgehog using simple dfs.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int fx = find(x), fy = find(y);\n    if (fx == fy)\n        return false;  // cycle detected (or multiple edge)\n    parent[fx] = fy;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    // Initialize union-find data structure\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < n -1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d: u and v must be different\", i + 1);\n\n        bool success = unite(u, v);\n        ensuref(success, \"Graph contains a cycle or multiple edges, edge between %d and %d causes a problem\", u, v);\n    }\n\n    // Ensure the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int fx = find(x), fy = find(y);\n    if (fx == fy)\n        return false;  // cycle detected (or multiple edge)\n    parent[fx] = fy;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    // Initialize union-find data structure\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < n -1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d: u and v must be different\", i + 1);\n\n        bool success = unite(u, v);\n        ensuref(success, \"Graph contains a cycle or multiple edges, edge between %d and %d causes a problem\", u, v);\n    }\n\n    // Ensure the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int fx = find(x), fy = find(y);\n    if (fx == fy)\n        return false;  // cycle detected (or multiple edge)\n    parent[fx] = fy;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    // Initialize union-find data structure\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < n -1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d: u and v must be different\", i + 1);\n\n        bool success = unite(u, v);\n        ensuref(success, \"Graph contains a cycle or multiple edges, edge between %d and %d causes a problem\", u, v);\n    }\n\n    // Ensure the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nstring type;\nint node_id = 1;\nint max_nodes;\nvector<pair<int, int>> edges;\n\n// Generate a k-multihedgehog recursively\nvoid generate_k_multihedgehog(int parent_id, int k, bool valid = true) {\n    if (node_id > max_nodes) return;\n    \n    int current_id = node_id++;\n    if (parent_id != -1) {\n        edges.emplace_back(parent_id, current_id);\n    }\n    \n    if (node_id > max_nodes) return;\n\n    int center_degree = 3;\n    if (!valid && rnd.next(0, 1) == 0) {\n        // Make center degree less than 3 to invalidate\n        center_degree = 2;\n    }\n\n    if (k == 1) {\n        // Create hedgehog with center at current_id\n        int num_leaves = center_degree;\n        // Ensure we don't exceed the node limit\n        for (int i = 0; i < num_leaves && node_id <= max_nodes; ++i) {\n            int leaf_id = node_id++;\n            edges.emplace_back(current_id, leaf_id);\n        }\n    } else {\n        // For k >= 2, expand each leaf into a (k-1)-multihedgehog\n        int num_leaves = center_degree;\n        vector<int> leaves;\n        for (int i = 0; i < num_leaves && node_id <= max_nodes; ++i) {\n            int leaf_id = node_id++;\n            edges.emplace_back(current_id, leaf_id);\n            leaves.push_back(leaf_id);\n        }\n        // Recurse on each leaf\n        for (int leaf : leaves) {\n            generate_k_multihedgehog(current_id, k - 1, valid);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    n = opt<int>(\"n\");\n    k = opt<int>(\"k\");\n    type = opt<string>(\"type\", \"valid\");\n    \n    max_nodes = n;\n    node_id = 1;\n    edges.clear();\n    \n    if (type == \"valid\") {\n        // Generate a valid k-multihedgehog\n        generate_k_multihedgehog(-1, k, true);\n    } else if (type == \"invalid_center_degree\") {\n        // Generate an invalid k-multihedgehog by setting center degrees less than 3\n        generate_k_multihedgehog(-1, k, false);\n    } else if (type == \"invalid_structure\") {\n        // Generate a tree that is not a k-multihedgehog\n        // For simplicity, we create a random tree\n        vector<int> parents(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            parents[i] = rnd.next(1, i - 1);\n            edges.emplace_back(parents[i], i);\n        }\n        shuffle(edges.begin(), edges.end());\n    } else {\n        // Default to generating a valid k-multihedgehog\n        generate_k_multihedgehog(-1, k, true);\n    }\n    \n    // Adjust n to the actual number of nodes generated\n    n = node_id - 1;\n    printf(\"%d %d\\n\", n, k);\n    for (auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nstring type;\nint node_id = 1;\nint max_nodes;\nvector<pair<int, int>> edges;\n\n// Generate a k-multihedgehog recursively\nvoid generate_k_multihedgehog(int parent_id, int k, bool valid = true) {\n    if (node_id > max_nodes) return;\n    \n    int current_id = node_id++;\n    if (parent_id != -1) {\n        edges.emplace_back(parent_id, current_id);\n    }\n    \n    if (node_id > max_nodes) return;\n\n    int center_degree = 3;\n    if (!valid && rnd.next(0, 1) == 0) {\n        // Make center degree less than 3 to invalidate\n        center_degree = 2;\n    }\n\n    if (k == 1) {\n        // Create hedgehog with center at current_id\n        int num_leaves = center_degree;\n        // Ensure we don't exceed the node limit\n        for (int i = 0; i < num_leaves && node_id <= max_nodes; ++i) {\n            int leaf_id = node_id++;\n            edges.emplace_back(current_id, leaf_id);\n        }\n    } else {\n        // For k >= 2, expand each leaf into a (k-1)-multihedgehog\n        int num_leaves = center_degree;\n        vector<int> leaves;\n        for (int i = 0; i < num_leaves && node_id <= max_nodes; ++i) {\n            int leaf_id = node_id++;\n            edges.emplace_back(current_id, leaf_id);\n            leaves.push_back(leaf_id);\n        }\n        // Recurse on each leaf\n        for (int leaf : leaves) {\n            generate_k_multihedgehog(current_id, k - 1, valid);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    n = opt<int>(\"n\");\n    k = opt<int>(\"k\");\n    type = opt<string>(\"type\", \"valid\");\n    \n    max_nodes = n;\n    node_id = 1;\n    edges.clear();\n    \n    if (type == \"valid\") {\n        // Generate a valid k-multihedgehog\n        generate_k_multihedgehog(-1, k, true);\n    } else if (type == \"invalid_center_degree\") {\n        // Generate an invalid k-multihedgehog by setting center degrees less than 3\n        generate_k_multihedgehog(-1, k, false);\n    } else if (type == \"invalid_structure\") {\n        // Generate a tree that is not a k-multihedgehog\n        // For simplicity, we create a random tree\n        vector<int> parents(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            parents[i] = rnd.next(1, i - 1);\n            edges.emplace_back(parents[i], i);\n        }\n        shuffle(edges.begin(), edges.end());\n    } else {\n        // Default to generating a valid k-multihedgehog\n        generate_k_multihedgehog(-1, k, true);\n    }\n    \n    // Adjust n to the actual number of nodes generated\n    n = node_id - 1;\n    printf(\"%d %d\\n\", n, k);\n    for (auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Valid k-multihedgehogs with small n and k\n./gen -n 4 -k 1 -type valid\n./gen -n 13 -k 2 -type valid\n./gen -n 40 -k 3 -type valid\n\n# Valid k-multihedgehogs with maximum n and varying k\n./gen -n 100000 -k 4 -type valid\n./gen -n 100000 -k 5 -type valid\n./gen -n 100000 -k 6 -type valid\n./gen -n 100000 -k 7 -type valid\n./gen -n 100000 -k 8 -type valid\n./gen -n 100000 -k 9 -type valid\n./gen -n 100000 -k 10 -type valid\n\n# Invalid k-multihedgehogs where centers have degree less than 3\n./gen -n 14 -k 2 -type invalid_center_degree\n./gen -n 100 -k 3 -type invalid_center_degree\n./gen -n 10000 -k 4 -type invalid_center_degree\n\n# Invalid k-multihedgehogs due to wrong structure\n./gen -n 5 -k 1 -type invalid_structure\n./gen -n 1000 -k 2 -type invalid_structure\n./gen -n 50000 -k 5 -type invalid_structure\n\n# Edge cases\n./gen -n 1 -k 1 -type valid\n./gen -n 2 -k 1 -type valid\n./gen -n 3 -k 1 -type valid\n\n# Maximum n with minimum k\n./gen -n 100000 -k 1 -type valid\n\n# Maximum n with maximum k (k adjusted to fit n)\n./gen -n 100000 -k 1e9 -type valid\n\n# Small n with large k (Invalid because n is too small for large k)\n./gen -n 10 -k 1000 -type valid\n\n# Random trees (invalid k-multihedgehogs)\n./gen -n 100000 -k 5 -type invalid_structure\n./gen -n 99999 -k 3 -type invalid_structure\n\n# Valid k-multihedgehogs with varying degrees\n./gen -n 100000 -k 10 -type valid\n\n# Invalid k-multihedgehog where one center has degree less than 3\n./gen -n 1000 -k 5 -type invalid_center_degree\n\n# Valid k-multihedgehog with k=1\n./gen -n 4 -k 1 -type valid\n\n# Invalid k-multihedgehog with k=1 but center degree less than 3\n./gen -n 3 -k 1 -type invalid_center_degree\n\n# Valid k-multihedgehog with large k and adjusted n\n./gen -n 1093 -k 6 -type valid\n\n# Invalid k-multihedgehog where structure breaks at certain level\n./gen -n 10000 -k 5 -type invalid_structure\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:57.359328",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1068/F",
      "title": "F. Knights",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of input contains one integer nn (1≤n≤1031≤n≤103) — number of knights in the initial placement.",
      "output_spec": "OutputPrint nn lines. Each line should contain 22 numbers xixi and yiyi (−109≤xi,yi≤109−109≤xi,yi≤109) — coordinates of ii-th knight. For all i≠ji≠j, (xi,yi)≠(xj,yj)(xi,yi)≠(xj,yj) should hold. In other words, all knights should be in different cells.It is guaranteed that the solution exists.",
      "sample_tests": "ExamplesInputCopy4OutputCopy1 13 11 54 4InputCopy7OutputCopy2 11 24 15 22 65 76 6",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line of input contains one integer nn (1≤n≤1031≤n≤103) — number of knights in the initial placement.\n\nOutputPrint nn lines. Each line should contain 22 numbers xixi and yiyi (−109≤xi,yi≤109−109≤xi,yi≤109) — coordinates of ii-th knight. For all i≠ji≠j, (xi,yi)≠(xj,yj)(xi,yi)≠(xj,yj) should hold. In other words, all knights should be in different cells.It is guaranteed that the solution exists.\n\nInputCopy4OutputCopy1 13 11 54 4InputCopy7OutputCopy2 11 24 15 22 65 76 6\n\nOutputCopy1 13 11 54 4\n\nOutputCopy2 11 24 15 22 65 76 6\n\nNoteLet's look at second example:Green zeroes are initial knights. Cell (3,3)(3,3) is under attack of 44 knights in cells (1,2)(1,2), (2,1)(2,1), (4,1)(4,1) and (5,2)(5,2), therefore Ivan will place a knight in this cell. Cell (4,5)(4,5) is initially attacked by only 33 knights in cells (2,6)(2,6), (5,7)(5,7) and (6,6)(6,6). But new knight in cell (3,3)(3,3) also attacks cell (4,5)(4,5), now it is attacked by 44 knights and Ivan will place another knight in this cell. There are no more free cells which are attacked by 44 or more knights, so the process stops. There are 99 knights in the end, which is not less than ⌊7210⌋=4⌊7210⌋=4.",
      "solutions": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces",
          "content": "I would like to invite you to participate in the rated Codeforces Round #518. Date and time of the round: Wednesday, October 24, 2018 at 18:05. The round was postponed from October 23 to October 24 because of the ICPC Indian Online Qualifier. This is the first competition I proposed. I hope you will enjoy it. The round will have 6 tasks for the second division and 5 tasks for first (3 problems are common). The contest will last for 2 hours. Tasks for you were prepared by Alexey kristevalex Kristev and Alexey Um_nik Danilyuk. Also thanks for: Nikolay KAN Kalinin and Ildar 300iq Gainullin for help in preparing the problems; Ivan isaf27 Safonov и Oleg Merkurev Merkurev for testing the round; Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon platforms. I would like to express a special gratitude to Um_nik for the help throughout the process of preparing the round and also for patience for my stupid questions. slight lyrical digressionAfter a lot of stupid questions... -Um_nik: The general rule is \"I'm not stupid\" This round is a thanks-round for support from Mail.Ru during the 8-year campaign!Scoring distribution will be announced later. I wish you a high rating and looking forward to see you at the competition!I'll be on the community Discord server shortly after the contest to discuss the problems.UPD: scoring distribution div1: 500 1000 1750 2250 2500 div2: 500 1250 1500 2250 2750 3500UPD2: edtorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62614",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1430
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces",
          "content": "1068A - BirthdayTo get LL new coins irrespective of the Ivan's collection he must get not less than L+KL+K coins as a present. Therefore each friend should gift at least X=⌈L+KM⌉X=⌈L+KM⌉ coins. But it may be not possible for all friends to gift XX coins if X⋅M>NX⋅M>N. Complexity is O(1)O(1). 1068B - LCM[a,b]a=b(a,b)[a,b]a=b(a,b), here (a,b)(a,b) is greatest common divisor. Let's see how many different values can have c=(a,b)c=(a,b). All values cc that divides bb are reachable if a=ca=c and every value of (a,b)(a,b) divides bb. So answer is number of divisors of bb. It can be calculated in O(b√)O(b) time. 1068C - Colored RooksLet's put rooks with color ii just on line number ii. Then, obviously, for any color the set of rooks of this color would be connected. Let's put rooks on positions (i,i)(i,i) for ii from 11 to nn. After that for any color there is a rook of this color on a board and for any two different colors aa bb union of set of rooks of color aa and set of rooks of color bb wouldn't be connected. And for final step we can do the following for every pair of harmonizing colors aa bb: let jj be index of first column without rooks, put rooks on cells (j,aj,a) and (j,bj,b). After that for colors aa bb union of set of rooks of color aa and set of rooks of color bb would become connected and for other pairs the connectedness doesn't change.Total number of rooks is n+2⋅mn+2⋅m. 1067A - Array Without Local Maximums Let's find solution with complexity O(n⋅a2)O(n⋅a2). We can count dp[prefix][a][flag]dp[prefix][a][flag] — quantity of ways to restore element from 11 to prefpref with last element equalls to aa, flag=0flag=0 means that previous element is less then the last or last element is first, flag=1flag=1 — the opposite. So dp[pref][a][0]=∑a−1i=1(dp[pref−1][i][1]+dp[pref−1][i][0])dp[pref][a][0]=∑i=1a−1(dp[pref−1][i][1]+dp[pref−1][i][0]), dp[pref][a][1]=dp[pref−1][a][0]+∑200i=adp[pref−1][i][1]dp[pref][a][1]=dp[pref−1][a][0]+∑i=a200dp[pref−1][i][1].Now let's count prefix_sums[a][flag]=∑ai=1dp[pref][i][flag]prefix_sums[a][flag]=∑i=1adp[pref][i][flag] on each prefix before counting all dp[pref]dp[pref], so we can recalculate dp in O(1) time.Complexity is O(n⋅a)O(n⋅a). 1067B - MultihedgehogSolution 1: Firstly let's find all vertices with degree 11. Now we can delete them and all, verticies which were incident to them must became verticies with degree 11. And also for each new veretice with degree 11 we must have already deleted not less then 33 verticies. If initial graph was kk-multihedgehog, after deleting vertices with degree 11 it would became k−1k−1-multihedgehog.It could be realised using bfs starting from all initial vertices with degree 11.Complexity is O(n)O(n).Solution 2: First of all let's find diametr of the graph. After that we can find middle vertex in diameter and check if it is a center of kk-multihedgehog using simple dfs.Complexity is O(n)O(n). 1067C - KnightsIf after some loops of the process we will have two neighboring lines with length xx total complexity of knights would be not less than O(x24)O(x24).In this construction:00 — initial placement.1,21,2 — added knights. Would be two neighboring lines with length O(2⋅n3)O(2⋅n3) so total complexity of knights would be O((2⋅n3)24)=O(n29)O((2⋅n3)24)=O(n29).The possible way to facilitate the invention this (or over) solutions is to write process modeling.Bonus: Solve this problem with complexity O(n26)O(n26). 1067D - Computer GameLet's denote max(bipi)max(bipi) as MM. Independent of our strategy we cannot get more than MM in one second (in expected value). But if we could upgrade one quest, we would upgrade the quest which maximizes bipibipi and then try to complete only this quest each second, thus getting +M+M to expected value each second. Therefore, our strategy looks like this: try to complete quests in some order, once we complete one quest we will always get +M+M to expected value each second.This observation leads to DP solution. Once we have one quest completed we already know what we will get, so interesting states are only those in which no quests are completed yet. Then it is not important what quests we tried to complete before, the only important parameter is remaining time.dpt+1=max(pi(ai+tM)+(1−pi)dpt)dpt+1=max(pi(ai+tM)+(1−pi)dpt).If we succeed then we will get aiai as a reward and for remaining tt seconds we will get MM each second, otherwise we get nothing and now only tt seconds left. This solution works in O(nT)O(nT) time which is too slow.We can slightly rewrite the formula for transition: dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai)dpt+1=max(pi(ai+tM)+(1−pi)dpt)=dpt+max(pi(tM−dpt)+piai).Now we can see that we take maximum value of functions pi⋅x+piaipi⋅x+piai in point xt=tM−dptxt=tM−dpt. We can build convex hull on these lines thus getting O(nlogn+Tlogn)O(nlog⁡n+Tlog⁡n) solution.But that's not all. We can actually prove that xt≤xt+1xt≤xt+1 or, after some substitutions and simplifications, dpt+1−dpt≤Mdpt+1−dpt≤M. This we will prove by actual meaning of dptdpt. Take optimal solution for t+1t+1 seconds and do the same for tt seconds, except that we don't have last second, so we will just drop our action. But we can't gain more than MM in one second, so this drop cannot decrease answer more than MM. Thus the inequality is proven.This means that we only move right along over convex hull, so for each line there will be consecutive seconds in which we are using that line. If we could somehow determine these segments of times for each line and learn how to make many DP transitions at once then we would solve the problem even faster.Let's start with learning how to make many DP transitions (when we are staying on one line for the whole time). It is more clear using first formula for DP transition: dpt+1=pi(ai+tM)+(1−pi)dptdpt+1=pi(ai+tM)+(1−pi)dpt (we don't have max now because we already know which line to use). We can see that to get vector (dpt+1t+11)T(dpt+1t+11)T from vector (dptt1)T(dptt1)T we can apply linear transformation i.e. multiply by some matrix:⎛⎝⎜dpt+1t+11⎞⎠⎟=⎛⎝⎜1−pi00piM10piai11⎞⎠⎟⎛⎝⎜dptt1⎞⎠⎟(dpt+1t+11)=(1−pipiMpiai011001)(dptt1)To apply it kk times just use binary exponentiation to get kk-th power of transition matrix.To determine how long we actually have to stay on given line we will use binary search on answer. We know for which value of xx we should move to the next line and we know that xx increases with each second, so we can try to stay on given line for some time and see if we should actually change the line.This is already O(n(logn+log2T))O(n(log⁡n+log2⁡T)) solution, but we can improve it one more time by making binary exponentiation and binary search on power for this exponentiation at the same time.Final complexity is O(n(logn+logT))O(n(log⁡n+log⁡T)) 1067E - Random Forest RankI'll try to explain how to come up with this solution rather than just state the fact. For those who are more interested in getting AC, here is your fact: rank of a forest is twice the size of maximal matching.When we see expected value, we usually want to somehow rewrite the thing under the expected value, apply linearity of expectation and then calculate some independent values. But that's not the case: rank behave strangely and we cannot rewrite it as sum of something, at least I don't know any such solutions (if you do, please write them in the comments). So it looks like we are forced to understand what rank is.The rank of a matrix is a size of its largest non-vanishing minor. But our matrix is symmetric, maybe we can look only at symmetric minors (in a sense that we use the same set of rows and columns)? This is actually true but it is just a fact from linear algebra (seems to be not very well known) and has little to do with our problem, so I'll drop its proof and if someone is interested, ask me in comments.Why do we like symmetric minors? Because they correspond to induced subgraphs of our graph. And all induced subgraphs of a forest are forests too! So let's study when a forest has full rank.To do it, let's calculate determinant of its matrix. Matrix has full rank iff its determinant is non-zero. Let's write a determinant as a sum over all permutations.detA=∑π∏ni=1AiπidetA=∑π∏i=1nAiπiIf Aiπi≠0Aiπi≠0 then we have edge (i,πi)(i,πi) in our forest. Each permutation is a product of independent cycles. So to have non-zero product ∏ni=1Aiπi∏i=1nAiπi all the permutation cycles should be cycles in the forest. But forests have no cycles without repeating vertices! Well, actually they do: each edge generate one cycle of length 22. And that's all, there are no other cycles in forest (11 vertex is not a cycle, because we don't have self-loops). To have non-zero product ∏ni=1Aiπi∏i=1nAiπi all cycles of permutation must have length 22 and correspond to edges of forest. So we can divide all vertices in pairs, and in each pair there is an edge. That's the definition of perfect matching. Why can't they still result in zero sum? Because if there is a perfect matching in a forest then it is unique, so we actually have no more than one non-zero summand.OK, forest has full rank is equivalent to forest has perfect matching. Suppose that mm is the size of maximal matching of a forest. Then no its induced subgraph of size strictly greater than 2m2m can have perfect matching. And there is a subgraph of size exactly 2m2m which does have perfect matching: the ends of edges in maximal matching.Cool, we have proven the fact from the beginning. If you just want AC, continue reading from here. Now we have to calculate expected size of maximal matching. That sound much easier: we already have a linear DP which calculates maximal matching, and its values are exactly sizes of current maximal matching. To remind: dp[v][taken]dp[v][taken] is a size of maximal matching in subtree rooted at vv where boolean flag takentaken means did we already cover vertex vv or is it still free. All we have to do is to change the value stored in DP for expected value and also calculate probabilities to actually be in state with given flag takentaken.Complexity — O(n)O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62688",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1068 和字母"
          },
          "content_length": 10105
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 1",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 2",
          "code": "Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 3",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 4",
          "code": "21 2\n3 1\n4 1\n5 1\n6 2\n7 2\n8 2\n1 2\n9 1\n9 10\n9 11\n9 12\n10 13\n10 14\n10 15\n11 16\n11 17\n11 18\n12 19\n12 20\n12 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 5",
          "code": "-1 200 -1 200 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 [Thanks, Mail.Ru!] — announcement - Codeforces - Code 6",
          "code": "Participant's output -501767591",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62614",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 1",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 2",
          "code": "2 10\n1 100000 0.5\n20 20 0.4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #518 — editorial - Codeforces - Code 3",
          "code": "After that we can find middle vertex in diameter and check if it is a center of k-multihedgehog using simple dfs.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62688",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // Reading n from the input file\n\n    // Read participant's output\n    vector<pair<int, int>> positions;\n    set<pair<int, int>> occupied_cells;\n\n    for(int i = 0; i < n; ++i) {\n        int xi = ouf.readInt(-1000000000, 1000000000, format(\"x[%d]\", i+1).c_str());\n        int yi = ouf.readInt(-1000000000, 1000000000, format(\"y[%d]\",i+1).c_str());\n\n        if(occupied_cells.count({xi, yi})) {\n            quitf(_wa, \"Duplicated position at line %d: (%d, %d)\", i+1, xi, yi);\n        }\n\n        occupied_cells.insert({xi, yi});\n        positions.push_back({xi, yi});\n    }\n\n    // Simulate the process\n    map<pair<int, int>, int> attack_counts;\n    queue<pair<int, int>> knights_queue; // Knights added in each iteration\n\n    for(auto &p: positions) {\n        knights_queue.push(p);\n    }\n\n    const int dx[] = {-2,-1,1,2,-2,-1,1,2};\n    const int dy[] = {1,2,2,1,-1,-2,-2,-1};\n\n    while(!knights_queue.empty()) {\n        int sz = knights_queue.size();\n        vector<pair<int, int>> new_knights;\n        for(int i = 0; i < sz; ++i) {\n            auto knight = knights_queue.front(); knights_queue.pop();\n            int x = knight.first, y = knight.second;\n            for(int k = 0; k < 8; ++k) {\n                int nx = x + dx[k];\n                int ny = y + dy[k];\n                pair<int,int> attacked_cell = {nx, ny};\n                if(occupied_cells.count(attacked_cell)) {\n                    continue; // Cell already occupied by a knight\n                }\n                attack_counts[attacked_cell]++;\n                if(attack_counts[attacked_cell] == 4) {\n                    // Add this cell to new knights to be added\n                    new_knights.push_back(attacked_cell);\n                }\n            }\n        }\n        if(new_knights.empty()) {\n            break; // No new knights added, process finishes\n        }\n        for(auto &nk: new_knights) {\n            occupied_cells.insert(nk);\n            knights_queue.push(nk);\n        }\n    }\n\n    int total_knights = occupied_cells.size();\n    int64_t required_knights = (int64_t)n * n / 10;\n\n    if(total_knights >= required_knights) {\n        quitf(_ok, \"Total knights = %d, required knights = %lld\", total_knights, required_knights);\n    } else {\n        quitf(_wa, \"Total knights = %d, required knights = %lld\", total_knights, required_knights);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator (always do this first).\n    registerGen(argc, argv, 1);\n\n    // Parse optional parameters.\n    // If \"-n\" is provided, we will use that directly.\n    // Otherwise, we consider \"-type\" to pick a suitable value for n.\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // If the user did not explicitly set n via -n, we set it by type:\n    if (n == -1) {\n        if (type == \"min\") {\n            n = 1;\n        } else if (type == \"max\") {\n            n = 1000;\n        } else if (type == \"small\") {\n            // small range: [2..10]\n            n = rnd.next(2, 10);\n        } else {\n            // random: [1..1000]\n            n = rnd.next(1, 1000);\n        }\n    }\n\n    // Ensure 1 <= n <= 1000 (per problem constraints).\n    n = max(n, 1);\n    n = min(n, 1000);\n\n    // Print output: just one integer n.\n    // The problem states: \"The only line of input contains one integer n.\"\n    cout << n << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator (always do this first).\n    registerGen(argc, argv, 1);\n\n    // Parse optional parameters.\n    // If \"-n\" is provided, we will use that directly.\n    // Otherwise, we consider \"-type\" to pick a suitable value for n.\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // If the user did not explicitly set n via -n, we set it by type:\n    if (n == -1) {\n        if (type == \"min\") {\n            n = 1;\n        } else if (type == \"max\") {\n            n = 1000;\n        } else if (type == \"small\") {\n            // small range: [2..10]\n            n = rnd.next(2, 10);\n        } else {\n            // random: [1..1000]\n            n = rnd.next(1, 1000);\n        }\n    }\n\n    // Ensure 1 <= n <= 1000 (per problem constraints).\n    n = max(n, 1);\n    n = min(n, 1000);\n\n    // Print output: just one integer n.\n    // The problem states: \"The only line of input contains one integer n.\"\n    cout << n << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 10\n./gen -n 11\n./gen -n 47\n./gen -n 99\n./gen -n 100\n./gen -n 500\n./gen -n 750\n./gen -n 999\n./gen -n 1000\n\n./gen -type min\n./gen -type small\n./gen -type random\n./gen -type small\n./gen -type random\n./gen -type random\n./gen -type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:13:59.665944",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "107/A",
      "title": "A. Dorm Water Supply",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and p (1 ≤ n ≤ 1000, 0 ≤ p ≤ n) — the number of houses and the number of pipes correspondingly. Then p lines follow — the description of p pipes. The i-th line contains three integers ai bi di, indicating a pipe of diameter di going from house ai to house bi (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ di ≤ 106).It is guaranteed that for each house there is at most one pipe going into it and at most one pipe going out of it.",
      "output_spec": "OutputPrint integer t in the first line — the number of tank-tap pairs of houses.For the next t lines, print 3 integers per line, separated by spaces: tanki, tapi, and diameteri, where tanki ≠ tapi (1 ≤ i ≤ t). Here tanki and tapi are indexes of tank and tap houses respectively, and diameteri is the maximum amount of water that can be conveyed. All the t lines should be ordered (increasingly) by tanki.",
      "sample_tests": "ExamplesInputCopy3 21 2 102 3 20OutputCopy11 3 10InputCopy3 31 2 202 3 103 1 5OutputCopy0InputCopy4 21 2 603 4 50OutputCopy21 2 603 4 50",
      "description": "A. Dorm Water Supply\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and p (1 ≤ n ≤ 1000, 0 ≤ p ≤ n) — the number of houses and the number of pipes correspondingly. Then p lines follow — the description of p pipes. The i-th line contains three integers ai bi di, indicating a pipe of diameter di going from house ai to house bi (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ di ≤ 106).It is guaranteed that for each house there is at most one pipe going into it and at most one pipe going out of it.\n\nOutputPrint integer t in the first line — the number of tank-tap pairs of houses.For the next t lines, print 3 integers per line, separated by spaces: tanki, tapi, and diameteri, where tanki ≠ tapi (1 ≤ i ≤ t). Here tanki and tapi are indexes of tank and tap houses respectively, and diameteri is the maximum amount of water that can be conveyed. All the t lines should be ordered (increasingly) by tanki.\n\nInputCopy3 21 2 102 3 20OutputCopy11 3 10InputCopy3 31 2 202 3 103 1 5OutputCopy0InputCopy4 21 2 603 4 50OutputCopy21 2 603 4 50\n\nInputCopy3 21 2 102 3 20\n\nOutputCopy11 3 10\n\nInputCopy3 31 2 202 3 103 1 5\n\nOutputCopy0\n\nInputCopy4 21 2 603 4 50\n\nOutputCopy21 2 603 4 50",
      "solutions": [
        {
          "title": "Codeforces Beta Round #83 - Codeforces",
          "content": "Hi all,Today we would like to invite you to take part in round #83 inspired by the ACM practice sessions last year when Dima was visiting the German University in Cairo (GUC).We have composed the problemset about life in Egypt and the GUC. Hope you will like it :)The points for the problems in Div 1 & 2 will be: 500-1000-1500-2000-2500.The writers of the problems are Dima and myself.We would like to thank RAD, Connector, it4.kp, Delinur, and MikeMirzayanov, who greatly helped in preparing this contest.We wish you a pleasant, educational and successful contest!The editorial is under construction.Good luck to everyone!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2511",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 624
        },
        {
          "title": "Editorial: Codeforces Beta Round #83 - Codeforces",
          "content": "Palindromic TimesWriter: AtefIn this problem it was required to find next palindrome on a digital clock. Since the lowest unit of time used 1 minute, and there are only 24 * 60 minutes in a day, one could simply go through each minute starting from the time given in the input plus 1 minute, until finding a palindrome. If no palindrome is found till the end of the day 23: 59, the output should then be 00: 00.DatatypesWriter: AtefLet us call a pair of datatypes (a, b), where a < b, BAD if and only if there exists a number x where x fits in a bits but x * x does not fit in b bits. The following observation helps in finding a solution to the problem. The best candidate for the number x is the largest number fitting in a bits, which is x = 2a - 1. So for each ai it is enough to check that the smallest aj > ai has enough bits to contain x * x = (2a - 1) * (2a - 1), which has at most 2 * a bits. Sorting the numbers first was needed to traverse the list of datatypes once and ensuring the condition above.Dorm Water SupplyWriter: AtefThe problem describes a graph of houses as nodes and one-way pipes as edges. The problem states that the graph will contain 1 or more chains of nodes. The required is to find the start and end of every chain (consisting of more than 1 node, which caused many hacks). The other requirement was to find the weakest edge in each of the chains. This can be done by traversing (using Depth-First Search (DFS) for example) the graph from each un-visited node with no incoming edges. These nodes are the start of a chain. By keeping track of the minimum diameter so far, whenever the DFS reaches a node with no outgoing edges, it means that this node is the end of the current chain. After storing, in a list or vector, the tuples (start, end, minimum diameter), we sort these tuples by start index and print.Basketball TeamWriter: AtefThis problem is asking for the probability. Consider two sets of teams: the set of teams where Herr Wafa is the only student from his major and the set where at least one other student from Herr Wafa's major is present. These two sets don't intersect, so once we can compute the number of teams in the first set, A, and the number of teams in the second set, B, the answer would be B / (A + B).The number of teams in the first set is A = . We subtract one as Herr Wafa is guaranteed the spot, and the other (n - 1) spots are to be taken by the remaining students.Now let's count the number of teams having exactly k students from Herr Wafa's major apart from him. This number would be . Much like for the first set, (n - (k + 1)) students from the other majors should he selected, and none of them should be from Herr Wafa's major. The total number of teams where at least one other student is from Herr Wafa's major is therefore .The statements above describe the mathematical solution. It can be implemented in various ways.Crime ManagementWriter: AtefAt the first glance the upper limit for n being 1018 looks huge. But in fact, combined with the fact, that the answer should be output modulo 12345, it's should not scare you but rather hint that the problem has a DP approach.Like all DP problems the way to approach it is to split the problem into sub-problems and figure out what extra information should be carried between the sub-problems in order to combine them into the solution to the whole problem.Say, n is 11 and we solved the problem for the first 10 crimes. Clearly, just the number of ways to commit the first 10 crimes is not enough to solve the full problem with n = 11. The extra information to be carried along with the number of ways to commit n crimes and be innocent is the following: the number of ways to commit the first n crimes and have remaining multiplicities d1, d2, ...d26 respectively. The fact that the product of the multiplicities does not exceed 123 makes this a solvable task, as the set of all possible remainders contains not more elements than the product of multiplicities.To illustrate the idea from the first paragraph consider the first example case. It has two constraints, A with multiplicity 1 and B with multiplicity 2. The remainder of the number of crimes of type A is always zero, and committing crimes of type A may not yield any punishment. The remainder of the number of crimes of type B is zero or one. Therefore, while solving the sub-problems for the first n2 <  = n crimes, it's enough to keep track of only two numbers: \"number of ways to commit n2 crimes and be completely innocent\" and \"number of ways to commit n2 crimes and have committed one 'extra' crime of type B\".The key step to solve the problem now is to notice that each transition from the solution for the first k crimes to the solution for the first (k + 1) crimes can be seen as multiplying the vector of the current state by the transition matrix. Once all possible transitions are converted to the matrix form, the problem can be solved by raising the matrix into n-th power. Raising the matrix into large power can be done efficiently using matrix exponentiation: on some steps instead of computing Ai + 1 = Ai· A0 one can compute A2i = Ai· Ai.The last trick of this problem is to deal with multiple allowed multiplicities. If they were not allowed, the remainders per each crime type could have been kept with the modulo being equal to the multiplicity for this crime type. Moreover, if no crime type is listed more than once, the only valid final state is the state where the remainders are zero across all the crime types.With multiple allowed multiplicities, for each crime type the remainder modulo the product of the multiplicities of crimes for this type should be kept. (Strictly speaking, LCM is enough, but the constraints allow to use the plain product instead). Then, at the stage of printing the output, instead of treating the counter for the state with zero remainders as the only contributor to the output, one would have to iterate through all possible states and verify if each set of remainders conducts a valid final state.ArrangementWriter: AtefThe problem asks for finding the lexicographically n-th permutation satisfying the input constraints.The trick which confused many contestants, as well as a few authors and testers, is that instead of having the restrictions formulated in a way position[a[i]] < position[b[i]] the restrictions were element at position[a[i]] < element at position[b[i]].As in most problems where one has to output lexicographically n-th answer, the idea which can result in the solution which is passing the systests is to learn how to compute the number of solutions satisfying certain constraints.We will speak about how to compute the number of solutions in a bit, but first let's understand how having such function would lead to a solution. The very first observation is: if the total number of possible solutions is less than y - 2000, then the answer is \"The times have changed\". Once we have ensured that the solution exists it can be found using some of search.A simple approach would be the following: fix the first element of the resulting permutation to be 1 and count the number of possible solutions. If we do have enough to reach year y, then the first element must be 1, because there exists enough permutations with the first element being 1 to cover the years up to y, and any permutation where the first element is not 1 comes after any permutation where the first element is 1 in lexicographical order.And if fixing the first element to be 1 is not giving enough permutations, then we should decrease the \"desired\" year by the number of solutions with 1 being fixed as the first element and start looking for the solutions with 2 as the first element. The intuition is that there are not enough solutions with 1 being the first element, but once we acknowledge that and start looking for the other solutions --- with 2 as the first element, we are speaking not about arrangements for years 2001 and onwards but about the years 2001 + number of solutions with first element being one and onwards. Therefore instead of looking for the permutation with index y - 2001 with the first element being 1 we are looking for the permutation with the lower index, y - 2001 - number of solutions with first element being one, with the first element being 2 or higher.This process should be continued until all the elements are identified. Once the first index is fixed the known prefix would become a two-numbers prefix, and it will grow until all the permutation is constructed.Now to complete the solution we need to be able to compute the number of permutations which satisfy two restrictions: the input constraints and the added \"permutation has prefix P\" constraint. This problem can be solved using DP.For a given prefix P of length m, (n-m) other elements should be placed.Assume first that we are going to be iterating over all possible permutations with the given prefix using the brute force, but, instead of trying each possible value for the element at the next empty position i, we would be trying each possible position for the next not-yet-placed element i. This approach would work, but in O((n - m)!) time, which is obviously unfeasible. We need to find some way to reduce the state space and make it run faster.The key observation is the following: the state of the partially solved problem can be completely described by the bitmask of the currently occupied positions. This statement is nontrivial, as, from the first glance, it seems that apart from the unused positions mask, the information about the order, in which the already-placed elements are placed, is important. However it's not. Recall that all the constraints have the form of \"element at position ai is less than the element at position bi\". Provided the elements are placed in increasing order, in order to satisfy each constraint it's enough to confirm that, if the element to be placed is being put into position i, there is no such constraint in the input, that the element at position i should be less than the element at position j, while the element at position j has already been placed.This approach results in the DP with 2n - m states. Note that the next element to be placed can always be determined by the number of bits set in the mask and the prefix elements.The implementation of the above algorithm requires nontrivial coding, as the elements, belonging to the prefix, have to be treated differently compared to the elements which were placed by the DP. This is because the DP is enforcing that the elements are always added in the increasing order, which does not have to be the case for the elements conducting the prefix.DartsWriter: DimaBefore doing the coding let's do some math. The answer to this problem can be computed as the total area of all input rectangles / the area of the union of all input rectangles.One of the easy ways to understand it is the following. First notice that if all the rectangles are the same, the answer is always the number of rectangles. Now forget that the input figures are rectangles, assume any shape is  allowed, and then try to construct the example case given the union area s and the resulting expected score e. Notice that you can start with any shape constructed of non-intersecting figures with the total area s, and then add more figures on top of these, such that the contour of the union is the same as the contour of the first original figure of area s. Specifically, you'd need to add some figures of the total sum of t = s· (e - 1), but the number doesn't matter here. The key is that the placement of these added figures doesn't change the result, and therefore the answer will always depend only on the total area of the input figures and the area of their union.Now back to the rectangles. Computing the sum of the ares of the rectangles is easy. The hard part is to compute the area of their union in better than O(n3). Note that the union may have multiple disjoins components, it does not have to be convex, it may have holes and, in short, does not have to be easy to describe.One of the relatively-easy-to-implement solutions is the following. We will be computing the are of the union of the rectangles using the trapezoid method. Note that for the trapezoid method the order, in which the segments of the figure are provided, doesn't matter. Therefore, in order to use the trapezoid method, we \"only\" need to find all non-vertical directed segments which are the part of the contour of the union.Let me elaborate a bit more on the previous paragraph. We don't need vertical segments, because their contribution to the resulting area is zero in the trapezoid method of computing the area. The direction of the segment is the important part though. It's not enough to know that the segment (x1, x2) - (y1, y2) belongs to the contour of the union. It's important to know whether the area of the union if the part of the plane above it or below it.Imagine the test case where the union of all the rectangles is a big rectangle with a hole inside it. In this case we need to know that the segments, describing the outer part of the union, should contribute to the area with the \"plus\" sign, while the segments describing the inner hole should be considered with the \"minus\" sign.Specifically, for the trapezoid method, the sign of x2 - x1 would be describing the direction of this segment: for example, if x1 < x2 than the segment is \"positive\" and if x1 < x2 it's \"negative\". To find all such segments let's consider all distinct  non-vertical lines. There are at most 4n such lines in the input. Each segment of the final contour of the union should lay on one of those lines, so it's enough to focus on the lines only, consider them independently from each other (but make sure to process each distinct line only once!) and for each line construct a set of the positive and negative segments.Let's formulate the rules under which a part of the line would be a positive or negative segment. They turn out to be very simple:1) If some segment (x1, y1) - (x2, y2) is part of the border of one of the input rectangles, then it's a \"positive\" segment if this input rectangle lays below this segment and a \"negative\" segment if this rectangle lays above this segment.2) If some segment (x1, y1) - (x2, y2) belongs to the intersection of the borders of two different input rectangles, with one being a \"positive\" one and one being a \"negative\" one, then this segment does not belong to the contour.3) If some segment (x1, y1) - (x2, y2) is being covered by another rectangle, then it does not belong to the contour. \"Covered\" means laying completely inside some other rectangle, the border cases are covered above.The easy way of constructing all the segments could look as the following pseudo-code:for each distinct non-vertical line  create the array of markers. the marker holds the x coordinate and one of four events: { start union area below, end union area below, start union area above, end union area above }.  iterate through all the input rectangles    if this rectangle has one segment laying on the line under consideration       add two markers: one for start and one for end. whether the markers are above or below is determined by the position of this rectangle with respect to this line    else if this rectangle intersects this line      find the intersection points and add four markers: { start area below } and { start area above } for the left intersection point and { end area below } and { end area above } for the right intersection point  sort the array of markers by the x coordinate of the events  traverse the array of markers. if some segment (x1..x2) is being reported as having the union area only above it or only below it, it becomes the negative or positive segment of the union respectively.At this point one could run some sort of DFS to merge the segments into the connected loops, but this is actually unnecessary to compute the area using the trapezoid method. Just summing up (x2 - x1)· (y1 + y2) / 2 for all the segments does the trick, and it would automatically ensure that the outer contours are taken with the positive sign and the inner contours are taken with the negative sign.The solution described above runs in O(n2· logn) : for each of O(n) lines we have at most O(n) intersections, which should be sorted in O(n· logn) inside the loop over all the lines.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 16423
        }
      ],
      "code_examples": [
        {
          "title": "Editorial: Codeforces Beta Round #83 - Codeforces - Code 1",
          "code": "52\n\n474 24 24 954 9 234 474 114 24 114 234 24 114 114 234 9 9 24 9 54 234 54 9 954 474 9 54 54 54 234 9 114 24 54 114 954 954 474 24 54 54 234 234 474 474 24 114 9 954 954 954 474in the above case 9 is there but no 18......24 is there but no 48...hence the output should be \"YES\"but the correct answer for the case is \"NO\"plz explain why is so ??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(0, n, \"p\");\n    inf.readEoln();\n    \n    vector<int> in_deg(n + 1, 0);\n    vector<int> out_deg(n + 1, 0);\n    \n    for (int i = 0; i < p; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000, \"di\");\n        inf.readEoln();\n        \n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n        \n        ++out_deg[ai];\n        ensuref(out_deg[ai] <= 1, \"House %d has more than one outgoing pipe\", ai);\n        \n        ++in_deg[bi];\n        ensuref(in_deg[bi] <= 1, \"House %d has more than one incoming pipe\", bi);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(0, n, \"p\");\n    inf.readEoln();\n    \n    vector<int> in_deg(n + 1, 0);\n    vector<int> out_deg(n + 1, 0);\n    \n    for (int i = 0; i < p; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000, \"di\");\n        inf.readEoln();\n        \n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n        \n        ++out_deg[ai];\n        ensuref(out_deg[ai] <= 1, \"House %d has more than one outgoing pipe\", ai);\n        \n        ++in_deg[bi];\n        ensuref(in_deg[bi] <= 1, \"House %d has more than one incoming pipe\", bi);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(0, n, \"p\");\n    inf.readEoln();\n    \n    vector<int> in_deg(n + 1, 0);\n    vector<int> out_deg(n + 1, 0);\n    \n    for (int i = 0; i < p; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000, \"di\");\n        inf.readEoln();\n        \n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n        \n        ++out_deg[ai];\n        ensuref(out_deg[ai] <= 1, \"House %d has more than one outgoing pipe\", ai);\n        \n        ++in_deg[bi];\n        ensuref(in_deg[bi] <= 1, \"House %d has more than one incoming pipe\", bi);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n    vector<int> nodes(n);\n    iota(nodes.begin(), nodes.end(), 1);\n\n    if (type == \"path\") {\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 0; i < n - 1; ++i) {\n            int ai = nodes[i];\n            int bi = nodes[i + 1];\n            edges.emplace_back(ai, bi);\n        }\n    } else if (type == \"cycle\") {\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 0; i < n; ++i) {\n            int ai = nodes[i];\n            int bi = nodes[(i + 1) % n];\n            edges.emplace_back(ai, bi);\n        }\n    } else if (type == \"random\") {\n        int m = opt<int>(\"m\", n);\n        m = min(m, n);\n        shuffle(nodes.begin(), nodes.end());\n        vector<int> OutNodes = nodes;\n        shuffle(nodes.begin(), nodes.end());\n        vector<int> InNodes = nodes;\n        set<pair<int, int>> usedEdges;\n        for (int i = 0; i < m; ++i) {\n            int ai = OutNodes[i];\n            int bi = InNodes[i];\n            if (ai == bi) {\n                if (i + 1 < n) {\n                    swap(InNodes[i], InNodes[i + 1]);\n                    bi = InNodes[i];\n                    if (ai == bi) {\n                        // Swap back\n                        swap(InNodes[i], InNodes[i + 1]);\n                        continue;\n                    }\n                } else if (i > 0) {\n                    swap(InNodes[i], InNodes[i - 1]);\n                    bi = InNodes[i];\n                    if (ai == bi) {\n                        // Swap back\n                        swap(InNodes[i], InNodes[i - 1]);\n                        continue;\n                    }\n                } else {\n                    // Cannot swap, skip this edge\n                    continue;\n                }\n            }\n            if (usedEdges.count({ai, bi})) {\n                continue;\n            }\n            edges.emplace_back(ai, bi);\n            usedEdges.insert({ai, bi});\n        }\n    }\n\n    // Generate random diameters between 1 and 1e6\n    vector<int> diameters(edges.size());\n    for (int i = 0; i < diameters.size(); ++i) {\n        diameters[i] = rnd.next(1, 1000000);\n    }\n\n    int n_nodes = n;\n    int p_pipes = edges.size();\n\n    printf(\"%d %d\\n\", n_nodes, p_pipes);\n\n    for (int i = 0; i < edges.size(); ++i) {\n        printf(\"%d %d %d\\n\", edges[i].first, edges[i].second, diameters[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n    vector<int> nodes(n);\n    iota(nodes.begin(), nodes.end(), 1);\n\n    if (type == \"path\") {\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 0; i < n - 1; ++i) {\n            int ai = nodes[i];\n            int bi = nodes[i + 1];\n            edges.emplace_back(ai, bi);\n        }\n    } else if (type == \"cycle\") {\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 0; i < n; ++i) {\n            int ai = nodes[i];\n            int bi = nodes[(i + 1) % n];\n            edges.emplace_back(ai, bi);\n        }\n    } else if (type == \"random\") {\n        int m = opt<int>(\"m\", n);\n        m = min(m, n);\n        shuffle(nodes.begin(), nodes.end());\n        vector<int> OutNodes = nodes;\n        shuffle(nodes.begin(), nodes.end());\n        vector<int> InNodes = nodes;\n        set<pair<int, int>> usedEdges;\n        for (int i = 0; i < m; ++i) {\n            int ai = OutNodes[i];\n            int bi = InNodes[i];\n            if (ai == bi) {\n                if (i + 1 < n) {\n                    swap(InNodes[i], InNodes[i + 1]);\n                    bi = InNodes[i];\n                    if (ai == bi) {\n                        // Swap back\n                        swap(InNodes[i], InNodes[i + 1]);\n                        continue;\n                    }\n                } else if (i > 0) {\n                    swap(InNodes[i], InNodes[i - 1]);\n                    bi = InNodes[i];\n                    if (ai == bi) {\n                        // Swap back\n                        swap(InNodes[i], InNodes[i - 1]);\n                        continue;\n                    }\n                } else {\n                    // Cannot swap, skip this edge\n                    continue;\n                }\n            }\n            if (usedEdges.count({ai, bi})) {\n                continue;\n            }\n            edges.emplace_back(ai, bi);\n            usedEdges.insert({ai, bi});\n        }\n    }\n\n    // Generate random diameters between 1 and 1e6\n    vector<int> diameters(edges.size());\n    for (int i = 0; i < diameters.size(); ++i) {\n        diameters[i] = rnd.next(1, 1000000);\n    }\n\n    int n_nodes = n;\n    int p_pipes = edges.size();\n\n    printf(\"%d %d\\n\", n_nodes, p_pipes);\n\n    for (int i = 0; i < edges.size(); ++i) {\n        printf(\"%d %d %d\\n\", edges[i].first, edges[i].second, diameters[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type path\n./gen -n 1 -type cycle\n./gen -n 1 -type random -m 1\n\n./gen -n 2 -type path\n./gen -n 2 -type cycle\n./gen -n 2 -type random -m 1\n./gen -n 2 -type random -m 2\n\n./gen -n 5 -type path\n./gen -n 5 -type cycle\n./gen -n 5 -type random -m 2\n./gen -n 5 -type random -m 5\n\n./gen -n 10 -type path\n./gen -n 10 -type cycle\n./gen -n 10 -type random -m 5\n./gen -n 10 -type random -m 10\n\n./gen -n 100 -type path\n./gen -n 100 -type cycle\n./gen -n 100 -type random -m 50\n./gen -n 100 -type random -m 100\n\n./gen -n 1000 -type path\n./gen -n 1000 -type cycle\n./gen -n 1000 -type random -m 500\n./gen -n 1000 -type random -m 1000\n./gen -n 1000 -type random -m 900\n\n./gen -n 500 -type path\n./gen -n 500 -type cycle\n./gen -n 500 -type random -m 250\n./gen -n 500 -type random -m 500\n\n./gen -n 1 -type random -m 0\n./gen -n 10 -type random -m 0\n./gen -n 1000 -type random -m 0\n\n./gen -n 1000 -type random -m 1\n./gen -n 1000 -type random -m 100\n./gen -n 1000 -type random -m 999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:01.303160",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "107/B",
      "title": "B. Basketball Team",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and h (1 ≤ n ≤ 100, 1 ≤ m ≤ 1000, 1 ≤ h ≤ m) — the number of players on the team, the number of departments in GUC and Herr Wafa's department, correspondingly. The second line contains a single-space-separated list of m integers si (1 ≤ si ≤ 100), denoting the number of students in the i-th department. Note that sh includes Herr Wafa.",
      "output_spec": "OutputPrint the probability that Herr Wafa will have at least one teammate from his department. If there is not enough basketball players in GUC to participate in ABC, print -1. The answer will be accepted if it has absolute or relative error not exceeding 10 - 6.",
      "sample_tests": "ExamplesInputCopy3 2 12 1OutputCopy1InputCopy3 2 11 1OutputCopy-1InputCopy3 2 12 2OutputCopy0.666667",
      "description": "B. Basketball Team\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m and h (1 ≤ n ≤ 100, 1 ≤ m ≤ 1000, 1 ≤ h ≤ m) — the number of players on the team, the number of departments in GUC and Herr Wafa's department, correspondingly. The second line contains a single-space-separated list of m integers si (1 ≤ si ≤ 100), denoting the number of students in the i-th department. Note that sh includes Herr Wafa.\n\nOutputPrint the probability that Herr Wafa will have at least one teammate from his department. If there is not enough basketball players in GUC to participate in ABC, print -1. The answer will be accepted if it has absolute or relative error not exceeding 10 - 6.\n\nInputCopy3 2 12 1OutputCopy1InputCopy3 2 11 1OutputCopy-1InputCopy3 2 12 2OutputCopy0.666667\n\nInputCopy3 2 12 1\n\nOutputCopy1\n\nInputCopy3 2 11 1\n\nOutputCopy-1\n\nInputCopy3 2 12 2\n\nOutputCopy0.666667\n\nNoteIn the first example all 3 players (2 from department 1 and 1 from department 2) must be chosen for the team. Both players from Wafa's departments will be chosen, so he's guaranteed to have a teammate from his department.In the second example, there are not enough players.In the third example, there are three possibilities to compose the team containing Herr Wafa. In two of them the other player from Herr Wafa's department is part of the team.",
      "solutions": [
        {
          "title": "Codeforces Beta Round #83 - Codeforces",
          "content": "Hi all,Today we would like to invite you to take part in round #83 inspired by the ACM practice sessions last year when Dima was visiting the German University in Cairo (GUC).We have composed the problemset about life in Egypt and the GUC. Hope you will like it :)The points for the problems in Div 1 & 2 will be: 500-1000-1500-2000-2500.The writers of the problems are Dima and myself.We would like to thank RAD, Connector, it4.kp, Delinur, and MikeMirzayanov, who greatly helped in preparing this contest.We wish you a pleasant, educational and successful contest!The editorial is under construction.Good luck to everyone!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2511",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 624
        },
        {
          "title": "Editorial: Codeforces Beta Round #83 - Codeforces",
          "content": "Palindromic TimesWriter: AtefIn this problem it was required to find next palindrome on a digital clock. Since the lowest unit of time used 1 minute, and there are only 24 * 60 minutes in a day, one could simply go through each minute starting from the time given in the input plus 1 minute, until finding a palindrome. If no palindrome is found till the end of the day 23: 59, the output should then be 00: 00.DatatypesWriter: AtefLet us call a pair of datatypes (a, b), where a < b, BAD if and only if there exists a number x where x fits in a bits but x * x does not fit in b bits. The following observation helps in finding a solution to the problem. The best candidate for the number x is the largest number fitting in a bits, which is x = 2a - 1. So for each ai it is enough to check that the smallest aj > ai has enough bits to contain x * x = (2a - 1) * (2a - 1), which has at most 2 * a bits. Sorting the numbers first was needed to traverse the list of datatypes once and ensuring the condition above.Dorm Water SupplyWriter: AtefThe problem describes a graph of houses as nodes and one-way pipes as edges. The problem states that the graph will contain 1 or more chains of nodes. The required is to find the start and end of every chain (consisting of more than 1 node, which caused many hacks). The other requirement was to find the weakest edge in each of the chains. This can be done by traversing (using Depth-First Search (DFS) for example) the graph from each un-visited node with no incoming edges. These nodes are the start of a chain. By keeping track of the minimum diameter so far, whenever the DFS reaches a node with no outgoing edges, it means that this node is the end of the current chain. After storing, in a list or vector, the tuples (start, end, minimum diameter), we sort these tuples by start index and print.Basketball TeamWriter: AtefThis problem is asking for the probability. Consider two sets of teams: the set of teams where Herr Wafa is the only student from his major and the set where at least one other student from Herr Wafa's major is present. These two sets don't intersect, so once we can compute the number of teams in the first set, A, and the number of teams in the second set, B, the answer would be B / (A + B).The number of teams in the first set is A = . We subtract one as Herr Wafa is guaranteed the spot, and the other (n - 1) spots are to be taken by the remaining students.Now let's count the number of teams having exactly k students from Herr Wafa's major apart from him. This number would be . Much like for the first set, (n - (k + 1)) students from the other majors should he selected, and none of them should be from Herr Wafa's major. The total number of teams where at least one other student is from Herr Wafa's major is therefore .The statements above describe the mathematical solution. It can be implemented in various ways.Crime ManagementWriter: AtefAt the first glance the upper limit for n being 1018 looks huge. But in fact, combined with the fact, that the answer should be output modulo 12345, it's should not scare you but rather hint that the problem has a DP approach.Like all DP problems the way to approach it is to split the problem into sub-problems and figure out what extra information should be carried between the sub-problems in order to combine them into the solution to the whole problem.Say, n is 11 and we solved the problem for the first 10 crimes. Clearly, just the number of ways to commit the first 10 crimes is not enough to solve the full problem with n = 11. The extra information to be carried along with the number of ways to commit n crimes and be innocent is the following: the number of ways to commit the first n crimes and have remaining multiplicities d1, d2, ...d26 respectively. The fact that the product of the multiplicities does not exceed 123 makes this a solvable task, as the set of all possible remainders contains not more elements than the product of multiplicities.To illustrate the idea from the first paragraph consider the first example case. It has two constraints, A with multiplicity 1 and B with multiplicity 2. The remainder of the number of crimes of type A is always zero, and committing crimes of type A may not yield any punishment. The remainder of the number of crimes of type B is zero or one. Therefore, while solving the sub-problems for the first n2 <  = n crimes, it's enough to keep track of only two numbers: \"number of ways to commit n2 crimes and be completely innocent\" and \"number of ways to commit n2 crimes and have committed one 'extra' crime of type B\".The key step to solve the problem now is to notice that each transition from the solution for the first k crimes to the solution for the first (k + 1) crimes can be seen as multiplying the vector of the current state by the transition matrix. Once all possible transitions are converted to the matrix form, the problem can be solved by raising the matrix into n-th power. Raising the matrix into large power can be done efficiently using matrix exponentiation: on some steps instead of computing Ai + 1 = Ai· A0 one can compute A2i = Ai· Ai.The last trick of this problem is to deal with multiple allowed multiplicities. If they were not allowed, the remainders per each crime type could have been kept with the modulo being equal to the multiplicity for this crime type. Moreover, if no crime type is listed more than once, the only valid final state is the state where the remainders are zero across all the crime types.With multiple allowed multiplicities, for each crime type the remainder modulo the product of the multiplicities of crimes for this type should be kept. (Strictly speaking, LCM is enough, but the constraints allow to use the plain product instead). Then, at the stage of printing the output, instead of treating the counter for the state with zero remainders as the only contributor to the output, one would have to iterate through all possible states and verify if each set of remainders conducts a valid final state.ArrangementWriter: AtefThe problem asks for finding the lexicographically n-th permutation satisfying the input constraints.The trick which confused many contestants, as well as a few authors and testers, is that instead of having the restrictions formulated in a way position[a[i]] < position[b[i]] the restrictions were element at position[a[i]] < element at position[b[i]].As in most problems where one has to output lexicographically n-th answer, the idea which can result in the solution which is passing the systests is to learn how to compute the number of solutions satisfying certain constraints.We will speak about how to compute the number of solutions in a bit, but first let's understand how having such function would lead to a solution. The very first observation is: if the total number of possible solutions is less than y - 2000, then the answer is \"The times have changed\". Once we have ensured that the solution exists it can be found using some of search.A simple approach would be the following: fix the first element of the resulting permutation to be 1 and count the number of possible solutions. If we do have enough to reach year y, then the first element must be 1, because there exists enough permutations with the first element being 1 to cover the years up to y, and any permutation where the first element is not 1 comes after any permutation where the first element is 1 in lexicographical order.And if fixing the first element to be 1 is not giving enough permutations, then we should decrease the \"desired\" year by the number of solutions with 1 being fixed as the first element and start looking for the solutions with 2 as the first element. The intuition is that there are not enough solutions with 1 being the first element, but once we acknowledge that and start looking for the other solutions --- with 2 as the first element, we are speaking not about arrangements for years 2001 and onwards but about the years 2001 + number of solutions with first element being one and onwards. Therefore instead of looking for the permutation with index y - 2001 with the first element being 1 we are looking for the permutation with the lower index, y - 2001 - number of solutions with first element being one, with the first element being 2 or higher.This process should be continued until all the elements are identified. Once the first index is fixed the known prefix would become a two-numbers prefix, and it will grow until all the permutation is constructed.Now to complete the solution we need to be able to compute the number of permutations which satisfy two restrictions: the input constraints and the added \"permutation has prefix P\" constraint. This problem can be solved using DP.For a given prefix P of length m, (n-m) other elements should be placed.Assume first that we are going to be iterating over all possible permutations with the given prefix using the brute force, but, instead of trying each possible value for the element at the next empty position i, we would be trying each possible position for the next not-yet-placed element i. This approach would work, but in O((n - m)!) time, which is obviously unfeasible. We need to find some way to reduce the state space and make it run faster.The key observation is the following: the state of the partially solved problem can be completely described by the bitmask of the currently occupied positions. This statement is nontrivial, as, from the first glance, it seems that apart from the unused positions mask, the information about the order, in which the already-placed elements are placed, is important. However it's not. Recall that all the constraints have the form of \"element at position ai is less than the element at position bi\". Provided the elements are placed in increasing order, in order to satisfy each constraint it's enough to confirm that, if the element to be placed is being put into position i, there is no such constraint in the input, that the element at position i should be less than the element at position j, while the element at position j has already been placed.This approach results in the DP with 2n - m states. Note that the next element to be placed can always be determined by the number of bits set in the mask and the prefix elements.The implementation of the above algorithm requires nontrivial coding, as the elements, belonging to the prefix, have to be treated differently compared to the elements which were placed by the DP. This is because the DP is enforcing that the elements are always added in the increasing order, which does not have to be the case for the elements conducting the prefix.DartsWriter: DimaBefore doing the coding let's do some math. The answer to this problem can be computed as the total area of all input rectangles / the area of the union of all input rectangles.One of the easy ways to understand it is the following. First notice that if all the rectangles are the same, the answer is always the number of rectangles. Now forget that the input figures are rectangles, assume any shape is  allowed, and then try to construct the example case given the union area s and the resulting expected score e. Notice that you can start with any shape constructed of non-intersecting figures with the total area s, and then add more figures on top of these, such that the contour of the union is the same as the contour of the first original figure of area s. Specifically, you'd need to add some figures of the total sum of t = s· (e - 1), but the number doesn't matter here. The key is that the placement of these added figures doesn't change the result, and therefore the answer will always depend only on the total area of the input figures and the area of their union.Now back to the rectangles. Computing the sum of the ares of the rectangles is easy. The hard part is to compute the area of their union in better than O(n3). Note that the union may have multiple disjoins components, it does not have to be convex, it may have holes and, in short, does not have to be easy to describe.One of the relatively-easy-to-implement solutions is the following. We will be computing the are of the union of the rectangles using the trapezoid method. Note that for the trapezoid method the order, in which the segments of the figure are provided, doesn't matter. Therefore, in order to use the trapezoid method, we \"only\" need to find all non-vertical directed segments which are the part of the contour of the union.Let me elaborate a bit more on the previous paragraph. We don't need vertical segments, because their contribution to the resulting area is zero in the trapezoid method of computing the area. The direction of the segment is the important part though. It's not enough to know that the segment (x1, x2) - (y1, y2) belongs to the contour of the union. It's important to know whether the area of the union if the part of the plane above it or below it.Imagine the test case where the union of all the rectangles is a big rectangle with a hole inside it. In this case we need to know that the segments, describing the outer part of the union, should contribute to the area with the \"plus\" sign, while the segments describing the inner hole should be considered with the \"minus\" sign.Specifically, for the trapezoid method, the sign of x2 - x1 would be describing the direction of this segment: for example, if x1 < x2 than the segment is \"positive\" and if x1 < x2 it's \"negative\". To find all such segments let's consider all distinct  non-vertical lines. There are at most 4n such lines in the input. Each segment of the final contour of the union should lay on one of those lines, so it's enough to focus on the lines only, consider them independently from each other (but make sure to process each distinct line only once!) and for each line construct a set of the positive and negative segments.Let's formulate the rules under which a part of the line would be a positive or negative segment. They turn out to be very simple:1) If some segment (x1, y1) - (x2, y2) is part of the border of one of the input rectangles, then it's a \"positive\" segment if this input rectangle lays below this segment and a \"negative\" segment if this rectangle lays above this segment.2) If some segment (x1, y1) - (x2, y2) belongs to the intersection of the borders of two different input rectangles, with one being a \"positive\" one and one being a \"negative\" one, then this segment does not belong to the contour.3) If some segment (x1, y1) - (x2, y2) is being covered by another rectangle, then it does not belong to the contour. \"Covered\" means laying completely inside some other rectangle, the border cases are covered above.The easy way of constructing all the segments could look as the following pseudo-code:for each distinct non-vertical line  create the array of markers. the marker holds the x coordinate and one of four events: { start union area below, end union area below, start union area above, end union area above }.  iterate through all the input rectangles    if this rectangle has one segment laying on the line under consideration       add two markers: one for start and one for end. whether the markers are above or below is determined by the position of this rectangle with respect to this line    else if this rectangle intersects this line      find the intersection points and add four markers: { start area below } and { start area above } for the left intersection point and { end area below } and { end area above } for the right intersection point  sort the array of markers by the x coordinate of the events  traverse the array of markers. if some segment (x1..x2) is being reported as having the union area only above it or only below it, it becomes the negative or positive segment of the union respectively.At this point one could run some sort of DFS to merge the segments into the connected loops, but this is actually unnecessary to compute the area using the trapezoid method. Just summing up (x2 - x1)· (y1 + y2) / 2 for all the segments does the trick, and it would automatically ensure that the outer contours are taken with the positive sign and the inner contours are taken with the negative sign.The solution described above runs in O(n2· logn) : for each of O(n) lines we have at most O(n) intersections, which should be sorted in O(n· logn) inside the loop over all the lines.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 16423
        }
      ],
      "code_examples": [
        {
          "title": "Editorial: Codeforces Beta Round #83 - Codeforces - Code 1",
          "code": "52\n\n474 24 24 954 9 234 474 114 24 114 234 24 114 114 234 9 9 24 9 54 234 54 9 954 474 9 54 54 54 234 9 114 24 54 114 954 954 474 24 54 54 234 234 474 474 24 114 9 954 954 954 474in the above case 9 is there but no 18......24 is there but no 48...hence the output should be \"YES\"but the correct answer for the case is \"NO\"plz explain why is so ??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int h = inf.readInt(1, m, \"h\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(m, 1, 100, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int h = inf.readInt(1, m, \"h\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(m, 1, 100, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int h = inf.readInt(1, m, \"h\");\n    inf.readEoln();\n    vector<int> s = inf.readInts(m, 1, 100, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n\n    int n, m, h;\n    vector<int> s;\n\n    if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        h = 1;\n        s.push_back(1);\n    } else if (type == \"maximal\") {\n        n = 100;\n        m = 1000;\n        h = rnd.next(1, m);\n        s.resize(m, 100);\n    } else if (type == \"sum_less_than_n\") {\n        n = opt<int>(\"n\", 10);\n        m = opt<int>(\"m\", 5);\n        h = opt<int>(\"h\", 1);\n        s.resize(m, 1);\n        int total_s = m;\n        if (total_s >= n) {\n            // Decrease total_s to be less than n\n            s[0] = n - 1 - (m - 1);\n            for (int i = 1; i < m; ++i) {\n                s[i] = 1;\n            }\n        } else {\n            // total_s already less than n\n        }\n    } else if (type == \"sh_equals_n\") {\n        n = opt<int>(\"n\", 5);\n        m = opt<int>(\"m\", 7);\n        h = opt<int>(\"h\", 1);\n        s.resize(m, 1);\n        s[h-1] = n;\n        int total_s = accumulate(s.begin(), s.end(), 0);\n        if (total_s < n) {\n            s[0] += (n - total_s);\n        }\n    } else if (type == \"sh_equals_1\") {\n        n = opt<int>(\"n\", rnd.next(1, 100));\n        m = opt<int>(\"m\", rnd.next(2, 1000));\n        h = opt<int>(\"h\", rnd.next(1, m));\n        s.resize(m);\n        for (int i = 0; i < m; ++i) {\n            s[i] = rnd.next(1, 100);\n        }\n        s[h-1] = 1;\n        int total_s = accumulate(s.begin(), s.end(), 0);\n        if (total_s < n) {\n            s[0] += (n - total_s);\n        }\n    } else if (type == \"m_equals_1\") {\n        m = 1;\n        n = opt<int>(\"n\", rnd.next(1, 100));\n        h = 1;\n        s.push_back(max(n, rnd.next(1, 100)));\n    } else if (type == \"random\") {\n        n = opt<int>(\"n\", rnd.next(1, 100));\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n        h = rnd.next(1, m);\n        s.resize(m);\n        for (int i = 0; i < m; ++i) {\n            s[i] = rnd.next(1, 100);\n        }\n        int total_s = accumulate(s.begin(), s.end(), 0);\n        if (total_s < n) {\n            s[0] += (n - total_s + 1);\n        }\n    } else if (type == \"precision_test\") {\n        n = opt<int>(\"n\", rnd.next(1, 100));\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n        h = opt<int>(\"h\", rnd.next(1, m));\n        s.resize(m, 1);\n        s[h-1] = rnd.next(1, 100);\n        int total_s = accumulate(s.begin(), s.end(), 0);\n        if (total_s < n) {\n            s[0] += (n - total_s + 1);\n        }\n    } else {\n        // Default to random\n        n = opt<int>(\"n\", rnd.next(1, 100));\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n        h = rnd.next(1, m);\n        s.resize(m);\n        for (int i = 0; i < m; ++i) {\n            s[i] = rnd.next(1, 100);\n        }\n        int total_s = accumulate(s.begin(), s.end(), 0);\n        if (total_s < n) {\n            s[0] += (n - total_s + 1);\n        }\n    }\n\n    printf(\"%d %d %d\\n\", n, m, h);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", s[i]);\n        if (i < m - 1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n\n    int n, m, h;\n    vector<int> s;\n\n    if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        h = 1;\n        s.push_back(1);\n    } else if (type == \"maximal\") {\n        n = 100;\n        m = 1000;\n        h = rnd.next(1, m);\n        s.resize(m, 100);\n    } else if (type == \"sum_less_than_n\") {\n        n = opt<int>(\"n\", 10);\n        m = opt<int>(\"m\", 5);\n        h = opt<int>(\"h\", 1);\n        s.resize(m, 1);\n        int total_s = m;\n        if (total_s >= n) {\n            // Decrease total_s to be less than n\n            s[0] = n - 1 - (m - 1);\n            for (int i = 1; i < m; ++i) {\n                s[i] = 1;\n            }\n        } else {\n            // total_s already less than n\n        }\n    } else if (type == \"sh_equals_n\") {\n        n = opt<int>(\"n\", 5);\n        m = opt<int>(\"m\", 7);\n        h = opt<int>(\"h\", 1);\n        s.resize(m, 1);\n        s[h-1] = n;\n        int total_s = accumulate(s.begin(), s.end(), 0);\n        if (total_s < n) {\n            s[0] += (n - total_s);\n        }\n    } else if (type == \"sh_equals_1\") {\n        n = opt<int>(\"n\", rnd.next(1, 100));\n        m = opt<int>(\"m\", rnd.next(2, 1000));\n        h = opt<int>(\"h\", rnd.next(1, m));\n        s.resize(m);\n        for (int i = 0; i < m; ++i) {\n            s[i] = rnd.next(1, 100);\n        }\n        s[h-1] = 1;\n        int total_s = accumulate(s.begin(), s.end(), 0);\n        if (total_s < n) {\n            s[0] += (n - total_s);\n        }\n    } else if (type == \"m_equals_1\") {\n        m = 1;\n        n = opt<int>(\"n\", rnd.next(1, 100));\n        h = 1;\n        s.push_back(max(n, rnd.next(1, 100)));\n    } else if (type == \"random\") {\n        n = opt<int>(\"n\", rnd.next(1, 100));\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n        h = rnd.next(1, m);\n        s.resize(m);\n        for (int i = 0; i < m; ++i) {\n            s[i] = rnd.next(1, 100);\n        }\n        int total_s = accumulate(s.begin(), s.end(), 0);\n        if (total_s < n) {\n            s[0] += (n - total_s + 1);\n        }\n    } else if (type == \"precision_test\") {\n        n = opt<int>(\"n\", rnd.next(1, 100));\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n        h = opt<int>(\"h\", rnd.next(1, m));\n        s.resize(m, 1);\n        s[h-1] = rnd.next(1, 100);\n        int total_s = accumulate(s.begin(), s.end(), 0);\n        if (total_s < n) {\n            s[0] += (n - total_s + 1);\n        }\n    } else {\n        // Default to random\n        n = opt<int>(\"n\", rnd.next(1, 100));\n        m = opt<int>(\"m\", rnd.next(1, 1000));\n        h = rnd.next(1, m);\n        s.resize(m);\n        for (int i = 0; i < m; ++i) {\n            s[i] = rnd.next(1, 100);\n        }\n        int total_s = accumulate(s.begin(), s.end(), 0);\n        if (total_s < n) {\n            s[0] += (n - total_s + 1);\n        }\n    }\n\n    printf(\"%d %d %d\\n\", n, m, h);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", s[i]);\n        if (i < m - 1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n\n./gen -type maximal\n\n./gen -type sum_less_than_n -n 10 -m 5 -h 1\n\n./gen -type sh_equals_n -n 5 -m 7 -h 3\n\n./gen -type sh_equals_1 -n 10 -m 10 -h 5\n\n./gen -type m_equals_1 -n 50\n\n./gen -type random\n\n./gen -type random -n 100 -m 1000\n\n./gen -type random -n 1 -m 1\n\n./gen -type random -n 100 -m 1\n\n./gen -type random -n 1 -m 1000\n\n./gen -type precision_test\n\n./gen -type sh_equals_1 -n 100 -m 500 -h 200\n\n./gen -type sh_equals_n -n 80 -m 100 -h 50\n\n./gen -type random -n 75 -m 800\n\n./gen -type random -n 50 -m 1000\n\n./gen -type random -n 99 -m 1\n\n./gen -type random -n 2 -m 1000\n\n./gen -type random -n 100 -m 999\n\n./gen -type sum_less_than_n -n 100 -m 100 -h 1\n\n./gen -type sum_less_than_n -n 5 -m 1000 -h 500\n\n./gen -type m_equals_1 -n 1\n\n./gen -type sh_equals_n -n 1 -m 500 -h 250\n\n./gen -type sh_equals_n -n 100 -m 1000 -h 600\n\n./gen -type random -n 100 -m 1000\n\n./gen -type precision_test -n 95 -m 500 -h 250\n\n./gen -type precision_test -n 100 -m 1000 -h 1\n\n./gen -type sh_equals_1 -n 100 -m 1000 -h 1000\n\n./gen -type random -n 75 -m 800\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:03.321686",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "107/C",
      "title": "C. Размещение",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано три целых числа n, y и m (1 ≤ n ≤ 16, 2001 ≤ y ≤ 1018, 0 ≤ m ≤ 100) — соответственно, количество профессоров, год, для которого следует вывести порядок размещения профессоров и количество пар мест, про которые известно, что отношение старшинства профессоров должно соблюдаться.Далее в m строках записаны m пар целых чисел «ai bi», для которых должно выполняться требование, что профессор, занимающий место ai, старше профессора, занимающего место bi (1 ≤ ai, bi ≤ n, ai ≠ bi). Некоторые пары могут быть перечислены более одного раза.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать поток cin (также вы можете использовать спецификатор %I64d).",
      "output_spec": "Выходные данныеВыведите порядок размещения профессоров в году y.Если к этому году размещения, удовлетворяющие вышеописанным требованиям, закончатся, или заданные отношения старшинства противоречивы, выведите «The times have changed» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать3 2001 21 22 3Выходные данныеСкопировать1 2 3Входные данныеСкопировать7 2020 61 21 32 42 53 63 7Выходные данныеСкопировать1 2 3 7 4 6 5Входные данныеСкопировать10 3630801 0Выходные данныеСкопироватьThe times have changedВходные данныеСкопировать3 2001 31 22 33 1Выходные данныеСкопироватьThe times have changed",
      "description": "C. Размещение\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано три целых числа n, y и m (1 ≤ n ≤ 16, 2001 ≤ y ≤ 1018, 0 ≤ m ≤ 100) — соответственно, количество профессоров, год, для которого следует вывести порядок размещения профессоров и количество пар мест, про которые известно, что отношение старшинства профессоров должно соблюдаться.Далее в m строках записаны m пар целых чисел «ai bi», для которых должно выполняться требование, что профессор, занимающий место ai, старше профессора, занимающего место bi (1 ≤ ai, bi ≤ n, ai ≠ bi). Некоторые пары могут быть перечислены более одного раза.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать поток cin (также вы можете использовать спецификатор %I64d).\n\nВходные данные\n\nВыходные данныеВыведите порядок размещения профессоров в году y.Если к этому году размещения, удовлетворяющие вышеописанным требованиям, закончатся, или заданные отношения старшинства противоречивы, выведите «The times have changed» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать3 2001 21 22 3Выходные данныеСкопировать1 2 3Входные данныеСкопировать7 2020 61 21 32 42 53 63 7Выходные данныеСкопировать1 2 3 7 4 6 5Входные данныеСкопировать10 3630801 0Выходные данныеСкопироватьThe times have changedВходные данныеСкопировать3 2001 31 22 33 1Выходные данныеСкопироватьThe times have changed\n\nВходные данныеСкопировать3 2001 21 22 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 2 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 2020 61 21 32 42 53 63 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 2 3 7 4 6 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 3630801 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьThe times have changed\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2001 31 22 33 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьThe times have changed\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере лексикографически первым является порядок «1 2 3».В третьем примере после 3630800-го года допустимые порядки размещения закончатся.В четвертом примере не существует ни одного размещения удовлетворяющего всем ограничениям.Лексикографическое сравнение размещений реализует оператор < в современных языках программирования. Размещение a лексикографически меньше размещения b, если существует такое i (1 ≤ i ≤ n), что ai < bi, а для любого j (1 ≤ j < i) aj = bj.",
      "solutions": [
        {
          "title": "Codeforces Beta Round #83 - Codeforces",
          "content": "Всем привет,Сегодня мы рады пригласить вас принять участие в раунде #83, составленном по мотивам нашей подготовки к ACM в прошлом году, когда Dima был в гостях у German University in Cairo (GUC).Мы подготовили набор задач про жизнь в Египте и GUC. Надеемся, вам понравится :) Разбалловка задач в Div 1 & 2 стандартная: 500-1000-1500-2000-2500.Авторы задач: Dima и я. Спасибо всем, кто помогали нам готовить контест: RAD, Connector, it4.kp, Delinur, и MikeMirzayanov.Желаем вам приятного, познавательного и интересного соревнования!Всем удачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2511",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 542
        },
        {
          "title": "Editorial: Codeforces Beta Round #83 - Codeforces",
          "content": "Время-палиндромАвтор: AtefВ этой задаче необходимо найти следующий палиндром на цифровых часах. В задача точнось времени ограничивается минутами, и в сутках всего 24 * 60 минут. Соответственно, достаточно проверить все минуты, начиная с введённого времени, до тех пор, пока не будет обнаружен палиндром. Если палиндром не был обнаружен до конца дня, 23: 59, ответом будет 00: 00.Типы данныхАвтор: AtefБудем считать пару типов данных (a, b), где a < b, \"плохой\" тогда и только тогда, когда существует числоx такое что x помещается в a бит, но x * x не помещается в b бит. Для решения задачи поможет следующее наблюдение. Лучшим кандидатом на число x будет максимальное число, которое помещается в a bits --- то есть x = 2a - 1. Таким образом, для каждого ai достаточно проверить что минимальное из aj > ai содержит достаточно бит, чтобы хранить x * x = (2a - 1) * (2a - 1), для которого требуется максимум 2 * a бит. Для того, чтобы находить следующее минимальное aj > ai числа на входе имеет смысл предварительно отсортировать.ВодоснабжениеАвтор: AtefВ задача задаётся граф корпусов общежития и направленных труб между ними. По условию задачи этот граф будет содержать одну или блее цепочек труб. Необходимо найти начало и конец каждой цепочки, принимая во внимания, что цепочка может состоять из более чем одной трубы.Также для каждой цепочки необходимо найти наиболее слабое звено. Чтобы сделать это, следует пройти по каждой цепочке, например, запуская поиск в глубину из каждого корпуса не имеющего входящих труб. Эти корпуса будут началами цепочек, и, по ходу поиска в глубину, нужно также помнить минимальный диаметр среди встреченных труб. После того, как все цепочки найдены, перед выводом их следует отсортировать по номеру корпуса, откуда выходит данная цепочка.Баскетбольная командаАвтор: AtefРассмотрим два множества возможных команд: команды, где Мистер Вафа является единственным студентом со своего факультета и команты, где хотя бы один студент с факультета Мистера Вафы, кроме самого Мистера Вафы, является членом команды. Эти множества не пересекаются. Если вычислить количество команд в первом множестве --- A, и количество команд во втором множестве --- B, то ответм будет B / (A + B).Количество команд в первом множестве A = . Нужно вычесть единицу так как Мистер Вафа точно является членом команды, а оставшиеся (n - 1) игроков будут выбраны из оставшихся студентов.Теперь найдем количество команд, где кроме Мистера Вафы в команде есть ещё k студентов с его факультета. Это будет . По аналогии с количеством команд в первом множестве, нужно выбрать (n - (k + 1)) студентов с других факультетов и ни один из них не должен быть с факультета Мистера Вафы. Таким образом, общее количество команд, где у Мистера Вафы будет хотя бы один партнёр по команде с его факультета, равно .Выше приведено математическое решение. Оно допускает множество алгоритмических реализаций.Преступление и наказаниеАвтор: AtefС первого взгляда ограничение на n в 1018 кажется огромным. Однако, в сочетании с тем, что ответ следует вывести по модулю 12345 оно должно не пугать вас, а наоборот, помогать думать в правильном направлении: как решить задачу методом динамического программирования.Как и во всех задачах на динамическое программирование, подход заключается в том, чтобы разбить задачу на подзадачи и понять, какую дополнительную информацию следует передавать из поздадачи в подзадачу чтобы в итоге добраться до решения общей задачи.Предположим, что n равно 11, и у нас есть решение для первых 10 преступлений. Понятно. что просто знать ответ --- количество способов, которыми можно совершить первые 10 преступлений и остаться безнаказанным --- недостаточно для того, чтобы решить задачу для n = 11. Дополнительной информацией, которую необходимо передать из подзадачи в подзадачу является следующее множество чисел: количества способов, которыми можно совершить первые n преступлений, имея после этого кратности преступлений по всем типам d1, d2, ...d26 соответственно. Так как произведение кратностей во входном файле не превосходит 123 размер множества всех возможных комбинаций кратностей тоже ограничен сверху ста двадцатью тремя.Чтобы лучше понять эту идею, рассмотрим первый тест из условия. В нём есть два ограничения, A с кратностью 1 и B с кратностью 2. Остаток по преступлениям типа A всегда ноль. Остаток по преступлениям типа B может быть либо нулём либо единицей. Таким образом, решая подзадачу для первых n2 <  = n преступлений, достаточно помнить два числа: \"количество способов, которыми можно совершить n2 преступлений и быть невиновным по всем статьям\", и \"количество способов, которыми можно совершить n2 преступлений из которых есть одно ' нескомпенсированное' преступление типа B\".Ключевым шагом к решению теперь является наблюдение, что каждый переход от моножества решений для первых k преступлений ко множеству решений для первых (k + 1) преступлений можно задать матрицей перехода. Эта матрица будет одинаковой на каждом шагу. После построения этой матрицы задача можеть быть решена за логарифм от n = 1018 используя идею matrix exponentiation: на некоторых шагах вместо того, чтобы вычислять Ai + 1 = Ai· A0 можо вычислить A2i = Ai· Ai.доПоследним подводным камнем в этой задача являются множественные кратности. Если бы у каждого преступления была максимум одна кратность, достаточно было бы хранить в множестве состояний текущую кратность по данному преступлению. Более того, после возведения матрицы в степень единственным допустимым состояниям было бы состояние, где все кратности равны нулю.Если же множественные кратности разрешены, то для каждого типа преступлений нужно хранить кратности по могулю произведения всех допустимых кратностей для этого типа претуплений. (Строго говоря, достаточно хранить кратности до наименьшего общего кратного кратностей, но в данных огранчениях это не требуется.) Затем, на этапе вывода ответа, вместо того, чтобы вывести содержимое одной клетки финальной матрицы, следует пройтись по всем её элементам и выбрать те, красности по которым удовлетворяют входным ограничениям на кратности.РазмещениеАвтор: AtefВ задаче требуется найти лексикографически n-ю сортировку, удовлетворяющую данным ограничениям.Подвох, который смутим многих участников, а заодно и некоторых тестеров и авторов опорных решений, заключается в том, что вместо интуитивного ограничения в формате position[a[i]] < position[b[i]] ограничения в этой задача имеют вид  element at position[a[i]] < element at position[b[i]].В большинстве задач, где следует вывести лексикографически n-ое решение, хорошей идеей, зачастую приводящей к решению, является идея научиться считать количество возможных решений, на которые ракладываются некоторые ограничения.Перед тем как научиться считать количество возможных решений, давайте поймём как это поможет нас решить задачу. Для начала сделаем следующее наюлюдение: если общее количество решений меньше, чем y - 2000, то ответом будет \"The times have changed\". А когда эта проверка на существование решения произведена, найти само решение можно, например, подбирая его слева направо.Подобрать решение можно, наример, так: зафиксируем первый элемент равным единице и подсчитаем количество возможных решений.  Если их меньше, чем индекс перестановки, которую нужно найти,  то первым элементов результирующей перестановки должна быть единица --- поскольку все перестановки, где первым числом идет единица лексикографически меньше перестановок, где первый элемент больше единицы, и, таким образом, если мы допускаем гипотезу, что первый элемент может быть не единицей, мы сразу приходим к противоречию.А если зафиксировать первый элемент в единицу не дало нам достаточно перестановок, тогда следует уменьшить y на количество перестановок, где первым элементом является единица, и продолжить поиск в предположении, что первым элементов является двойка. Вычесть количество перестаноков, где первым эдементов является единица, необходим, потому что, согласно условию задачи. мы пропускаем те порядки размещения, которые использовались в 2001, 2002 и т.д. годах.Процеесс подбора следует продложать пока все элементы не были зафиксированы на каких-то значаниях. Когда первый элемент перестановки становится известным, можно приступать ко второму элементу, затем к третьему и т.д.Теперь, чтобы решение стало полным, нужно уметь вычислять количество перестановок, удовлетворяющих двум ограничениям: набору ограничений на граф размещения из теста и зафиксированному префиксу. Эта часть задачи решается динамикой.Для данного префикса P необходимо подсчитать количество способов, которыми можно разместить оставшиеся (n-m) элементов не нарушив ни одного ограничения.Предположим, что мы будем генерировать все возможные перестановки. Однако, вместо стандартного подхода \"попробуем поставить на позицию i любой свободный элемент и решим задачу для оставшихся позиций начиная с (i+1)-й\", используем несколько иной подход: \"для данного способа разместить первые i элементов, не считая элементов, которые образуют префикс, возьмём (i+1)-й элемент и проверим все позиции, куда его можно было бы поместить\". При этом будем идти по элементам в возрастающем порядке, пропуская, конечно, элементы, которые являются частью уже известного префикса.Несложно видеть, что такой алгоритм генерации всех перестановок работает, но за время O((n - m)!), что конечно, недопустимо. Соответственно, нужно каким-то образом уменьшить пространство состояний, чтобы свернуть этот алгоритм генерации перестановок в динамику.Необходимое нам наблюдение такое: состояние частично решённой задачи однозначно задаётся битовой маской использованых позиций. С первого взгляда может показаться, что этой информации недостаточно, так как на будущие ограничения влияет не только маска занятых позиций, но и то, в каком порядке расположены элементы на этих позициях. Однако, это оказывается несущественным, если заполнение перестановки элементами производится в порядке возрастания свободных элементов. Действительно, пусть для некоторой маски занятых позиций мы хотим поставить элемент e в свободную позицию i. Чтобы проверить допустимо ли такое положение для элемента e, будем проверять те пары входных ограничений, которые касаются позиции i. Если ограничение касается позиции i и другой позиции, которая ещё свободна, то оно не нарушается элементом e. Если же ограничение накладывается на позицию e и другую позицию, в которой уже есть элемент, то верно одно из двух: либо другая позиция принадлежит префиксу, и тогда мы точно знаем, какой на ней стоит элемент, либо же нам заведомо известно, что элемент на этой позиции меньше, чем e, потому как наша динамика расставляет элементы начиная с меньших.ДартсАвтор: DimaПеред тем, как перейти к алгоритму, отметим, что ответом на задачу будет отношение суммарной площади всех прямоугольников к площади объединения всех прямоугольников.Чтобы понять это, сделаем следующее наблюдение. В первую очередь понятно, что если все прямоугольники совпадают, то ответом будет их количество. Теперь временно забудем про то, что фигуры должны быть прямоугольниками, предположим, что форма фигур на входе может быть любой, и покажем как построить пример, где площать объединения была бы s и ожидаемое среднее количество проткнутых фигур было бы e. Понятно, что такой пример можно построить начав с произвольного контура объединения, ограничевающего площать s, путём добавления дополнительных фигур, лежащих внутри этого контура. Суммарно необходимо будет добавить фигур на общую площать t = s· (e - 1), но конкретное число не важно. Важно то, что взаимное расположение этих добавленных фигур не имеет значения, и, соответственно, ответ на исходную задачу зависит только от площади контура объединения всех фигур и суммарной площади всех фигур.Вернёмся теперь к прямоугольникам. Найти суммарную площадь всех прямоугольников легко. Сложно найти площадь объединения всех прямоугольников быстрее, чем за O(n3). Обратите внимание, что объединение может состоять из множества несвязных компонент, компоненты не обязаны быть выпуклыми, они могут содержать дырки, и вообще, в общем случае описать объединение всех входных прямоугольников не очень просто. К счастью, в этой задаче нас интересует только площать этого объединения.Одно из решений, которое относительно несложно закодировать, заключается в следующем. Будем считать площадь объединения методом трапеций. Отметим сразу, что для вычисления площади методом трапеций достаточно знать все ориентированные сегменты контура, а их порядок совершенно не важен. Таким образом достаточно \"просто\" найти все ориентированные сегменты, которые образуют контур объединения, причём вертикальные сегменты могут быть сразу исключены из рассмотрения.Например, если для какого-то теста объединение представляет собой фигуру с дыркой, то внешний контур должен превратиться во множество сегментов с положительной общей площадью, а внутренний контур --- во множество сегментов с отрицательной общей площадью. Иными словами, внешний контур следует обойти по часовой стрелке, а внутренний --- против часовой стрелки.Для того, чтобы найти все такие сегменты, рассмотрим все различные невертикальные прямые, на которых лежат стороны входных квадратов. Их не больше, чем 4n. Понятно, что каждый сегмент объединения лежит на одной из этих прямых, соответственно, достаточно проверить отдельно каждую из прямых, но только по одному разу.Правила, по которым можно выделить \"положительные\" и \"отрицательные\" сегменты на каждой прямой достаточно просты:1) Если сегмент этой прямой (x1, y1) - (x2, y2) является частью границы одного из входных прямоугольников, тогда помечаем этот сегмент как \"положительный\" или \"отрицательный\" в зависимости от того, лежит ли данный прямоугольник выше или ниже прямой.2) Если на сегменте этой прямой (x1, y1) - (x2, y2) накладываются границы двух входных прямоугольников, лежащих по разные стороны от прямой, то этот сегмент не може являться частью контура.3) Если сегмент (x1, y1) - (x2, y2) лежит полностью внутри какого-то из входных прямоугольников, то он не может являться частью контура.Соответственно, построить все сегмента контура объединения можно с помощью примерно следующего кода:для каждой уникальной не-вертикальной прямой  создаём массив маркеров. маркер хранит x-координату и одно из четырёх событий: { начало/конец положительного сегмента, начало/конец отрицательного сегмента }   проходим во всем входным прямоугольникам    если одна из сторон этого прямоугольника принадлежит рассматриваемой прямой       добавляем два маркера: начало и конец сегмента. знак сегмента определяется положением прямоугольника относительно  рассматриваемой прямой.    иначе если это прямоугольник пересекается с прямой      находим левую и правую точки пересечения, и помечаем сегмент между ними четырьмя маркерами, покрывая его и положительным и отрицательным сегментом.  сортируем массив маркеров по их x-координате  идём по маркерам слева направо. если про какой-то сегмент известно, что он должен быть положительным, и не должен быть отрицательным, выводим его как положительный сегмент финального контура. если известно, что он должен быть отрицательным и не должен быть положительным, выводим его как отрицательный сегмент финального контура.После этого можно было бы выписать множество финальных контуров используя, например, поиск в глубину, но для метода трапеций это не требуется. Достаточно просуммировать (x2 - x1)· (y1 + y2) / 2  для каждого сегмента.Вышеописанное решение работает за O(n2· logn) : для каждой из O(n) прямых мы рассматриваем O(n) пересечений, и их сортировка занимает O(n· logn) на каждую прямую.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 15542
        }
      ],
      "code_examples": [
        {
          "title": "Editorial: Codeforces Beta Round #83 - Codeforces - Code 1",
          "code": "52\n\n474 24 24 954 9 234 474 114 24 114 234 24 114 114 234 9 9 24 9 54 234 54 9 954 474 9 54 54 54 234 9 114 24 54 114 954 954 474 24 54 54 234 234 474 474 24 114 9 954 954 954 474in the above case 9 is there but no 18......24 is there but no 48...hence the output should be \"YES\"but the correct answer for the case is \"NO\"plz explain why is so ??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 16, \"n\");\n    inf.readSpace();\n    long long y = inf.readLong(2001LL, 1000000000000000000LL, \"y\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"ai and bi must not be equal (ai=%d, bi=%d)\", ai, bi);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 16, \"n\");\n    inf.readSpace();\n    long long y = inf.readLong(2001LL, 1000000000000000000LL, \"y\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"ai and bi must not be equal (ai=%d, bi=%d)\", ai, bi);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 16, \"n\");\n    inf.readSpace();\n    long long y = inf.readLong(2001LL, 1000000000000000000LL, \"y\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"ai and bi must not be equal (ai=%d, bi=%d)\", ai, bi);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    long long y = opt<long long>(\"y\");\n    int m = opt<int>(\"m\", -1); // default -1 means we'll adjust m based on type\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is in range\n    assert(1 <= n && n <= 16);\n    assert(2001 <= y && y <= 1e18);\n\n    vector<pair<int, int> > constraints;\n\n    // Generate constraints based on type\n    if (type == \"empty_constraints\") {\n        if (m == -1) m = 0;\n        // No constraints\n    } else if (type == \"contradictory\") {\n        if (n >= 2) {\n            if (m == -1) m = 2;\n            constraints.push_back({1, 2}); // 1 > 2\n            constraints.push_back({2, 1}); // 2 > 1, contradictory\n        } else {\n            // Cannot create contradictory constraints with n < 2\n            m = 0;\n        }\n    } else if (type == \"contradictory_cyclic\") {\n        if (n >= 3) {\n            if (m == -1) m = 3;\n            constraints.push_back({1, 2});\n            constraints.push_back({2, 3});\n            constraints.push_back({3, 1}); // cycle\n        } else {\n            m = 0; // Can't create cycle\n        }\n    } else if (type == \"chain\") {\n        if (m == -1) m = n-1;\n        for (int i = 1; i <= n - 1; ++i) {\n            constraints.push_back({i, i + 1});\n        }\n        // The number of valid permutations is 1 (only one arrangement)\n    } else if (type == \"random\") {\n        if (m == -1) m = rnd.next(0, min(100, n * (n - 1)));\n        set<pair<int, int>> s;\n        while ((int)s.size() < m) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai != bi) {\n                s.insert({ai, bi});\n            }\n        }\n        for (auto& p : s) {\n            constraints.push_back(p);\n        }\n    } else if (type == \"max_year\") {\n        if (m == -1) m = 0;\n        // Nothing else to do\n    } else if (type == \"single_arrangement\") {\n        // Constraints that enforce only one valid arrangement\n        constraints.clear();\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                constraints.push_back({i, j}); // seat i must have more senior professor than seat j\n            }\n        }\n        m = constraints.size();\n    } else {\n        // Default to random constraints\n        if (m == -1) m = rnd.next(0, min(100, n * (n - 1)));\n        set<pair<int, int>> s;\n        while ((int)s.size() < m) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai != bi) {\n                s.insert({ai, bi});\n            }\n        }\n        for (auto& p : s) {\n            constraints.push_back(p);\n        }\n    }\n\n    // Output n y m\n    printf(\"%d %lld %d\\n\", n, y, (int)constraints.size());\n    // Output constraints\n    for (auto& p : constraints) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    long long y = opt<long long>(\"y\");\n    int m = opt<int>(\"m\", -1); // default -1 means we'll adjust m based on type\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is in range\n    assert(1 <= n && n <= 16);\n    assert(2001 <= y && y <= 1e18);\n\n    vector<pair<int, int> > constraints;\n\n    // Generate constraints based on type\n    if (type == \"empty_constraints\") {\n        if (m == -1) m = 0;\n        // No constraints\n    } else if (type == \"contradictory\") {\n        if (n >= 2) {\n            if (m == -1) m = 2;\n            constraints.push_back({1, 2}); // 1 > 2\n            constraints.push_back({2, 1}); // 2 > 1, contradictory\n        } else {\n            // Cannot create contradictory constraints with n < 2\n            m = 0;\n        }\n    } else if (type == \"contradictory_cyclic\") {\n        if (n >= 3) {\n            if (m == -1) m = 3;\n            constraints.push_back({1, 2});\n            constraints.push_back({2, 3});\n            constraints.push_back({3, 1}); // cycle\n        } else {\n            m = 0; // Can't create cycle\n        }\n    } else if (type == \"chain\") {\n        if (m == -1) m = n-1;\n        for (int i = 1; i <= n - 1; ++i) {\n            constraints.push_back({i, i + 1});\n        }\n        // The number of valid permutations is 1 (only one arrangement)\n    } else if (type == \"random\") {\n        if (m == -1) m = rnd.next(0, min(100, n * (n - 1)));\n        set<pair<int, int>> s;\n        while ((int)s.size() < m) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai != bi) {\n                s.insert({ai, bi});\n            }\n        }\n        for (auto& p : s) {\n            constraints.push_back(p);\n        }\n    } else if (type == \"max_year\") {\n        if (m == -1) m = 0;\n        // Nothing else to do\n    } else if (type == \"single_arrangement\") {\n        // Constraints that enforce only one valid arrangement\n        constraints.clear();\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                constraints.push_back({i, j}); // seat i must have more senior professor than seat j\n            }\n        }\n        m = constraints.size();\n    } else {\n        // Default to random constraints\n        if (m == -1) m = rnd.next(0, min(100, n * (n - 1)));\n        set<pair<int, int>> s;\n        while ((int)s.size() < m) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai != bi) {\n                s.insert({ai, bi});\n            }\n        }\n        for (auto& p : s) {\n            constraints.push_back(p);\n        }\n    }\n\n    // Output n y m\n    printf(\"%d %lld %d\\n\", n, y, (int)constraints.size());\n    // Output constraints\n    for (auto& p : constraints) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal n, minimal m\n./gen -n 1 -y 2001 -m 0 -type empty_constraints\n\n# n=2, m=0\n./gen -n 2 -y 2001 -m 0 -type empty_constraints\n\n# n=2, contradictory constraints\n./gen -n 2 -y 2001 -type contradictory\n\n# n=3, chain constraints\n./gen -n 3 -y 2001 -type chain\n\n# n=3, contradictory cyclic constraints \n./gen -n 3 -y 2001 -type contradictory_cyclic\n\n# n=3, random constraints\n./gen -n 3 -y 2001 -m 2 -type random\n\n# n=5, empty constraints, y=2010\n./gen -n 5 -y 2010 -m 0 -type empty_constraints\n\n# n=5, m=10, random constraints\n./gen -n 5 -y 2001 -m 10 -type random\n\n# n=5, chain constraints\n./gen -n 5 -y 2001 -type chain\n\n# n=5, chain constraints, y=2005\n./gen -n 5 -y 2005 -type chain\n\n# n=10, m=0, y=2001\n./gen -n 10 -y 2001 -m 0 -type empty_constraints\n\n# n=10, m=50, random constraints\n./gen -n 10 -y 2001 -m 50 -type random\n\n# n=10, contradictory constraints\n./gen -n 10 -y 2001 -m 50 -type contradictory\n\n# n=10, y beyond total permutations\n./gen -n 10 -y 50000000 -m 0 -type max_year\n\n# n=16, m=0, y=2001\n./gen -n 16 -y 2001 -m 0 -type empty_constraints\n\n# n=16, m=100, random constraints\n./gen -n 16 -y 2001 -m 100 -type random\n\n# n=16, chain constraints\n./gen -n 16 -y 2001 -type chain\n\n# n=16, chain constraints, y=2002\n./gen -n 16 -y 2002 -type chain\n\n# n=16, single arrangement\n./gen -n 16 -y 2001 -type single_arrangement\n\n# n=16, contradictory constraints\n./gen -n 16 -y 2001 -type contradictory_cyclic\n\n# Random n and m\n./gen -n 7 -y 2010 -m 20 -type random\n\n./gen -n 8 -y 2020 -m 50 -type random\n\n# n=16, test year overflows\n./gen -n 16 -y 1000000000000000000 -m 0 -type max_year\n\n# n=4, contradictory constraints\n./gen -n 4 -y 2001 -type contradictory_cyclic\n\n# n=4, chain constraints\n./gen -n 4 -y 2001 -type chain\n\n# n=2, m=1, random constraints\n./gen -n 2 -y 2001 -m 1 -type random\n\n# n=15, m=100, random constraints\n./gen -n 15 -y 2001 -m 100 -type random\n\n# n=10, single arrangement, y=2001\n./gen -n 10 -y 2001 -type single_arrangement\n\n# n=10, single arrangement, y=2002\n./gen -n 10 -y 2002 -type single_arrangement\n\n# n=15, m=0, y=999999999999999999\n./gen -n 15 -y 999999999999999999 -m 0 -type max_year\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:05.534991",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "107/D",
      "title": "D. Crime Management",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and c (0 ≤ n ≤ 1018, 0 ≤ c ≤ 1000) — the number of crimes Zeyad would like to commit and the number of conditions he is aware of.Then the definitions for c conditions follow. There are 26 types of crimes. Each crime definition consists of crime type — a capital Latin letter — and its multiplicity. The multiplicity of each crime is a positive integer number and the product of all multiplicities does not exceed 123. Some conditions may be repeated in the input more than once.Crime of multiplicity 1 is not yielding any punishment regardless of the number of times it was committed. The strictness of the law is compensated by the fact that it's non-mandatory.Obviously, if some crime is not listed in the set of conditions, then Zeyad will not consider it, as committing it would unavoidably lead to the punishment.Please, do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use the cin stream (you may also use the %I64d specificator).",
      "output_spec": "OutputOutput the number of different ways Zeyad can commit exactly n crimes with no punishment modulo 12345.",
      "sample_tests": "ExamplesInputCopy5 2A 1B 2OutputCopy16InputCopy6 3A 1B 2C 3OutputCopy113InputCopy8 3A 2A 3B 2OutputCopy128",
      "description": "D. Crime Management\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and c (0 ≤ n ≤ 1018, 0 ≤ c ≤ 1000) — the number of crimes Zeyad would like to commit and the number of conditions he is aware of.Then the definitions for c conditions follow. There are 26 types of crimes. Each crime definition consists of crime type — a capital Latin letter — and its multiplicity. The multiplicity of each crime is a positive integer number and the product of all multiplicities does not exceed 123. Some conditions may be repeated in the input more than once.Crime of multiplicity 1 is not yielding any punishment regardless of the number of times it was committed. The strictness of the law is compensated by the fact that it's non-mandatory.Obviously, if some crime is not listed in the set of conditions, then Zeyad will not consider it, as committing it would unavoidably lead to the punishment.Please, do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use the cin stream (you may also use the %I64d specificator).\n\nOutputOutput the number of different ways Zeyad can commit exactly n crimes with no punishment modulo 12345.\n\nInputCopy5 2A 1B 2OutputCopy16InputCopy6 3A 1B 2C 3OutputCopy113InputCopy8 3A 2A 3B 2OutputCopy128\n\nInputCopy5 2A 1B 2\n\nOutputCopy16\n\nInputCopy6 3A 1B 2C 3\n\nOutputCopy113\n\nInputCopy8 3A 2A 3B 2\n\nOutputCopy128\n\nNoteIn the first test case, the 16 ways are: AAAAA, AAABB, AABAB, AABBA, ABAAB, ABABA, ABBAA, BAAAB, BAABA, BABAA, BBAAA, ABBBB, BABBB, BBABB, BBBAB, BBBBA.",
      "solutions": [
        {
          "title": "Codeforces Beta Round #83 - Codeforces",
          "content": "Hi all,Today we would like to invite you to take part in round #83 inspired by the ACM practice sessions last year when Dima was visiting the German University in Cairo (GUC).We have composed the problemset about life in Egypt and the GUC. Hope you will like it :)The points for the problems in Div 1 & 2 will be: 500-1000-1500-2000-2500.The writers of the problems are Dima and myself.We would like to thank RAD, Connector, it4.kp, Delinur, and MikeMirzayanov, who greatly helped in preparing this contest.We wish you a pleasant, educational and successful contest!The editorial is under construction.Good luck to everyone!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2511",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 624
        },
        {
          "title": "Editorial: Codeforces Beta Round #83 - Codeforces",
          "content": "Palindromic TimesWriter: AtefIn this problem it was required to find next palindrome on a digital clock. Since the lowest unit of time used 1 minute, and there are only 24 * 60 minutes in a day, one could simply go through each minute starting from the time given in the input plus 1 minute, until finding a palindrome. If no palindrome is found till the end of the day 23: 59, the output should then be 00: 00.DatatypesWriter: AtefLet us call a pair of datatypes (a, b), where a < b, BAD if and only if there exists a number x where x fits in a bits but x * x does not fit in b bits. The following observation helps in finding a solution to the problem. The best candidate for the number x is the largest number fitting in a bits, which is x = 2a - 1. So for each ai it is enough to check that the smallest aj > ai has enough bits to contain x * x = (2a - 1) * (2a - 1), which has at most 2 * a bits. Sorting the numbers first was needed to traverse the list of datatypes once and ensuring the condition above.Dorm Water SupplyWriter: AtefThe problem describes a graph of houses as nodes and one-way pipes as edges. The problem states that the graph will contain 1 or more chains of nodes. The required is to find the start and end of every chain (consisting of more than 1 node, which caused many hacks). The other requirement was to find the weakest edge in each of the chains. This can be done by traversing (using Depth-First Search (DFS) for example) the graph from each un-visited node with no incoming edges. These nodes are the start of a chain. By keeping track of the minimum diameter so far, whenever the DFS reaches a node with no outgoing edges, it means that this node is the end of the current chain. After storing, in a list or vector, the tuples (start, end, minimum diameter), we sort these tuples by start index and print.Basketball TeamWriter: AtefThis problem is asking for the probability. Consider two sets of teams: the set of teams where Herr Wafa is the only student from his major and the set where at least one other student from Herr Wafa's major is present. These two sets don't intersect, so once we can compute the number of teams in the first set, A, and the number of teams in the second set, B, the answer would be B / (A + B).The number of teams in the first set is A = . We subtract one as Herr Wafa is guaranteed the spot, and the other (n - 1) spots are to be taken by the remaining students.Now let's count the number of teams having exactly k students from Herr Wafa's major apart from him. This number would be . Much like for the first set, (n - (k + 1)) students from the other majors should he selected, and none of them should be from Herr Wafa's major. The total number of teams where at least one other student is from Herr Wafa's major is therefore .The statements above describe the mathematical solution. It can be implemented in various ways.Crime ManagementWriter: AtefAt the first glance the upper limit for n being 1018 looks huge. But in fact, combined with the fact, that the answer should be output modulo 12345, it's should not scare you but rather hint that the problem has a DP approach.Like all DP problems the way to approach it is to split the problem into sub-problems and figure out what extra information should be carried between the sub-problems in order to combine them into the solution to the whole problem.Say, n is 11 and we solved the problem for the first 10 crimes. Clearly, just the number of ways to commit the first 10 crimes is not enough to solve the full problem with n = 11. The extra information to be carried along with the number of ways to commit n crimes and be innocent is the following: the number of ways to commit the first n crimes and have remaining multiplicities d1, d2, ...d26 respectively. The fact that the product of the multiplicities does not exceed 123 makes this a solvable task, as the set of all possible remainders contains not more elements than the product of multiplicities.To illustrate the idea from the first paragraph consider the first example case. It has two constraints, A with multiplicity 1 and B with multiplicity 2. The remainder of the number of crimes of type A is always zero, and committing crimes of type A may not yield any punishment. The remainder of the number of crimes of type B is zero or one. Therefore, while solving the sub-problems for the first n2 <  = n crimes, it's enough to keep track of only two numbers: \"number of ways to commit n2 crimes and be completely innocent\" and \"number of ways to commit n2 crimes and have committed one 'extra' crime of type B\".The key step to solve the problem now is to notice that each transition from the solution for the first k crimes to the solution for the first (k + 1) crimes can be seen as multiplying the vector of the current state by the transition matrix. Once all possible transitions are converted to the matrix form, the problem can be solved by raising the matrix into n-th power. Raising the matrix into large power can be done efficiently using matrix exponentiation: on some steps instead of computing Ai + 1 = Ai· A0 one can compute A2i = Ai· Ai.The last trick of this problem is to deal with multiple allowed multiplicities. If they were not allowed, the remainders per each crime type could have been kept with the modulo being equal to the multiplicity for this crime type. Moreover, if no crime type is listed more than once, the only valid final state is the state where the remainders are zero across all the crime types.With multiple allowed multiplicities, for each crime type the remainder modulo the product of the multiplicities of crimes for this type should be kept. (Strictly speaking, LCM is enough, but the constraints allow to use the plain product instead). Then, at the stage of printing the output, instead of treating the counter for the state with zero remainders as the only contributor to the output, one would have to iterate through all possible states and verify if each set of remainders conducts a valid final state.ArrangementWriter: AtefThe problem asks for finding the lexicographically n-th permutation satisfying the input constraints.The trick which confused many contestants, as well as a few authors and testers, is that instead of having the restrictions formulated in a way position[a[i]] < position[b[i]] the restrictions were element at position[a[i]] < element at position[b[i]].As in most problems where one has to output lexicographically n-th answer, the idea which can result in the solution which is passing the systests is to learn how to compute the number of solutions satisfying certain constraints.We will speak about how to compute the number of solutions in a bit, but first let's understand how having such function would lead to a solution. The very first observation is: if the total number of possible solutions is less than y - 2000, then the answer is \"The times have changed\". Once we have ensured that the solution exists it can be found using some of search.A simple approach would be the following: fix the first element of the resulting permutation to be 1 and count the number of possible solutions. If we do have enough to reach year y, then the first element must be 1, because there exists enough permutations with the first element being 1 to cover the years up to y, and any permutation where the first element is not 1 comes after any permutation where the first element is 1 in lexicographical order.And if fixing the first element to be 1 is not giving enough permutations, then we should decrease the \"desired\" year by the number of solutions with 1 being fixed as the first element and start looking for the solutions with 2 as the first element. The intuition is that there are not enough solutions with 1 being the first element, but once we acknowledge that and start looking for the other solutions --- with 2 as the first element, we are speaking not about arrangements for years 2001 and onwards but about the years 2001 + number of solutions with first element being one and onwards. Therefore instead of looking for the permutation with index y - 2001 with the first element being 1 we are looking for the permutation with the lower index, y - 2001 - number of solutions with first element being one, with the first element being 2 or higher.This process should be continued until all the elements are identified. Once the first index is fixed the known prefix would become a two-numbers prefix, and it will grow until all the permutation is constructed.Now to complete the solution we need to be able to compute the number of permutations which satisfy two restrictions: the input constraints and the added \"permutation has prefix P\" constraint. This problem can be solved using DP.For a given prefix P of length m, (n-m) other elements should be placed.Assume first that we are going to be iterating over all possible permutations with the given prefix using the brute force, but, instead of trying each possible value for the element at the next empty position i, we would be trying each possible position for the next not-yet-placed element i. This approach would work, but in O((n - m)!) time, which is obviously unfeasible. We need to find some way to reduce the state space and make it run faster.The key observation is the following: the state of the partially solved problem can be completely described by the bitmask of the currently occupied positions. This statement is nontrivial, as, from the first glance, it seems that apart from the unused positions mask, the information about the order, in which the already-placed elements are placed, is important. However it's not. Recall that all the constraints have the form of \"element at position ai is less than the element at position bi\". Provided the elements are placed in increasing order, in order to satisfy each constraint it's enough to confirm that, if the element to be placed is being put into position i, there is no such constraint in the input, that the element at position i should be less than the element at position j, while the element at position j has already been placed.This approach results in the DP with 2n - m states. Note that the next element to be placed can always be determined by the number of bits set in the mask and the prefix elements.The implementation of the above algorithm requires nontrivial coding, as the elements, belonging to the prefix, have to be treated differently compared to the elements which were placed by the DP. This is because the DP is enforcing that the elements are always added in the increasing order, which does not have to be the case for the elements conducting the prefix.DartsWriter: DimaBefore doing the coding let's do some math. The answer to this problem can be computed as the total area of all input rectangles / the area of the union of all input rectangles.One of the easy ways to understand it is the following. First notice that if all the rectangles are the same, the answer is always the number of rectangles. Now forget that the input figures are rectangles, assume any shape is  allowed, and then try to construct the example case given the union area s and the resulting expected score e. Notice that you can start with any shape constructed of non-intersecting figures with the total area s, and then add more figures on top of these, such that the contour of the union is the same as the contour of the first original figure of area s. Specifically, you'd need to add some figures of the total sum of t = s· (e - 1), but the number doesn't matter here. The key is that the placement of these added figures doesn't change the result, and therefore the answer will always depend only on the total area of the input figures and the area of their union.Now back to the rectangles. Computing the sum of the ares of the rectangles is easy. The hard part is to compute the area of their union in better than O(n3). Note that the union may have multiple disjoins components, it does not have to be convex, it may have holes and, in short, does not have to be easy to describe.One of the relatively-easy-to-implement solutions is the following. We will be computing the are of the union of the rectangles using the trapezoid method. Note that for the trapezoid method the order, in which the segments of the figure are provided, doesn't matter. Therefore, in order to use the trapezoid method, we \"only\" need to find all non-vertical directed segments which are the part of the contour of the union.Let me elaborate a bit more on the previous paragraph. We don't need vertical segments, because their contribution to the resulting area is zero in the trapezoid method of computing the area. The direction of the segment is the important part though. It's not enough to know that the segment (x1, x2) - (y1, y2) belongs to the contour of the union. It's important to know whether the area of the union if the part of the plane above it or below it.Imagine the test case where the union of all the rectangles is a big rectangle with a hole inside it. In this case we need to know that the segments, describing the outer part of the union, should contribute to the area with the \"plus\" sign, while the segments describing the inner hole should be considered with the \"minus\" sign.Specifically, for the trapezoid method, the sign of x2 - x1 would be describing the direction of this segment: for example, if x1 < x2 than the segment is \"positive\" and if x1 < x2 it's \"negative\". To find all such segments let's consider all distinct  non-vertical lines. There are at most 4n such lines in the input. Each segment of the final contour of the union should lay on one of those lines, so it's enough to focus on the lines only, consider them independently from each other (but make sure to process each distinct line only once!) and for each line construct a set of the positive and negative segments.Let's formulate the rules under which a part of the line would be a positive or negative segment. They turn out to be very simple:1) If some segment (x1, y1) - (x2, y2) is part of the border of one of the input rectangles, then it's a \"positive\" segment if this input rectangle lays below this segment and a \"negative\" segment if this rectangle lays above this segment.2) If some segment (x1, y1) - (x2, y2) belongs to the intersection of the borders of two different input rectangles, with one being a \"positive\" one and one being a \"negative\" one, then this segment does not belong to the contour.3) If some segment (x1, y1) - (x2, y2) is being covered by another rectangle, then it does not belong to the contour. \"Covered\" means laying completely inside some other rectangle, the border cases are covered above.The easy way of constructing all the segments could look as the following pseudo-code:for each distinct non-vertical line  create the array of markers. the marker holds the x coordinate and one of four events: { start union area below, end union area below, start union area above, end union area above }.  iterate through all the input rectangles    if this rectangle has one segment laying on the line under consideration       add two markers: one for start and one for end. whether the markers are above or below is determined by the position of this rectangle with respect to this line    else if this rectangle intersects this line      find the intersection points and add four markers: { start area below } and { start area above } for the left intersection point and { end area below } and { end area above } for the right intersection point  sort the array of markers by the x coordinate of the events  traverse the array of markers. if some segment (x1..x2) is being reported as having the union area only above it or only below it, it becomes the negative or positive segment of the union respectively.At this point one could run some sort of DFS to merge the segments into the connected loops, but this is actually unnecessary to compute the area using the trapezoid method. Just summing up (x2 - x1)· (y1 + y2) / 2 for all the segments does the trick, and it would automatically ensure that the outer contours are taken with the positive sign and the inner contours are taken with the negative sign.The solution described above runs in O(n2· logn) : for each of O(n) lines we have at most O(n) intersections, which should be sorted in O(n· logn) inside the loop over all the lines.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 16423
        }
      ],
      "code_examples": [
        {
          "title": "Editorial: Codeforces Beta Round #83 - Codeforces - Code 1",
          "code": "52\n\n474 24 24 954 9 234 474 114 24 114 234 24 114 114 234 9 9 24 9 54 234 54 9 954 474 9 54 54 54 234 9 114 24 54 114 954 954 474 24 54 54 234 234 474 474 24 114 9 954 954 954 474in the above case 9 is there but no 18......24 is there but no 48...hence the output should be \"YES\"but the correct answer for the case is \"NO\"plz explain why is so ??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\"); // 0 ≤ n ≤ 1e18\n    inf.readSpace();\n    int c = inf.readInt(0, 1000, \"c\"); // 0 ≤ c ≤ 1000\n    inf.readEoln();\n\n    int product = 1;\n    for (int i = 0; i < c; i++) {\n        string ti = inf.readToken(\"[A-Z]\", \"ti\");\n        inf.readSpace();\n        int mi = inf.readInt(1, 123, \"mi\"); // mi ≥1, mi ≤123\n        product *= mi;\n        ensuref(product <= 123, \"Product of mi's exceeds 123 after multiplying mi=%d at line %d\", mi, i+2);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\"); // 0 ≤ n ≤ 1e18\n    inf.readSpace();\n    int c = inf.readInt(0, 1000, \"c\"); // 0 ≤ c ≤ 1000\n    inf.readEoln();\n\n    int product = 1;\n    for (int i = 0; i < c; i++) {\n        string ti = inf.readToken(\"[A-Z]\", \"ti\");\n        inf.readSpace();\n        int mi = inf.readInt(1, 123, \"mi\"); // mi ≥1, mi ≤123\n        product *= mi;\n        ensuref(product <= 123, \"Product of mi's exceeds 123 after multiplying mi=%d at line %d\", mi, i+2);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\"); // 0 ≤ n ≤ 1e18\n    inf.readSpace();\n    int c = inf.readInt(0, 1000, \"c\"); // 0 ≤ c ≤ 1000\n    inf.readEoln();\n\n    int product = 1;\n    for (int i = 0; i < c; i++) {\n        string ti = inf.readToken(\"[A-Z]\", \"ti\");\n        inf.readSpace();\n        int mi = inf.readInt(1, 123, \"mi\"); // mi ≥1, mi ≤123\n        product *= mi;\n        ensuref(product <= 123, \"Product of mi's exceeds 123 after multiplying mi=%d at line %d\", mi, i+2);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<char, int>> conditions;\n    int product = 1;\n\n    if (type == \"random\") {\n        // Generate c random conditions, ensuring total product of mi's ≤123\n        vector<char> crime_types;\n        for (int i = 0; i < 26; ++i) crime_types.push_back('A' + i);\n        shuffle(crime_types.begin(), crime_types.end());\n        int crimes_used = 0;\n        int max_crimes = min(c, 26);\n        for (int i = 0; i < c; ++i) {\n            char t;\n            if (crimes_used < max_crimes) {\n                t = crime_types[crimes_used];\n                crimes_used++;\n            } else {\n                // Reuse existing crime types\n                t = crime_types[rnd.next(0, max_crimes -1)];\n            }\n            int mi_max = 123 / max(1, product);\n            if (mi_max == 0) mi_max = 1;\n            int mi = rnd.next(1, mi_max);\n            product *= mi;\n            if (product > 123) mi = 1;\n            conditions.emplace_back(t, mi);\n        }\n    } else if (type == \"mi1\") {\n        // All mi's are 1\n        vector<char> crime_types;\n        for (int i = 0; i < 26; ++i) crime_types.push_back('A' + i);\n        for (int i = 0; i < c; ++i) {\n            char t = crime_types[i % 26];\n            int mi = 1;\n            conditions.emplace_back(t, mi);\n        }\n        product = 1;\n    } else if (type == \"max_c\") {\n        // c = 1000, repeating conditions\n        for (int i = 0; i < c; ++i) {\n            conditions.emplace_back('A', 1);\n        }\n        product = 1;\n    } else if (type == \"max_mi\") {\n        // mi = 123\n        conditions.emplace_back('A', 123);\n        product = 123;\n        // If c > 1, add mi=1 conditions\n        for (int i = 1; i < c; ++i) {\n            conditions.emplace_back('A', 1);\n        }\n    } else if (type == \"product123\") {\n        // mi's that multiply to 123, e.g., mi=3 and mi=41\n        conditions.emplace_back('A', 3);\n        conditions.emplace_back('B', 41);\n        product = 123;\n        // Add mi=1 conditions to reach c\n        int remaining_c = c - 2;\n        for (int i = 0; i < remaining_c; ++i) {\n            char t = 'C' + (i % 24); // From 'C' to 'Z'\n            conditions.emplace_back(t, 1);\n        }\n    } else if (type == \"multiple_mi\") {\n        // Multiple conditions for the same crime\n        char crime = 'A'; // same crime\n        vector<int> mi_values = {2, 3, 5};\n        product = 1;\n        for (int mi : mi_values) {\n            product *= mi;\n            conditions.push_back({crime, mi});\n        }\n        int remaining_c = c - mi_values.size();\n        for (int i = 0; i < remaining_c; ++i) {\n            conditions.push_back({crime, 1});\n        }\n    }\n\n    // Ensure product does not exceed 123\n    if (product > 123) {\n        // Adjust mi's to 1 to make product ≤123\n        for (auto &p : conditions) {\n            p.second = 1;\n        }\n        product = 1;\n    }\n\n    /* Output */\n\n    printf(\"%lld %d\\n\", n, int(conditions.size()));\n    for (auto p : conditions) {\n        printf(\"%c %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<char, int>> conditions;\n    int product = 1;\n\n    if (type == \"random\") {\n        // Generate c random conditions, ensuring total product of mi's ≤123\n        vector<char> crime_types;\n        for (int i = 0; i < 26; ++i) crime_types.push_back('A' + i);\n        shuffle(crime_types.begin(), crime_types.end());\n        int crimes_used = 0;\n        int max_crimes = min(c, 26);\n        for (int i = 0; i < c; ++i) {\n            char t;\n            if (crimes_used < max_crimes) {\n                t = crime_types[crimes_used];\n                crimes_used++;\n            } else {\n                // Reuse existing crime types\n                t = crime_types[rnd.next(0, max_crimes -1)];\n            }\n            int mi_max = 123 / max(1, product);\n            if (mi_max == 0) mi_max = 1;\n            int mi = rnd.next(1, mi_max);\n            product *= mi;\n            if (product > 123) mi = 1;\n            conditions.emplace_back(t, mi);\n        }\n    } else if (type == \"mi1\") {\n        // All mi's are 1\n        vector<char> crime_types;\n        for (int i = 0; i < 26; ++i) crime_types.push_back('A' + i);\n        for (int i = 0; i < c; ++i) {\n            char t = crime_types[i % 26];\n            int mi = 1;\n            conditions.emplace_back(t, mi);\n        }\n        product = 1;\n    } else if (type == \"max_c\") {\n        // c = 1000, repeating conditions\n        for (int i = 0; i < c; ++i) {\n            conditions.emplace_back('A', 1);\n        }\n        product = 1;\n    } else if (type == \"max_mi\") {\n        // mi = 123\n        conditions.emplace_back('A', 123);\n        product = 123;\n        // If c > 1, add mi=1 conditions\n        for (int i = 1; i < c; ++i) {\n            conditions.emplace_back('A', 1);\n        }\n    } else if (type == \"product123\") {\n        // mi's that multiply to 123, e.g., mi=3 and mi=41\n        conditions.emplace_back('A', 3);\n        conditions.emplace_back('B', 41);\n        product = 123;\n        // Add mi=1 conditions to reach c\n        int remaining_c = c - 2;\n        for (int i = 0; i < remaining_c; ++i) {\n            char t = 'C' + (i % 24); // From 'C' to 'Z'\n            conditions.emplace_back(t, 1);\n        }\n    } else if (type == \"multiple_mi\") {\n        // Multiple conditions for the same crime\n        char crime = 'A'; // same crime\n        vector<int> mi_values = {2, 3, 5};\n        product = 1;\n        for (int mi : mi_values) {\n            product *= mi;\n            conditions.push_back({crime, mi});\n        }\n        int remaining_c = c - mi_values.size();\n        for (int i = 0; i < remaining_c; ++i) {\n            conditions.push_back({crime, 1});\n        }\n    }\n\n    // Ensure product does not exceed 123\n    if (product > 123) {\n        // Adjust mi's to 1 to make product ≤123\n        for (auto &p : conditions) {\n            p.second = 1;\n        }\n        product = 1;\n    }\n\n    /* Output */\n\n    printf(\"%lld %d\\n\", n, int(conditions.size()));\n    for (auto p : conditions) {\n        printf(\"%c %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Edge cases with n = 0\n./gen -n 0 -c 0 -type mi1\n./gen -n 0 -c 10 -type mi1\n./gen -n 0 -c 100 -type mi1\n\n# Edge cases with c = 0\n./gen -n 10 -c 0 -type mi1\n\n# Small n and c\n./gen -n 5 -c 2 -type mi1\n./gen -n 5 -c 2 -type random\n./gen -n 5 -c 2 -type product123\n\n# Maximum n\n./gen -n 1000000000000000000 -c 1 -type mi1\n./gen -n 1000000000000000000 -c 1 -type max_mi\n./gen -n 1000000000000000000 -c 2 -type product123\n\n# Maximum c\n./gen -n 100 -c 1000 -type mi1\n./gen -n 1000 -c 1000 -type mi1\n\n# 'product123' type\n./gen -n 10 -c 2 -type product123\n./gen -n 100 -c 3 -type product123\n\n# Repeat conditions\n./gen -n 100 -c 1000 -type max_c\n\n# Zero crimes\n./gen -n 0 -c 1000 -type mi1\n\n# Multiple mi's for the same crime\n./gen -n 10 -c 5 -type multiple_mi\n./gen -n 1000000000000000000 -c 1000 -type multiple_mi\n\n# All mi =1, c=1000\n./gen -n 5000 -c 1000 -type mi1\n\n# All mi=1, c small\n./gen -n 5000 -c 10 -type mi1\n\n# Random types\n./gen -n 100 -c 10 -type random\n./gen -n 1000 -c 100 -type random\n./gen -n 1000000 -c 26 -type random\n\n# Edge of mi products\n./gen -n 1000 -c 2 -type product123\n\n# Max mi\n./gen -n 1000000000000000000 -c 1 -type max_mi\n./gen -n 1000000000000000000 -c 10 -type max_mi\n\n# c = 1000, mi=1, check that mi product is still valid\n./gen -n 1000 -c 1000 -type mi1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:07.317999",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "107/E",
      "title": "E. Darts",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integer n (1 ≤ n ≤ 500) — the number of photos on the wall. Then follow n lines describing the photos, each containing 8 single-space-separated integers (coordinates of 4 vertices): x1, y1, x2, y2, x3, y3, x4, y4. Each photo is a rectangle with a nonzero area. The coordinates are integers, not exceeding 104 by absolute value. The coordinates of the rectangle are given in either clockwise or counterclockwise order.",
      "output_spec": "OutputPrint the expected score of the throw. The answer will be accepted if it has absolute or relative error not exceeding 10 - 6.",
      "sample_tests": "ExamplesInputCopy10 0 0 2 2 2 2 0OutputCopy1.0000000000InputCopy1-1 0 0 1 1 0 0 -1OutputCopy1.0000000000InputCopy40 0 0 1 3 1 3 00 0 0 3 1 3 1 03 3 2 3 2 0 3 03 3 3 2 0 2 0 3OutputCopy1.5000000000InputCopy2-1 0 0 1 1 0 0 -10 0 1 1 2 0 1 -1OutputCopy1.1428571429",
      "description": "time limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains integer n (1 ≤ n ≤ 500) — the number of photos on the wall. Then follow n lines describing the photos, each containing 8 single-space-separated integers (coordinates of 4 vertices): x1, y1, x2, y2, x3, y3, x4, y4. Each photo is a rectangle with a nonzero area. The coordinates are integers, not exceeding 104 by absolute value. The coordinates of the rectangle are given in either clockwise or counterclockwise order.\n\nOutputPrint the expected score of the throw. The answer will be accepted if it has absolute or relative error not exceeding 10 - 6.\n\nInputCopy10 0 0 2 2 2 2 0OutputCopy1.0000000000InputCopy1-1 0 0 1 1 0 0 -1OutputCopy1.0000000000InputCopy40 0 0 1 3 1 3 00 0 0 3 1 3 1 03 3 2 3 2 0 3 03 3 3 2 0 2 0 3OutputCopy1.5000000000InputCopy2-1 0 0 1 1 0 0 -10 0 1 1 2 0 1 -1OutputCopy1.1428571429\n\nInputCopy10 0 0 2 2 2 2 0\n\nOutputCopy1.0000000000\n\nInputCopy1-1 0 0 1 1 0 0 -1\n\nOutputCopy1.0000000000\n\nInputCopy40 0 0 1 3 1 3 00 0 0 3 1 3 1 03 3 2 3 2 0 3 03 3 3 2 0 2 0 3\n\nOutputCopy1.5000000000\n\nInputCopy2-1 0 0 1 1 0 0 -10 0 1 1 2 0 1 -1\n\nOutputCopy1.1428571429",
      "solutions": [
        {
          "title": "Codeforces Beta Round #83 - Codeforces",
          "content": "Hi all,Today we would like to invite you to take part in round #83 inspired by the ACM practice sessions last year when Dima was visiting the German University in Cairo (GUC).We have composed the problemset about life in Egypt and the GUC. Hope you will like it :)The points for the problems in Div 1 & 2 will be: 500-1000-1500-2000-2500.The writers of the problems are Dima and myself.We would like to thank RAD, Connector, it4.kp, Delinur, and MikeMirzayanov, who greatly helped in preparing this contest.We wish you a pleasant, educational and successful contest!The editorial is under construction.Good luck to everyone!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2511",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 624
        },
        {
          "title": "Editorial: Codeforces Beta Round #83 - Codeforces",
          "content": "Palindromic TimesWriter: AtefIn this problem it was required to find next palindrome on a digital clock. Since the lowest unit of time used 1 minute, and there are only 24 * 60 minutes in a day, one could simply go through each minute starting from the time given in the input plus 1 minute, until finding a palindrome. If no palindrome is found till the end of the day 23: 59, the output should then be 00: 00.DatatypesWriter: AtefLet us call a pair of datatypes (a, b), where a < b, BAD if and only if there exists a number x where x fits in a bits but x * x does not fit in b bits. The following observation helps in finding a solution to the problem. The best candidate for the number x is the largest number fitting in a bits, which is x = 2a - 1. So for each ai it is enough to check that the smallest aj > ai has enough bits to contain x * x = (2a - 1) * (2a - 1), which has at most 2 * a bits. Sorting the numbers first was needed to traverse the list of datatypes once and ensuring the condition above.Dorm Water SupplyWriter: AtefThe problem describes a graph of houses as nodes and one-way pipes as edges. The problem states that the graph will contain 1 or more chains of nodes. The required is to find the start and end of every chain (consisting of more than 1 node, which caused many hacks). The other requirement was to find the weakest edge in each of the chains. This can be done by traversing (using Depth-First Search (DFS) for example) the graph from each un-visited node with no incoming edges. These nodes are the start of a chain. By keeping track of the minimum diameter so far, whenever the DFS reaches a node with no outgoing edges, it means that this node is the end of the current chain. After storing, in a list or vector, the tuples (start, end, minimum diameter), we sort these tuples by start index and print.Basketball TeamWriter: AtefThis problem is asking for the probability. Consider two sets of teams: the set of teams where Herr Wafa is the only student from his major and the set where at least one other student from Herr Wafa's major is present. These two sets don't intersect, so once we can compute the number of teams in the first set, A, and the number of teams in the second set, B, the answer would be B / (A + B).The number of teams in the first set is A = . We subtract one as Herr Wafa is guaranteed the spot, and the other (n - 1) spots are to be taken by the remaining students.Now let's count the number of teams having exactly k students from Herr Wafa's major apart from him. This number would be . Much like for the first set, (n - (k + 1)) students from the other majors should he selected, and none of them should be from Herr Wafa's major. The total number of teams where at least one other student is from Herr Wafa's major is therefore .The statements above describe the mathematical solution. It can be implemented in various ways.Crime ManagementWriter: AtefAt the first glance the upper limit for n being 1018 looks huge. But in fact, combined with the fact, that the answer should be output modulo 12345, it's should not scare you but rather hint that the problem has a DP approach.Like all DP problems the way to approach it is to split the problem into sub-problems and figure out what extra information should be carried between the sub-problems in order to combine them into the solution to the whole problem.Say, n is 11 and we solved the problem for the first 10 crimes. Clearly, just the number of ways to commit the first 10 crimes is not enough to solve the full problem with n = 11. The extra information to be carried along with the number of ways to commit n crimes and be innocent is the following: the number of ways to commit the first n crimes and have remaining multiplicities d1, d2, ...d26 respectively. The fact that the product of the multiplicities does not exceed 123 makes this a solvable task, as the set of all possible remainders contains not more elements than the product of multiplicities.To illustrate the idea from the first paragraph consider the first example case. It has two constraints, A with multiplicity 1 and B with multiplicity 2. The remainder of the number of crimes of type A is always zero, and committing crimes of type A may not yield any punishment. The remainder of the number of crimes of type B is zero or one. Therefore, while solving the sub-problems for the first n2 <  = n crimes, it's enough to keep track of only two numbers: \"number of ways to commit n2 crimes and be completely innocent\" and \"number of ways to commit n2 crimes and have committed one 'extra' crime of type B\".The key step to solve the problem now is to notice that each transition from the solution for the first k crimes to the solution for the first (k + 1) crimes can be seen as multiplying the vector of the current state by the transition matrix. Once all possible transitions are converted to the matrix form, the problem can be solved by raising the matrix into n-th power. Raising the matrix into large power can be done efficiently using matrix exponentiation: on some steps instead of computing Ai + 1 = Ai· A0 one can compute A2i = Ai· Ai.The last trick of this problem is to deal with multiple allowed multiplicities. If they were not allowed, the remainders per each crime type could have been kept with the modulo being equal to the multiplicity for this crime type. Moreover, if no crime type is listed more than once, the only valid final state is the state where the remainders are zero across all the crime types.With multiple allowed multiplicities, for each crime type the remainder modulo the product of the multiplicities of crimes for this type should be kept. (Strictly speaking, LCM is enough, but the constraints allow to use the plain product instead). Then, at the stage of printing the output, instead of treating the counter for the state with zero remainders as the only contributor to the output, one would have to iterate through all possible states and verify if each set of remainders conducts a valid final state.ArrangementWriter: AtefThe problem asks for finding the lexicographically n-th permutation satisfying the input constraints.The trick which confused many contestants, as well as a few authors and testers, is that instead of having the restrictions formulated in a way position[a[i]] < position[b[i]] the restrictions were element at position[a[i]] < element at position[b[i]].As in most problems where one has to output lexicographically n-th answer, the idea which can result in the solution which is passing the systests is to learn how to compute the number of solutions satisfying certain constraints.We will speak about how to compute the number of solutions in a bit, but first let's understand how having such function would lead to a solution. The very first observation is: if the total number of possible solutions is less than y - 2000, then the answer is \"The times have changed\". Once we have ensured that the solution exists it can be found using some of search.A simple approach would be the following: fix the first element of the resulting permutation to be 1 and count the number of possible solutions. If we do have enough to reach year y, then the first element must be 1, because there exists enough permutations with the first element being 1 to cover the years up to y, and any permutation where the first element is not 1 comes after any permutation where the first element is 1 in lexicographical order.And if fixing the first element to be 1 is not giving enough permutations, then we should decrease the \"desired\" year by the number of solutions with 1 being fixed as the first element and start looking for the solutions with 2 as the first element. The intuition is that there are not enough solutions with 1 being the first element, but once we acknowledge that and start looking for the other solutions --- with 2 as the first element, we are speaking not about arrangements for years 2001 and onwards but about the years 2001 + number of solutions with first element being one and onwards. Therefore instead of looking for the permutation with index y - 2001 with the first element being 1 we are looking for the permutation with the lower index, y - 2001 - number of solutions with first element being one, with the first element being 2 or higher.This process should be continued until all the elements are identified. Once the first index is fixed the known prefix would become a two-numbers prefix, and it will grow until all the permutation is constructed.Now to complete the solution we need to be able to compute the number of permutations which satisfy two restrictions: the input constraints and the added \"permutation has prefix P\" constraint. This problem can be solved using DP.For a given prefix P of length m, (n-m) other elements should be placed.Assume first that we are going to be iterating over all possible permutations with the given prefix using the brute force, but, instead of trying each possible value for the element at the next empty position i, we would be trying each possible position for the next not-yet-placed element i. This approach would work, but in O((n - m)!) time, which is obviously unfeasible. We need to find some way to reduce the state space and make it run faster.The key observation is the following: the state of the partially solved problem can be completely described by the bitmask of the currently occupied positions. This statement is nontrivial, as, from the first glance, it seems that apart from the unused positions mask, the information about the order, in which the already-placed elements are placed, is important. However it's not. Recall that all the constraints have the form of \"element at position ai is less than the element at position bi\". Provided the elements are placed in increasing order, in order to satisfy each constraint it's enough to confirm that, if the element to be placed is being put into position i, there is no such constraint in the input, that the element at position i should be less than the element at position j, while the element at position j has already been placed.This approach results in the DP with 2n - m states. Note that the next element to be placed can always be determined by the number of bits set in the mask and the prefix elements.The implementation of the above algorithm requires nontrivial coding, as the elements, belonging to the prefix, have to be treated differently compared to the elements which were placed by the DP. This is because the DP is enforcing that the elements are always added in the increasing order, which does not have to be the case for the elements conducting the prefix.DartsWriter: DimaBefore doing the coding let's do some math. The answer to this problem can be computed as the total area of all input rectangles / the area of the union of all input rectangles.One of the easy ways to understand it is the following. First notice that if all the rectangles are the same, the answer is always the number of rectangles. Now forget that the input figures are rectangles, assume any shape is  allowed, and then try to construct the example case given the union area s and the resulting expected score e. Notice that you can start with any shape constructed of non-intersecting figures with the total area s, and then add more figures on top of these, such that the contour of the union is the same as the contour of the first original figure of area s. Specifically, you'd need to add some figures of the total sum of t = s· (e - 1), but the number doesn't matter here. The key is that the placement of these added figures doesn't change the result, and therefore the answer will always depend only on the total area of the input figures and the area of their union.Now back to the rectangles. Computing the sum of the ares of the rectangles is easy. The hard part is to compute the area of their union in better than O(n3). Note that the union may have multiple disjoins components, it does not have to be convex, it may have holes and, in short, does not have to be easy to describe.One of the relatively-easy-to-implement solutions is the following. We will be computing the are of the union of the rectangles using the trapezoid method. Note that for the trapezoid method the order, in which the segments of the figure are provided, doesn't matter. Therefore, in order to use the trapezoid method, we \"only\" need to find all non-vertical directed segments which are the part of the contour of the union.Let me elaborate a bit more on the previous paragraph. We don't need vertical segments, because their contribution to the resulting area is zero in the trapezoid method of computing the area. The direction of the segment is the important part though. It's not enough to know that the segment (x1, x2) - (y1, y2) belongs to the contour of the union. It's important to know whether the area of the union if the part of the plane above it or below it.Imagine the test case where the union of all the rectangles is a big rectangle with a hole inside it. In this case we need to know that the segments, describing the outer part of the union, should contribute to the area with the \"plus\" sign, while the segments describing the inner hole should be considered with the \"minus\" sign.Specifically, for the trapezoid method, the sign of x2 - x1 would be describing the direction of this segment: for example, if x1 < x2 than the segment is \"positive\" and if x1 < x2 it's \"negative\". To find all such segments let's consider all distinct  non-vertical lines. There are at most 4n such lines in the input. Each segment of the final contour of the union should lay on one of those lines, so it's enough to focus on the lines only, consider them independently from each other (but make sure to process each distinct line only once!) and for each line construct a set of the positive and negative segments.Let's formulate the rules under which a part of the line would be a positive or negative segment. They turn out to be very simple:1) If some segment (x1, y1) - (x2, y2) is part of the border of one of the input rectangles, then it's a \"positive\" segment if this input rectangle lays below this segment and a \"negative\" segment if this rectangle lays above this segment.2) If some segment (x1, y1) - (x2, y2) belongs to the intersection of the borders of two different input rectangles, with one being a \"positive\" one and one being a \"negative\" one, then this segment does not belong to the contour.3) If some segment (x1, y1) - (x2, y2) is being covered by another rectangle, then it does not belong to the contour. \"Covered\" means laying completely inside some other rectangle, the border cases are covered above.The easy way of constructing all the segments could look as the following pseudo-code:for each distinct non-vertical line  create the array of markers. the marker holds the x coordinate and one of four events: { start union area below, end union area below, start union area above, end union area above }.  iterate through all the input rectangles    if this rectangle has one segment laying on the line under consideration       add two markers: one for start and one for end. whether the markers are above or below is determined by the position of this rectangle with respect to this line    else if this rectangle intersects this line      find the intersection points and add four markers: { start area below } and { start area above } for the left intersection point and { end area below } and { end area above } for the right intersection point  sort the array of markers by the x coordinate of the events  traverse the array of markers. if some segment (x1..x2) is being reported as having the union area only above it or only below it, it becomes the negative or positive segment of the union respectively.At this point one could run some sort of DFS to merge the segments into the connected loops, but this is actually unnecessary to compute the area using the trapezoid method. Just summing up (x2 - x1)· (y1 + y2) / 2 for all the segments does the trick, and it would automatically ensure that the outer contours are taken with the positive sign and the inner contours are taken with the negative sign.The solution described above runs in O(n2· logn) : for each of O(n) lines we have at most O(n) intersections, which should be sorted in O(n· logn) inside the loop over all the lines.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/2514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 16423
        }
      ],
      "code_examples": [
        {
          "title": "Editorial: Codeforces Beta Round #83 - Codeforces - Code 1",
          "code": "52\n\n474 24 24 954 9 234 474 114 24 114 234 24 114 114 234 9 9 24 9 54 234 54 9 954 474 9 54 54 54 234 9 114 24 54 114 954 954 474 24 54 54 234 234 474 474 24 114 9 954 954 954 474in the above case 9 is there but no 18......24 is there but no 48...hence the output should be \"YES\"but the correct answer for the case is \"NO\"plz explain why is so ??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/2514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string line = inf.readLine();\n        ensuref(!line.empty(), \"Line is empty\");\n        ensuref(line[0] != ' ', \"Line starts with space\");\n        ensuref(line.back() != ' ', \"Line ends with space\");\n        int idx = 0;\n        int nTokens = 0;\n        vector<int> nums;\n        while (idx < line.size()) {\n            // Parse integer\n            bool negative = false;\n            if (line[idx] == '-') {\n                negative = true;\n                ++idx;\n                ensuref(idx < line.size(), \"Token starting with '-' is incomplete\");\n            }\n            ensuref(isdigit(line[idx]), \"Expected digit, found '%c'\", line[idx]);\n            int num = 0;\n            while (idx < line.size() && isdigit(line[idx])) {\n                num = num * 10 + (line[idx] - '0');\n                ++idx;\n            }\n            if (negative) num = -num;\n            ensuref(abs(num) <= 10000, \"Coordinate value out of range: %d\", num);\n            nums.push_back(num);\n            ++nTokens;\n            ensuref(nTokens <= 8, \"Line contains more than 8 numbers\");\n            if (nTokens < 8) {\n                ensuref(idx < line.size(), \"Line ended prematurely after token %d\", nTokens);\n                ensuref(line[idx] == ' ', \"Expected single space after token %d\", nTokens);\n                ++idx;\n                ensuref(idx < line.size(), \"Line ended prematurely after space\");\n                ensuref(line[idx] != ' ', \"Multiple spaces detected after token %d\", nTokens);\n            } else if (nTokens ==8) {\n                // Ensure we're at the end of the line\n                ensuref(idx == line.size(), \"Extra characters after 8th token\");\n            }\n        }\n        ensuref(nTokens == 8, \"Line contains less than 8 numbers\");\n\n        int x[4], y[4];\n        for (int j = 0; j < 4; j++) {\n            x[j] = nums[j * 2];\n            y[j] = nums[j * 2 + 1];\n        }\n        // Now check that the points correspond to a rectangle\n        // Compute dx[i], dy[i], len2[i]\n        int dx[4], dy[4];\n        int len2[4];\n        for (int j = 0; j < 4; j++) {\n            int next = (j + 1) % 4;\n            dx[j] = x[next] - x[j];\n            dy[j] = y[next] - y[j];\n            len2[j] = dx[j] * dx[j] + dy[j] * dy[j];\n        }\n        // Check that opposite sides are equal\n        ensuref(len2[0] == len2[2], \"Opposite sides are not equal in length\");\n        ensuref(len2[1] == len2[3], \"Opposite sides are not equal in length\");\n        // Ensure side lengths are non-zero\n        ensuref(len2[0] > 0, \"Side length is zero\");\n        ensuref(len2[1] > 0, \"Side length is zero\");\n        // Check that adjacent sides are perpendicular\n        for (int j = 0; j < 4; j++) {\n            int next = (j + 1) % 4;\n            int dp = dx[j] * dx[next] + dy[j] * dy[next];\n            ensuref(dp == 0, \"Adjacent sides are not perpendicular\");\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string line = inf.readLine();\n        ensuref(!line.empty(), \"Line is empty\");\n        ensuref(line[0] != ' ', \"Line starts with space\");\n        ensuref(line.back() != ' ', \"Line ends with space\");\n        int idx = 0;\n        int nTokens = 0;\n        vector<int> nums;\n        while (idx < line.size()) {\n            // Parse integer\n            bool negative = false;\n            if (line[idx] == '-') {\n                negative = true;\n                ++idx;\n                ensuref(idx < line.size(), \"Token starting with '-' is incomplete\");\n            }\n            ensuref(isdigit(line[idx]), \"Expected digit, found '%c'\", line[idx]);\n            int num = 0;\n            while (idx < line.size() && isdigit(line[idx])) {\n                num = num * 10 + (line[idx] - '0');\n                ++idx;\n            }\n            if (negative) num = -num;\n            ensuref(abs(num) <= 10000, \"Coordinate value out of range: %d\", num);\n            nums.push_back(num);\n            ++nTokens;\n            ensuref(nTokens <= 8, \"Line contains more than 8 numbers\");\n            if (nTokens < 8) {\n                ensuref(idx < line.size(), \"Line ended prematurely after token %d\", nTokens);\n                ensuref(line[idx] == ' ', \"Expected single space after token %d\", nTokens);\n                ++idx;\n                ensuref(idx < line.size(), \"Line ended prematurely after space\");\n                ensuref(line[idx] != ' ', \"Multiple spaces detected after token %d\", nTokens);\n            } else if (nTokens ==8) {\n                // Ensure we're at the end of the line\n                ensuref(idx == line.size(), \"Extra characters after 8th token\");\n            }\n        }\n        ensuref(nTokens == 8, \"Line contains less than 8 numbers\");\n\n        int x[4], y[4];\n        for (int j = 0; j < 4; j++) {\n            x[j] = nums[j * 2];\n            y[j] = nums[j * 2 + 1];\n        }\n        // Now check that the points correspond to a rectangle\n        // Compute dx[i], dy[i], len2[i]\n        int dx[4], dy[4];\n        int len2[4];\n        for (int j = 0; j < 4; j++) {\n            int next = (j + 1) % 4;\n            dx[j] = x[next] - x[j];\n            dy[j] = y[next] - y[j];\n            len2[j] = dx[j] * dx[j] + dy[j] * dy[j];\n        }\n        // Check that opposite sides are equal\n        ensuref(len2[0] == len2[2], \"Opposite sides are not equal in length\");\n        ensuref(len2[1] == len2[3], \"Opposite sides are not equal in length\");\n        // Ensure side lengths are non-zero\n        ensuref(len2[0] > 0, \"Side length is zero\");\n        ensuref(len2[1] > 0, \"Side length is zero\");\n        // Check that adjacent sides are perpendicular\n        for (int j = 0; j < 4; j++) {\n            int next = (j + 1) % 4;\n            int dp = dx[j] * dx[next] + dy[j] * dy[next];\n            ensuref(dp == 0, \"Adjacent sides are not perpendicular\");\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string line = inf.readLine();\n        ensuref(!line.empty(), \"Line is empty\");\n        ensuref(line[0] != ' ', \"Line starts with space\");\n        ensuref(line.back() != ' ', \"Line ends with space\");\n        int idx = 0;\n        int nTokens = 0;\n        vector<int> nums;\n        while (idx < line.size()) {\n            // Parse integer\n            bool negative = false;\n            if (line[idx] == '-') {\n                negative = true;\n                ++idx;\n                ensuref(idx < line.size(), \"Token starting with '-' is incomplete\");\n            }\n            ensuref(isdigit(line[idx]), \"Expected digit, found '%c'\", line[idx]);\n            int num = 0;\n            while (idx < line.size() && isdigit(line[idx])) {\n                num = num * 10 + (line[idx] - '0');\n                ++idx;\n            }\n            if (negative) num = -num;\n            ensuref(abs(num) <= 10000, \"Coordinate value out of range: %d\", num);\n            nums.push_back(num);\n            ++nTokens;\n            ensuref(nTokens <= 8, \"Line contains more than 8 numbers\");\n            if (nTokens < 8) {\n                ensuref(idx < line.size(), \"Line ended prematurely after token %d\", nTokens);\n                ensuref(line[idx] == ' ', \"Expected single space after token %d\", nTokens);\n                ++idx;\n                ensuref(idx < line.size(), \"Line ended prematurely after space\");\n                ensuref(line[idx] != ' ', \"Multiple spaces detected after token %d\", nTokens);\n            } else if (nTokens ==8) {\n                // Ensure we're at the end of the line\n                ensuref(idx == line.size(), \"Extra characters after 8th token\");\n            }\n        }\n        ensuref(nTokens == 8, \"Line contains less than 8 numbers\");\n\n        int x[4], y[4];\n        for (int j = 0; j < 4; j++) {\n            x[j] = nums[j * 2];\n            y[j] = nums[j * 2 + 1];\n        }\n        // Now check that the points correspond to a rectangle\n        // Compute dx[i], dy[i], len2[i]\n        int dx[4], dy[4];\n        int len2[4];\n        for (int j = 0; j < 4; j++) {\n            int next = (j + 1) % 4;\n            dx[j] = x[next] - x[j];\n            dy[j] = y[next] - y[j];\n            len2[j] = dx[j] * dx[j] + dy[j] * dy[j];\n        }\n        // Check that opposite sides are equal\n        ensuref(len2[0] == len2[2], \"Opposite sides are not equal in length\");\n        ensuref(len2[1] == len2[3], \"Opposite sides are not equal in length\");\n        // Ensure side lengths are non-zero\n        ensuref(len2[0] > 0, \"Side length is zero\");\n        ensuref(len2[1] > 0, \"Side length is zero\");\n        // Check that adjacent sides are perpendicular\n        for (int j = 0; j < 4; j++) {\n            int next = (j + 1) % 4;\n            int dp = dx[j] * dx[next] + dy[j] * dy[next];\n            ensuref(dp == 0, \"Adjacent sides are not perpendicular\");\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateRectangle(int cx, int cy, int w, int h, double angle, array<int,8>& rect, bool randomOrder) {\n    double theta = angle;\n    double cos_theta = cos(theta);\n    double sin_theta = sin(theta);\n\n    double dx1 = w/2.0 * cos_theta;\n    double dy1 = w/2.0 * sin_theta;\n    double dx2 = -h/2.0 * sin_theta;\n    double dy2 = h/2.0 * cos_theta;\n\n    vector<pair<double,double>> points(4);\n    points[0] = make_pair(cx + dx1 + dx2, cy + dy1 + dy2);\n    points[1] = make_pair(cx + dx1 - dx2, cy + dy1 - dy2);\n    points[2] = make_pair(cx - dx1 - dx2, cy - dy1 - dy2);\n    points[3] = make_pair(cx - dx1 + dx2, cy - dy1 + dy2);\n\n    // Convert to integers\n    vector<pair<int,int>> int_points(4);\n    for(int i = 0; i < 4; ++i) {\n        int x = (int)round(points[i].first);\n        int y = (int)round(points[i].second);\n        int_points[i] = make_pair(x, y);\n    }\n\n    // Optionally randomize order of points\n    if (randomOrder) {\n        shuffle(int_points.begin(), int_points.end());\n    } else {\n        // Ensure order is either CW or CCW\n        // Let's compute center of mass\n        double cx = 0, cy = 0;\n        for(auto p : int_points) {\n            cx += p.first;\n            cy += p.second;\n        }\n        cx /= 4;\n        cy /= 4;\n        // Compute angles from center\n        vector<pair<double,int>> angles;\n        for(int i = 0; i < 4; ++i) {\n            double angle = atan2(int_points[i].second - cy, int_points[i].first - cx);\n            angles.emplace_back(angle, i);\n        }\n        // Sort points by angle\n        sort(angles.begin(), angles.end());\n        // Build rect\n        for(int i = 0; i < 4; ++i) {\n            int idx = angles[i].second;\n            rect[2*i] = int_points[idx].first;\n            rect[2*i+1] = int_points[idx].second;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxc = opt<int>(\"maxc\", 10000);\n\n    vector<array<int, 8>> rectangles;  // Each rectangle is 8 integers\n\n    if (type == \"axis-aligned-non-overlap\") {\n        // Generate n axis-aligned rectangles that do not overlap\n        int side = ceil(sqrt(n));\n        int size = maxc / side / 2;\n        int x = -maxc + size, y = -maxc + size;\n        for(int i = 0; i < n; ++i) {\n            int x1 = x, y1 = y;\n            int x2 = x, y2 = y + size;\n            int x3 = x + size, y3 = y + size;\n            int x4 = x + size, y4 = y;\n            rectangles.push_back({x1,y1, x2,y2, x3,y3, x4,y4});\n\n            x += size * 2;\n            if (x > maxc - size) {\n                x = -maxc + size;\n                y += size * 2;\n            }\n        }\n    } else if (type == \"axis-aligned-overlap\") {\n        // Generate n axis-aligned rectangles that overlap at the center\n        int size = maxc / 4;\n        for(int i = 0; i < n; ++i) {\n            int x_offset = rnd.next(-size, size);\n            int y_offset = rnd.next(-size, size);\n            int s = rnd.next(1, size);\n            int x1 = x_offset - s, y1 = y_offset - s;\n            int x2 = x_offset - s, y2 = y_offset + s;\n            int x3 = x_offset + s, y3 = y_offset + s;\n            int x4 = x_offset + s, y4 = y_offset - s;\n            rectangles.push_back({x1,y1, x2,y2, x3,y3, x4,y4});\n        }\n    } else if (type == \"rotated\") {\n        // Generate n rotated rectangles\n        for(int i = 0; i < n; ++i) {\n            int cx = rnd.next(-maxc/2, maxc/2);\n            int cy = rnd.next(-maxc/2, maxc/2);\n            int w = rnd.next(1, maxc/4);\n            int h = rnd.next(1, maxc/4);\n            double angle = rnd.next(0.0, M_PI * 2);\n            array<int,8> rect;\n            generateRectangle(cx, cy, w, h, angle, rect, false);\n            rectangles.push_back(rect);\n        }\n    } else if (type == \"full-overlap\") {\n        // All rectangles are exactly the same\n        int size = maxc / 2;\n        int cx = 0, cy = 0;\n        int w = size, h = size;\n        double angle = 0;  // Axis-aligned rectangle\n        array<int,8> rect;\n        generateRectangle(cx, cy, w, h, angle, rect, false);\n        for(int i = 0; i < n; ++i) {\n            rectangles.push_back(rect);\n        }\n    } else if (type == \"random\") {\n        // Generate n random rectangles\n        for(int i = 0; i < n; ++i) {\n            int cx = rnd.next(-maxc/2, maxc/2);\n            int cy = rnd.next(-maxc/2, maxc/2);\n            int w = rnd.next(1, maxc/4);\n            int h = rnd.next(1, maxc/4);\n            double angle = rnd.next(0.0, M_PI * 2);\n            array<int,8> rect;\n            generateRectangle(cx, cy, w, h, angle, rect, true);  // Randomize order\n            rectangles.push_back(rect);\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output n lines of rectangles\n    for(auto &rect : rectangles) {\n        for(int i=0; i<8; ++i) {\n            printf(\"%d%c\", rect[i], (i==7)?'\\n':' ');\n        }\n    }\n\n    return 0;\n}\n\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateRectangle(int cx, int cy, int w, int h, double angle, array<int,8>& rect, bool randomOrder) {\n    double theta = angle;\n    double cos_theta = cos(theta);\n    double sin_theta = sin(theta);\n\n    double dx1 = w/2.0 * cos_theta;\n    double dy1 = w/2.0 * sin_theta;\n    double dx2 = -h/2.0 * sin_theta;\n    double dy2 = h/2.0 * cos_theta;\n\n    vector<pair<double,double>> points(4);\n    points[0] = make_pair(cx + dx1 + dx2, cy + dy1 + dy2);\n    points[1] = make_pair(cx + dx1 - dx2, cy + dy1 - dy2);\n    points[2] = make_pair(cx - dx1 - dx2, cy - dy1 - dy2);\n    points[3] = make_pair(cx - dx1 + dx2, cy - dy1 + dy2);\n\n    // Convert to integers\n    vector<pair<int,int>> int_points(4);\n    for(int i = 0; i < 4; ++i) {\n        int x = (int)round(points[i].first);\n        int y = (int)round(points[i].second);\n        int_points[i] = make_pair(x, y);\n    }\n\n    // Optionally randomize order of points\n    if (randomOrder) {\n        shuffle(int_points.begin(), int_points.end());\n    } else {\n        // Ensure order is either CW or CCW\n        // Let's compute center of mass\n        double cx = 0, cy = 0;\n        for(auto p : int_points) {\n            cx += p.first;\n            cy += p.second;\n        }\n        cx /= 4;\n        cy /= 4;\n        // Compute angles from center\n        vector<pair<double,int>> angles;\n        for(int i = 0; i < 4; ++i) {\n            double angle = atan2(int_points[i].second - cy, int_points[i].first - cx);\n            angles.emplace_back(angle, i);\n        }\n        // Sort points by angle\n        sort(angles.begin(), angles.end());\n        // Build rect\n        for(int i = 0; i < 4; ++i) {\n            int idx = angles[i].second;\n            rect[2*i] = int_points[idx].first;\n            rect[2*i+1] = int_points[idx].second;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxc = opt<int>(\"maxc\", 10000);\n\n    vector<array<int, 8>> rectangles;  // Each rectangle is 8 integers\n\n    if (type == \"axis-aligned-non-overlap\") {\n        // Generate n axis-aligned rectangles that do not overlap\n        int side = ceil(sqrt(n));\n        int size = maxc / side / 2;\n        int x = -maxc + size, y = -maxc + size;\n        for(int i = 0; i < n; ++i) {\n            int x1 = x, y1 = y;\n            int x2 = x, y2 = y + size;\n            int x3 = x + size, y3 = y + size;\n            int x4 = x + size, y4 = y;\n            rectangles.push_back({x1,y1, x2,y2, x3,y3, x4,y4});\n\n            x += size * 2;\n            if (x > maxc - size) {\n                x = -maxc + size;\n                y += size * 2;\n            }\n        }\n    } else if (type == \"axis-aligned-overlap\") {\n        // Generate n axis-aligned rectangles that overlap at the center\n        int size = maxc / 4;\n        for(int i = 0; i < n; ++i) {\n            int x_offset = rnd.next(-size, size);\n            int y_offset = rnd.next(-size, size);\n            int s = rnd.next(1, size);\n            int x1 = x_offset - s, y1 = y_offset - s;\n            int x2 = x_offset - s, y2 = y_offset + s;\n            int x3 = x_offset + s, y3 = y_offset + s;\n            int x4 = x_offset + s, y4 = y_offset - s;\n            rectangles.push_back({x1,y1, x2,y2, x3,y3, x4,y4});\n        }\n    } else if (type == \"rotated\") {\n        // Generate n rotated rectangles\n        for(int i = 0; i < n; ++i) {\n            int cx = rnd.next(-maxc/2, maxc/2);\n            int cy = rnd.next(-maxc/2, maxc/2);\n            int w = rnd.next(1, maxc/4);\n            int h = rnd.next(1, maxc/4);\n            double angle = rnd.next(0.0, M_PI * 2);\n            array<int,8> rect;\n            generateRectangle(cx, cy, w, h, angle, rect, false);\n            rectangles.push_back(rect);\n        }\n    } else if (type == \"full-overlap\") {\n        // All rectangles are exactly the same\n        int size = maxc / 2;\n        int cx = 0, cy = 0;\n        int w = size, h = size;\n        double angle = 0;  // Axis-aligned rectangle\n        array<int,8> rect;\n        generateRectangle(cx, cy, w, h, angle, rect, false);\n        for(int i = 0; i < n; ++i) {\n            rectangles.push_back(rect);\n        }\n    } else if (type == \"random\") {\n        // Generate n random rectangles\n        for(int i = 0; i < n; ++i) {\n            int cx = rnd.next(-maxc/2, maxc/2);\n            int cy = rnd.next(-maxc/2, maxc/2);\n            int w = rnd.next(1, maxc/4);\n            int h = rnd.next(1, maxc/4);\n            double angle = rnd.next(0.0, M_PI * 2);\n            array<int,8> rect;\n            generateRectangle(cx, cy, w, h, angle, rect, true);  // Randomize order\n            rectangles.push_back(rect);\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output n lines of rectangles\n    for(auto &rect : rectangles) {\n        for(int i=0; i<8; ++i) {\n            printf(\"%d%c\", rect[i], (i==7)?'\\n':' ');\n        }\n    }\n\n    return 0;\n}\n\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type full-overlap\n./gen -n 1 -type axis-aligned-non-overlap\n./gen -n 1 -type axis-aligned-overlap\n./gen -n 1 -type rotated\n./gen -n 1 -type random\n\n./gen -n 2 -type axis-aligned-non-overlap\n./gen -n 2 -type axis-aligned-overlap\n./gen -n 2 -type rotated\n./gen -n 2 -type full-overlap\n./gen -n 2 -type random\n\n./gen -n 10 -type axis-aligned-non-overlap\n./gen -n 10 -type axis-aligned-overlap\n./gen -n 10 -type rotated\n./gen -n 10 -type full-overlap\n./gen -n 10 -type random\n\n./gen -n 50 -type axis-aligned-non-overlap\n./gen -n 50 -type axis-aligned-overlap\n./gen -n 50 -type rotated\n./gen -n 50 -type full-overlap\n./gen -n 50 -type random\n\n./gen -n 100 -type axis-aligned-non-overlap\n./gen -n 100 -type axis-aligned-overlap\n./gen -n 100 -type rotated\n./gen -n 100 -type full-overlap\n./gen -n 100 -type random\n\n./gen -n 200 -type axis-aligned-non-overlap\n./gen -n 200 -type axis-aligned-overlap\n./gen -n 200 -type rotated\n./gen -n 200 -type full-overlap\n./gen -n 200 -type random\n\n./gen -n 500 -type axis-aligned-non-overlap\n./gen -n 500 -type axis-aligned-overlap\n./gen -n 500 -type rotated\n./gen -n 500 -type full-overlap\n./gen -n 500 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:09.285490",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/A",
      "title": "A. Find a Number",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two positive integers dd and ss (1≤d≤500,1≤s≤50001≤d≤500,1≤s≤5000) separated by space.",
      "output_spec": "OutputPrint the required number or -1 if it doesn't exist.",
      "sample_tests": "ExamplesInputСкопировать13 50OutputСкопировать699998InputСкопировать61 2OutputСкопировать1000000000000000000000000000001InputСкопировать15 50OutputСкопировать-1",
      "description": "A. Find a Number\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two positive integers dd and ss (1≤d≤500,1≤s≤50001≤d≤500,1≤s≤5000) separated by space.\n\nOutputPrint the required number or -1 if it doesn't exist.\n\nInputСкопировать13 50OutputСкопировать699998InputСкопировать61 2OutputСкопировать1000000000000000000000000000001InputСкопировать15 50OutputСкопировать-1\n\nInputСкопировать13 50\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать699998\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать61 2\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать1000000000000000000000000000001\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать15 50\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать-1\n\nOutputСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces",
          "content": "Добрый день!16-го октября завершился Четвертьфинал Южного подрегиона NEERC (Northern Eurasia) чемпионата ICPC. В Саратове встретились 72 команды, многие из которых получили приглашение по результатам квалификационного этапа.Уже в субботу, 20-го октября в 11:05 (МСК) состоится онлайн-зеркало 2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды).Надеюсь, вам понравятся задачи. Председателем жюри этого соревнования являюсь я, а над задачами работал дружный коллектив жюри экс-участников чемпионата из Саратовского ГУ и иногородние члены жюри. Спасибо всем!Приглашаю команды ICPC к участию и просто индивидуальных участников соревнований Codeforces принять участие!Конечно, соревнование будет нерейтинговое.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62570",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 759
        },
        {
          "title": "Solution to problem M. Algoland and Berland of 2018-2019 ICPC, NEERC - Codeforces",
          "content": "Today, I solved a beautiful problem from the NEERC Subregional Contest: Problem M. Since I didn't find an editorial nor a solution in the comments, I decided to write this blog about my solution. For a visualization of my solution see: Visualization of the program The problem boils down to constructing a spanning tree of a 2D point set with certain constraints. No three points in the point set are collinear. The points have two colors: red and blue. There is at least one blue and one red point. The constraints on the spanning tree are: Edges of the spanning tree can only intersect at the ends, if they are drawn as line segments. Edges of the spanning tree can only connect points with different colors. For each blue point, the degree of the point in the spanning tree should be equal to riri. The constraints on riri are nice: 1≤ri≤# of red points1≤ri≤# of red points. And ∑ri=n−1∑ri=n−1, which is of course needed if the final graph needs to be a tree. It turns out that these conditions are strong enough that it is always possible to construct a spanning tree!Let's prove this by induction on the size of the point set, nn.Base case n=2n=2Because there is at least one red and one blue point, the smallest case is n=2n=2: one red and one blue point. Because of the constraint ∑ri=n−1=1∑ri=n−1=1, this means that the degree of the only blue point left is 1. The trivial solution is to connect the blue and the red point.Induction step n>2n>2:Now the hard part; Let's assume it is possible to make a spanning tree for all 2≤k<n2≤k<n. Now we are given a point set with nn points, how do we construct the spanning tree for it? First, let's sort the points on their x-coordinate. We use the y-coordinate as a tiebreaker. Let's do casework on the colors of the leftmost and rightmost point:Case 1: extreme points have different colorsLet's analyze the convex hull of the point set. As these two points both lie on the convex hull, the convex hull contains at least one red and one blue point. Certainly, there must be an adjacent pair of points on the hull with different colors. Let's connect these with an edge. If riri of the blue point is 1, we delete this point. Else we delete the red point, and lower riri by one. Notice that both the ∑ri∑ri and nn decreased by one, so the resulting riri satisfy all constraints. It can also be verified that at least one red and blue point remain, with some casework. So we can use the induction hypothesis on this smaller point set, which gives us a spanning tree. Could our newly added edge intersect with an existing edge? No, because the edge lies on the convex hull. So in this case we are done.For the last two cases, where both extreme points have the same color, we will use a different technique. Let's give each point a weight, For blue points, we set wi=−1+riwi=−1+ri. For red points we set wi=−1wi=−1. If the sum of weights is -1, that means ∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1. So if we could somehow split the point set with a vertical line through some point, such that the left and right halve both have the sum of weights equal to -1, we could use the induction hypothesis. For this to work we need both sides to have at least one point of each color. Case 2: extreme points are both blueLet's look at the prefix sums of the weights of the point set in sorted order. So the prefix sum is pk=∑i<kwipk=∑i<kwi, where the points are labeled from left to right. Because the total prefix sum is −1−1, and the prefix sum starts at 00, it must cross from nonnegative to negative at some point. Because the weights of all blue points are nonnegative the only place this can happen is at a red point. Because the weight of a red point is −1−1, it will cross from 00 to −1−1, and this is exactly what we wanted, a sum of weight equal to −1−1. Now we can draw a vertical line through this red point, and by the induction hypothesis construct two spanning trees, one containing all points to the left and the mid point, and one with all points to the right and the middle red point. Note that because the red point can't be one of the extreme points, the two point sets are definitely smaller than the initial point set. Since these spanning trees exist in two disjoint regions, they don't intersect. And they connect at the midpoint, so their union is a valid spanning tree of the whole point set! To ensure the regions are disjoint even if there are ties in x-coordinates, we tilt the splitting line slighly.Case 3: extreme points are both redWe do exactly the same, looking for a prefix sum which is equal to −1−1. Now it turns out this is sometimes not possible. But by similar (but inverted) logic as in Case 2, there exists a blue point, such that the prefix sum goes from negative to nonnegative. We again make a vertical splitting line through this point, but now we modify the riri we will use for this blue midpoint in the left and right subproblem. We choose these new riri's such that the sum of weights in the left and right point sets is again −1−1. Then we apply the induction hypothesis to get two valid spanning trees of the left and right side. And the union of these spanning trees will be a valid spanning tree for the entire point set. This concludes the proof.This proof is constructive, so for actually generating a spanning tree we can follow the induction logic backwards until the spanning tree is fully constructed. The easiest way to code this is to make a recursive function that constructs a spanning tree for the point set it's given. Based on the colors of the outermost points we either calculate a convex hull or prefix sums from left to right and call the function recursively. We only recurse nn times, and the complexity per call can be made O(nlogn)O(nlog⁡n), so this gives O(n2logn)O(n2log⁡n). But if we additionally presort the points and ensure the point set stays sorted in the recursive calls, the convex hull calculation can also be done in linear time, resulting in O(n2)O(n2) running time. Although this is not needed, I think this approach can be optimized further by using Smart divide and conquer and Decremental convex hull, and some modifications to quickly find two oppositely colored adjacent points on the convex hull. This would give a recursive formula for the time complexity of T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log(n))=O(nlog2n)T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log⁡(n))=O(nlog2⁡n), but this is definitely not needed to get AC.My code can be found here: submission",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/105126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6546
        }
      ],
      "code_examples": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 1",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 2",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 3",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 4",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 5",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 6",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int d = inf.readInt(1, 500, \"d\");\n    inf.readSpace();\n    int s = inf.readInt(1, 5000, \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int d = inf.readInt(1, 500, \"d\");\n    inf.readSpace();\n    int s = inf.readInt(1, 5000, \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int d = inf.readInt(1, 500, \"d\");\n    inf.readSpace();\n    int s = inf.readInt(1, 5000, \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int d = opt<int>(\"d\", -1);\n    int s = opt<int>(\"s\", -1);\n\n    if (type == \"small\") {\n        // Generate small d and s\n        if (d == -1) d = rnd.next(1, 10);\n        if (s == -1) s = rnd.next(1, 10);\n    } else if (type == \"large_sum\") {\n        // Large s\n        if (d == -1) d = rnd.next(1, 500);\n        s = 5000;\n    } else if (type == \"large_d\") {\n        // Large d\n        d = 500;\n        if (s == -1) s = rnd.next(1, 5000);\n    } else if (type == \"no_solution\") {\n        // Generate a case where no solution exists\n        if (d == -1) d = rnd.next(1, 500);\n        if (s == -1) s = rnd.next(1, 5000);\n        // Let's use the sample input where no solution exists\n        d = 15;\n        s = 50;\n    } else if (type == \"random\") {\n        // Random values within constraints\n        if (d == -1) d = rnd.next(1, 500);\n        if (s == -1) s = rnd.next(1, 5000);\n    } else {\n        cerr << \"Invalid type\" << endl;\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", d, s);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int d = opt<int>(\"d\", -1);\n    int s = opt<int>(\"s\", -1);\n\n    if (type == \"small\") {\n        // Generate small d and s\n        if (d == -1) d = rnd.next(1, 10);\n        if (s == -1) s = rnd.next(1, 10);\n    } else if (type == \"large_sum\") {\n        // Large s\n        if (d == -1) d = rnd.next(1, 500);\n        s = 5000;\n    } else if (type == \"large_d\") {\n        // Large d\n        d = 500;\n        if (s == -1) s = rnd.next(1, 5000);\n    } else if (type == \"no_solution\") {\n        // Generate a case where no solution exists\n        if (d == -1) d = rnd.next(1, 500);\n        if (s == -1) s = rnd.next(1, 5000);\n        // Let's use the sample input where no solution exists\n        d = 15;\n        s = 50;\n    } else if (type == \"random\") {\n        // Random values within constraints\n        if (d == -1) d = rnd.next(1, 500);\n        if (s == -1) s = rnd.next(1, 5000);\n    } else {\n        cerr << \"Invalid type\" << endl;\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", d, s);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Smallest possible input\n./gen -type small -d 1 -s 1\n\n# Small inputs\n./gen -type small\n./gen -type small -d 2 -s 3\n./gen -type small -d 10 -s 10\n./gen -type small -d 5 -s 5\n\n# Maximum sum, small d\n./gen -type large_sum -d 1\n./gen -type large_sum -d 2\n./gen -type large_sum -d 10\n\n# Maximum sum, maximum d\n./gen -type large_sum -d 500\n\n# Maximum d, minimum s\n./gen -type random -d 500 -s 1\n./gen -type random -d 500 -s 10\n\n# Random cases with maximum d and s\n./gen -type random -d 500 -s 5000\n\n# Random cases\n./gen -type random\n./gen -type random\n./gen -type random\n\n# No solution cases (from sample input and invented)\n./gen -type no_solution -d 15 -s 50\n./gen -type no_solution -d 20 -s 7\n./gen -type no_solution -d 8 -s 5\n\n# Cases where n should be very large (large sum)\n./gen -type large_sum -d 1 -s 5000\n./gen -type large_sum -d 2 -s 5000\n./gen -type large_sum -d 500 -s 5000\n\n# Cases where s is maximum, d is small\n./gen -type large_sum -d 1\n./gen -type large_sum -d 5\n./gen -type large_sum -d 10\n\n# Cases where s and d are medium\n./gen -type random -d 250 -s 2500\n./gen -type random -d 100 -s 1000\n\n# Random small s and d\n./gen -type random -d 10 -s 10\n./gen -type random -d 20 -s 15\n\n# Edge cases\n./gen -type small -d 500 -s 5000\n./gen -type small -d 1 -s 5000\n\n# Random cases\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:11.255564",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/B",
      "title": "Problem 1070/B",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000);\n    inf.readEoln();\n\n    int count_blacklist = 0;\n\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine();\n\n        ensuref(line.size() >= 1, \"Line %d is empty\", i + 2);\n\n        // Ensure no spaces in line\n        ensuref(line.find(' ') == string::npos, \"Line %d contains spaces\", i + 2);\n\n        char sign = line[0];\n        ensuref(sign == '+' || sign == '-', \"Line %d must start with '+' or '-'\", i + 2);\n\n        if (sign == '-') {\n            count_blacklist++;\n        }\n\n        string subnet_str = line.substr(1);\n\n        ensuref(!subnet_str.empty(), \"Line %d has no subnet after sign\", i + 2);\n\n        // Check that subnet_str contains only digits, '.', '/'\n        for (char c : subnet_str) {\n            ensuref((c >= '0' && c <= '9') || c == '.' || c == '/', \"Invalid character '%c' in subnet on line %d\", c, i + 2);\n        }\n\n        // Find '/'\n        size_t slash_pos = subnet_str.find('/');\n\n        ensuref(subnet_str.find('/', slash_pos + 1) == string::npos, \"Line %d contains multiple '/'\", i + 2);\n\n        string ip_str, x_str;\n        int x = 32;\n\n        if (slash_pos == string::npos) {\n            ip_str = subnet_str;\n        } else {\n            ip_str = subnet_str.substr(0, slash_pos);\n            x_str = subnet_str.substr(slash_pos + 1);\n\n            ensuref(!x_str.empty(), \"Missing subnet mask x in line %d\", i + 2);\n\n            // Check x_str is integer between 0 and 32, no leading zeros except for '0'\n\n            ensuref(x_str.size() <= 2, \"Invalid subnet mask x in line %d\", i + 2);\n\n            if (x_str.size() > 1) {\n                ensuref(x_str[0] != '0', \"Subnet mask x in line %d has leading zeros\", i + 2);\n            }\n\n            for (char c : x_str) {\n                ensuref(c >= '0' && c <= '9', \"Invalid character '%c' in subnet mask x on line %d\", c, i + 2);\n            }\n\n            x = stoi(x_str);\n            ensuref(x >= 0 && x <= 32, \"Subnet mask x in line %d is out of range [0,32]\", i + 2);\n        }\n\n        // Now, parse ip_str\n        vector<string> octets;\n        size_t pos = 0, prev_pos = 0;\n        while ((pos = ip_str.find('.', prev_pos)) != string::npos) {\n            octets.emplace_back(ip_str.substr(prev_pos, pos - prev_pos));\n            prev_pos = pos + 1;\n        }\n        octets.emplace_back(ip_str.substr(prev_pos));\n\n        ensuref(octets.size() == 4, \"IP address in line %d does not have 4 octets\", i + 2);\n\n        uint32_t addr = 0;\n\n        for (int j = 0; j < 4; ++j) {\n            string octet_str = octets[j];\n            ensuref(!octet_str.empty(), \"Empty octet in IP address in line %d\", i + 2);\n\n            if (octet_str.size() > 1) {\n                ensuref(octet_str[0] != '0', \"Octet in line %d has leading zeros\", i + 2);\n            }\n\n            for (char c : octet_str) {\n                ensuref(c >= '0' && c <= '9', \"Invalid character '%c' in octet on line %d\", c, i + 2);\n            }\n\n            int octet = stoi(octet_str);\n            ensuref(octet >= 0 && octet <= 255, \"Octet value in line %d is out of range [0,255]\", i + 2);\n            addr = (addr << 8) | octet;\n        }\n\n        // Now, check the last (32 - x) bits are zeros\n        if (x == 0) {\n            // All bits must be zeros\n            ensuref(addr == 0, \"Invalid subnet address in line %d, address must be 0.0.0.0 for x=0\", i + 2);\n        } else if (x < 32) {\n            uint32_t mask = (1ULL << (32 - x)) - 1;\n            ensuref((addr & mask) == 0, \"Invalid subnet address in line %d, last %d bits must be zeros\", i + 2, 32 - x);\n        }\n        // When x == 32, no bits need to be checked\n    }\n\n    ensuref(count_blacklist >= 1, \"There must be at least one blacklist subnet\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000);\n    inf.readEoln();\n\n    int count_blacklist = 0;\n\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine();\n\n        ensuref(line.size() >= 1, \"Line %d is empty\", i + 2);\n\n        // Ensure no spaces in line\n        ensuref(line.find(' ') == string::npos, \"Line %d contains spaces\", i + 2);\n\n        char sign = line[0];\n        ensuref(sign == '+' || sign == '-', \"Line %d must start with '+' or '-'\", i + 2);\n\n        if (sign == '-') {\n            count_blacklist++;\n        }\n\n        string subnet_str = line.substr(1);\n\n        ensuref(!subnet_str.empty(), \"Line %d has no subnet after sign\", i + 2);\n\n        // Check that subnet_str contains only digits, '.', '/'\n        for (char c : subnet_str) {\n            ensuref((c >= '0' && c <= '9') || c == '.' || c == '/', \"Invalid character '%c' in subnet on line %d\", c, i + 2);\n        }\n\n        // Find '/'\n        size_t slash_pos = subnet_str.find('/');\n\n        ensuref(subnet_str.find('/', slash_pos + 1) == string::npos, \"Line %d contains multiple '/'\", i + 2);\n\n        string ip_str, x_str;\n        int x = 32;\n\n        if (slash_pos == string::npos) {\n            ip_str = subnet_str;\n        } else {\n            ip_str = subnet_str.substr(0, slash_pos);\n            x_str = subnet_str.substr(slash_pos + 1);\n\n            ensuref(!x_str.empty(), \"Missing subnet mask x in line %d\", i + 2);\n\n            // Check x_str is integer between 0 and 32, no leading zeros except for '0'\n\n            ensuref(x_str.size() <= 2, \"Invalid subnet mask x in line %d\", i + 2);\n\n            if (x_str.size() > 1) {\n                ensuref(x_str[0] != '0', \"Subnet mask x in line %d has leading zeros\", i + 2);\n            }\n\n            for (char c : x_str) {\n                ensuref(c >= '0' && c <= '9', \"Invalid character '%c' in subnet mask x on line %d\", c, i + 2);\n            }\n\n            x = stoi(x_str);\n            ensuref(x >= 0 && x <= 32, \"Subnet mask x in line %d is out of range [0,32]\", i + 2);\n        }\n\n        // Now, parse ip_str\n        vector<string> octets;\n        size_t pos = 0, prev_pos = 0;\n        while ((pos = ip_str.find('.', prev_pos)) != string::npos) {\n            octets.emplace_back(ip_str.substr(prev_pos, pos - prev_pos));\n            prev_pos = pos + 1;\n        }\n        octets.emplace_back(ip_str.substr(prev_pos));\n\n        ensuref(octets.size() == 4, \"IP address in line %d does not have 4 octets\", i + 2);\n\n        uint32_t addr = 0;\n\n        for (int j = 0; j < 4; ++j) {\n            string octet_str = octets[j];\n            ensuref(!octet_str.empty(), \"Empty octet in IP address in line %d\", i + 2);\n\n            if (octet_str.size() > 1) {\n                ensuref(octet_str[0] != '0', \"Octet in line %d has leading zeros\", i + 2);\n            }\n\n            for (char c : octet_str) {\n                ensuref(c >= '0' && c <= '9', \"Invalid character '%c' in octet on line %d\", c, i + 2);\n            }\n\n            int octet = stoi(octet_str);\n            ensuref(octet >= 0 && octet <= 255, \"Octet value in line %d is out of range [0,255]\", i + 2);\n            addr = (addr << 8) | octet;\n        }\n\n        // Now, check the last (32 - x) bits are zeros\n        if (x == 0) {\n            // All bits must be zeros\n            ensuref(addr == 0, \"Invalid subnet address in line %d, address must be 0.0.0.0 for x=0\", i + 2);\n        } else if (x < 32) {\n            uint32_t mask = (1ULL << (32 - x)) - 1;\n            ensuref((addr & mask) == 0, \"Invalid subnet address in line %d, last %d bits must be zeros\", i + 2, 32 - x);\n        }\n        // When x == 32, no bits need to be checked\n    }\n\n    ensuref(count_blacklist >= 1, \"There must be at least one blacklist subnet\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000);\n    inf.readEoln();\n\n    int count_blacklist = 0;\n\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine();\n\n        ensuref(line.size() >= 1, \"Line %d is empty\", i + 2);\n\n        // Ensure no spaces in line\n        ensuref(line.find(' ') == string::npos, \"Line %d contains spaces\", i + 2);\n\n        char sign = line[0];\n        ensuref(sign == '+' || sign == '-', \"Line %d must start with '+' or '-'\", i + 2);\n\n        if (sign == '-') {\n            count_blacklist++;\n        }\n\n        string subnet_str = line.substr(1);\n\n        ensuref(!subnet_str.empty(), \"Line %d has no subnet after sign\", i + 2);\n\n        // Check that subnet_str contains only digits, '.', '/'\n        for (char c : subnet_str) {\n            ensuref((c >= '0' && c <= '9') || c == '.' || c == '/', \"Invalid character '%c' in subnet on line %d\", c, i + 2);\n        }\n\n        // Find '/'\n        size_t slash_pos = subnet_str.find('/');\n\n        ensuref(subnet_str.find('/', slash_pos + 1) == string::npos, \"Line %d contains multiple '/'\", i + 2);\n\n        string ip_str, x_str;\n        int x = 32;\n\n        if (slash_pos == string::npos) {\n            ip_str = subnet_str;\n        } else {\n            ip_str = subnet_str.substr(0, slash_pos);\n            x_str = subnet_str.substr(slash_pos + 1);\n\n            ensuref(!x_str.empty(), \"Missing subnet mask x in line %d\", i + 2);\n\n            // Check x_str is integer between 0 and 32, no leading zeros except for '0'\n\n            ensuref(x_str.size() <= 2, \"Invalid subnet mask x in line %d\", i + 2);\n\n            if (x_str.size() > 1) {\n                ensuref(x_str[0] != '0', \"Subnet mask x in line %d has leading zeros\", i + 2);\n            }\n\n            for (char c : x_str) {\n                ensuref(c >= '0' && c <= '9', \"Invalid character '%c' in subnet mask x on line %d\", c, i + 2);\n            }\n\n            x = stoi(x_str);\n            ensuref(x >= 0 && x <= 32, \"Subnet mask x in line %d is out of range [0,32]\", i + 2);\n        }\n\n        // Now, parse ip_str\n        vector<string> octets;\n        size_t pos = 0, prev_pos = 0;\n        while ((pos = ip_str.find('.', prev_pos)) != string::npos) {\n            octets.emplace_back(ip_str.substr(prev_pos, pos - prev_pos));\n            prev_pos = pos + 1;\n        }\n        octets.emplace_back(ip_str.substr(prev_pos));\n\n        ensuref(octets.size() == 4, \"IP address in line %d does not have 4 octets\", i + 2);\n\n        uint32_t addr = 0;\n\n        for (int j = 0; j < 4; ++j) {\n            string octet_str = octets[j];\n            ensuref(!octet_str.empty(), \"Empty octet in IP address in line %d\", i + 2);\n\n            if (octet_str.size() > 1) {\n                ensuref(octet_str[0] != '0', \"Octet in line %d has leading zeros\", i + 2);\n            }\n\n            for (char c : octet_str) {\n                ensuref(c >= '0' && c <= '9', \"Invalid character '%c' in octet on line %d\", c, i + 2);\n            }\n\n            int octet = stoi(octet_str);\n            ensuref(octet >= 0 && octet <= 255, \"Octet value in line %d is out of range [0,255]\", i + 2);\n            addr = (addr << 8) | octet;\n        }\n\n        // Now, check the last (32 - x) bits are zeros\n        if (x == 0) {\n            // All bits must be zeros\n            ensuref(addr == 0, \"Invalid subnet address in line %d, address must be 0.0.0.0 for x=0\", i + 2);\n        } else if (x < 32) {\n            uint32_t mask = (1ULL << (32 - x)) - 1;\n            ensuref((addr & mask) == 0, \"Invalid subnet address in line %d, last %d bits must be zeros\", i + 2, 32 - x);\n        }\n        // When x == 32, no bits need to be checked\n    }\n\n    ensuref(count_blacklist >= 1, \"There must be at least one blacklist subnet\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned int uint32;\n\nstruct Interval {\n    uint32 start;\n    uint32 end;\n    Interval() {}\n    Interval(uint32 s, uint32 e) : start(s), end(e) {}\n    bool operator<(const Interval &other) const {\n        return start < other.start || (start == other.start && end < other.end);\n    }\n};\n\n// Function to convert IPv4 address string to uint32\nuint32 ipToUint32(string s) {\n    int a, b, c, d;\n    if (sscanf(s.c_str(), \"%d.%d.%d.%d\", &a, &b, &c, &d) != 4)\n        return 0;\n    return ((uint32)a << 24) | ((uint32)b << 16) | ((uint32)c << 8) | (uint32)d;\n}\n\n// Function to get interval from subnet notation\nInterval getInterval(string s) {\n    size_t pos = s.find('/');\n    string ipPart = s, maskPart = \"\";\n    if (pos != string::npos) {\n        ipPart = s.substr(0, pos);\n        maskPart = s.substr(pos + 1);\n    }\n    uint32 ip = ipToUint32(ipPart);\n    int mask = 32;\n    if (!maskPart.empty()) {\n        mask = stoi(maskPart);\n    }\n    uint32 maskBits = mask == 0 ? 0 : (~0u) << (32 - mask);\n    uint32 network = ip & maskBits;\n    uint32 broadcast = network | (~maskBits);\n    return Interval(network, broadcast);\n}\n\n// Merge overlapping intervals\nvector<Interval> mergeIntervals(vector<Interval> intervals) {\n    if (intervals.empty())\n        return intervals;\n    sort(intervals.begin(), intervals.end());\n    vector<Interval> result;\n    Interval current = intervals[0];\n    for (size_t i = 1; i < intervals.size(); ++i) {\n        if (intervals[i].start <= current.end + 1) {\n            current.end = max(current.end, intervals[i].end);\n        } else {\n            result.push_back(current);\n            current = intervals[i];\n        }\n    }\n    result.push_back(current);\n    return result;\n}\n\n// Check for conflicts between two sets of intervals\nbool hasConflict(const vector<Interval> &blacklist, const vector<Interval> &whitelist) {\n    size_t i = 0, j = 0;\n    while (i < blacklist.size() && j < whitelist.size()) {\n        uint32 bl_start = blacklist[i].start;\n        uint32 bl_end = blacklist[i].end;\n        uint32 wl_start = whitelist[j].start;\n        uint32 wl_end = whitelist[j].end;\n\n        if (bl_end < wl_start) {\n            ++i;\n        } else if (wl_end < bl_start) {\n            ++j;\n        } else {\n            // Overlap exists\n            return true;\n        }\n    }\n    return false;\n}\n\n// Check if all intervals in 'a' are covered by intervals in 'b'\nbool isCovered(const vector<Interval> &a, const vector<Interval> &b) {\n    size_t i = 0, j = 0;\n    while (i < a.size()) {\n        while (j < b.size() && b[j].end < a[i].start) {\n            ++j;\n        }\n        if (j == b.size() || b[j].start > a[i].start || b[j].end < a[i].end) {\n            // Interval a[i] is not fully covered by b\n            return false;\n        }\n        ++i;\n    }\n    return true;\n}\n\n// Check if intervals in 'a' are all excluded from intervals in 'b'\nbool isExcluded(const vector<Interval> &a, const vector<Interval> &b) {\n    size_t i = 0, j = 0;\n    while (i < a.size()) {\n        while (j < b.size() && b[j].end < a[i].start) {\n            ++j;\n        }\n        if (j < b.size() && b[j].start <= a[i].end) {\n            // Overlap exists, 'a' not fully excluded from 'b'\n            return false;\n        }\n        ++i;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from 'inf'\n    int n = inf.readInt();\n    vector<Interval> oldBlacklist, oldWhitelist;\n    for (int i = 0; i < n; i++) {\n        string line = inf.readWord();\n        char sign = line[0];\n        string subnet = line.substr(1);\n        Interval interval = getInterval(subnet);\n        if (sign == '-') {\n            oldBlacklist.push_back(interval);\n        } else if (sign == '+') {\n            oldWhitelist.push_back(interval);\n        } else {\n            quitf(_fail, \"Invalid sign %c in input\", sign);\n        }\n    }\n    // Merge intervals to simplify checking\n    oldBlacklist = mergeIntervals(oldBlacklist);\n    oldWhitelist = mergeIntervals(oldWhitelist);\n\n    // Check for conflicts\n    bool conflict = hasConflict(oldBlacklist, oldWhitelist);\n\n    // Read judge's answer\n    int t_ans;\n    if (conflict) {\n        int ans_value = ans.readInt();\n        if (ans_value != -1) {\n            quitf(_fail, \"Jury's answer is not -1 when conflict exists\");\n        }\n        t_ans = -1;\n    } else {\n        t_ans = ans.readInt();\n        ans.readEoln();\n        for (int i = 0; i < t_ans; i++) {\n            ans.readLine();\n        }\n    }\n\n    // Read participant's output\n    int contestant_t = ouf.readInt();\n    if (contestant_t == -1) {\n        if (conflict) {\n            quitf(_ok, \"Correctly detected conflict\");\n        } else {\n            quitf(_wa, \"No conflict exists, but participant outputs -1\");\n        }\n    } else {\n        if (conflict) {\n            quitf(_wa, \"Conflict exists, but participant does not output -1\");\n        }\n        if (t_ans != -1 && contestant_t > t_ans) {\n            quitf(_wa, \"Participant's t = %d, which is greater than minimal t = %d\", contestant_t, t_ans);\n        }\n        vector<Interval> participantIntervals;\n        for (int i = 0; i < contestant_t; i++) {\n            string subnet = ouf.readWord();\n            Interval interval = getInterval(subnet);\n            participantIntervals.push_back(interval);\n        }\n        // Merge participant intervals\n        participantIntervals = mergeIntervals(participantIntervals);\n        // Merge old blacklists and whitelists for efficient checking\n        vector<Interval> mergedBlacklist = oldBlacklist;\n        vector<Interval> mergedWhitelist = oldWhitelist;\n\n        // Check coverage\n        if (!isCovered(mergedBlacklist, participantIntervals)) {\n            quitf(_wa, \"Participant's subnets do not cover all old blacklisted addresses\");\n        }\n        if (!isExcluded(mergedWhitelist, participantIntervals)) {\n            quitf(_wa, \"Participant's subnets include some old whitelisted addresses\");\n        }\n        if (t_ans != -1 && contestant_t < t_ans) {\n            quitf(_fail, \"Participant has better answer (t = %d) than jury's answer t = %d\", contestant_t, t_ans);\n        } else {\n            quitf(_ok, \"Participant's answer is correct\");\n        }\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid printIPAddress(uint32_t addr) {\n    printf(\"%u.%u.%u.%u\", \n        (addr >> 24) & 0xFF, \n        (addr >> 16) & 0xFF, \n        (addr >> 8) & 0xFF, \n        addr & 0xFF);\n}\n\nuint32_t randomAddressWithPrefix(int x) {\n    uint32_t addr;\n    if (x == 0) {\n        addr = 0;\n    } else {\n        uint64_t maxPrefix = 1ULL << x;\n        uint64_t prefix = rnd.next(maxPrefix);  // From 0 to 2^x - 1\n        uint64_t address = prefix << (32 - x);\n        addr = (uint32_t)address;\n    }\n    return addr;\n}\n\nvoid printSubnet(uint32_t addr, int x) {\n    printIPAddress(addr);\n    if (x != 32) {\n        printf(\"/%d\", x);\n    }\n}\n\nstruct Subnet {\n    char sign; // '+' or '-'\n    uint32_t addr;\n    int x; // prefix length\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is at least 1\n    n = max(1, n);\n\n    vector<Subnet> subnets;\n\n    if (type == \"random\") {\n        // Generate n random subnets with random '+' or '-'\n        // Ensure at least one subnet is in blacklist ('-')\n        int numBlacklist = 0;\n        for (int i = 0; i < n; ++i) {\n            Subnet s;\n            s.sign = rnd.next(2) ? '+' : '-';\n            if (s.sign == '-') numBlacklist++;\n            s.x = rnd.next(33); // x in [0,32]\n            s.addr = randomAddressWithPrefix(s.x);\n            subnets.push_back(s);\n        }\n        if (numBlacklist == 0) {\n            // Ensure at least one blacklist subnet\n            subnets[0].sign = '-';\n        }\n    } else if (type == \"conflict\") {\n        // Generate subnets with conflicts\n        subnets.clear();\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) {\n            // Generate unique address\n            uint32_t addr = rnd.next(1ULL << 32);\n            Subnet s1, s2;\n            s1.sign = '+';\n            s2.sign = '-';\n            s1.x = s2.x = 32;\n            s1.addr = s2.addr = addr;\n            subnets.push_back(s1);\n            subnets.push_back(s2);\n        }\n        if (n % 2 == 1) {\n            // Add an extra conflicting pair\n            uint32_t addr = rnd.next(1ULL << 32);\n            Subnet s1, s2;\n            s1.sign = '+';\n            s2.sign = '-';\n            s1.x = s2.x = 32;\n            s1.addr = s2.addr = addr;\n            subnets.push_back(s1);\n            subnets.push_back(s2);\n            n = subnets.size();\n        } else {\n            n = subnets.size();\n        }\n    } else if (type == \"large_blacklist\") {\n        // Generate n subnets, all in blacklist\n        for (int i = 0; i < n; ++i) {\n            Subnet s;\n            s.sign = '-';\n            s.x = rnd.next(33);\n            s.addr = randomAddressWithPrefix(s.x);\n            subnets.push_back(s);\n        }\n    } else if (type == \"large_whitelist\") {\n        // Generate n subnets, majority in whitelist\n        int numBlacklist = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            Subnet s;\n            s.sign = '+';\n            s.x = rnd.next(33);\n            s.addr = randomAddressWithPrefix(s.x);\n            subnets.push_back(s);\n        }\n        // Ensure at least one blacklist subnet\n        Subnet s;\n        s.sign = '-';\n        s.x = rnd.next(33);\n        s.addr = randomAddressWithPrefix(s.x);\n        subnets.push_back(s);\n        n = subnets.size();\n    } else if (type == \"max_overlap\") {\n        // Generate subnets that overlap maximally\n        Subnet s;\n        s.sign = '-';\n        s.x = 0;\n        s.addr = randomAddressWithPrefix(s.x); // Should be 0.0.0.0\n        subnets.push_back(s);\n\n        for (int i = 1; i < n; ++i) {\n            Subnet t;\n            t.sign = '+';\n            t.x = rnd.next(1, 32); // x from 1 to 32\n            t.addr = randomAddressWithPrefix(t.x);\n            subnets.push_back(t);\n        }\n        n = subnets.size();\n    } else if (type == \"no_overlap\") {\n        // Generate subnets that do not overlap\n        int numBlacklist = 0;\n        uint32_t addr = 0;\n        for (int i = 0; i < n; ++i) {\n            Subnet s;\n            s.sign = rnd.next(2) ? '+' : '-';\n            if (s.sign == '-') numBlacklist++;\n            s.x = 32;\n            s.addr = addr;\n            addr++;\n            subnets.push_back(s);\n        }\n        if (numBlacklist == 0) {\n            // Ensure at least one blacklist subnet\n            subnets[0].sign = '-';\n        }\n    } else {\n        // Default to random\n        // Same as \"random\" type\n        int numBlacklist = 0;\n        for (int i = 0; i < n; ++i) {\n            Subnet s;\n            s.sign = rnd.next(2) ? '+' : '-';\n            if (s.sign == '-') numBlacklist++;\n            s.x = rnd.next(33); // x in [0,32]\n            s.addr = randomAddressWithPrefix(s.x);\n            subnets.push_back(s);\n        }\n        if (numBlacklist == 0) {\n            // Ensure at least one blacklist subnet\n            subnets[0].sign = '-';\n        }\n    }\n\n    // Shuffle subnets for randomness\n    shuffle(subnets.begin(), subnets.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output subnets\n    for (int i = 0; i < n; ++i) {\n        printf(\"%c\", subnets[i].sign);\n        printIPAddress(subnets[i].addr);\n        if (subnets[i].x != 32) {\n            printf(\"/%d\", subnets[i].x);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid printIPAddress(uint32_t addr) {\n    printf(\"%u.%u.%u.%u\", \n        (addr >> 24) & 0xFF, \n        (addr >> 16) & 0xFF, \n        (addr >> 8) & 0xFF, \n        addr & 0xFF);\n}\n\nuint32_t randomAddressWithPrefix(int x) {\n    uint32_t addr;\n    if (x == 0) {\n        addr = 0;\n    } else {\n        uint64_t maxPrefix = 1ULL << x;\n        uint64_t prefix = rnd.next(maxPrefix);  // From 0 to 2^x - 1\n        uint64_t address = prefix << (32 - x);\n        addr = (uint32_t)address;\n    }\n    return addr;\n}\n\nvoid printSubnet(uint32_t addr, int x) {\n    printIPAddress(addr);\n    if (x != 32) {\n        printf(\"/%d\", x);\n    }\n}\n\nstruct Subnet {\n    char sign; // '+' or '-'\n    uint32_t addr;\n    int x; // prefix length\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is at least 1\n    n = max(1, n);\n\n    vector<Subnet> subnets;\n\n    if (type == \"random\") {\n        // Generate n random subnets with random '+' or '-'\n        // Ensure at least one subnet is in blacklist ('-')\n        int numBlacklist = 0;\n        for (int i = 0; i < n; ++i) {\n            Subnet s;\n            s.sign = rnd.next(2) ? '+' : '-';\n            if (s.sign == '-') numBlacklist++;\n            s.x = rnd.next(33); // x in [0,32]\n            s.addr = randomAddressWithPrefix(s.x);\n            subnets.push_back(s);\n        }\n        if (numBlacklist == 0) {\n            // Ensure at least one blacklist subnet\n            subnets[0].sign = '-';\n        }\n    } else if (type == \"conflict\") {\n        // Generate subnets with conflicts\n        subnets.clear();\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) {\n            // Generate unique address\n            uint32_t addr = rnd.next(1ULL << 32);\n            Subnet s1, s2;\n            s1.sign = '+';\n            s2.sign = '-';\n            s1.x = s2.x = 32;\n            s1.addr = s2.addr = addr;\n            subnets.push_back(s1);\n            subnets.push_back(s2);\n        }\n        if (n % 2 == 1) {\n            // Add an extra conflicting pair\n            uint32_t addr = rnd.next(1ULL << 32);\n            Subnet s1, s2;\n            s1.sign = '+';\n            s2.sign = '-';\n            s1.x = s2.x = 32;\n            s1.addr = s2.addr = addr;\n            subnets.push_back(s1);\n            subnets.push_back(s2);\n            n = subnets.size();\n        } else {\n            n = subnets.size();\n        }\n    } else if (type == \"large_blacklist\") {\n        // Generate n subnets, all in blacklist\n        for (int i = 0; i < n; ++i) {\n            Subnet s;\n            s.sign = '-';\n            s.x = rnd.next(33);\n            s.addr = randomAddressWithPrefix(s.x);\n            subnets.push_back(s);\n        }\n    } else if (type == \"large_whitelist\") {\n        // Generate n subnets, majority in whitelist\n        int numBlacklist = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            Subnet s;\n            s.sign = '+';\n            s.x = rnd.next(33);\n            s.addr = randomAddressWithPrefix(s.x);\n            subnets.push_back(s);\n        }\n        // Ensure at least one blacklist subnet\n        Subnet s;\n        s.sign = '-';\n        s.x = rnd.next(33);\n        s.addr = randomAddressWithPrefix(s.x);\n        subnets.push_back(s);\n        n = subnets.size();\n    } else if (type == \"max_overlap\") {\n        // Generate subnets that overlap maximally\n        Subnet s;\n        s.sign = '-';\n        s.x = 0;\n        s.addr = randomAddressWithPrefix(s.x); // Should be 0.0.0.0\n        subnets.push_back(s);\n\n        for (int i = 1; i < n; ++i) {\n            Subnet t;\n            t.sign = '+';\n            t.x = rnd.next(1, 32); // x from 1 to 32\n            t.addr = randomAddressWithPrefix(t.x);\n            subnets.push_back(t);\n        }\n        n = subnets.size();\n    } else if (type == \"no_overlap\") {\n        // Generate subnets that do not overlap\n        int numBlacklist = 0;\n        uint32_t addr = 0;\n        for (int i = 0; i < n; ++i) {\n            Subnet s;\n            s.sign = rnd.next(2) ? '+' : '-';\n            if (s.sign == '-') numBlacklist++;\n            s.x = 32;\n            s.addr = addr;\n            addr++;\n            subnets.push_back(s);\n        }\n        if (numBlacklist == 0) {\n            // Ensure at least one blacklist subnet\n            subnets[0].sign = '-';\n        }\n    } else {\n        // Default to random\n        // Same as \"random\" type\n        int numBlacklist = 0;\n        for (int i = 0; i < n; ++i) {\n            Subnet s;\n            s.sign = rnd.next(2) ? '+' : '-';\n            if (s.sign == '-') numBlacklist++;\n            s.x = rnd.next(33); // x in [0,32]\n            s.addr = randomAddressWithPrefix(s.x);\n            subnets.push_back(s);\n        }\n        if (numBlacklist == 0) {\n            // Ensure at least one blacklist subnet\n            subnets[0].sign = '-';\n        }\n    }\n\n    // Shuffle subnets for randomness\n    shuffle(subnets.begin(), subnets.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output subnets\n    for (int i = 0; i < n; ++i) {\n        printf(\"%c\", subnets[i].sign);\n        printIPAddress(subnets[i].addr);\n        if (subnets[i].x != 32) {\n            printf(\"/%d\", subnets[i].x);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 1000 -type random\n./gen -n 200000 -type random\n\n./gen -n 2 -type conflict\n./gen -n 10 -type conflict\n./gen -n 1000 -type conflict\n./gen -n 200000 -type conflict\n\n./gen -n 200000 -type large_blacklist\n./gen -n 200000 -type large_whitelist\n\n./gen -n 200000 -type max_overlap\n./gen -n 10000 -type max_overlap\n./gen -n 1000 -type max_overlap\n\n./gen -n 200000 -type no_overlap\n./gen -n 10000 -type no_overlap\n./gen -n 1000 -type no_overlap\n\n./gen -n 100000 -type random\n./gen -n 200000 -type random\n\n./gen -n 1 -type conflict\n\n./gen -n 1 -type large_whitelist\n\n./gen -n 1 -type large_blacklist\n\n./gen -n 10 -type max_overlap\n\n./gen -n 100 -type no_overlap\n\n./gen -n 100000 -type large_whitelist\n\n./gen -n 100000 -type large_blacklist\n\n./gen -n 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:12.964199",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/C",
      "title": "C. Cloud Computing",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers nn, kk and mm (1≤n,k≤106,1≤m≤2⋅1051≤n,k≤106,1≤m≤2⋅105) — the number of days to analyze, the desired daily number of cores, the number of tariff plans.The following mm lines contain descriptions of tariff plans, one description per line. Each line contains four integers lili, riri, cici, pipi (1≤li≤ri≤n1≤li≤ri≤n, 1≤ci,pi≤1061≤ci,pi≤106), where lili and riri are starting and finishing days of the ii-th tariff plan, cici — number of cores, pipi — price of a single core for daily rent on the ii-th tariff plan.",
      "output_spec": "OutputPrint a single integer number — the minimal amount of money that Buber will pay.",
      "sample_tests": "ExamplesInputСкопировать5 7 31 4 5 31 3 5 22 5 10 1OutputСкопировать44InputСкопировать7 13 52 3 10 73 5 10 101 2 10 64 5 10 93 4 10 8OutputСкопировать462InputСкопировать4 100 33 3 2 51 1 3 22 4 4 4OutputСкопировать64",
      "description": "C. Cloud Computing\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains three integers nn, kk and mm (1≤n,k≤106,1≤m≤2⋅1051≤n,k≤106,1≤m≤2⋅105) — the number of days to analyze, the desired daily number of cores, the number of tariff plans.The following mm lines contain descriptions of tariff plans, one description per line. Each line contains four integers lili, riri, cici, pipi (1≤li≤ri≤n1≤li≤ri≤n, 1≤ci,pi≤1061≤ci,pi≤106), where lili and riri are starting and finishing days of the ii-th tariff plan, cici — number of cores, pipi — price of a single core for daily rent on the ii-th tariff plan.\n\nOutputPrint a single integer number — the minimal amount of money that Buber will pay.\n\nInputСкопировать5 7 31 4 5 31 3 5 22 5 10 1OutputСкопировать44InputСкопировать7 13 52 3 10 73 5 10 101 2 10 64 5 10 93 4 10 8OutputСкопировать462InputСкопировать4 100 33 3 2 51 1 3 22 4 4 4OutputСкопировать64\n\nInputСкопировать5 7 31 4 5 31 3 5 22 5 10 1\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать44\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать7 13 52 3 10 73 5 10 101 2 10 64 5 10 93 4 10 8\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать462\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать4 100 33 3 2 51 1 3 22 4 4 4\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать64\n\nOutputСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces",
          "content": "Добрый день!16-го октября завершился Четвертьфинал Южного подрегиона NEERC (Northern Eurasia) чемпионата ICPC. В Саратове встретились 72 команды, многие из которых получили приглашение по результатам квалификационного этапа.Уже в субботу, 20-го октября в 11:05 (МСК) состоится онлайн-зеркало 2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды).Надеюсь, вам понравятся задачи. Председателем жюри этого соревнования являюсь я, а над задачами работал дружный коллектив жюри экс-участников чемпионата из Саратовского ГУ и иногородние члены жюри. Спасибо всем!Приглашаю команды ICPC к участию и просто индивидуальных участников соревнований Codeforces принять участие!Конечно, соревнование будет нерейтинговое.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62570",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 759
        },
        {
          "title": "Solution to problem M. Algoland and Berland of 2018-2019 ICPC, NEERC - Codeforces",
          "content": "Today, I solved a beautiful problem from the NEERC Subregional Contest: Problem M. Since I didn't find an editorial nor a solution in the comments, I decided to write this blog about my solution. For a visualization of my solution see: Visualization of the program The problem boils down to constructing a spanning tree of a 2D point set with certain constraints. No three points in the point set are collinear. The points have two colors: red and blue. There is at least one blue and one red point. The constraints on the spanning tree are: Edges of the spanning tree can only intersect at the ends, if they are drawn as line segments. Edges of the spanning tree can only connect points with different colors. For each blue point, the degree of the point in the spanning tree should be equal to riri. The constraints on riri are nice: 1≤ri≤# of red points1≤ri≤# of red points. And ∑ri=n−1∑ri=n−1, which is of course needed if the final graph needs to be a tree. It turns out that these conditions are strong enough that it is always possible to construct a spanning tree!Let's prove this by induction on the size of the point set, nn.Base case n=2n=2Because there is at least one red and one blue point, the smallest case is n=2n=2: one red and one blue point. Because of the constraint ∑ri=n−1=1∑ri=n−1=1, this means that the degree of the only blue point left is 1. The trivial solution is to connect the blue and the red point.Induction step n>2n>2:Now the hard part; Let's assume it is possible to make a spanning tree for all 2≤k<n2≤k<n. Now we are given a point set with nn points, how do we construct the spanning tree for it? First, let's sort the points on their x-coordinate. We use the y-coordinate as a tiebreaker. Let's do casework on the colors of the leftmost and rightmost point:Case 1: extreme points have different colorsLet's analyze the convex hull of the point set. As these two points both lie on the convex hull, the convex hull contains at least one red and one blue point. Certainly, there must be an adjacent pair of points on the hull with different colors. Let's connect these with an edge. If riri of the blue point is 1, we delete this point. Else we delete the red point, and lower riri by one. Notice that both the ∑ri∑ri and nn decreased by one, so the resulting riri satisfy all constraints. It can also be verified that at least one red and blue point remain, with some casework. So we can use the induction hypothesis on this smaller point set, which gives us a spanning tree. Could our newly added edge intersect with an existing edge? No, because the edge lies on the convex hull. So in this case we are done.For the last two cases, where both extreme points have the same color, we will use a different technique. Let's give each point a weight, For blue points, we set wi=−1+riwi=−1+ri. For red points we set wi=−1wi=−1. If the sum of weights is -1, that means ∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1. So if we could somehow split the point set with a vertical line through some point, such that the left and right halve both have the sum of weights equal to -1, we could use the induction hypothesis. For this to work we need both sides to have at least one point of each color. Case 2: extreme points are both blueLet's look at the prefix sums of the weights of the point set in sorted order. So the prefix sum is pk=∑i<kwipk=∑i<kwi, where the points are labeled from left to right. Because the total prefix sum is −1−1, and the prefix sum starts at 00, it must cross from nonnegative to negative at some point. Because the weights of all blue points are nonnegative the only place this can happen is at a red point. Because the weight of a red point is −1−1, it will cross from 00 to −1−1, and this is exactly what we wanted, a sum of weight equal to −1−1. Now we can draw a vertical line through this red point, and by the induction hypothesis construct two spanning trees, one containing all points to the left and the mid point, and one with all points to the right and the middle red point. Note that because the red point can't be one of the extreme points, the two point sets are definitely smaller than the initial point set. Since these spanning trees exist in two disjoint regions, they don't intersect. And they connect at the midpoint, so their union is a valid spanning tree of the whole point set! To ensure the regions are disjoint even if there are ties in x-coordinates, we tilt the splitting line slighly.Case 3: extreme points are both redWe do exactly the same, looking for a prefix sum which is equal to −1−1. Now it turns out this is sometimes not possible. But by similar (but inverted) logic as in Case 2, there exists a blue point, such that the prefix sum goes from negative to nonnegative. We again make a vertical splitting line through this point, but now we modify the riri we will use for this blue midpoint in the left and right subproblem. We choose these new riri's such that the sum of weights in the left and right point sets is again −1−1. Then we apply the induction hypothesis to get two valid spanning trees of the left and right side. And the union of these spanning trees will be a valid spanning tree for the entire point set. This concludes the proof.This proof is constructive, so for actually generating a spanning tree we can follow the induction logic backwards until the spanning tree is fully constructed. The easiest way to code this is to make a recursive function that constructs a spanning tree for the point set it's given. Based on the colors of the outermost points we either calculate a convex hull or prefix sums from left to right and call the function recursively. We only recurse nn times, and the complexity per call can be made O(nlogn)O(nlog⁡n), so this gives O(n2logn)O(n2log⁡n). But if we additionally presort the points and ensure the point set stays sorted in the recursive calls, the convex hull calculation can also be done in linear time, resulting in O(n2)O(n2) running time. Although this is not needed, I think this approach can be optimized further by using Smart divide and conquer and Decremental convex hull, and some modifications to quickly find two oppositely colored adjacent points on the convex hull. This would give a recursive formula for the time complexity of T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log(n))=O(nlog2n)T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log⁡(n))=O(nlog2⁡n), but this is definitely not needed to get AC.My code can be found here: submission",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/105126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6546
        }
      ],
      "code_examples": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 1",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 2",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 3",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 4",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 5",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 6",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readSpace();\n        int c_i = inf.readInt(1, 1000000, \"c_i\");\n        inf.readSpace();\n        int p_i = inf.readInt(1, 1000000, \"p_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readSpace();\n        int c_i = inf.readInt(1, 1000000, \"c_i\");\n        inf.readSpace();\n        int p_i = inf.readInt(1, 1000000, \"p_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readSpace();\n        int c_i = inf.readInt(1, 1000000, \"c_i\");\n        inf.readSpace();\n        int p_i = inf.readInt(1, 1000000, \"p_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        /* Random test case */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = rnd.next(1, 1000000);\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"max_caps\") {\n        /* Test case with maximum capacities */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = 1000000;\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"min_caps\") {\n        /* Test case with minimum capacities */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = 1;\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"full_coverage\") {\n        /* All plans cover all days */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = 1;\n            int r_i = n;\n            int c_i = rnd.next(1, 1000000);\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"one_day_plans\") {\n        /* All plans cover only one day */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = l_i;\n            int c_i = rnd.next(1, 1000000);\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"min_prices\") {\n        /* All plans have minimum price */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = rnd.next(1, 1000000);\n            int p_i = 1;\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"max_prices\") {\n        /* All plans have maximum price */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = rnd.next(1, 1000000);\n            int p_i = 1000000;\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"less_capacity\") {\n        /* Some days have total capacity less than k */\n        printf(\"%d %d %d\\n\", n, k, m);\n\n        vector<int> capacities(n + 1, 0);\n\n        int d = rnd.next(1, min(n, 10)); // Number of days with capacities less than k\n\n        for(int day = 1; day <= n; ++day) {\n            if (day <= d) {\n                capacities[day] = k - 1;\n            } else {\n                capacities[day] = rnd.next(k, k + 10);\n            }\n        }\n\n        int plans_generated = 0;\n\n        // Generate a plan for each day to ensure the capacities per day\n        for(int day = 1; day <= n && plans_generated < m; ++day) {\n            int l_i = day;\n            int r_i = day;\n            int c_i = capacities[day];\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n            plans_generated++;\n        }\n\n        // Fill remaining plans randomly if needed\n        while(plans_generated < m) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = rnd.next(1, 1000000);\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n            plans_generated++;\n        }\n    } else {\n        /* Default to random if unknown type */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = rnd.next(1, 1000000);\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        /* Random test case */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = rnd.next(1, 1000000);\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"max_caps\") {\n        /* Test case with maximum capacities */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = 1000000;\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"min_caps\") {\n        /* Test case with minimum capacities */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = 1;\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"full_coverage\") {\n        /* All plans cover all days */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = 1;\n            int r_i = n;\n            int c_i = rnd.next(1, 1000000);\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"one_day_plans\") {\n        /* All plans cover only one day */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = l_i;\n            int c_i = rnd.next(1, 1000000);\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"min_prices\") {\n        /* All plans have minimum price */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = rnd.next(1, 1000000);\n            int p_i = 1;\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"max_prices\") {\n        /* All plans have maximum price */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = rnd.next(1, 1000000);\n            int p_i = 1000000;\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    } else if (type == \"less_capacity\") {\n        /* Some days have total capacity less than k */\n        printf(\"%d %d %d\\n\", n, k, m);\n\n        vector<int> capacities(n + 1, 0);\n\n        int d = rnd.next(1, min(n, 10)); // Number of days with capacities less than k\n\n        for(int day = 1; day <= n; ++day) {\n            if (day <= d) {\n                capacities[day] = k - 1;\n            } else {\n                capacities[day] = rnd.next(k, k + 10);\n            }\n        }\n\n        int plans_generated = 0;\n\n        // Generate a plan for each day to ensure the capacities per day\n        for(int day = 1; day <= n && plans_generated < m; ++day) {\n            int l_i = day;\n            int r_i = day;\n            int c_i = capacities[day];\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n            plans_generated++;\n        }\n\n        // Fill remaining plans randomly if needed\n        while(plans_generated < m) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = rnd.next(1, 1000000);\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n            plans_generated++;\n        }\n    } else {\n        /* Default to random if unknown type */\n        printf(\"%d %d %d\\n\", n, k, m);\n        for(int i = 0; i < m; i++) {\n            int l_i = rnd.next(1, n);\n            int r_i = rnd.next(l_i, n);\n            int c_i = rnd.next(1, 1000000);\n            int p_i = rnd.next(1, 1000000);\n            printf(\"%d %d %d %d\\n\", l_i, r_i, c_i, p_i);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -k 5 -m 10 -type random\n./gen -n 100 -k 50 -m 100 -type random\n./gen -n 1000 -k 500 -m 1000 -type random\n./gen -n 10000 -k 5000 -m 10000 -type random\n./gen -n 100000 -k 50000 -m 100000 -type random\n./gen -n 1000000 -k 500000 -m 200000 -type random\n\n./gen -n 1000000 -k 1000000 -m 200000 -type max_caps\n./gen -n 1000000 -k 1 -m 200000 -type min_caps\n\n./gen -n 1000000 -k 500000 -m 200000 -type full_coverage\n\n./gen -n 1000000 -k 1 -m 200000 -type one_day_plans\n\n./gen -n 1000000 -k 1000000 -m 200000 -type min_prices\n./gen -n 1000000 -k 1000000 -m 200000 -type max_prices\n\n./gen -n 1000000 -k 1000000 -m 200000 -type less_capacity\n\n./gen -n 10 -k 7 -m 5 -type full_coverage\n./gen -n 7 -k 13 -m 5 -type one_day_plans\n\n./gen -n 4 -k 100 -m 3 -type less_capacity\n\n./gen -n 1 -k 1 -m 1 -type random\n./gen -n 1000000 -k 1000000 -m 1 -type random\n\n./gen -n 1000000 -k 1000000 -m 200000 -type random\n\n./gen -n 500000 -k 500000 -m 100000 -type random\n./gen -n 10 -k 5 -m 10 -type less_capacity\n\n./gen -n 1000 -k 1000000 -m 200000 -type min_caps\n./gen -n 1000000 -k 1000000 -m 200000 -type min_caps\n\n./gen -n 1000000 -k 500000 -m 200000 -type max_caps\n\n./gen -n 1000000 -k 1 -m 200000 -type min_prices\n./gen -n 1000000 -k 1 -m 200000 -type max_prices\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:15.085523",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/D",
      "title": "D. Garbage Disposal",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers nn and kk (1≤n≤2⋅105,1≤k≤1091≤n≤2⋅105,1≤k≤109) — number of days to consider and bag's capacity. The second line contains nn space separated integers aiai (0≤ai≤1090≤ai≤109) — the number of units of garbage produced on the ii-th day.",
      "output_spec": "OutputOutput a single integer — the minimum number of bags Vasya needs to dispose of all garbage. Each unit of garbage should be disposed on the day it was produced or on the next day. No garbage can be left after the nn-th day. In a day it is allowed to compose and drop multiple bags.",
      "sample_tests": "ExamplesInputСкопировать3 23 2 1OutputСкопировать3InputСкопировать5 11000000000 1000000000 1000000000 1000000000 1000000000OutputСкопировать5000000000InputСкопировать3 21 0 1OutputСкопировать2InputСкопировать4 42 8 4 1OutputСкопировать4",
      "description": "D. Garbage Disposal\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers nn and kk (1≤n≤2⋅105,1≤k≤1091≤n≤2⋅105,1≤k≤109) — number of days to consider and bag's capacity. The second line contains nn space separated integers aiai (0≤ai≤1090≤ai≤109) — the number of units of garbage produced on the ii-th day.\n\nOutputOutput a single integer — the minimum number of bags Vasya needs to dispose of all garbage. Each unit of garbage should be disposed on the day it was produced or on the next day. No garbage can be left after the nn-th day. In a day it is allowed to compose and drop multiple bags.\n\nInputСкопировать3 23 2 1OutputСкопировать3InputСкопировать5 11000000000 1000000000 1000000000 1000000000 1000000000OutputСкопировать5000000000InputСкопировать3 21 0 1OutputСкопировать2InputСкопировать4 42 8 4 1OutputСкопировать4\n\nInputСкопировать3 23 2 1\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать3\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать5 11000000000 1000000000 1000000000 1000000000 1000000000\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать5000000000\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать3 21 0 1\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать2\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать4 42 8 4 1\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать4\n\nOutputСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces",
          "content": "Добрый день!16-го октября завершился Четвертьфинал Южного подрегиона NEERC (Northern Eurasia) чемпионата ICPC. В Саратове встретились 72 команды, многие из которых получили приглашение по результатам квалификационного этапа.Уже в субботу, 20-го октября в 11:05 (МСК) состоится онлайн-зеркало 2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды).Надеюсь, вам понравятся задачи. Председателем жюри этого соревнования являюсь я, а над задачами работал дружный коллектив жюри экс-участников чемпионата из Саратовского ГУ и иногородние члены жюри. Спасибо всем!Приглашаю команды ICPC к участию и просто индивидуальных участников соревнований Codeforces принять участие!Конечно, соревнование будет нерейтинговое.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62570",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 759
        },
        {
          "title": "Solution to problem M. Algoland and Berland of 2018-2019 ICPC, NEERC - Codeforces",
          "content": "Today, I solved a beautiful problem from the NEERC Subregional Contest: Problem M. Since I didn't find an editorial nor a solution in the comments, I decided to write this blog about my solution. For a visualization of my solution see: Visualization of the program The problem boils down to constructing a spanning tree of a 2D point set with certain constraints. No three points in the point set are collinear. The points have two colors: red and blue. There is at least one blue and one red point. The constraints on the spanning tree are: Edges of the spanning tree can only intersect at the ends, if they are drawn as line segments. Edges of the spanning tree can only connect points with different colors. For each blue point, the degree of the point in the spanning tree should be equal to riri. The constraints on riri are nice: 1≤ri≤# of red points1≤ri≤# of red points. And ∑ri=n−1∑ri=n−1, which is of course needed if the final graph needs to be a tree. It turns out that these conditions are strong enough that it is always possible to construct a spanning tree!Let's prove this by induction on the size of the point set, nn.Base case n=2n=2Because there is at least one red and one blue point, the smallest case is n=2n=2: one red and one blue point. Because of the constraint ∑ri=n−1=1∑ri=n−1=1, this means that the degree of the only blue point left is 1. The trivial solution is to connect the blue and the red point.Induction step n>2n>2:Now the hard part; Let's assume it is possible to make a spanning tree for all 2≤k<n2≤k<n. Now we are given a point set with nn points, how do we construct the spanning tree for it? First, let's sort the points on their x-coordinate. We use the y-coordinate as a tiebreaker. Let's do casework on the colors of the leftmost and rightmost point:Case 1: extreme points have different colorsLet's analyze the convex hull of the point set. As these two points both lie on the convex hull, the convex hull contains at least one red and one blue point. Certainly, there must be an adjacent pair of points on the hull with different colors. Let's connect these with an edge. If riri of the blue point is 1, we delete this point. Else we delete the red point, and lower riri by one. Notice that both the ∑ri∑ri and nn decreased by one, so the resulting riri satisfy all constraints. It can also be verified that at least one red and blue point remain, with some casework. So we can use the induction hypothesis on this smaller point set, which gives us a spanning tree. Could our newly added edge intersect with an existing edge? No, because the edge lies on the convex hull. So in this case we are done.For the last two cases, where both extreme points have the same color, we will use a different technique. Let's give each point a weight, For blue points, we set wi=−1+riwi=−1+ri. For red points we set wi=−1wi=−1. If the sum of weights is -1, that means ∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1. So if we could somehow split the point set with a vertical line through some point, such that the left and right halve both have the sum of weights equal to -1, we could use the induction hypothesis. For this to work we need both sides to have at least one point of each color. Case 2: extreme points are both blueLet's look at the prefix sums of the weights of the point set in sorted order. So the prefix sum is pk=∑i<kwipk=∑i<kwi, where the points are labeled from left to right. Because the total prefix sum is −1−1, and the prefix sum starts at 00, it must cross from nonnegative to negative at some point. Because the weights of all blue points are nonnegative the only place this can happen is at a red point. Because the weight of a red point is −1−1, it will cross from 00 to −1−1, and this is exactly what we wanted, a sum of weight equal to −1−1. Now we can draw a vertical line through this red point, and by the induction hypothesis construct two spanning trees, one containing all points to the left and the mid point, and one with all points to the right and the middle red point. Note that because the red point can't be one of the extreme points, the two point sets are definitely smaller than the initial point set. Since these spanning trees exist in two disjoint regions, they don't intersect. And they connect at the midpoint, so their union is a valid spanning tree of the whole point set! To ensure the regions are disjoint even if there are ties in x-coordinates, we tilt the splitting line slighly.Case 3: extreme points are both redWe do exactly the same, looking for a prefix sum which is equal to −1−1. Now it turns out this is sometimes not possible. But by similar (but inverted) logic as in Case 2, there exists a blue point, such that the prefix sum goes from negative to nonnegative. We again make a vertical splitting line through this point, but now we modify the riri we will use for this blue midpoint in the left and right subproblem. We choose these new riri's such that the sum of weights in the left and right point sets is again −1−1. Then we apply the induction hypothesis to get two valid spanning trees of the left and right side. And the union of these spanning trees will be a valid spanning tree for the entire point set. This concludes the proof.This proof is constructive, so for actually generating a spanning tree we can follow the induction logic backwards until the spanning tree is fully constructed. The easiest way to code this is to make a recursive function that constructs a spanning tree for the point set it's given. Based on the colors of the outermost points we either calculate a convex hull or prefix sums from left to right and call the function recursively. We only recurse nn times, and the complexity per call can be made O(nlogn)O(nlog⁡n), so this gives O(n2logn)O(n2log⁡n). But if we additionally presort the points and ensure the point set stays sorted in the recursive calls, the convex hull calculation can also be done in linear time, resulting in O(n2)O(n2) running time. Although this is not needed, I think this approach can be optimized further by using Smart divide and conquer and Decremental convex hull, and some modifications to quickly find two oppositely colored adjacent points on the convex hull. This would give a recursive formula for the time complexity of T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log(n))=O(nlog2n)T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log⁡(n))=O(nlog2⁡n), but this is definitely not needed to get AC.My code can be found here: submission",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/105126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6546
        }
      ],
      "code_examples": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 1",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 2",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 3",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 4",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 5",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 6",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"zero_garbage\") {\n        // All a_i are zero\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"max_garbage\") {\n        // All a_i are 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"random\") {\n        // Random a_i in [0, 1e9]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    } else if (type == \"increasing\") {\n        // a_i increases from 0 to 1e9\n        int delta = std::max(1, 1000000000 / (n - 1));\n        int val = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val = std::min(1000000000, val + delta);\n        }\n    } else if (type == \"decreasing\") {\n        // a_i decreases from 1e9 to 0\n        int delta = std::max(1, 1000000000 / (n - 1));\n        int val = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val = std::max(0, val - delta);\n        }\n    } else if (type == \"alternating_zero\") {\n        // a_i is zero on even days\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = 0;\n            } else {\n                a[i] = rnd.next(1, 1000000000);\n            }\n        }\n    } else if (type == \"single_large\") {\n        // Only one a_i is 1e9, others are zero\n        int pos = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n        a[pos] = 1000000000;\n    } else if (type == \"all_ones\") {\n        // All a_i are 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"random_small\") {\n        // Random a_i in [0, min(k, 1000)]\n        int max_a = std::min(k, 1000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, max_a);\n        }\n    } else if (type == \"max_carryover\") {\n        // Generates a_i to maximize carry over\n        int carry = k;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, k - 1);\n            if (i % 2 == 0) {\n                a[i] = k - 1; // Maximize carry over\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"zero_garbage\") {\n        // All a_i are zero\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"max_garbage\") {\n        // All a_i are 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"random\") {\n        // Random a_i in [0, 1e9]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    } else if (type == \"increasing\") {\n        // a_i increases from 0 to 1e9\n        int delta = std::max(1, 1000000000 / (n - 1));\n        int val = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val = std::min(1000000000, val + delta);\n        }\n    } else if (type == \"decreasing\") {\n        // a_i decreases from 1e9 to 0\n        int delta = std::max(1, 1000000000 / (n - 1));\n        int val = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val = std::max(0, val - delta);\n        }\n    } else if (type == \"alternating_zero\") {\n        // a_i is zero on even days\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = 0;\n            } else {\n                a[i] = rnd.next(1, 1000000000);\n            }\n        }\n    } else if (type == \"single_large\") {\n        // Only one a_i is 1e9, others are zero\n        int pos = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n        a[pos] = 1000000000;\n    } else if (type == \"all_ones\") {\n        // All a_i are 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"random_small\") {\n        // Random a_i in [0, min(k, 1000)]\n        int max_a = std::min(k, 1000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, max_a);\n        }\n    } else if (type == \"max_carryover\") {\n        // Generates a_i to maximize carry over\n        int carry = k;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, k - 1);\n            if (i % 2 == 0) {\n                a[i] = k - 1; // Maximize carry over\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, small k\n./gen -n 1 -k 1 -type zero_garbage\n./gen -n 1 -k 1 -type max_garbage\n./gen -n 1 -k 1 -type random_small\n./gen -n 1 -k 1000000000 -type single_large\n\n# Moderate n, small k\n./gen -n 10 -k 1 -type all_ones\n./gen -n 10 -k 1 -type increasing\n./gen -n 10 -k 1 -type decreasing\n\n# Max n, small k\n./gen -n 200000 -k 1 -type random_small\n\n# Max n, max k\n./gen -n 200000 -k 1000000000 -type max_garbage\n./gen -n 200000 -k 1000000000 -type zero_garbage\n./gen -n 200000 -k 1000000000 -type random\n\n# Moderate n, max k\n./gen -n 1000 -k 1000000000 -type random\n\n# Edge case: n=1\n./gen -n 1 -k 1000000000 -type single_large\n\n# Alternating zero garbage\n./gen -n 1000 -k 1000 -type alternating_zero\n./gen -n 200000 -k 1000 -type alternating_zero\n\n# Increasing garbage\n./gen -n 200000 -k 500000000 -type increasing\n\n# Decreasing garbage\n./gen -n 200000 -k 500000000 -type decreasing\n\n# Max carryover\n./gen -n 200000 -k 1000000000 -type max_carryover\n\n# Random small garbage\n./gen -n 200000 -k 1000 -type random_small\n\n# All ones garbage\n./gen -n 200000 -k 1 -type all_ones\n\n# Single large garbage\n./gen -n 200000 -k 1 -type single_large\n\n# Random garbage\n./gen -n 200000 -k 1000000000 -type random\n\n# Max garbage for small k\n./gen -n 200000 -k 1 -type max_garbage\n\n# Edge case: Max n with zeros\n./gen -n 200000 -k 1000000000 -type zero_garbage\n\n# Edge case: Max n with increasing garbage and small k\n./gen -n 200000 -k 1 -type increasing\n\n# Edge case: Max n with decreasing garbage and small k\n./gen -n 200000 -k 1 -type decreasing\n\n# Edge case: garbage equals k on every day\n./gen -n 1000 -k 1000 -type all_ones\n\n# Edge case: garbage needing max carryover with large k\n./gen -n 1000 -k 1000000000 -type max_carryover\n\n# Edge case: garbage needing max carryover with small k\n./gen -n 1000 -k 1 -type max_carryover\n\n# Edge case: random garbage with k=1\n./gen -n 200000 -k 1 -type random\n\n# Edge case: large n, large k, random data\n./gen -n 200000 -k 1000000000 -type random\n\n# Edge case: small n, large k, single large garbage\n./gen -n 2 -k 1000000000 -type single_large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:16.940123",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/E",
      "title": "E. Getting Deals Done",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains single integer cc (1≤c≤5⋅1041≤c≤5⋅104) — number of test cases. Then description of cc test cases follows. Solve test cases separately, test cases are completely independent and do not affect each other.Each test case is described by two lines. The first of these lines contains three space-separated integers nn, mm and tt (1≤n≤2⋅105,1≤m≤2⋅105,1≤t≤4⋅10101≤n≤2⋅105,1≤m≤2⋅105,1≤t≤4⋅1010) — the number of tasks in Polycarp's list, the number of tasks he can do without a break and the total amount of time Polycarp can work on tasks. The second line of the test case contains nn space separated integers p1,p2,…,pnp1,p2,…,pn (1≤pi≤2⋅1051≤pi≤2⋅105) — difficulties of the tasks.The sum of values nn for all test cases in the input does not exceed 2⋅1052⋅105.",
      "output_spec": "OutputPrint cc lines, each line should contain answer for the corresponding test case — the maximum possible number of tasks Polycarp can complete and the integer value dd (1≤d≤t1≤d≤t) Polycarp should use in time management rule, separated by space. If there are several possible values dd for a test case, output any of them.",
      "sample_tests": "ExamplesInputСкопировать45 2 165 6 1 4 75 3 305 6 1 4 76 4 1512 5 15 7 20 171 1 50100OutputСкопировать3 54 72 100 25InputСкопировать311 1 296 4 3 7 5 3 4 7 3 5 37 1 51 1 1 1 1 1 15 2 182 3 3 7 5OutputСкопировать4 33 14 5",
      "description": "E. Getting Deals Done\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains single integer cc (1≤c≤5⋅1041≤c≤5⋅104) — number of test cases. Then description of cc test cases follows. Solve test cases separately, test cases are completely independent and do not affect each other.Each test case is described by two lines. The first of these lines contains three space-separated integers nn, mm and tt (1≤n≤2⋅105,1≤m≤2⋅105,1≤t≤4⋅10101≤n≤2⋅105,1≤m≤2⋅105,1≤t≤4⋅1010) — the number of tasks in Polycarp's list, the number of tasks he can do without a break and the total amount of time Polycarp can work on tasks. The second line of the test case contains nn space separated integers p1,p2,…,pnp1,p2,…,pn (1≤pi≤2⋅1051≤pi≤2⋅105) — difficulties of the tasks.The sum of values nn for all test cases in the input does not exceed 2⋅1052⋅105.\n\nOutputPrint cc lines, each line should contain answer for the corresponding test case — the maximum possible number of tasks Polycarp can complete and the integer value dd (1≤d≤t1≤d≤t) Polycarp should use in time management rule, separated by space. If there are several possible values dd for a test case, output any of them.\n\nInputСкопировать45 2 165 6 1 4 75 3 305 6 1 4 76 4 1512 5 15 7 20 171 1 50100OutputСкопировать3 54 72 100 25InputСкопировать311 1 296 4 3 7 5 3 4 7 3 5 37 1 51 1 1 1 1 1 15 2 182 3 3 7 5OutputСкопировать4 33 14 5\n\nInputСкопировать45 2 165 6 1 4 75 3 305 6 1 4 76 4 1512 5 15 7 20 171 1 50100\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать3 54 72 100 25\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать311 1 296 4 3 7 5 3 4 7 3 5 37 1 51 1 1 1 1 1 15 2 182 3 3 7 5\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать4 33 14 5\n\nOutputСкопировать\n\nСкопировать\n\nNoteIn the first test case of the first example n=5n=5, m=2m=2 and t=16t=16. The sequence of difficulties is [5,6,1,4,7][5,6,1,4,7]. If Polycarp chooses d=5d=5 then he will complete 33 tasks. Polycarp will work by the following schedule:  Polycarp reads the first task, its difficulty is not greater than dd (p1=5≤d=5p1=5≤d=5) and works for 55 minutes (i.e. the minutes 1,2,…,51,2,…,5);  Polycarp reads the second task, its difficulty is greater than dd (p2=6>d=5p2=6>d=5) and skips it without spending any time;  Polycarp reads the third task, its difficulty is not greater than dd (p3=1≤d=5p3=1≤d=5) and works for 11 minute (i.e. the minute 66);  Polycarp notices that he has finished m=2m=2 tasks and takes a break for 5+1=65+1=6 minutes (i.e. on the minutes 7,8,…,127,8,…,12);  Polycarp reads the fourth task, its difficulty is not greater than dd (p4=4≤d=5p4=4≤d=5) and works for 44 minutes (i.e. the minutes 13,14,15,1613,14,15,16);  Polycarp stops work because of t=16t=16. In total in the first test case Polycarp will complete 33 tasks for d=5d=5. He can't choose other value for dd to increase the number of completed tasks.",
      "solutions": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces",
          "content": "Добрый день!16-го октября завершился Четвертьфинал Южного подрегиона NEERC (Northern Eurasia) чемпионата ICPC. В Саратове встретились 72 команды, многие из которых получили приглашение по результатам квалификационного этапа.Уже в субботу, 20-го октября в 11:05 (МСК) состоится онлайн-зеркало 2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды).Надеюсь, вам понравятся задачи. Председателем жюри этого соревнования являюсь я, а над задачами работал дружный коллектив жюри экс-участников чемпионата из Саратовского ГУ и иногородние члены жюри. Спасибо всем!Приглашаю команды ICPC к участию и просто индивидуальных участников соревнований Codeforces принять участие!Конечно, соревнование будет нерейтинговое.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62570",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 759
        },
        {
          "title": "Solution to problem M. Algoland and Berland of 2018-2019 ICPC, NEERC - Codeforces",
          "content": "Today, I solved a beautiful problem from the NEERC Subregional Contest: Problem M. Since I didn't find an editorial nor a solution in the comments, I decided to write this blog about my solution. For a visualization of my solution see: Visualization of the program The problem boils down to constructing a spanning tree of a 2D point set with certain constraints. No three points in the point set are collinear. The points have two colors: red and blue. There is at least one blue and one red point. The constraints on the spanning tree are: Edges of the spanning tree can only intersect at the ends, if they are drawn as line segments. Edges of the spanning tree can only connect points with different colors. For each blue point, the degree of the point in the spanning tree should be equal to riri. The constraints on riri are nice: 1≤ri≤# of red points1≤ri≤# of red points. And ∑ri=n−1∑ri=n−1, which is of course needed if the final graph needs to be a tree. It turns out that these conditions are strong enough that it is always possible to construct a spanning tree!Let's prove this by induction on the size of the point set, nn.Base case n=2n=2Because there is at least one red and one blue point, the smallest case is n=2n=2: one red and one blue point. Because of the constraint ∑ri=n−1=1∑ri=n−1=1, this means that the degree of the only blue point left is 1. The trivial solution is to connect the blue and the red point.Induction step n>2n>2:Now the hard part; Let's assume it is possible to make a spanning tree for all 2≤k<n2≤k<n. Now we are given a point set with nn points, how do we construct the spanning tree for it? First, let's sort the points on their x-coordinate. We use the y-coordinate as a tiebreaker. Let's do casework on the colors of the leftmost and rightmost point:Case 1: extreme points have different colorsLet's analyze the convex hull of the point set. As these two points both lie on the convex hull, the convex hull contains at least one red and one blue point. Certainly, there must be an adjacent pair of points on the hull with different colors. Let's connect these with an edge. If riri of the blue point is 1, we delete this point. Else we delete the red point, and lower riri by one. Notice that both the ∑ri∑ri and nn decreased by one, so the resulting riri satisfy all constraints. It can also be verified that at least one red and blue point remain, with some casework. So we can use the induction hypothesis on this smaller point set, which gives us a spanning tree. Could our newly added edge intersect with an existing edge? No, because the edge lies on the convex hull. So in this case we are done.For the last two cases, where both extreme points have the same color, we will use a different technique. Let's give each point a weight, For blue points, we set wi=−1+riwi=−1+ri. For red points we set wi=−1wi=−1. If the sum of weights is -1, that means ∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1. So if we could somehow split the point set with a vertical line through some point, such that the left and right halve both have the sum of weights equal to -1, we could use the induction hypothesis. For this to work we need both sides to have at least one point of each color. Case 2: extreme points are both blueLet's look at the prefix sums of the weights of the point set in sorted order. So the prefix sum is pk=∑i<kwipk=∑i<kwi, where the points are labeled from left to right. Because the total prefix sum is −1−1, and the prefix sum starts at 00, it must cross from nonnegative to negative at some point. Because the weights of all blue points are nonnegative the only place this can happen is at a red point. Because the weight of a red point is −1−1, it will cross from 00 to −1−1, and this is exactly what we wanted, a sum of weight equal to −1−1. Now we can draw a vertical line through this red point, and by the induction hypothesis construct two spanning trees, one containing all points to the left and the mid point, and one with all points to the right and the middle red point. Note that because the red point can't be one of the extreme points, the two point sets are definitely smaller than the initial point set. Since these spanning trees exist in two disjoint regions, they don't intersect. And they connect at the midpoint, so their union is a valid spanning tree of the whole point set! To ensure the regions are disjoint even if there are ties in x-coordinates, we tilt the splitting line slighly.Case 3: extreme points are both redWe do exactly the same, looking for a prefix sum which is equal to −1−1. Now it turns out this is sometimes not possible. But by similar (but inverted) logic as in Case 2, there exists a blue point, such that the prefix sum goes from negative to nonnegative. We again make a vertical splitting line through this point, but now we modify the riri we will use for this blue midpoint in the left and right subproblem. We choose these new riri's such that the sum of weights in the left and right point sets is again −1−1. Then we apply the induction hypothesis to get two valid spanning trees of the left and right side. And the union of these spanning trees will be a valid spanning tree for the entire point set. This concludes the proof.This proof is constructive, so for actually generating a spanning tree we can follow the induction logic backwards until the spanning tree is fully constructed. The easiest way to code this is to make a recursive function that constructs a spanning tree for the point set it's given. Based on the colors of the outermost points we either calculate a convex hull or prefix sums from left to right and call the function recursively. We only recurse nn times, and the complexity per call can be made O(nlogn)O(nlog⁡n), so this gives O(n2logn)O(n2log⁡n). But if we additionally presort the points and ensure the point set stays sorted in the recursive calls, the convex hull calculation can also be done in linear time, resulting in O(n2)O(n2) running time. Although this is not needed, I think this approach can be optimized further by using Smart divide and conquer and Decremental convex hull, and some modifications to quickly find two oppositely colored adjacent points on the convex hull. This would give a recursive formula for the time complexity of T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log(n))=O(nlog2n)T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log⁡(n))=O(nlog2⁡n), but this is definitely not needed to get AC.My code can be found here: submission",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/105126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6546
        }
      ],
      "code_examples": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 1",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 2",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 3",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 4",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 5",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 6",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int c = inf.readInt(1, 50000, \"c\");\n    inf.readEoln();\n\n    int64_t total_n = 0;\n    for (int test = 0; test < c; ++test) {\n        int n = inf.readInt(1, 200000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 200000, \"m\");\n        inf.readSpace();\n        long long t = inf.readLong(1LL, 40000000000LL, \"t\");\n        inf.readEoln();\n\n        total_n += n;\n        ensuref(total_n <= 200000LL, \"The sum of n over all test cases must not exceed 2*10^5\");\n\n        vector<int> p = inf.readInts(n, 1, 200000, \"p_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int c = inf.readInt(1, 50000, \"c\");\n    inf.readEoln();\n\n    int64_t total_n = 0;\n    for (int test = 0; test < c; ++test) {\n        int n = inf.readInt(1, 200000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 200000, \"m\");\n        inf.readSpace();\n        long long t = inf.readLong(1LL, 40000000000LL, \"t\");\n        inf.readEoln();\n\n        total_n += n;\n        ensuref(total_n <= 200000LL, \"The sum of n over all test cases must not exceed 2*10^5\");\n\n        vector<int> p = inf.readInts(n, 1, 200000, \"p_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int c = inf.readInt(1, 50000, \"c\");\n    inf.readEoln();\n\n    int64_t total_n = 0;\n    for (int test = 0; test < c; ++test) {\n        int n = inf.readInt(1, 200000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 200000, \"m\");\n        inf.readSpace();\n        long long t = inf.readLong(1LL, 40000000000LL, \"t\");\n        inf.readEoln();\n\n        total_n += n;\n        ensuref(total_n <= 200000LL, \"The sum of n over all test cases must not exceed 2*10^5\");\n\n        vector<int> p = inf.readInts(n, 1, 200000, \"p_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int c = inf.readInt(); // number of test cases\n    for (int tc = 1; tc <= c; ++tc) {\n        int n = inf.readInt();\n        int m = inf.readInt();\n        ll t = inf.readLong();\n        vector<ll> p(n);\n        for (int i = 0; i < n; ++i) {\n            p[i] = inf.readInt();\n        }\n\n        // Read jury's answer\n        ll k_ans = ans.readLong();\n        ll d_ans = ans.readLong();\n\n        // Read contestant's answer\n        ll k_ouf = ouf.readLong();\n        ll d_ouf = ouf.readLong();\n\n        if (d_ouf < 1 || d_ouf > t)\n            quitf(_wa, \"test case %d: d = %lld is not in range [1, t=%lld]\", tc, d_ouf, t);\n\n        // Simulate Polycarp's process to get number of tasks he can complete with d = d_ouf\n        ll k_calc = 0; // number of tasks Polycarp can complete with d_ouf\n        ll total_time = 0;\n        int tasks_in_current_group = 0;\n        ll group_time = 0;\n\n        for (int i = 0; i < n; ++i) {\n            if (total_time >= t)\n                break;\n            if (p[i] > d_ouf)\n                continue;\n            if (total_time + p[i] > t)\n                break;\n            total_time += p[i];\n            k_calc += 1;\n            tasks_in_current_group += 1;\n            group_time += p[i];\n            if (tasks_in_current_group == m) {\n                // Need to take a break\n                if (total_time + group_time > t) {\n                    // Cannot take full break, work is over\n                    break;\n                }\n                total_time += group_time;\n                tasks_in_current_group = 0;\n                group_time = 0;\n            }\n        }\n\n        // Now check that k_calc ≥ k_ouf\n        if (k_calc < k_ouf)\n            quitf(_wa, \"test case %d: With d = %lld, Polycarp can complete at most %lld tasks, participant claimed %lld tasks\",\n                  tc, d_ouf, k_calc, k_ouf);\n\n        // Compare participant's answer k_ouf with jury's answer k_ans\n        if (k_ouf > k_ans) {\n            quitf(_fail, \"test case %d: participant's answer is better than jury's answer, k_ouf = %lld, k_ans = %lld\",\n                  tc, k_ouf, k_ans);\n        } else if (k_ouf < k_ans) {\n            quitf(_wa, \"test case %d: participant's answer is worse than jury's answer, k_ouf = %lld, k_ans = %lld\",\n                  tc, k_ouf, k_ans);\n        }\n        // Else, k_ouf == k_ans, accept this test case and continue\n    }\n\n    // After all test cases, ensure that there's no extra data in the contestant's output\n    ouf.skipBlanks();\n    if (!ouf.eof())\n        quitf(_wa, \"Extra data after last test case in contestant's output\");\n\n    quitf(_ok, \"All test cases passed\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateTestCase(int n, int m, long long t, int pmin, int pmax, string ptype) {\n    printf(\"%d %d %lld\\n\", n, m, t);\n\n    vector<int> p(n);\n\n    if (ptype == \"const\") {\n        int value = rnd.next(pmin, pmax);\n        for (int i = 0; i < n; ++i) {\n            p[i] = value;\n        }\n    } else if (ptype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(pmin, pmax);\n        }\n    } else if (ptype == \"increasing\") {\n        int val = pmin;\n        int delta = (pmax - pmin) / max(1, n - 1);\n        for (int i = 0; i < n; ++i) {\n            p[i] = val;\n            val = min(pmax, val + delta);\n        }\n    } else if (ptype == \"decreasing\") {\n        int val = pmax;\n        int delta = (pmax - pmin) / max(1, n - 1);\n        for (int i = 0; i < n; ++i) {\n            p[i] = val;\n            val = max(pmin, val - delta);\n        }\n    } else if (ptype == \"ones\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = 1;\n        }\n    } else if (ptype == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = pmax;\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(pmin, pmax);\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], (i == n - 1 ? '\\n' : ' '));\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int c = opt<int>(\"c\", 1);\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 1);\n    long long t = opt<long long>(\"t\", 100);\n\n    int pmin = opt<int>(\"pmin\", 1);\n    int pmax = opt<int>(\"pmax\", 200000);\n\n    string ptype = opt<string>(\"ptype\", \"random\");\n\n    int maxc = 50000;\n    int maxn = 200000;\n\n    c = min(c, maxc);\n\n    // Adjust n and c to meet total n <= 2e5\n    if (1LL * c * n > 200000) {\n        n = 200000 / c;\n        if (n == 0) n = 1;\n    }\n\n    printf(\"%d\\n\", c);\n\n    if (type == \"small\") {\n        // Small test cases\n        for (int i = 0; i < c; ++i) {\n            int nn = rnd.next(1, 10);\n            int mm = rnd.next(1, nn);\n            long long tt = rnd.next(1, 100);\n            generateTestCase(nn, mm, tt, 1, 10, ptype);\n        }\n    } else if (type == \"large_n\") {\n        // Single test case with large n\n        c = 1;\n        printf(\"%d\\n\", c);\n        int nn = 200000;\n        int mm = rnd.next(1, nn);\n        long long tt = 40000000000LL;\n        generateTestCase(nn, mm, tt, pmin, pmax, ptype);\n    } else if (type == \"large_c\") {\n        // c = 5e4, n = 4 per test case\n        c = 50000;\n        n = 4;\n        m = rnd.next(1, n);\n        long long tt = rnd.next(1LL, 40000000000LL);\n\n        printf(\"%d\\n\", c);\n        for (int i = 0; i < c; ++i) {\n            generateTestCase(n, m, tt, pmin, pmax, ptype);\n        }\n    } else if (type == \"edge\") {\n        // Edge cases\n        // c=1, n=1, m=1\n        c = 1;\n        printf(\"%d\\n\", c);\n        generateTestCase(1, 1, 1, 1, 1, \"ones\");\n    } else {\n        // Default random\n        for (int i = 0; i < c; ++i) {\n            int nn = n;\n            int mm = min(m, nn);\n            long long tt = t;\n\n            generateTestCase(nn, mm, tt, pmin, pmax, ptype);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateTestCase(int n, int m, long long t, int pmin, int pmax, string ptype) {\n    printf(\"%d %d %lld\\n\", n, m, t);\n\n    vector<int> p(n);\n\n    if (ptype == \"const\") {\n        int value = rnd.next(pmin, pmax);\n        for (int i = 0; i < n; ++i) {\n            p[i] = value;\n        }\n    } else if (ptype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(pmin, pmax);\n        }\n    } else if (ptype == \"increasing\") {\n        int val = pmin;\n        int delta = (pmax - pmin) / max(1, n - 1);\n        for (int i = 0; i < n; ++i) {\n            p[i] = val;\n            val = min(pmax, val + delta);\n        }\n    } else if (ptype == \"decreasing\") {\n        int val = pmax;\n        int delta = (pmax - pmin) / max(1, n - 1);\n        for (int i = 0; i < n; ++i) {\n            p[i] = val;\n            val = max(pmin, val - delta);\n        }\n    } else if (ptype == \"ones\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = 1;\n        }\n    } else if (ptype == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = pmax;\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(pmin, pmax);\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], (i == n - 1 ? '\\n' : ' '));\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int c = opt<int>(\"c\", 1);\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 1);\n    long long t = opt<long long>(\"t\", 100);\n\n    int pmin = opt<int>(\"pmin\", 1);\n    int pmax = opt<int>(\"pmax\", 200000);\n\n    string ptype = opt<string>(\"ptype\", \"random\");\n\n    int maxc = 50000;\n    int maxn = 200000;\n\n    c = min(c, maxc);\n\n    // Adjust n and c to meet total n <= 2e5\n    if (1LL * c * n > 200000) {\n        n = 200000 / c;\n        if (n == 0) n = 1;\n    }\n\n    printf(\"%d\\n\", c);\n\n    if (type == \"small\") {\n        // Small test cases\n        for (int i = 0; i < c; ++i) {\n            int nn = rnd.next(1, 10);\n            int mm = rnd.next(1, nn);\n            long long tt = rnd.next(1, 100);\n            generateTestCase(nn, mm, tt, 1, 10, ptype);\n        }\n    } else if (type == \"large_n\") {\n        // Single test case with large n\n        c = 1;\n        printf(\"%d\\n\", c);\n        int nn = 200000;\n        int mm = rnd.next(1, nn);\n        long long tt = 40000000000LL;\n        generateTestCase(nn, mm, tt, pmin, pmax, ptype);\n    } else if (type == \"large_c\") {\n        // c = 5e4, n = 4 per test case\n        c = 50000;\n        n = 4;\n        m = rnd.next(1, n);\n        long long tt = rnd.next(1LL, 40000000000LL);\n\n        printf(\"%d\\n\", c);\n        for (int i = 0; i < c; ++i) {\n            generateTestCase(n, m, tt, pmin, pmax, ptype);\n        }\n    } else if (type == \"edge\") {\n        // Edge cases\n        // c=1, n=1, m=1\n        c = 1;\n        printf(\"%d\\n\", c);\n        generateTestCase(1, 1, 1, 1, 1, \"ones\");\n    } else {\n        // Default random\n        for (int i = 0; i < c; ++i) {\n            int nn = n;\n            int mm = min(m, nn);\n            long long tt = t;\n\n            generateTestCase(nn, mm, tt, pmin, pmax, ptype);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -type small -c 1 -ptype ones\n./gen -type small -c 5\n./gen -type small -c 10 -ptype random\n\n# Edge cases\n./gen -type edge\n\n# Large n test case\n./gen -type large_n -ptype random\n\n# Large c test case\n./gen -type large_c -ptype random\n\n# Random test cases with various parameters\n./gen -type random -c 50000 -n 4 -m 1 -t 1000000 -pmin 1 -pmax 200000 -ptype const\n\n./gen -type random -c 1000 -n 200 -m 1 -t 1000000000 -pmin 1 -pmax 200000 -ptype random\n\n./gen -type random -c 2000 -n 100 -m 50 -t 10000000000 -pmin 1 -pmax 200000 -ptype increasing\n\n./gen -type random -c 2000 -n 100 -m 50 -t 10000000000 -pmin 1 -pmax 200000 -ptype decreasing\n\n./gen -type random -c 100 -n 2000 -m 500 -t 40000000000 -pmin 1 -pmax 200000 -ptype max\n\n./gen -type random -c 100 -n 2000 -m 500 -t 40000000000 -pmin 1 -pmax 200000 -ptype ones\n\n./gen -type random -c 50 -n 4000 -m 1000 -t 40000000000 -pmin 199999 -pmax 200000 -ptype random\n\n./gen -type random -c 50 -n 4000 -m 4000 -t 40000000000 -pmin 1 -pmax 1 -ptype ones\n\n./gen -type random -c 1000 -n 200 -m 1 -t 40000000000 -pmin 1 -pmax 200000 -ptype random\n\n./gen -type random -c 1 -n 200000 -m 1 -t 40000000000 -pmin 1 -pmax 200000 -ptype random\n\n./gen -type random -c 2 -n 100000 -m 200000 -t 40000000000 -pmin 1 -pmax 200000 -ptype random\n\n./gen -type random -c 5 -n 40000 -m 1 -t 1 -pmin 1 -pmax 2 -ptype random\n\n./gen -type random -c 5 -n 40000 -m 1 -t 40000000000 -pmin 1 -pmax 200000 -ptype random\n\n./gen -type random -c 1000 -n 5 -m 5 -t 500 -pmin 1 -pmax 100 -ptype random\n\n./gen -type random -c 1000 -n 5 -m 5 -t 1000000000 -pmin 1 -pmax 1 -ptype ones\n\n./gen -type random -c 1000 -n 5 -m 1 -t 10000000000 -pmin 200000 -pmax 200000 -ptype max\n\n./gen -type random -c 40000 -n 5 -m 5 -t 1000000 -pmin 1 -pmax 100 -ptype random\n\n./gen -type random -c 50000 -n 4 -m 1 -t 1000000 -pmin 100000 -pmax 200000 -ptype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:18.701451",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/F",
      "title": "F. Debate",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer nn (1≤n≤4⋅1051≤n≤4⋅105) — the number of people who want to take part in the debate as a spectator.These people are described on the next nn lines. Each line describes a single person and contains the string sisi and integer aiai separated by space (1≤ai≤50001≤ai≤5000), where sisi denotes person's political views (possible values — \"00\", \"10\", \"01\", \"11\") and aiai — the influence of the ii-th person.",
      "output_spec": "OutputPrint a single integer — maximal possible total influence of a set of spectators so that at least half of them support Alice and at least half of them support Bob. If it is impossible print 0 instead.",
      "sample_tests": "ExamplesInputCopy611 610 401 300 300 700 9OutputCopy22InputCopy511 101 100 10010 101 1OutputCopy103InputCopy611 1910 2200 1800 2911 2910 28OutputCopy105InputCopy300 500000 500000 5000OutputCopy0",
      "description": "time limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer nn (1≤n≤4⋅1051≤n≤4⋅105) — the number of people who want to take part in the debate as a spectator.These people are described on the next nn lines. Each line describes a single person and contains the string sisi and integer aiai separated by space (1≤ai≤50001≤ai≤5000), where sisi denotes person's political views (possible values — \"00\", \"10\", \"01\", \"11\") and aiai — the influence of the ii-th person.\n\nOutputPrint a single integer — maximal possible total influence of a set of spectators so that at least half of them support Alice and at least half of them support Bob. If it is impossible print 0 instead.\n\nInputCopy611 610 401 300 300 700 9OutputCopy22InputCopy511 101 100 10010 101 1OutputCopy103InputCopy611 1910 2200 1800 2911 2910 28OutputCopy105InputCopy300 500000 500000 5000OutputCopy0\n\nInputCopy611 610 401 300 300 700 9\n\nOutputCopy22\n\nInputCopy511 101 100 10010 101 1\n\nOutputCopy103\n\nInputCopy611 1910 2200 1800 2911 2910 28\n\nOutputCopy105\n\nInputCopy300 500000 500000 5000\n\nOutputCopy0\n\nNoteIn the first example 44 spectators can be invited to maximize total influence: 11, 22, 33 and 66. Their political views are: \"11\", \"10\", \"01\" and \"00\". So in total 22 out of 44 spectators support Alice and 22 out of 44 spectators support Bob. The total influence is 6+4+3+9=226+4+3+9=22.In the second example the direction can select all the people except the 55-th person.In the third example the direction can select people with indices: 11, 44, 55 and 66.In the fourth example it is impossible to select any non-empty set of spectators.",
      "solutions": [
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces",
          "content": "Hello!ACM-ICPC Southern Subregional Contest (NEERC/Northern Eurasia) 2018 has ended on October 16. There were 72 teams onsite in Saratov, most of them were invited because of their result on the qualification stage.On Saturday, October 20, 2018 at 16:05UTC+8 will start online-mirror 2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred).In this contest I play a role of Cheif Judge and the jury teams consists of ex-participants of ICPC from Saratov and jury members from other cities. Many thanks to all of them! I hope you will like the problems!I invite ACM-ICPC teams and individual participants of Codeforces competitions to take part! Sure, the contest will be unrated.MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62570",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 737
        },
        {
          "title": "Solution to problem M. Algoland and Berland of 2018-2019 ICPC, NEERC - Codeforces",
          "content": "Today, I solved a beautiful problem from the NEERC Subregional Contest: Problem M. Since I didn't find an editorial nor a solution in the comments, I decided to write this blog about my solution. For a visualization of my solution see: Visualization of the program The problem boils down to constructing a spanning tree of a 2D point set with certain constraints. No three points in the point set are collinear. The points have two colors: red and blue. There is at least one blue and one red point. The constraints on the spanning tree are: Edges of the spanning tree can only intersect at the ends, if they are drawn as line segments. Edges of the spanning tree can only connect points with different colors. For each blue point, the degree of the point in the spanning tree should be equal to riri. The constraints on riri are nice: 1≤ri≤# of red points1≤ri≤# of red points. And ∑ri=n−1∑ri=n−1, which is of course needed if the final graph needs to be a tree. It turns out that these conditions are strong enough that it is always possible to construct a spanning tree!Let's prove this by induction on the size of the point set, nn.Base case n=2n=2Because there is at least one red and one blue point, the smallest case is n=2n=2: one red and one blue point. Because of the constraint ∑ri=n−1=1∑ri=n−1=1, this means that the degree of the only blue point left is 1. The trivial solution is to connect the blue and the red point.Induction step n>2n>2:Now the hard part; Let's assume it is possible to make a spanning tree for all 2≤k<n2≤k<n. Now we are given a point set with nn points, how do we construct the spanning tree for it? First, let's sort the points on their x-coordinate. We use the y-coordinate as a tiebreaker. Let's do casework on the colors of the leftmost and rightmost point:Case 1: extreme points have different colorsLet's analyze the convex hull of the point set. As these two points both lie on the convex hull, the convex hull contains at least one red and one blue point. Certainly, there must be an adjacent pair of points on the hull with different colors. Let's connect these with an edge. If riri of the blue point is 1, we delete this point. Else we delete the red point, and lower riri by one. Notice that both the ∑ri∑ri and nn decreased by one, so the resulting riri satisfy all constraints. It can also be verified that at least one red and blue point remain, with some casework. So we can use the induction hypothesis on this smaller point set, which gives us a spanning tree. Could our newly added edge intersect with an existing edge? No, because the edge lies on the convex hull. So in this case we are done.For the last two cases, where both extreme points have the same color, we will use a different technique. Let's give each point a weight, For blue points, we set wi=−1+riwi=−1+ri. For red points we set wi=−1wi=−1. If the sum of weights is -1, that means ∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1. So if we could somehow split the point set with a vertical line through some point, such that the left and right halve both have the sum of weights equal to -1, we could use the induction hypothesis. For this to work we need both sides to have at least one point of each color. Case 2: extreme points are both blueLet's look at the prefix sums of the weights of the point set in sorted order. So the prefix sum is pk=∑i<kwipk=∑i<kwi, where the points are labeled from left to right. Because the total prefix sum is −1−1, and the prefix sum starts at 00, it must cross from nonnegative to negative at some point. Because the weights of all blue points are nonnegative the only place this can happen is at a red point. Because the weight of a red point is −1−1, it will cross from 00 to −1−1, and this is exactly what we wanted, a sum of weight equal to −1−1. Now we can draw a vertical line through this red point, and by the induction hypothesis construct two spanning trees, one containing all points to the left and the mid point, and one with all points to the right and the middle red point. Note that because the red point can't be one of the extreme points, the two point sets are definitely smaller than the initial point set. Since these spanning trees exist in two disjoint regions, they don't intersect. And they connect at the midpoint, so their union is a valid spanning tree of the whole point set! To ensure the regions are disjoint even if there are ties in x-coordinates, we tilt the splitting line slighly.Case 3: extreme points are both redWe do exactly the same, looking for a prefix sum which is equal to −1−1. Now it turns out this is sometimes not possible. But by similar (but inverted) logic as in Case 2, there exists a blue point, such that the prefix sum goes from negative to nonnegative. We again make a vertical splitting line through this point, but now we modify the riri we will use for this blue midpoint in the left and right subproblem. We choose these new riri's such that the sum of weights in the left and right point sets is again −1−1. Then we apply the induction hypothesis to get two valid spanning trees of the left and right side. And the union of these spanning trees will be a valid spanning tree for the entire point set. This concludes the proof.This proof is constructive, so for actually generating a spanning tree we can follow the induction logic backwards until the spanning tree is fully constructed. The easiest way to code this is to make a recursive function that constructs a spanning tree for the point set it's given. Based on the colors of the outermost points we either calculate a convex hull or prefix sums from left to right and call the function recursively. We only recurse nn times, and the complexity per call can be made O(nlogn)O(nlog⁡n), so this gives O(n2logn)O(n2log⁡n). But if we additionally presort the points and ensure the point set stays sorted in the recursive calls, the convex hull calculation can also be done in linear time, resulting in O(n2)O(n2) running time. Although this is not needed, I think this approach can be optimized further by using Smart divide and conquer and Decremental convex hull, and some modifications to quickly find two oppositely colored adjacent points on the convex hull. This would give a recursive formula for the time complexity of T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log(n))=O(nlog2n)T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log⁡(n))=O(nlog2⁡n), but this is definitely not needed to get AC.My code can be found here: submission",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/105126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6546
        }
      ],
      "code_examples": [
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 1",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 2",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 3",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 4",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 5",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 6",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s_i = inf.readToken(\"00|01|10|11\", \"s_i\");\n        inf.readSpace();\n        int a_i = inf.readInt(1, 5000, \"a_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s_i = inf.readToken(\"00|01|10|11\", \"s_i\");\n        inf.readSpace();\n        int a_i = inf.readInt(1, 5000, \"a_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s_i = inf.readToken(\"00|01|10|11\", \"s_i\");\n        inf.readSpace();\n        int a_i = inf.readInt(1, 5000, \"a_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxA = opt<int>(\"maxA\", 5000);\n    string caseType = opt<string>(\"caseType\", \"random\");\n\n    vector<pair<string, int>> spectators;\n\n    if (caseType == \"random\") {\n        // Randomly generate political views and ai\n        for(int i = 0; i < n; ++i) {\n            // Randomly pick a political view from [\"00\", \"01\", \"10\", \"11\"]\n            int viewType = rnd.next(4); // 0 to 3\n            string s;\n            if(viewType == 0) s = \"00\";\n            else if(viewType == 1) s = \"01\";\n            else if(viewType == 2) s = \"10\";\n            else s = \"11\";\n\n            // Randomly generate ai between 1 and maxA\n            int ai = rnd.next(1, maxA);\n\n            spectators.push_back({s, ai});\n        }\n    } else if (caseType == \"only00\") {\n        // All spectators have political view \"00\"\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({\"00\", ai});\n        }\n    } else if (caseType == \"only11\") {\n        // All spectators have political view \"11\"\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({\"11\", ai});\n        }\n    } else if (caseType == \"balanced\") {\n        // Equal numbers of each type\n        int numPerType = n / 4;\n        int remainder = n % 4;\n        vector<string> types = {\"00\", \"01\", \"10\", \"11\"};\n        int idx = 0;\n        for(auto t : types) {\n            int num = numPerType + (remainder > 0 ? 1 : 0);\n            if (remainder > 0) remainder--;\n            for(int i = 0; i < num; ++i) {\n                int ai = rnd.next(1, maxA);\n                spectators.push_back({t, ai});\n            }\n            idx++;\n        }\n        // Shuffle the spectators\n        shuffle(spectators.begin(), spectators.end());\n    } else if (caseType == \"maxInfluence\") {\n        // High influence values for \"00\" types\n        for(int i = 0; i < n; ++i) {\n            int viewType = rnd.next(4); // 0 to 3\n            string s;\n            int ai;\n            if(viewType == 0) {\n                s = \"00\";\n                ai = maxA;\n            } else if(viewType == 1) {\n                s = \"01\";\n                ai = rnd.next(1, maxA);\n            } else if(viewType == 2) {\n                s = \"10\";\n                ai = rnd.next(1, maxA);\n            } else {\n                s = \"11\";\n                ai = rnd.next(1, maxA);\n            }\n            spectators.push_back({s, ai});\n        }\n    } else if (caseType == \"overHalfAlice\") {\n        int numAliceSupporters = n / 2 + 1; // More than half\n        int numBobSupporters = n / 2 - 1; // Less than half\n        int numNoneSupporters = n - numAliceSupporters - numBobSupporters;\n        for(int i = 0; i < numAliceSupporters; ++i) {\n            string s = \"10\"; // Supports Alice only\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        for(int i = 0; i < numBobSupporters; ++i) {\n            string s = \"01\"; // Supports Bob only\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        for(int i = 0; i < numNoneSupporters; ++i) {\n            string s = \"00\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        shuffle(spectators.begin(), spectators.end());\n    } else if (caseType == \"overHalfBob\") {\n        int numBobSupporters = n / 2 + 1;\n        int numAliceSupporters = n / 2 -1;\n        int numNoneSupporters = n - numBobSupporters - numAliceSupporters;\n        for(int i = 0; i < numBobSupporters; ++i) {\n            string s = \"01\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        for(int i = 0; i < numAliceSupporters; ++i) {\n            string s = \"10\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        for(int i = 0; i < numNoneSupporters; ++i) {\n            string s = \"00\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        shuffle(spectators.begin(), spectators.end());\n    } else if (caseType == \"impossible\") {\n        // All \"00\" types\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({\"00\", ai});\n        }\n    } else if (caseType == \"small\") {\n        // Generate small random test case\n        for(int i = 0; i < n; ++i) {\n            int viewType = rnd.next(4);\n            string s;\n            if(viewType == 0) s = \"00\";\n            else if(viewType == 1) s = \"01\";\n            else if(viewType == 2) s = \"10\";\n            else s = \"11\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n    } else {\n        // Default case: random\n        for(int i = 0; i < n; ++i) {\n            int viewType = rnd.next(4);\n            string s;\n            if(viewType == 0) s = \"00\";\n            else if(viewType == 1) s = \"01\";\n            else if(viewType == 2) s = \"10\";\n            else s = \"11\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s %d\\n\", spectators[i].first.c_str(), spectators[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxA = opt<int>(\"maxA\", 5000);\n    string caseType = opt<string>(\"caseType\", \"random\");\n\n    vector<pair<string, int>> spectators;\n\n    if (caseType == \"random\") {\n        // Randomly generate political views and ai\n        for(int i = 0; i < n; ++i) {\n            // Randomly pick a political view from [\"00\", \"01\", \"10\", \"11\"]\n            int viewType = rnd.next(4); // 0 to 3\n            string s;\n            if(viewType == 0) s = \"00\";\n            else if(viewType == 1) s = \"01\";\n            else if(viewType == 2) s = \"10\";\n            else s = \"11\";\n\n            // Randomly generate ai between 1 and maxA\n            int ai = rnd.next(1, maxA);\n\n            spectators.push_back({s, ai});\n        }\n    } else if (caseType == \"only00\") {\n        // All spectators have political view \"00\"\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({\"00\", ai});\n        }\n    } else if (caseType == \"only11\") {\n        // All spectators have political view \"11\"\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({\"11\", ai});\n        }\n    } else if (caseType == \"balanced\") {\n        // Equal numbers of each type\n        int numPerType = n / 4;\n        int remainder = n % 4;\n        vector<string> types = {\"00\", \"01\", \"10\", \"11\"};\n        int idx = 0;\n        for(auto t : types) {\n            int num = numPerType + (remainder > 0 ? 1 : 0);\n            if (remainder > 0) remainder--;\n            for(int i = 0; i < num; ++i) {\n                int ai = rnd.next(1, maxA);\n                spectators.push_back({t, ai});\n            }\n            idx++;\n        }\n        // Shuffle the spectators\n        shuffle(spectators.begin(), spectators.end());\n    } else if (caseType == \"maxInfluence\") {\n        // High influence values for \"00\" types\n        for(int i = 0; i < n; ++i) {\n            int viewType = rnd.next(4); // 0 to 3\n            string s;\n            int ai;\n            if(viewType == 0) {\n                s = \"00\";\n                ai = maxA;\n            } else if(viewType == 1) {\n                s = \"01\";\n                ai = rnd.next(1, maxA);\n            } else if(viewType == 2) {\n                s = \"10\";\n                ai = rnd.next(1, maxA);\n            } else {\n                s = \"11\";\n                ai = rnd.next(1, maxA);\n            }\n            spectators.push_back({s, ai});\n        }\n    } else if (caseType == \"overHalfAlice\") {\n        int numAliceSupporters = n / 2 + 1; // More than half\n        int numBobSupporters = n / 2 - 1; // Less than half\n        int numNoneSupporters = n - numAliceSupporters - numBobSupporters;\n        for(int i = 0; i < numAliceSupporters; ++i) {\n            string s = \"10\"; // Supports Alice only\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        for(int i = 0; i < numBobSupporters; ++i) {\n            string s = \"01\"; // Supports Bob only\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        for(int i = 0; i < numNoneSupporters; ++i) {\n            string s = \"00\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        shuffle(spectators.begin(), spectators.end());\n    } else if (caseType == \"overHalfBob\") {\n        int numBobSupporters = n / 2 + 1;\n        int numAliceSupporters = n / 2 -1;\n        int numNoneSupporters = n - numBobSupporters - numAliceSupporters;\n        for(int i = 0; i < numBobSupporters; ++i) {\n            string s = \"01\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        for(int i = 0; i < numAliceSupporters; ++i) {\n            string s = \"10\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        for(int i = 0; i < numNoneSupporters; ++i) {\n            string s = \"00\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n        shuffle(spectators.begin(), spectators.end());\n    } else if (caseType == \"impossible\") {\n        // All \"00\" types\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({\"00\", ai});\n        }\n    } else if (caseType == \"small\") {\n        // Generate small random test case\n        for(int i = 0; i < n; ++i) {\n            int viewType = rnd.next(4);\n            string s;\n            if(viewType == 0) s = \"00\";\n            else if(viewType == 1) s = \"01\";\n            else if(viewType == 2) s = \"10\";\n            else s = \"11\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n    } else {\n        // Default case: random\n        for(int i = 0; i < n; ++i) {\n            int viewType = rnd.next(4);\n            string s;\n            if(viewType == 0) s = \"00\";\n            else if(viewType == 1) s = \"01\";\n            else if(viewType == 2) s = \"10\";\n            else s = \"11\";\n            int ai = rnd.next(1, maxA);\n            spectators.push_back({s, ai});\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s %d\\n\", spectators[i].first.c_str(), spectators[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -maxA 5000 -caseType small\n./gen -n 6 -maxA 5000 -caseType small\n./gen -n 5 -caseType small\n./gen -n 10 -caseType balanced\n./gen -n 100 -caseType balanced\n./gen -n 1000 -caseType balanced\n./gen -n 400000 -caseType random\n./gen -n 400000 -caseType only00\n./gen -n 400000 -caseType only11\n./gen -n 400000 -caseType overHalfAlice\n./gen -n 400000 -caseType overHalfBob\n./gen -n 400000 -caseType impossible\n./gen -n 99999 -maxA 1 -caseType maxInfluence\n./gen -n 400000 -caseType maxInfluence\n./gen -n 10 -caseType overHalfAlice\n./gen -n 10 -caseType overHalfBob\n./gen -n 123456 -caseType maxInfluence\n./gen -n 1 -caseType only11\n./gen -n 1 -caseType only00\n./gen -n 4 -caseType balanced\n./gen -n 50 -caseType maxInfluence\n./gen -n 5000 -caseType random\n./gen -n 5000 -maxA 1 -caseType random\n./gen -n 5000 -maxA 5000 -caseType random\n./gen -n 400000 -caseType random\n./gen -n 100000 -caseType balanced\n./gen -n 200000 -caseType overHalfBob\n./gen -n 300000 -caseType overHalfAlice\n./gen -n 400000 -caseType only00\n./gen -n 400000 -caseType only11\n./gen -n 400000 -caseType impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:20.276669",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/G",
      "title": "G. Monsters and Potions",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers nn and mm (1≤n≤1001≤n≤100; 1≤m≤n1≤m≤n) — length of the game board and the number of heroes on it.The following mm lines describe heroes. Each line contains two integers sisi and hihi (1≤si≤n1≤si≤n; 1≤hi≤1061≤hi≤106), where sisi is the initial position and hihi is the initial HP of the ii-th hero. It is guaranteed that each cell sisi is blank. It is also guaranteed that all sisi are different. The following line contains nn integers a1,a2,…,ana1,a2,…,an (−106≤aj≤106−106≤aj≤106), where ajaj describes the ii-th cell of the game board:  aj=0aj=0 means that the ii-th cell is blank,  aj<0aj<0 means that the ii-th cell contains monster with positive HP of −aj−aj,  aj>0aj>0 means that the ii-th cell contains potion with ajaj HP.",
      "output_spec": "OutputOn the first line of the output print the index of the rally point cell.On the second line print mm integers — the order in which heroes should move to the rally point. Heroes are numbered from 11 to mm in the order they are given in the input.If there are multiple solutions, print any of them.If it is impossible to find a rally point which can be reached by all heroes, print a single integer -1 in the output.",
      "sample_tests": "ExamplesInputСкопировать8 38 21 34 90 3 -5 0 -5 -4 -1 0OutputСкопировать63 1 2 InputСкопировать1 11 10OutputСкопировать11 InputСкопировать3 21 13 10 -5000 0OutputСкопировать-1InputСкопировать8 31 155 108 10 -5 -5 -5 0 -5 -5 0OutputСкопировать72 1 3",
      "description": "G. Monsters and Potions\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers nn and mm (1≤n≤1001≤n≤100; 1≤m≤n1≤m≤n) — length of the game board and the number of heroes on it.The following mm lines describe heroes. Each line contains two integers sisi and hihi (1≤si≤n1≤si≤n; 1≤hi≤1061≤hi≤106), where sisi is the initial position and hihi is the initial HP of the ii-th hero. It is guaranteed that each cell sisi is blank. It is also guaranteed that all sisi are different. The following line contains nn integers a1,a2,…,ana1,a2,…,an (−106≤aj≤106−106≤aj≤106), where ajaj describes the ii-th cell of the game board:  aj=0aj=0 means that the ii-th cell is blank,  aj<0aj<0 means that the ii-th cell contains monster with positive HP of −aj−aj,  aj>0aj>0 means that the ii-th cell contains potion with ajaj HP.\n\nOutputOn the first line of the output print the index of the rally point cell.On the second line print mm integers — the order in which heroes should move to the rally point. Heroes are numbered from 11 to mm in the order they are given in the input.If there are multiple solutions, print any of them.If it is impossible to find a rally point which can be reached by all heroes, print a single integer -1 in the output.\n\nInputСкопировать8 38 21 34 90 3 -5 0 -5 -4 -1 0OutputСкопировать63 1 2 InputСкопировать1 11 10OutputСкопировать11 InputСкопировать3 21 13 10 -5000 0OutputСкопировать-1InputСкопировать8 31 155 108 10 -5 -5 -5 0 -5 -5 0OutputСкопировать72 1 3\n\nInputСкопировать8 38 21 34 90 3 -5 0 -5 -4 -1 0\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать63 1 2\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать1 11 10\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать11\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать3 21 13 10 -5000 0\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать-1\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать8 31 155 108 10 -5 -5 -5 0 -5 -5 0\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать72 1 3\n\nOutputСкопировать\n\nСкопировать\n\nNoteThe picture illustrates the first example:",
      "solutions": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces",
          "content": "Добрый день!16-го октября завершился Четвертьфинал Южного подрегиона NEERC (Northern Eurasia) чемпионата ICPC. В Саратове встретились 72 команды, многие из которых получили приглашение по результатам квалификационного этапа.Уже в субботу, 20-го октября в 11:05 (МСК) состоится онлайн-зеркало 2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды).Надеюсь, вам понравятся задачи. Председателем жюри этого соревнования являюсь я, а над задачами работал дружный коллектив жюри экс-участников чемпионата из Саратовского ГУ и иногородние члены жюри. Спасибо всем!Приглашаю команды ICPC к участию и просто индивидуальных участников соревнований Codeforces принять участие!Конечно, соревнование будет нерейтинговое.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/62570",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 759
        },
        {
          "title": "Solution to problem M. Algoland and Berland of 2018-2019 ICPC, NEERC - Codeforces",
          "content": "Today, I solved a beautiful problem from the NEERC Subregional Contest: Problem M. Since I didn't find an editorial nor a solution in the comments, I decided to write this blog about my solution. For a visualization of my solution see: Visualization of the program The problem boils down to constructing a spanning tree of a 2D point set with certain constraints. No three points in the point set are collinear. The points have two colors: red and blue. There is at least one blue and one red point. The constraints on the spanning tree are: Edges of the spanning tree can only intersect at the ends, if they are drawn as line segments. Edges of the spanning tree can only connect points with different colors. For each blue point, the degree of the point in the spanning tree should be equal to riri. The constraints on riri are nice: 1≤ri≤# of red points1≤ri≤# of red points. And ∑ri=n−1∑ri=n−1, which is of course needed if the final graph needs to be a tree. It turns out that these conditions are strong enough that it is always possible to construct a spanning tree!Let's prove this by induction on the size of the point set, nn.Base case n=2n=2Because there is at least one red and one blue point, the smallest case is n=2n=2: one red and one blue point. Because of the constraint ∑ri=n−1=1∑ri=n−1=1, this means that the degree of the only blue point left is 1. The trivial solution is to connect the blue and the red point.Induction step n>2n>2:Now the hard part; Let's assume it is possible to make a spanning tree for all 2≤k<n2≤k<n. Now we are given a point set with nn points, how do we construct the spanning tree for it? First, let's sort the points on their x-coordinate. We use the y-coordinate as a tiebreaker. Let's do casework on the colors of the leftmost and rightmost point:Case 1: extreme points have different colorsLet's analyze the convex hull of the point set. As these two points both lie on the convex hull, the convex hull contains at least one red and one blue point. Certainly, there must be an adjacent pair of points on the hull with different colors. Let's connect these with an edge. If riri of the blue point is 1, we delete this point. Else we delete the red point, and lower riri by one. Notice that both the ∑ri∑ri and nn decreased by one, so the resulting riri satisfy all constraints. It can also be verified that at least one red and blue point remain, with some casework. So we can use the induction hypothesis on this smaller point set, which gives us a spanning tree. Could our newly added edge intersect with an existing edge? No, because the edge lies on the convex hull. So in this case we are done.For the last two cases, where both extreme points have the same color, we will use a different technique. Let's give each point a weight, For blue points, we set wi=−1+riwi=−1+ri. For red points we set wi=−1wi=−1. If the sum of weights is -1, that means ∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1. So if we could somehow split the point set with a vertical line through some point, such that the left and right halve both have the sum of weights equal to -1, we could use the induction hypothesis. For this to work we need both sides to have at least one point of each color. Case 2: extreme points are both blueLet's look at the prefix sums of the weights of the point set in sorted order. So the prefix sum is pk=∑i<kwipk=∑i<kwi, where the points are labeled from left to right. Because the total prefix sum is −1−1, and the prefix sum starts at 00, it must cross from nonnegative to negative at some point. Because the weights of all blue points are nonnegative the only place this can happen is at a red point. Because the weight of a red point is −1−1, it will cross from 00 to −1−1, and this is exactly what we wanted, a sum of weight equal to −1−1. Now we can draw a vertical line through this red point, and by the induction hypothesis construct two spanning trees, one containing all points to the left and the mid point, and one with all points to the right and the middle red point. Note that because the red point can't be one of the extreme points, the two point sets are definitely smaller than the initial point set. Since these spanning trees exist in two disjoint regions, they don't intersect. And they connect at the midpoint, so their union is a valid spanning tree of the whole point set! To ensure the regions are disjoint even if there are ties in x-coordinates, we tilt the splitting line slighly.Case 3: extreme points are both redWe do exactly the same, looking for a prefix sum which is equal to −1−1. Now it turns out this is sometimes not possible. But by similar (but inverted) logic as in Case 2, there exists a blue point, such that the prefix sum goes from negative to nonnegative. We again make a vertical splitting line through this point, but now we modify the riri we will use for this blue midpoint in the left and right subproblem. We choose these new riri's such that the sum of weights in the left and right point sets is again −1−1. Then we apply the induction hypothesis to get two valid spanning trees of the left and right side. And the union of these spanning trees will be a valid spanning tree for the entire point set. This concludes the proof.This proof is constructive, so for actually generating a spanning tree we can follow the induction logic backwards until the spanning tree is fully constructed. The easiest way to code this is to make a recursive function that constructs a spanning tree for the point set it's given. Based on the colors of the outermost points we either calculate a convex hull or prefix sums from left to right and call the function recursively. We only recurse nn times, and the complexity per call can be made O(nlogn)O(nlog⁡n), so this gives O(n2logn)O(n2log⁡n). But if we additionally presort the points and ensure the point set stays sorted in the recursive calls, the convex hull calculation can also be done in linear time, resulting in O(n2)O(n2) running time. Although this is not needed, I think this approach can be optimized further by using Smart divide and conquer and Decremental convex hull, and some modifications to quickly find two oppositely colored adjacent points on the convex hull. This would give a recursive formula for the time complexity of T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log(n))=O(nlog2n)T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log⁡(n))=O(nlog2⁡n), but this is definitely not needed to get AC.My code can be found here: submission",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/105126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6546
        }
      ],
      "code_examples": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 1",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 2",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 3",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 4",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 5",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 6",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    set<int> s_set;\n    for (int i = 0; i < m; ++i) {\n        int s_i = inf.readInt(1, n, \"s_i\");\n        inf.readSpace();\n        int h_i = inf.readInt(1, 1000000, \"h_i\");\n        inf.readEoln();\n\n        ensuref(s_set.count(s_i) == 0, \"s_i=%d is not unique\", s_i);\n        s_set.insert(s_i);\n    }\n\n    vector<int> a = inf.readInts(n, -1000000, 1000000, \"a\");\n    inf.readEoln();\n\n    for (int s_i : s_set) {\n        ensuref(a[s_i - 1] == 0, \"Cell at position s_i=%d must be blank, but a[%d]=%d\", s_i, s_i, a[s_i - 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    set<int> s_set;\n    for (int i = 0; i < m; ++i) {\n        int s_i = inf.readInt(1, n, \"s_i\");\n        inf.readSpace();\n        int h_i = inf.readInt(1, 1000000, \"h_i\");\n        inf.readEoln();\n\n        ensuref(s_set.count(s_i) == 0, \"s_i=%d is not unique\", s_i);\n        s_set.insert(s_i);\n    }\n\n    vector<int> a = inf.readInts(n, -1000000, 1000000, \"a\");\n    inf.readEoln();\n\n    for (int s_i : s_set) {\n        ensuref(a[s_i - 1] == 0, \"Cell at position s_i=%d must be blank, but a[%d]=%d\", s_i, s_i, a[s_i - 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    set<int> s_set;\n    for (int i = 0; i < m; ++i) {\n        int s_i = inf.readInt(1, n, \"s_i\");\n        inf.readSpace();\n        int h_i = inf.readInt(1, 1000000, \"h_i\");\n        inf.readEoln();\n\n        ensuref(s_set.count(s_i) == 0, \"s_i=%d is not unique\", s_i);\n        s_set.insert(s_i);\n    }\n\n    vector<int> a = inf.readInts(n, -1000000, 1000000, \"a\");\n    inf.readEoln();\n\n    for (int s_i : s_set) {\n        ensuref(a[s_i - 1] == 0, \"Cell at position s_i=%d must be blank, but a[%d]=%d\", s_i, s_i, a[s_i - 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Hero {\n    int pos;\n    int hp;\n    Hero(int p, int h) : pos(p), hp(h) {}\n};\n\nint n, m;\nvector<Hero> heroes;\nvector<int> cells; // cell contents: 0 (blank), >0 (potion), <0 (monster)\n\nbool readAns(InStream& stream, bool is_jury, bool& has_solution) {\n    int t = stream.readInt(-1, n, \"rally point\");\n    if (t == -1) {\n        has_solution = false;\n        return true; // Claimed impossible\n    }\n    has_solution = true;\n    int rally_point = t;\n    vector<int> order;\n    set<int> hero_set;\n    for (int i = 0; i < m; i++) {\n        int h = stream.readInt(1, m, format(\"hero[%d]\", i + 1).c_str());\n        if (hero_set.count(h))\n            stream.quitf(_wa, \"hero %d appears more than once in the order\", h);\n        hero_set.insert(h);\n        order.push_back(h - 1); // index from 0\n    }\n    if (hero_set.size() != m)\n        stream.quitf(_wa, \"heroes in the order are not a permutation of 1..%d\", m);\n    // Copy the initial state\n    vector<int> cell_state = cells;\n    vector<int> hero_hp(m);\n    for (int i = 0; i < m; i++)\n        hero_hp[i] = heroes[i].hp;\n    for (int idx = 0; idx < m; idx++) {\n        int hero_idx = order[idx];\n        int pos = heroes[hero_idx].pos;\n        int hp = hero_hp[hero_idx];\n        int dir = (pos < rally_point) ? 1 : -1;\n        while (pos != rally_point) {\n            pos += dir;\n            int cell_content = cell_state[pos - 1]; // cells indexed from 0\n            if (cell_content == 0) {\n                // blank cell\n            } else if (cell_content > 0) {\n                // potion\n                hp += cell_content;\n                cell_state[pos - 1] = 0; // potion disappears\n            } else if (cell_content < 0) {\n                int monster_hp = -cell_content;\n                if (monster_hp > hp) {\n                    stream.quitf(_wa, \"hero %d dies when moving to cell %d, monster's HP (%d) > hero's HP (%d)\", hero_idx + 1, pos, monster_hp, hp);\n                }\n                hp -= monster_hp;\n                if (hp < 0) {\n                    stream.quitf(_wa, \"hero %d dies after fighting monster at cell %d, hero's HP drops below zero (%d)\", hero_idx + 1, pos, hp);\n                }\n                cell_state[pos - 1] = 0; // monster disappears\n            }\n        }\n        // Hero reaches rally point\n        hero_hp[hero_idx] = hp;\n    }\n    return true; // Valid solution\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    n = inf.readInt(1, 100000, \"n\");\n    m = inf.readInt(1, n, \"m\");\n    vector<int> hero_positions;\n    set<int> hero_pos_set;\n    for (int i = 0; i < m; i++) {\n        int s_i = inf.readInt(1, n, \"s_i\");\n        if (hero_pos_set.count(s_i))\n            exit(1); // Invalid input, positions are not unique\n        hero_pos_set.insert(s_i);\n        int h_i = inf.readInt(1, 1000000, \"h_i\");\n        heroes.push_back(Hero(s_i, h_i));\n    }\n    cells.resize(n);\n    for (int i = 0; i < n; i++) {\n        cells[i] = inf.readInt(-1000000, 1000000, \"a_i\");\n    }\n\n    bool jury_has_solution;\n    bool jury_valid = readAns(ans, true, jury_has_solution);\n\n    bool participant_has_solution;\n    bool participant_valid = readAns(ouf, false, participant_has_solution);\n\n    if (!participant_has_solution && !jury_has_solution) {\n        quitf(_ok, \"Correctly outputs -1, impossible\");\n    } else if (!participant_has_solution && jury_has_solution) {\n        quitf(_wa, \"Participant claims impossible, but a solution exists\");\n    } else if (participant_has_solution && !jury_has_solution) {\n        quitf(_fail, \"Participant found a solution, but jury says impossible\");\n    } else {\n        quitf(_ok, \"Valid solution\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random(int n, int m)\n{\n    // Generate unique starting positions for heroes in blank cells\n    vector<int> positions(n);\n    iota(positions.begin(), positions.end(), 1); // positions from 1 to n\n    shuffle(positions.begin(), positions.end());\n\n    vector<int> s_i(m);\n    for (int i = 0; i < m; ++i)\n        s_i[i] = positions[i];\n\n    // Initialize the board with blank cells\n    vector<int> a_j(n, 0);\n\n    // Randomly assign monsters and potions to other cells\n    for (int i = 0; i < n; ++i)\n    {\n        // Skip hero starting positions\n        if (find(s_i.begin(), s_i.end(), i + 1) != s_i.end())\n            continue;\n\n        int r = rnd.next(3);\n        if (r == 0)\n        {\n            a_j[i] = 0; // blank\n        }\n        else if (r == 1)\n        {\n            // Monster\n            int hp = rnd.next(1, 1000000);\n            a_j[i] = -hp;\n        }\n        else\n        {\n            // Potion\n            int hp = rnd.next(1, 1000000);\n            a_j[i] = hp;\n        }\n    }\n\n    // Generate HP for heroes\n    vector<int> h_i(m);\n    for (int i = 0; i < m; ++i)\n        h_i[i] = rnd.next(1, 1000000);\n\n    // Output data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", s_i[i], h_i[i]);\n\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", a_j[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n}\n\nvoid generate_impossible(int n, int m)\n{\n    // All positions are monsters with high HP except heroes' starting positions\n    vector<int> positions(n);\n    iota(positions.begin(), positions.end(), 1); // positions from 1 to n\n    shuffle(positions.begin(), positions.end());\n\n    vector<int> s_i(m);\n    for (int i = 0; i < m; ++i)\n        s_i[i] = positions[i];\n\n    // Initialize the board with monsters of high HP\n    vector<int> a_j(n, -1000000);\n\n    // Set heroes' starting positions to blank\n    for (int i = 0; i < m; ++i)\n    {\n        a_j[s_i[i] - 1] = 0;\n    }\n\n    // Set heroes' HP to 1\n    vector<int> h_i(m, 1);\n\n    // Output data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", s_i[i], h_i[i]);\n\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", a_j[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n}\n\nvoid generate_monster_at_rally(int n, int m)\n{\n    // Generate unique positions\n    vector<int> positions(n);\n    iota(positions.begin(), positions.end(), 1);\n    shuffle(positions.begin(), positions.end());\n\n    vector<int> s_i(m);\n\n    // Assign positions to heroes\n    for (int i = 0; i < m; ++i)\n        s_i[i] = positions[i];\n\n    // Select a rally point\n    int rally_point = positions[m];\n    vector<int> a_j(n, 0);\n\n    // Put a monster at the rally point\n    int monster_hp = rnd.next(1, 1000000);\n    a_j[rally_point - 1] = -monster_hp;\n\n    // Heroes' starting positions are blank\n    for (int i = 0; i < m; ++i)\n        a_j[s_i[i] -1 ] = 0;\n\n    // Generate HP for heroes\n    vector<int> h_i(m);\n    for (int i = 0; i < m; ++i)\n        h_i[i] = rnd.next(1, 1000000);\n\n    // Ensure at least one hero can defeat the monster\n    bool hero_can_defeat = false;\n    for (int i = 0; i < m; ++i)\n    {\n        if (h_i[i] >= monster_hp)\n        {\n            hero_can_defeat = true;\n            break;\n        }\n    }\n    if (!hero_can_defeat)\n    {\n        // Set first hero's HP to monster_hp\n        h_i[0] = monster_hp;\n    }\n\n    // Output data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", s_i[i], h_i[i]);\n\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", a_j[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n}\n\nvoid generate_exactly_equal_hp(int n, int m)\n{\n    // Generate unique positions\n    vector<int> positions(n);\n    iota(positions.begin(), positions.end(), 1);\n    shuffle(positions.begin(), positions.end());\n\n    vector<int> s_i(m);\n\n    // Assign positions to heroes\n    for (int i = 0; i < m; ++i)\n        s_i[i] = positions[i];\n\n    // Initialize the board with blank cells\n    vector<int> a_j(n, 0);\n\n    // Generate HP for heroes\n    vector<int> h_i(m);\n    for (int i = 0; i < m; ++i)\n    {\n        int hero_hp = rnd.next(1, 1000000);\n        h_i[i] = hero_hp;\n    }\n\n    // Select a rally point\n    int rally_point = positions[m % n];\n    a_j[rally_point - 1] = 0; // Ensure rally point is blank\n\n    // For each hero, place a monster with HP equal to hero's HP along the path\n    for (int i = 0; i < m; ++i)\n    {\n        int pos_from = s_i[i];\n        int pos_to = rally_point;\n        if (pos_from == pos_to)\n            continue;\n        int dir = (pos_to > pos_from) ? 1 : -1;\n        int steps = abs(pos_to - pos_from);\n\n        // Place monster at a position along the path\n        int place = pos_from + dir * rnd.next(1, steps);\n        if (a_j[place - 1] == 0)\n            a_j[place - 1] = -h_i[i]; // Monster with HP equal to hero's HP\n    }\n\n    // Output data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", s_i[i], h_i[i]);\n\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", a_j[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\")\n        generate_random(n, m);\n    else if (type == \"impossible\")\n        generate_impossible(n, m);\n    else if (type == \"monster_at_rally\")\n        generate_monster_at_rally(n, m);\n    else if (type == \"exact_hp\")\n        generate_exactly_equal_hp(n, m);\n    else\n    {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random(int n, int m)\n{\n    // Generate unique starting positions for heroes in blank cells\n    vector<int> positions(n);\n    iota(positions.begin(), positions.end(), 1); // positions from 1 to n\n    shuffle(positions.begin(), positions.end());\n\n    vector<int> s_i(m);\n    for (int i = 0; i < m; ++i)\n        s_i[i] = positions[i];\n\n    // Initialize the board with blank cells\n    vector<int> a_j(n, 0);\n\n    // Randomly assign monsters and potions to other cells\n    for (int i = 0; i < n; ++i)\n    {\n        // Skip hero starting positions\n        if (find(s_i.begin(), s_i.end(), i + 1) != s_i.end())\n            continue;\n\n        int r = rnd.next(3);\n        if (r == 0)\n        {\n            a_j[i] = 0; // blank\n        }\n        else if (r == 1)\n        {\n            // Monster\n            int hp = rnd.next(1, 1000000);\n            a_j[i] = -hp;\n        }\n        else\n        {\n            // Potion\n            int hp = rnd.next(1, 1000000);\n            a_j[i] = hp;\n        }\n    }\n\n    // Generate HP for heroes\n    vector<int> h_i(m);\n    for (int i = 0; i < m; ++i)\n        h_i[i] = rnd.next(1, 1000000);\n\n    // Output data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", s_i[i], h_i[i]);\n\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", a_j[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n}\n\nvoid generate_impossible(int n, int m)\n{\n    // All positions are monsters with high HP except heroes' starting positions\n    vector<int> positions(n);\n    iota(positions.begin(), positions.end(), 1); // positions from 1 to n\n    shuffle(positions.begin(), positions.end());\n\n    vector<int> s_i(m);\n    for (int i = 0; i < m; ++i)\n        s_i[i] = positions[i];\n\n    // Initialize the board with monsters of high HP\n    vector<int> a_j(n, -1000000);\n\n    // Set heroes' starting positions to blank\n    for (int i = 0; i < m; ++i)\n    {\n        a_j[s_i[i] - 1] = 0;\n    }\n\n    // Set heroes' HP to 1\n    vector<int> h_i(m, 1);\n\n    // Output data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", s_i[i], h_i[i]);\n\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", a_j[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n}\n\nvoid generate_monster_at_rally(int n, int m)\n{\n    // Generate unique positions\n    vector<int> positions(n);\n    iota(positions.begin(), positions.end(), 1);\n    shuffle(positions.begin(), positions.end());\n\n    vector<int> s_i(m);\n\n    // Assign positions to heroes\n    for (int i = 0; i < m; ++i)\n        s_i[i] = positions[i];\n\n    // Select a rally point\n    int rally_point = positions[m];\n    vector<int> a_j(n, 0);\n\n    // Put a monster at the rally point\n    int monster_hp = rnd.next(1, 1000000);\n    a_j[rally_point - 1] = -monster_hp;\n\n    // Heroes' starting positions are blank\n    for (int i = 0; i < m; ++i)\n        a_j[s_i[i] -1 ] = 0;\n\n    // Generate HP for heroes\n    vector<int> h_i(m);\n    for (int i = 0; i < m; ++i)\n        h_i[i] = rnd.next(1, 1000000);\n\n    // Ensure at least one hero can defeat the monster\n    bool hero_can_defeat = false;\n    for (int i = 0; i < m; ++i)\n    {\n        if (h_i[i] >= monster_hp)\n        {\n            hero_can_defeat = true;\n            break;\n        }\n    }\n    if (!hero_can_defeat)\n    {\n        // Set first hero's HP to monster_hp\n        h_i[0] = monster_hp;\n    }\n\n    // Output data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", s_i[i], h_i[i]);\n\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", a_j[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n}\n\nvoid generate_exactly_equal_hp(int n, int m)\n{\n    // Generate unique positions\n    vector<int> positions(n);\n    iota(positions.begin(), positions.end(), 1);\n    shuffle(positions.begin(), positions.end());\n\n    vector<int> s_i(m);\n\n    // Assign positions to heroes\n    for (int i = 0; i < m; ++i)\n        s_i[i] = positions[i];\n\n    // Initialize the board with blank cells\n    vector<int> a_j(n, 0);\n\n    // Generate HP for heroes\n    vector<int> h_i(m);\n    for (int i = 0; i < m; ++i)\n    {\n        int hero_hp = rnd.next(1, 1000000);\n        h_i[i] = hero_hp;\n    }\n\n    // Select a rally point\n    int rally_point = positions[m % n];\n    a_j[rally_point - 1] = 0; // Ensure rally point is blank\n\n    // For each hero, place a monster with HP equal to hero's HP along the path\n    for (int i = 0; i < m; ++i)\n    {\n        int pos_from = s_i[i];\n        int pos_to = rally_point;\n        if (pos_from == pos_to)\n            continue;\n        int dir = (pos_to > pos_from) ? 1 : -1;\n        int steps = abs(pos_to - pos_from);\n\n        // Place monster at a position along the path\n        int place = pos_from + dir * rnd.next(1, steps);\n        if (a_j[place - 1] == 0)\n            a_j[place - 1] = -h_i[i]; // Monster with HP equal to hero's HP\n    }\n\n    // Output data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", s_i[i], h_i[i]);\n\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", a_j[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\")\n        generate_random(n, m);\n    else if (type == \"impossible\")\n        generate_impossible(n, m);\n    else if (type == \"monster_at_rally\")\n        generate_monster_at_rally(n, m);\n    else if (type == \"exact_hp\")\n        generate_exactly_equal_hp(n, m);\n    else\n    {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 10 -m 3 -type random\n./gen -n 20 -m 5 -type random\n./gen -n 50 -m 25 -type random\n./gen -n 100 -m 50 -type random\n\n./gen -n 5 -m 2 -type impossible\n./gen -n 10 -m 5 -type impossible\n./gen -n 20 -m 10 -type impossible\n./gen -n 50 -m 25 -type impossible\n./gen -n 100 -m 50 -type impossible\n\n./gen -n 5 -m 2 -type monster_at_rally\n./gen -n 10 -m 4 -type monster_at_rally\n./gen -n 20 -m 8 -type monster_at_rally\n./gen -n 50 -m 20 -type monster_at_rally\n./gen -n 100 -m 40 -type monster_at_rally\n\n./gen -n 5 -m 2 -type exact_hp\n./gen -n 10 -m 5 -type exact_hp\n./gen -n 20 -m 10 -type exact_hp\n./gen -n 50 -m 25 -type exact_hp\n./gen -n 100 -m 50 -type exact_hp\n\n./gen -n 7 -m 3 -type random\n./gen -n 14 -m 7 -type random\n./gen -n 21 -m 10 -type random\n./gen -n 35 -m 17 -type random\n./gen -n 70 -m 30 -type random\n\n./gen -n 8 -m 4 -type monster_at_rally\n./gen -n 16 -m 8 -type monster_at_rally\n./gen -n 24 -m 12 -type monster_at_rally\n./gen -n 40 -m 20 -type monster_at_rally\n./gen -n 80 -m 40 -type monster_at_rally\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:22.287145",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/H",
      "title": "Problem 1070/H",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    set<string> fileNames;\n    for (int i = 0; i < n; i++) {\n        string fi = inf.readLine();\n        int len = fi.length();\n        ensuref(len >=1 && len <=8, \"File name length should be between 1 and 8, but it is %d\", len);\n        for (char c : fi) {\n            ensuref(isdigit(c) || (c >= 'a' && c <= 'z') || c == '.', \"File name contains invalid character '%c'\", c);\n        }\n        ensuref(!fileNames.count(fi), \"File name '%s' is not unique\", fi.c_str());\n        fileNames.insert(fi);\n    }\n\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        string si = inf.readLine();\n        int len = si.length();\n        ensuref(len >=1 && len <=8, \"Query string length should be between 1 and 8, but it is %d\", len);\n        for (char c : si) {\n            ensuref(isdigit(c) || (c >= 'a' && c <= 'z') || c == '.', \"Query string contains invalid character '%c'\", c);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    set<string> fileNames;\n    for (int i = 0; i < n; i++) {\n        string fi = inf.readLine();\n        int len = fi.length();\n        ensuref(len >=1 && len <=8, \"File name length should be between 1 and 8, but it is %d\", len);\n        for (char c : fi) {\n            ensuref(isdigit(c) || (c >= 'a' && c <= 'z') || c == '.', \"File name contains invalid character '%c'\", c);\n        }\n        ensuref(!fileNames.count(fi), \"File name '%s' is not unique\", fi.c_str());\n        fileNames.insert(fi);\n    }\n\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        string si = inf.readLine();\n        int len = si.length();\n        ensuref(len >=1 && len <=8, \"Query string length should be between 1 and 8, but it is %d\", len);\n        for (char c : si) {\n            ensuref(isdigit(c) || (c >= 'a' && c <= 'z') || c == '.', \"Query string contains invalid character '%c'\", c);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    set<string> fileNames;\n    for (int i = 0; i < n; i++) {\n        string fi = inf.readLine();\n        int len = fi.length();\n        ensuref(len >=1 && len <=8, \"File name length should be between 1 and 8, but it is %d\", len);\n        for (char c : fi) {\n            ensuref(isdigit(c) || (c >= 'a' && c <= 'z') || c == '.', \"File name contains invalid character '%c'\", c);\n        }\n        ensuref(!fileNames.count(fi), \"File name '%s' is not unique\", fi.c_str());\n        fileNames.insert(fi);\n    }\n\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        string si = inf.readLine();\n        int len = si.length();\n        ensuref(len >=1 && len <=8, \"Query string length should be between 1 and 8, but it is %d\", len);\n        for (char c : si) {\n            ensuref(isdigit(c) || (c >= 'a' && c <= 'z') || c == '.', \"Query string contains invalid character '%c'\", c);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This problem allows multiple correct answers, because for each query,\n  any file containing the query as a substring is a valid suggestion.\n\n  The reported \"Token 'contests' doesn't correspond to pattern 'Query #1: file or '-''\"\n  error happens because testlib interprets a single string argument to readToken()\n  as a *regular expression* rather than a descriptive variable name.\n\n  To fix this:\n    1. Use two arguments for readToken(): the first one is the regular expression,\n       the second one is the variable name used only in error messages.\n    2. A simple pattern to capture a non-empty token is \".+\" (meaning 'one or more\n       of any character except for line breaks').\n\n  We also do not attempt to read extra data beyond what we need (2 tokens per query),\n  thus avoiding potential timeouts if the solution never closes its output.\n*/\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read the file names from the test input\n    int n = inf.readInt();\n    vector<string> files(n);\n    for(int i = 0; i < n; i++) {\n        files[i] = inf.readToken();\n    }\n\n    // Read the queries\n    int q = inf.readInt();\n    vector<string> queries(q);\n    for(int i = 0; i < q; i++) {\n        queries[i] = inf.readToken();\n    }\n\n    // For each query, we read exactly 2 tokens from participant's output:\n    //   1. An integer in [0..n] representing the reported count\n    //   2. A token (non-empty) which is either \"-\" or a file name\n    for(int i = 0; i < q; i++)\n    {\n        int reportedCount = ouf.readInt(\n            0,         // minimum\n            n,         // maximum\n            (\"Query #\" + to_string(i+1) + \": reported count\").c_str()\n        );\n\n        // Here, \".+\" is the pattern meaning \"at least one character (no whitespace)\"\n        // The second argument is only for the error message if there's a problem.\n        string fileOrDash = ouf.readToken(\n            \".+\",\n            (\"Query #\" + to_string(i+1) + \": file or '-'\").c_str()\n        );\n\n        // Compute how many files match the current query\n        vector<string> matched;\n        for(const auto &fname : files) {\n            if(fname.find(queries[i]) != string::npos) {\n                matched.push_back(fname);\n            }\n        }\n        int correctCount = (int)matched.size();\n\n        // Compare the participant's reported count with the correct count\n        if(reportedCount != correctCount) {\n            ouf.quitf(_wa,\n                \"Query #%d: expected %d matches, got %d\",\n                i + 1, correctCount, reportedCount\n            );\n        }\n\n        // If no matches, the second token should be \"-\"\n        if(correctCount == 0) {\n            if(fileOrDash != \"-\") {\n                ouf.quitf(_wa,\n                    \"Query #%d: expected '-' for zero matches, got '%s'\",\n                    i + 1, fileOrDash.c_str()\n                );\n            }\n        } else {\n            // If there's at least one match, the fileOrDash must be among the matched files\n            if(fileOrDash == \"-\") {\n                ouf.quitf(_wa,\n                    \"Query #%d: reported '-' but there are %d matches\",\n                    i + 1, correctCount\n                );\n            }\n            bool ok = false;\n            for(const auto &m : matched) {\n                if(m == fileOrDash) {\n                    ok = true;\n                    break;\n                }\n            }\n            if(!ok) {\n                ouf.quitf(_wa,\n                    \"Query #%d: reported file '%s' is not among valid matches\",\n                    i + 1, fileOrDash.c_str()\n                );\n            }\n        }\n    }\n\n    // We do not read or check extra data to avoid possible timeouts.\n    ouf.quitf(_ok, \"All queries are correct.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> filenames;\n\n    set<string> used;\n\n    const string chars = \"abcdefghijklmnopqrstuvwxyz0123456789.\";\n\n    if (type == \"random\") {\n        // Generate n unique random filenames of random length between 1 and 8\n        for (int i = 0; i < n; ) {\n            int len = rnd.next(1,8);\n            string name;\n            for (int j = 0; j < len; ++j) {\n                name += chars[rnd.next(0, int(chars.size()) - 1)];\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Generate q random queries of random length between 1 and 8\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            int len = rnd.next(1,8);\n            string query;\n            for (int j = 0; j < len; ++j) {\n                query += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            queries.push_back(query);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n\n    } else if (type == \"maxlen\") {\n        // Generate n unique filenames of length 8\n        for (int i = 0; i < n; ) {\n            string name;\n            for (int j = 0; j < 8; ++j) {\n                name += chars[rnd.next(0, int(chars.size()) - 1)];\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Generate q random queries of length 8\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            string query;\n            for (int j = 0; j < 8; ++j) {\n                query += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            queries.push_back(query);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"minlen\") {\n        // Generate filenames of length 1\n        if (n > int(chars.size())) {\n            fprintf(stderr, \"Cannot generate %d unique filenames of length 1\\n\", n);\n            exit(1);\n        }\n        for (int i = 0; i < n; ) {\n            char c = chars[rnd.next(0, int(chars.size()) - 1)];\n            string name(1, c);\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Generate q queries of length 1\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            char c = chars[rnd.next(0, int(chars.size()) -1)];\n            string query(1, c);\n            queries.push_back(query);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"all_match\") {\n        // All file names contain 'a' as substring\n        string common = \"a\";\n        // Build file names that all contain 'a' as substring\n        for (int i = 0; i < n; ) {\n            int len = rnd.next(1,8);\n            string name;\n            int pos = rnd.next(0, len - 1);\n            for (int j = 0; j < len; ++j) {\n                if (j == pos) {\n                    name += common;\n                } else {\n                    name += chars[rnd.next(0, int(chars.size()) - 1)];\n                }\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Build q queries, all are 'a'\n        vector<string> queries(q, common);\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"no_match\") {\n        // Generate filenames\n        for (int i = 0; i < n; ) {\n            int len = rnd.next(1,8);\n            string name;\n            for (int j = 0; j < len; ++j) {\n                name += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // For queries, ensure that they don't appear as substrings in any filenames\n        // Collect all substrings of filenames\n        set<string> substrings_of_filenames;\n        for (auto &name : filenames) {\n            int len = name.size();\n            for (int i = 0; i < len; ++i) {\n                for (int j = i+1; j <= len; ++j) {\n                    substrings_of_filenames.insert(name.substr(i, j - i));\n                }\n            }\n        }\n        vector<string> queries;\n        for (int i = 0; i < q; ) {\n            int len = rnd.next(1,8);\n            string query;\n            for (int j = 0; j < len; ++j) {\n                query += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            if (substrings_of_filenames.count(query)) continue;\n            queries.push_back(query);\n            ++i;\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"queries_repeat\") {\n        // Generate random filenames\n        for (int i = 0; i < n; ) {\n            int len = rnd.next(1,8);\n            string name;\n            for (int j = 0; j < len; ++j) {\n                name += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Generate q queries where only a few unique queries are repeated multiple times\n        int num_unique_queries = min(q / 10, 1000);\n        vector<string> unique_queries;\n        for (int i = 0; i < num_unique_queries; ) {\n            int len = rnd.next(1,8);\n            string query;\n            for (int j = 0; j < len; ++j) {\n                query += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            unique_queries.push_back(query);\n            ++i;\n        }\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            int idx = rnd.next(0, num_unique_queries - 1);\n            queries.push_back(unique_queries[idx]);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"maximal_overlap\") {\n        // Generate filenames designed to cause maximal overlapping substrings\n        filenames.push_back(\"a\");\n        used.insert(\"a\");\n        for (int i = 1; i < n; ) {\n            string last = filenames.back();\n            // Extend by one character\n            if (last.size() >= 8) {\n                last = last.substr(1); // Trim from front to keep length <=8\n            }\n            char c = chars[rnd.next(0, int(chars.size()) - 1)];\n            string name = last + c;\n            if (used.count(name)) {\n                continue;\n            }\n            filenames.push_back(name);\n            used.insert(name);\n            ++i;\n        }\n        // Generate queries that are substrings of these filenames\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            string name = filenames[rnd.next(0, n - 1)];\n            if (name.size() == 1) {\n                queries.push_back(name);\n                continue;\n            }\n            int len = rnd.next(1, int(name.size()));\n            int start = rnd.next(0, int(name.size()) - len);\n            string query = name.substr(start, len);\n            queries.push_back(query);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"special_chars\") {\n        // Generate filenames and queries with dots\n        for (int i = 0; i < n; ) {\n            int len = rnd.next(1,8);\n            string name;\n            for (int j = 0; j < len; ++j) {\n                if (rnd.next(0, 1) == 0)\n                    name += '.';\n                else\n                    name += chars[rnd.next(0, 25)];\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Generate queries with dots\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            int len = rnd.next(1,8);\n            string query;\n            for (int j = 0; j < len; ++j) {\n                if (rnd.next(0, 1) == 0)\n                    query += '.';\n                else\n                    query += chars[rnd.next(0, 25)];\n            }\n            queries.push_back(query);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> filenames;\n\n    set<string> used;\n\n    const string chars = \"abcdefghijklmnopqrstuvwxyz0123456789.\";\n\n    if (type == \"random\") {\n        // Generate n unique random filenames of random length between 1 and 8\n        for (int i = 0; i < n; ) {\n            int len = rnd.next(1,8);\n            string name;\n            for (int j = 0; j < len; ++j) {\n                name += chars[rnd.next(0, int(chars.size()) - 1)];\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Generate q random queries of random length between 1 and 8\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            int len = rnd.next(1,8);\n            string query;\n            for (int j = 0; j < len; ++j) {\n                query += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            queries.push_back(query);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n\n    } else if (type == \"maxlen\") {\n        // Generate n unique filenames of length 8\n        for (int i = 0; i < n; ) {\n            string name;\n            for (int j = 0; j < 8; ++j) {\n                name += chars[rnd.next(0, int(chars.size()) - 1)];\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Generate q random queries of length 8\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            string query;\n            for (int j = 0; j < 8; ++j) {\n                query += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            queries.push_back(query);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"minlen\") {\n        // Generate filenames of length 1\n        if (n > int(chars.size())) {\n            fprintf(stderr, \"Cannot generate %d unique filenames of length 1\\n\", n);\n            exit(1);\n        }\n        for (int i = 0; i < n; ) {\n            char c = chars[rnd.next(0, int(chars.size()) - 1)];\n            string name(1, c);\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Generate q queries of length 1\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            char c = chars[rnd.next(0, int(chars.size()) -1)];\n            string query(1, c);\n            queries.push_back(query);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"all_match\") {\n        // All file names contain 'a' as substring\n        string common = \"a\";\n        // Build file names that all contain 'a' as substring\n        for (int i = 0; i < n; ) {\n            int len = rnd.next(1,8);\n            string name;\n            int pos = rnd.next(0, len - 1);\n            for (int j = 0; j < len; ++j) {\n                if (j == pos) {\n                    name += common;\n                } else {\n                    name += chars[rnd.next(0, int(chars.size()) - 1)];\n                }\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Build q queries, all are 'a'\n        vector<string> queries(q, common);\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"no_match\") {\n        // Generate filenames\n        for (int i = 0; i < n; ) {\n            int len = rnd.next(1,8);\n            string name;\n            for (int j = 0; j < len; ++j) {\n                name += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // For queries, ensure that they don't appear as substrings in any filenames\n        // Collect all substrings of filenames\n        set<string> substrings_of_filenames;\n        for (auto &name : filenames) {\n            int len = name.size();\n            for (int i = 0; i < len; ++i) {\n                for (int j = i+1; j <= len; ++j) {\n                    substrings_of_filenames.insert(name.substr(i, j - i));\n                }\n            }\n        }\n        vector<string> queries;\n        for (int i = 0; i < q; ) {\n            int len = rnd.next(1,8);\n            string query;\n            for (int j = 0; j < len; ++j) {\n                query += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            if (substrings_of_filenames.count(query)) continue;\n            queries.push_back(query);\n            ++i;\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"queries_repeat\") {\n        // Generate random filenames\n        for (int i = 0; i < n; ) {\n            int len = rnd.next(1,8);\n            string name;\n            for (int j = 0; j < len; ++j) {\n                name += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Generate q queries where only a few unique queries are repeated multiple times\n        int num_unique_queries = min(q / 10, 1000);\n        vector<string> unique_queries;\n        for (int i = 0; i < num_unique_queries; ) {\n            int len = rnd.next(1,8);\n            string query;\n            for (int j = 0; j < len; ++j) {\n                query += chars[rnd.next(0, int(chars.size()) -1)];\n            }\n            unique_queries.push_back(query);\n            ++i;\n        }\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            int idx = rnd.next(0, num_unique_queries - 1);\n            queries.push_back(unique_queries[idx]);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"maximal_overlap\") {\n        // Generate filenames designed to cause maximal overlapping substrings\n        filenames.push_back(\"a\");\n        used.insert(\"a\");\n        for (int i = 1; i < n; ) {\n            string last = filenames.back();\n            // Extend by one character\n            if (last.size() >= 8) {\n                last = last.substr(1); // Trim from front to keep length <=8\n            }\n            char c = chars[rnd.next(0, int(chars.size()) - 1)];\n            string name = last + c;\n            if (used.count(name)) {\n                continue;\n            }\n            filenames.push_back(name);\n            used.insert(name);\n            ++i;\n        }\n        // Generate queries that are substrings of these filenames\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            string name = filenames[rnd.next(0, n - 1)];\n            if (name.size() == 1) {\n                queries.push_back(name);\n                continue;\n            }\n            int len = rnd.next(1, int(name.size()));\n            int start = rnd.next(0, int(name.size()) - len);\n            string query = name.substr(start, len);\n            queries.push_back(query);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else if (type == \"special_chars\") {\n        // Generate filenames and queries with dots\n        for (int i = 0; i < n; ) {\n            int len = rnd.next(1,8);\n            string name;\n            for (int j = 0; j < len; ++j) {\n                if (rnd.next(0, 1) == 0)\n                    name += '.';\n                else\n                    name += chars[rnd.next(0, 25)];\n            }\n            if (used.count(name)) continue;\n            used.insert(name);\n            filenames.push_back(name);\n            ++i;\n        }\n        // Generate queries with dots\n        vector<string> queries;\n        for (int i = 0; i < q; ++i) {\n            int len = rnd.next(1,8);\n            string query;\n            for (int j = 0; j < len; ++j) {\n                if (rnd.next(0, 1) == 0)\n                    query += '.';\n                else\n                    query += chars[rnd.next(0, 25)];\n            }\n            queries.push_back(query);\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto &name : filenames)\n            printf(\"%s\\n\", name.c_str());\n        printf(\"%d\\n\", q);\n        for (auto &query : queries)\n            printf(\"%s\\n\", query.c_str());\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -type random\n./gen -n 10 -q 20 -type random\n./gen -n 100 -q 200 -type random\n./gen -n 1000 -q 5000 -type random\n./gen -n 10000 -q 50000 -type random\n\n./gen -n 10 -q 10 -type maxlen\n./gen -n 100 -q 100 -type maxlen\n./gen -n 1000 -q 1000 -type maxlen\n./gen -n 10000 -q 50000 -type maxlen\n\n./gen -n 10 -q 10 -type minlen\n./gen -n 37 -q 50 -type minlen\n\n./gen -n 100 -q 500 -type all_match\n./gen -n 1000 -q 5000 -type all_match\n./gen -n 10000 -q 50000 -type all_match\n\n./gen -n 100 -q 500 -type no_match\n./gen -n 1000 -q 5000 -type no_match\n./gen -n 10000 -q 50000 -type no_match\n\n./gen -n 1000 -q 5000 -type queries_repeat\n./gen -n 10000 -q 50000 -type queries_repeat\n\n./gen -n 1000 -q 5000 -type maximal_overlap\n./gen -n 10000 -q 50000 -type maximal_overlap\n\n./gen -n 10000 -q 50000 -type special_chars\n\n./gen -n 10000 -q 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:24.448307",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/I",
      "title": "I. Privatization of Roads in Berland",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput contains one or several test cases. The first line contains an integer tt (1≤t≤3001≤t≤300) — the number of test cases in the input. Solve test cases separately, test cases are completely independent and do not affect each other.The following lines describe the test cases. Each case starts with a line consisting of three space-separated integers nn, mm and kk (2≤n≤6002≤n≤600, 1≤m≤6001≤m≤600, 1≤k≤n−11≤k≤n−1) — the number of cities, the number of roads and the maximum diversity of the roads adjacent to a city.Then mm lines follow, each having a pair of space-separated integers aiai, bibi (1≤ai,bi≤n1≤ai,bi≤n; ai≠biai≠bi). It means that the ii-th road connects cities aiai and bibi. All roads are two-way. There is at most one road between a pair of the cities.The sum of nn values for all test cases doesn't exceed 600600. The sum of mm values for all test cases doesn't exceed 600600.",
      "output_spec": "OutputPrint tt lines: the ii-th line should contain the answer for the ii-th test case. For a test case, print a sequence of integers c1,c2,…,cmc1,c2,…,cm separated by space, where cici (1≤ci≤1005001≤ci≤100500) is the company which owns the ii-th road in your plan. If there are multiple solutions, output any of them. If there is no solution for a test case, print c1=c2=…=cm=0c1=c2=…=cm=0.",
      "sample_tests": "ExampleInputCopy33 3 21 22 33 14 5 21 21 31 42 32 44 6 21 21 31 42 32 43 4OutputCopy1 2 3 2 1 1 2 3 0 0 0 0 0 0",
      "description": "I. Privatization of Roads in Berland\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput contains one or several test cases. The first line contains an integer tt (1≤t≤3001≤t≤300) — the number of test cases in the input. Solve test cases separately, test cases are completely independent and do not affect each other.The following lines describe the test cases. Each case starts with a line consisting of three space-separated integers nn, mm and kk (2≤n≤6002≤n≤600, 1≤m≤6001≤m≤600, 1≤k≤n−11≤k≤n−1) — the number of cities, the number of roads and the maximum diversity of the roads adjacent to a city.Then mm lines follow, each having a pair of space-separated integers aiai, bibi (1≤ai,bi≤n1≤ai,bi≤n; ai≠biai≠bi). It means that the ii-th road connects cities aiai and bibi. All roads are two-way. There is at most one road between a pair of the cities.The sum of nn values for all test cases doesn't exceed 600600. The sum of mm values for all test cases doesn't exceed 600600.\n\nOutputPrint tt lines: the ii-th line should contain the answer for the ii-th test case. For a test case, print a sequence of integers c1,c2,…,cmc1,c2,…,cm separated by space, where cici (1≤ci≤1005001≤ci≤100500) is the company which owns the ii-th road in your plan. If there are multiple solutions, output any of them. If there is no solution for a test case, print c1=c2=…=cm=0c1=c2=…=cm=0.\n\nInputCopy33 3 21 22 33 14 5 21 21 31 42 32 44 6 21 21 31 42 32 43 4OutputCopy1 2 3 2 1 1 2 3 0 0 0 0 0 0\n\nInputCopy33 3 21 22 33 14 5 21 21 31 42 32 44 6 21 21 31 42 32 43 4\n\nOutputCopy1 2 3 2 1 1 2 3 0 0 0 0 0 0",
      "solutions": [
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces",
          "content": "Hello!ACM-ICPC Southern Subregional Contest (NEERC/Northern Eurasia) 2018 has ended on October 16. There were 72 teams onsite in Saratov, most of them were invited because of their result on the qualification stage.On Saturday, October 20, 2018 at 16:05UTC+8 will start online-mirror 2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred).In this contest I play a role of Cheif Judge and the jury teams consists of ex-participants of ICPC from Saratov and jury members from other cities. Many thanks to all of them! I hope you will like the problems!I invite ACM-ICPC teams and individual participants of Codeforces competitions to take part! Sure, the contest will be unrated.MikeMirzayanov",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/62570",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 737
        },
        {
          "title": "Solution to problem M. Algoland and Berland of 2018-2019 ICPC, NEERC - Codeforces",
          "content": "Today, I solved a beautiful problem from the NEERC Subregional Contest: Problem M. Since I didn't find an editorial nor a solution in the comments, I decided to write this blog about my solution. For a visualization of my solution see: Visualization of the program The problem boils down to constructing a spanning tree of a 2D point set with certain constraints. No three points in the point set are collinear. The points have two colors: red and blue. There is at least one blue and one red point. The constraints on the spanning tree are: Edges of the spanning tree can only intersect at the ends, if they are drawn as line segments. Edges of the spanning tree can only connect points with different colors. For each blue point, the degree of the point in the spanning tree should be equal to riri. The constraints on riri are nice: 1≤ri≤# of red points1≤ri≤# of red points. And ∑ri=n−1∑ri=n−1, which is of course needed if the final graph needs to be a tree. It turns out that these conditions are strong enough that it is always possible to construct a spanning tree!Let's prove this by induction on the size of the point set, nn.Base case n=2n=2Because there is at least one red and one blue point, the smallest case is n=2n=2: one red and one blue point. Because of the constraint ∑ri=n−1=1∑ri=n−1=1, this means that the degree of the only blue point left is 1. The trivial solution is to connect the blue and the red point.Induction step n>2n>2:Now the hard part; Let's assume it is possible to make a spanning tree for all 2≤k<n2≤k<n. Now we are given a point set with nn points, how do we construct the spanning tree for it? First, let's sort the points on their x-coordinate. We use the y-coordinate as a tiebreaker. Let's do casework on the colors of the leftmost and rightmost point:Case 1: extreme points have different colorsLet's analyze the convex hull of the point set. As these two points both lie on the convex hull, the convex hull contains at least one red and one blue point. Certainly, there must be an adjacent pair of points on the hull with different colors. Let's connect these with an edge. If riri of the blue point is 1, we delete this point. Else we delete the red point, and lower riri by one. Notice that both the ∑ri∑ri and nn decreased by one, so the resulting riri satisfy all constraints. It can also be verified that at least one red and blue point remain, with some casework. So we can use the induction hypothesis on this smaller point set, which gives us a spanning tree. Could our newly added edge intersect with an existing edge? No, because the edge lies on the convex hull. So in this case we are done.For the last two cases, where both extreme points have the same color, we will use a different technique. Let's give each point a weight, For blue points, we set wi=−1+riwi=−1+ri. For red points we set wi=−1wi=−1. If the sum of weights is -1, that means ∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1. So if we could somehow split the point set with a vertical line through some point, such that the left and right halve both have the sum of weights equal to -1, we could use the induction hypothesis. For this to work we need both sides to have at least one point of each color. Case 2: extreme points are both blueLet's look at the prefix sums of the weights of the point set in sorted order. So the prefix sum is pk=∑i<kwipk=∑i<kwi, where the points are labeled from left to right. Because the total prefix sum is −1−1, and the prefix sum starts at 00, it must cross from nonnegative to negative at some point. Because the weights of all blue points are nonnegative the only place this can happen is at a red point. Because the weight of a red point is −1−1, it will cross from 00 to −1−1, and this is exactly what we wanted, a sum of weight equal to −1−1. Now we can draw a vertical line through this red point, and by the induction hypothesis construct two spanning trees, one containing all points to the left and the mid point, and one with all points to the right and the middle red point. Note that because the red point can't be one of the extreme points, the two point sets are definitely smaller than the initial point set. Since these spanning trees exist in two disjoint regions, they don't intersect. And they connect at the midpoint, so their union is a valid spanning tree of the whole point set! To ensure the regions are disjoint even if there are ties in x-coordinates, we tilt the splitting line slighly.Case 3: extreme points are both redWe do exactly the same, looking for a prefix sum which is equal to −1−1. Now it turns out this is sometimes not possible. But by similar (but inverted) logic as in Case 2, there exists a blue point, such that the prefix sum goes from negative to nonnegative. We again make a vertical splitting line through this point, but now we modify the riri we will use for this blue midpoint in the left and right subproblem. We choose these new riri's such that the sum of weights in the left and right point sets is again −1−1. Then we apply the induction hypothesis to get two valid spanning trees of the left and right side. And the union of these spanning trees will be a valid spanning tree for the entire point set. This concludes the proof.This proof is constructive, so for actually generating a spanning tree we can follow the induction logic backwards until the spanning tree is fully constructed. The easiest way to code this is to make a recursive function that constructs a spanning tree for the point set it's given. Based on the colors of the outermost points we either calculate a convex hull or prefix sums from left to right and call the function recursively. We only recurse nn times, and the complexity per call can be made O(nlogn)O(nlog⁡n), so this gives O(n2logn)O(n2log⁡n). But if we additionally presort the points and ensure the point set stays sorted in the recursive calls, the convex hull calculation can also be done in linear time, resulting in O(n2)O(n2) running time. Although this is not needed, I think this approach can be optimized further by using Smart divide and conquer and Decremental convex hull, and some modifications to quickly find two oppositely colored adjacent points on the convex hull. This would give a recursive formula for the time complexity of T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log(n))=O(nlog2n)T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log⁡(n))=O(nlog2⁡n), but this is definitely not needed to get AC.My code can be found here: submission",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/105126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6546
        }
      ],
      "code_examples": [
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 1",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 2",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 3",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 4",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 5",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 6",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 300, \"t\");\n    inf.readEoln();\n\n    int total_n = 0;\n    int total_m = 0;\n\n    for (int testCase = 0; testCase < t; ++testCase) {\n        int n = inf.readInt(2, 600, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 600, \"m\");\n        inf.readSpace();\n        int k = inf.readInt(1, n - 1, \"k\");\n        inf.readEoln();\n\n        total_n += n;\n        total_m += m;\n\n        ensuref(total_n <= 600, \"Sum of n over all test cases can't exceed 600 but is %d after test case %d.\", total_n, testCase + 1);\n        ensuref(total_m <= 600, \"Sum of m over all test cases can't exceed 600 but is %d after test case %d.\", total_m, testCase +1);\n\n        set<pair<int, int>> edges;\n\n        for (int i = 0; i < m; ++i) {\n            int a_i = inf.readInt(1, n, \"a_i\");\n            inf.readSpace();\n            int b_i = inf.readInt(1, n, \"b_i\");\n            inf.readEoln();\n\n            ensuref(a_i != b_i, \"Road cannot connect a city to itself (no self-loops): a_i (%d) == b_i (%d).\", a_i, b_i);\n\n            // Ensure at most one road between any pair of cities\n            int u = a_i;\n            int v = b_i;\n            if (u > v) swap(u, v);\n            pair<int, int> edge = make_pair(u, v);\n\n            ensuref(edges.count(edge) == 0, \"Multiple roads connect the same pair of cities (%d, %d).\", u, v);\n            edges.insert(edge);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 300, \"t\");\n    inf.readEoln();\n\n    int total_n = 0;\n    int total_m = 0;\n\n    for (int testCase = 0; testCase < t; ++testCase) {\n        int n = inf.readInt(2, 600, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 600, \"m\");\n        inf.readSpace();\n        int k = inf.readInt(1, n - 1, \"k\");\n        inf.readEoln();\n\n        total_n += n;\n        total_m += m;\n\n        ensuref(total_n <= 600, \"Sum of n over all test cases can't exceed 600 but is %d after test case %d.\", total_n, testCase + 1);\n        ensuref(total_m <= 600, \"Sum of m over all test cases can't exceed 600 but is %d after test case %d.\", total_m, testCase +1);\n\n        set<pair<int, int>> edges;\n\n        for (int i = 0; i < m; ++i) {\n            int a_i = inf.readInt(1, n, \"a_i\");\n            inf.readSpace();\n            int b_i = inf.readInt(1, n, \"b_i\");\n            inf.readEoln();\n\n            ensuref(a_i != b_i, \"Road cannot connect a city to itself (no self-loops): a_i (%d) == b_i (%d).\", a_i, b_i);\n\n            // Ensure at most one road between any pair of cities\n            int u = a_i;\n            int v = b_i;\n            if (u > v) swap(u, v);\n            pair<int, int> edge = make_pair(u, v);\n\n            ensuref(edges.count(edge) == 0, \"Multiple roads connect the same pair of cities (%d, %d).\", u, v);\n            edges.insert(edge);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 300, \"t\");\n    inf.readEoln();\n\n    int total_n = 0;\n    int total_m = 0;\n\n    for (int testCase = 0; testCase < t; ++testCase) {\n        int n = inf.readInt(2, 600, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 600, \"m\");\n        inf.readSpace();\n        int k = inf.readInt(1, n - 1, \"k\");\n        inf.readEoln();\n\n        total_n += n;\n        total_m += m;\n\n        ensuref(total_n <= 600, \"Sum of n over all test cases can't exceed 600 but is %d after test case %d.\", total_n, testCase + 1);\n        ensuref(total_m <= 600, \"Sum of m over all test cases can't exceed 600 but is %d after test case %d.\", total_m, testCase +1);\n\n        set<pair<int, int>> edges;\n\n        for (int i = 0; i < m; ++i) {\n            int a_i = inf.readInt(1, n, \"a_i\");\n            inf.readSpace();\n            int b_i = inf.readInt(1, n, \"b_i\");\n            inf.readEoln();\n\n            ensuref(a_i != b_i, \"Road cannot connect a city to itself (no self-loops): a_i (%d) == b_i (%d).\", a_i, b_i);\n\n            // Ensure at most one road between any pair of cities\n            int u = a_i;\n            int v = b_i;\n            if (u > v) swap(u, v);\n            pair<int, int> edge = make_pair(u, v);\n\n            ensuref(edges.count(edge) == 0, \"Multiple roads connect the same pair of cities (%d, %d).\", u, v);\n            edges.insert(edge);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int t = inf.readInt(); // number of test cases\n\n    for (int testCase = 1; testCase <= t; testCase++) {\n        int n = inf.readInt(); // number of cities\n        int m = inf.readInt(); // number of roads\n        int k = inf.readInt(); // maximum number of companies adjacent to a city\n\n        vector<int> A(m), B(m);\n        for (int i = 0; i < m; i++) {\n            A[i] = inf.readInt(1, n); // city a_i\n            B[i] = inf.readInt(1, n); // city b_i\n            if (A[i] == B[i]) {\n                quitf(_fail, \"Invalid input: road connects city %d to itself\", A[i]);\n            }\n        }\n\n        // Read participant's output\n        vector<int> p_c = ouf.readInts(m, 0, 100500, \"participant's company assignments\");\n        // Read jury's output\n        vector<int> j_c = ans.readInts(m, 0, 100500, \"jury's company assignments\");\n\n        // Function to check if all elements are zeros\n        auto allZeros = [](const vector<int>& vec) -> bool {\n            return all_of(vec.begin(), vec.end(), [](int x) { return x == 0; });\n        };\n\n        if (allZeros(p_c)) {\n            if (allZeros(j_c)) {\n                // Both participant and jury agree that there is no solution\n                continue;\n            } else {\n                // Participant says no solution, but jury found a solution\n                quitf(_wa, \"Participant claims no solution exists in test case #%d, but a solution exists\", testCase);\n            }\n        } else {\n            // Check participant's assignments for validity\n            // Check that each company owns at most two roads\n            map<int, int> company_counts;\n            for (int i = 0; i < m; i++) {\n                int c = p_c[i];\n                if (c == 0) {\n                    quitf(_wa, \"Invalid company number 0 in test case #%d\", testCase);\n                }\n                company_counts[c]++;\n                if (company_counts[c] > 2) {\n                    quitf(_wa, \"Company %d owns more than two roads in test case #%d\", c, testCase);\n                }\n            }\n\n            // For each city, collect the companies adjacent to it\n            vector<set<int>> city_companies(n + 1); // cities are 1-indexed\n            for (int i = 0; i < m; i++) {\n                int c = p_c[i];\n                city_companies[A[i]].insert(c);\n                city_companies[B[i]].insert(c);\n            }\n\n            // Check that each city is adjacent to at most k companies\n            for (int u = 1; u <= n; u++) {\n                if ((int)city_companies[u].size() > k) {\n                    quitf(_wa, \"City %d is adjacent to %d companies, which exceeds k=%d in test case #%d\", \n                          u, city_companies[u].size(), k, testCase);\n                }\n            }\n\n            // If jury's answer is all zeros but participant found a solution\n            if (allZeros(j_c)) {\n                quitf(_fail, \"Participant found a solution in test case #%d, but jury says no solution exists\", testCase);\n            }\n            // Participant's answer is valid\n        }\n    }\n\n    // All test cases passed\n    quitf(_ok, \"All participant's answers are correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"possible\");\n    int t = opt<int>(\"t\", 1);\n\n    int total_n = 0;\n    int total_m = 0;\n\n    vector<string> test_cases;\n\n    for(int test = 0; test < t; ++test) {\n        int cur_n = n;\n        int cur_m = m;\n        int cur_k = k;\n        vector<pair<int, int> > edges;\n\n        if(type == \"possible\") {\n            // Adjust cur_n and cur_m to not exceed limits\n            cur_n = min(cur_n, 600 - total_n);\n            cur_m = min(cur_m, cur_n * (cur_n - 1) / 2);\n            cur_m = min(cur_m, 600 - total_m);\n            if(cur_n < 2 || cur_m <1) break;\n\n            // Ensure k in range\n            cur_k = min(cur_k, cur_n -1);\n            cur_k = max(cur_k, 1);\n\n            // Generate a random connected graph\n            edges.clear();\n            for(int i = 2; i <= cur_n; ++i) {\n                int pi = rnd.next(1, i -1);\n                edges.push_back({pi, i});\n            }\n            set<pair<int, int> > edge_set(edges.begin(), edges.end());\n            while((int)edge_set.size() < cur_m) {\n                int u = rnd.next(1, cur_n);\n                int v = rnd.next(1, cur_n);\n                if(u != v) {\n                    if(u > v) swap(u, v);\n                    edge_set.insert({u, v});\n                }\n            }\n            edges.assign(edge_set.begin(), edge_set.end());\n        } else if(type == \"impossible\") {\n            // Adjust cur_n and cur_m to not exceed limits\n            cur_n = min(cur_n, 600 - total_n);\n            cur_m = min(cur_m, cur_n * (cur_n - 1) / 2);\n            cur_m = min(cur_m, 600 - total_m);\n            if(cur_n < 2 || cur_m <1) break;\n\n            cur_k = 1; // force k =1\n            int center = 1;\n            edges.clear();\n            for(int i = 2; i <= cur_n; ++i) {\n                edges.push_back({center, i});\n            }\n            cur_m = edges.size();\n\n            if(cur_m < m) {\n                set<pair<int,int> > edge_set(edges.begin(), edges.end());\n                while ((int)edge_set.size() < m) {\n                    int u = rnd.next(2, cur_n);\n                    int v = rnd.next(2, cur_n);\n                    if(u != v) {\n                        if(u > v) swap(u, v);\n                        if(edge_set.count({u,v}) == 0) {\n                            edge_set.insert({u, v});\n                        }\n                    }\n                }\n                edges.assign(edge_set.begin(), edge_set.end());\n                cur_m = edges.size();\n            }\n        } else if(type == \"edge_case\") {\n            cur_n = 4;\n            cur_m = 3;\n            cur_k = 1;\n            edges = {{1,2}, {1,3}, {1,4}};\n        }\n\n        total_n += cur_n;\n        total_m += cur_m;\n\n        if(total_n > 600 || total_m >600) {\n            break;\n        }\n\n        stringstream ss;\n        ss << cur_n << ' ' << cur_m << ' ' << cur_k << '\\n';\n        for(auto edge : edges) {\n            ss << edge.first << ' ' << edge.second << '\\n';\n        }\n\n        test_cases.push_back(ss.str());\n    }\n\n    cout << test_cases.size() << '\\n';\n    for(auto &tc : test_cases) {\n        cout << tc;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"possible\");\n    int t = opt<int>(\"t\", 1);\n\n    int total_n = 0;\n    int total_m = 0;\n\n    vector<string> test_cases;\n\n    for(int test = 0; test < t; ++test) {\n        int cur_n = n;\n        int cur_m = m;\n        int cur_k = k;\n        vector<pair<int, int> > edges;\n\n        if(type == \"possible\") {\n            // Adjust cur_n and cur_m to not exceed limits\n            cur_n = min(cur_n, 600 - total_n);\n            cur_m = min(cur_m, cur_n * (cur_n - 1) / 2);\n            cur_m = min(cur_m, 600 - total_m);\n            if(cur_n < 2 || cur_m <1) break;\n\n            // Ensure k in range\n            cur_k = min(cur_k, cur_n -1);\n            cur_k = max(cur_k, 1);\n\n            // Generate a random connected graph\n            edges.clear();\n            for(int i = 2; i <= cur_n; ++i) {\n                int pi = rnd.next(1, i -1);\n                edges.push_back({pi, i});\n            }\n            set<pair<int, int> > edge_set(edges.begin(), edges.end());\n            while((int)edge_set.size() < cur_m) {\n                int u = rnd.next(1, cur_n);\n                int v = rnd.next(1, cur_n);\n                if(u != v) {\n                    if(u > v) swap(u, v);\n                    edge_set.insert({u, v});\n                }\n            }\n            edges.assign(edge_set.begin(), edge_set.end());\n        } else if(type == \"impossible\") {\n            // Adjust cur_n and cur_m to not exceed limits\n            cur_n = min(cur_n, 600 - total_n);\n            cur_m = min(cur_m, cur_n * (cur_n - 1) / 2);\n            cur_m = min(cur_m, 600 - total_m);\n            if(cur_n < 2 || cur_m <1) break;\n\n            cur_k = 1; // force k =1\n            int center = 1;\n            edges.clear();\n            for(int i = 2; i <= cur_n; ++i) {\n                edges.push_back({center, i});\n            }\n            cur_m = edges.size();\n\n            if(cur_m < m) {\n                set<pair<int,int> > edge_set(edges.begin(), edges.end());\n                while ((int)edge_set.size() < m) {\n                    int u = rnd.next(2, cur_n);\n                    int v = rnd.next(2, cur_n);\n                    if(u != v) {\n                        if(u > v) swap(u, v);\n                        if(edge_set.count({u,v}) == 0) {\n                            edge_set.insert({u, v});\n                        }\n                    }\n                }\n                edges.assign(edge_set.begin(), edge_set.end());\n                cur_m = edges.size();\n            }\n        } else if(type == \"edge_case\") {\n            cur_n = 4;\n            cur_m = 3;\n            cur_k = 1;\n            edges = {{1,2}, {1,3}, {1,4}};\n        }\n\n        total_n += cur_n;\n        total_m += cur_m;\n\n        if(total_n > 600 || total_m >600) {\n            break;\n        }\n\n        stringstream ss;\n        ss << cur_n << ' ' << cur_m << ' ' << cur_k << '\\n';\n        for(auto edge : edges) {\n            ss << edge.first << ' ' << edge.second << '\\n';\n        }\n\n        test_cases.push_back(ss.str());\n    }\n\n    cout << test_cases.size() << '\\n';\n    for(auto &tc : test_cases) {\n        cout << tc;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -k 1 -t 1 -type possible\n./gen -n 2 -m 1 -k 1 -t 1 -type impossible\n./gen -n 3 -m 3 -k 2 -t 1 -type possible\n./gen -n 3 -m 3 -k 1 -t 1 -type impossible\n./gen -n 4 -m 3 -k 1 -t 1 -type edge_case\n./gen -n 10 -m 15 -k 5 -t 2 -type possible\n./gen -n 10 -m 15 -k 1 -t 2 -type impossible\n./gen -n 100 -m 200 -k 99 -t 1 -type possible\n./gen -n 300 -m 450 -k 299 -t 1 -type possible\n./gen -n 50 -m 100 -k 1 -t 1 -type impossible\n./gen -n 50 -m 100 -k 2 -t 1 -type impossible\n./gen -n 5 -m 10 -k 1 -t 3 -type impossible\n./gen -n 100 -m 200 -k 1 -t 1 -type impossible\n./gen -n 600 -m 600 -k 1 -t 1 -type impossible\n./gen -n 600 -m 600 -k 599 -t 1 -type possible\n./gen -n 200 -m 300 -k 100 -t 2 -type possible\n./gen -n 10 -m 10 -k 5 -t 3 -type possible\n./gen -n 10 -m 10 -k 1 -t 3 -type impossible\n./gen -n 5 -m 7 -k 1 -t 2 -type impossible\n./gen -n 5 -m 7 -k 4 -t 2 -type possible\n./gen -n 2 -m 1 -k 1 -t 1 -type possible\n./gen -n 2 -m 1 -k 1 -t 1 -type impossible\n./gen -n 600 -m 600 -k 1 -t 1 -type impossible\n./gen -n 10 -m 10 -k 10 -t 2 -type possible\n./gen -n 10 -m 25 -k 1 -t 2 -type impossible\n./gen -n 4 -m 6 -k 2 -t 1 -type possible\n./gen -n 4 -m 6 -k 1 -t 1 -type impossible\n./gen -n 10 -m 15 -k 5 -t 2 -type possible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:26.278327",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/J",
      "title": "J. Streets and Avenues in Berhattan",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput contains one or several test cases to process. The first line contains tt (1≤t≤300001≤t≤30000) — the number of test cases. Solve test cases separately, test cases are completely independent and do not affect each other.The description of tt test cases follows. Each test case starts with line with space-separated numbers n,m,kn,m,k (1≤n,m≤300001≤n,m≤30000; n+m≤k≤2⋅105n+m≤k≤2⋅105) — the number of streets, number of avenues and the number of names in the committee's list, respectively.The the second line of each test case contains a string of kk uppercase English letters. ii-th letter of the string is the first letter of ii-th name from the committee's list. It's guaranteed that the sum of numbers nn from all test cases is not greater than 3000030000. Similarly, the sum of numbers mm from all test cases is not greater than 3000030000. The sum of numbers kk from all test cases is not greater than 2⋅1052⋅105.",
      "output_spec": "OutputFor each test case print single number CC in the separate line — minimal possible number of inconvenient crossroads in Berhattan after the naming process.",
      "sample_tests": "ExamplesInputСкопировать22 3 9EEZZEEZZZ2 7 9EEZZEEZZZOutputСкопировать04InputСкопировать24 4 8CZBBCZBC1 1 4TTCTOutputСкопировать10",
      "description": "J. Streets and Avenues in Berhattan\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput contains one or several test cases to process. The first line contains tt (1≤t≤300001≤t≤30000) — the number of test cases. Solve test cases separately, test cases are completely independent and do not affect each other.The description of tt test cases follows. Each test case starts with line with space-separated numbers n,m,kn,m,k (1≤n,m≤300001≤n,m≤30000; n+m≤k≤2⋅105n+m≤k≤2⋅105) — the number of streets, number of avenues and the number of names in the committee's list, respectively.The the second line of each test case contains a string of kk uppercase English letters. ii-th letter of the string is the first letter of ii-th name from the committee's list. It's guaranteed that the sum of numbers nn from all test cases is not greater than 3000030000. Similarly, the sum of numbers mm from all test cases is not greater than 3000030000. The sum of numbers kk from all test cases is not greater than 2⋅1052⋅105.\n\nOutputFor each test case print single number CC in the separate line — minimal possible number of inconvenient crossroads in Berhattan after the naming process.\n\nInputСкопировать22 3 9EEZZEEZZZ2 7 9EEZZEEZZZOutputСкопировать04InputСкопировать24 4 8CZBBCZBC1 1 4TTCTOutputСкопировать10\n\nInputСкопировать22 3 9EEZZEEZZZ2 7 9EEZZEEZZZ\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать04\n\nOutputСкопировать\n\nСкопировать\n\nInputСкопировать24 4 8CZBBCZBC1 1 4TTCT\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопировать10\n\nOutputСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces",
          "content": "Добрый день!16-го октября завершился Четвертьфинал Южного подрегиона NEERC (Northern Eurasia) чемпионата ICPC. В Саратове встретились 72 команды, многие из которых получили приглашение по результатам квалификационного этапа.Уже в субботу, 20-го октября в 11:05 (МСК) состоится онлайн-зеркало 2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды).Надеюсь, вам понравятся задачи. Председателем жюри этого соревнования являюсь я, а над задачами работал дружный коллектив жюри экс-участников чемпионата из Саратовского ГУ и иногородние члены жюри. Спасибо всем!Приглашаю команды ICPC к участию и просто индивидуальных участников соревнований Codeforces принять участие!Конечно, соревнование будет нерейтинговое.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62570",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 759
        },
        {
          "title": "Solution to problem M. Algoland and Berland of 2018-2019 ICPC, NEERC - Codeforces",
          "content": "Today, I solved a beautiful problem from the NEERC Subregional Contest: Problem M. Since I didn't find an editorial nor a solution in the comments, I decided to write this blog about my solution. For a visualization of my solution see: Visualization of the program The problem boils down to constructing a spanning tree of a 2D point set with certain constraints. No three points in the point set are collinear. The points have two colors: red and blue. There is at least one blue and one red point. The constraints on the spanning tree are: Edges of the spanning tree can only intersect at the ends, if they are drawn as line segments. Edges of the spanning tree can only connect points with different colors. For each blue point, the degree of the point in the spanning tree should be equal to riri. The constraints on riri are nice: 1≤ri≤# of red points1≤ri≤# of red points. And ∑ri=n−1∑ri=n−1, which is of course needed if the final graph needs to be a tree. It turns out that these conditions are strong enough that it is always possible to construct a spanning tree!Let's prove this by induction on the size of the point set, nn.Base case n=2n=2Because there is at least one red and one blue point, the smallest case is n=2n=2: one red and one blue point. Because of the constraint ∑ri=n−1=1∑ri=n−1=1, this means that the degree of the only blue point left is 1. The trivial solution is to connect the blue and the red point.Induction step n>2n>2:Now the hard part; Let's assume it is possible to make a spanning tree for all 2≤k<n2≤k<n. Now we are given a point set with nn points, how do we construct the spanning tree for it? First, let's sort the points on their x-coordinate. We use the y-coordinate as a tiebreaker. Let's do casework on the colors of the leftmost and rightmost point:Case 1: extreme points have different colorsLet's analyze the convex hull of the point set. As these two points both lie on the convex hull, the convex hull contains at least one red and one blue point. Certainly, there must be an adjacent pair of points on the hull with different colors. Let's connect these with an edge. If riri of the blue point is 1, we delete this point. Else we delete the red point, and lower riri by one. Notice that both the ∑ri∑ri and nn decreased by one, so the resulting riri satisfy all constraints. It can also be verified that at least one red and blue point remain, with some casework. So we can use the induction hypothesis on this smaller point set, which gives us a spanning tree. Could our newly added edge intersect with an existing edge? No, because the edge lies on the convex hull. So in this case we are done.For the last two cases, where both extreme points have the same color, we will use a different technique. Let's give each point a weight, For blue points, we set wi=−1+riwi=−1+ri. For red points we set wi=−1wi=−1. If the sum of weights is -1, that means ∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1. So if we could somehow split the point set with a vertical line through some point, such that the left and right halve both have the sum of weights equal to -1, we could use the induction hypothesis. For this to work we need both sides to have at least one point of each color. Case 2: extreme points are both blueLet's look at the prefix sums of the weights of the point set in sorted order. So the prefix sum is pk=∑i<kwipk=∑i<kwi, where the points are labeled from left to right. Because the total prefix sum is −1−1, and the prefix sum starts at 00, it must cross from nonnegative to negative at some point. Because the weights of all blue points are nonnegative the only place this can happen is at a red point. Because the weight of a red point is −1−1, it will cross from 00 to −1−1, and this is exactly what we wanted, a sum of weight equal to −1−1. Now we can draw a vertical line through this red point, and by the induction hypothesis construct two spanning trees, one containing all points to the left and the mid point, and one with all points to the right and the middle red point. Note that because the red point can't be one of the extreme points, the two point sets are definitely smaller than the initial point set. Since these spanning trees exist in two disjoint regions, they don't intersect. And they connect at the midpoint, so their union is a valid spanning tree of the whole point set! To ensure the regions are disjoint even if there are ties in x-coordinates, we tilt the splitting line slighly.Case 3: extreme points are both redWe do exactly the same, looking for a prefix sum which is equal to −1−1. Now it turns out this is sometimes not possible. But by similar (but inverted) logic as in Case 2, there exists a blue point, such that the prefix sum goes from negative to nonnegative. We again make a vertical splitting line through this point, but now we modify the riri we will use for this blue midpoint in the left and right subproblem. We choose these new riri's such that the sum of weights in the left and right point sets is again −1−1. Then we apply the induction hypothesis to get two valid spanning trees of the left and right side. And the union of these spanning trees will be a valid spanning tree for the entire point set. This concludes the proof.This proof is constructive, so for actually generating a spanning tree we can follow the induction logic backwards until the spanning tree is fully constructed. The easiest way to code this is to make a recursive function that constructs a spanning tree for the point set it's given. Based on the colors of the outermost points we either calculate a convex hull or prefix sums from left to right and call the function recursively. We only recurse nn times, and the complexity per call can be made O(nlogn)O(nlog⁡n), so this gives O(n2logn)O(n2log⁡n). But if we additionally presort the points and ensure the point set stays sorted in the recursive calls, the convex hull calculation can also be done in linear time, resulting in O(n2)O(n2) running time. Although this is not needed, I think this approach can be optimized further by using Smart divide and conquer and Decremental convex hull, and some modifications to quickly find two oppositely colored adjacent points on the convex hull. This would give a recursive formula for the time complexity of T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log(n))=O(nlog2n)T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log⁡(n))=O(nlog2⁡n), but this is definitely not needed to get AC.My code can be found here: submission",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/105126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6546
        }
      ],
      "code_examples": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 1",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 2",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 3",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 4",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 5",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 6",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 30000, \"t\");\n    inf.readEoln();\n\n    int sum_n = 0;\n    int sum_m = 0;\n    int sum_k = 0;\n    for (int testCase = 0; testCase < t; ++testCase) {\n        int n = inf.readInt(1, 30000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 30000, \"m\");\n        inf.readSpace();\n        int k = inf.readInt(n + m, 200000, \"k\"); // n + m <= k <= 200000\n        inf.readEoln();\n\n        sum_n += n;\n        sum_m += m;\n        sum_k += k;\n\n        ensuref(sum_n <= 30000, \"Sum of n over all test cases must not exceed 30000 (current sum_n = %d)\", sum_n);\n        ensuref(sum_m <= 30000, \"Sum of m over all test cases must not exceed 30000 (current sum_m = %d)\", sum_m);\n        ensuref(sum_k <= 200000, \"Sum of k over all test cases must not exceed 200000 (current sum_k = %d)\", sum_k);\n\n        string s = inf.readLine(\"[A-Z]{\" + to_string(k) + \"}\", \"s\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 30000, \"t\");\n    inf.readEoln();\n\n    int sum_n = 0;\n    int sum_m = 0;\n    int sum_k = 0;\n    for (int testCase = 0; testCase < t; ++testCase) {\n        int n = inf.readInt(1, 30000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 30000, \"m\");\n        inf.readSpace();\n        int k = inf.readInt(n + m, 200000, \"k\"); // n + m <= k <= 200000\n        inf.readEoln();\n\n        sum_n += n;\n        sum_m += m;\n        sum_k += k;\n\n        ensuref(sum_n <= 30000, \"Sum of n over all test cases must not exceed 30000 (current sum_n = %d)\", sum_n);\n        ensuref(sum_m <= 30000, \"Sum of m over all test cases must not exceed 30000 (current sum_m = %d)\", sum_m);\n        ensuref(sum_k <= 200000, \"Sum of k over all test cases must not exceed 200000 (current sum_k = %d)\", sum_k);\n\n        string s = inf.readLine(\"[A-Z]{\" + to_string(k) + \"}\", \"s\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 30000, \"t\");\n    inf.readEoln();\n\n    int sum_n = 0;\n    int sum_m = 0;\n    int sum_k = 0;\n    for (int testCase = 0; testCase < t; ++testCase) {\n        int n = inf.readInt(1, 30000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 30000, \"m\");\n        inf.readSpace();\n        int k = inf.readInt(n + m, 200000, \"k\"); // n + m <= k <= 200000\n        inf.readEoln();\n\n        sum_n += n;\n        sum_m += m;\n        sum_k += k;\n\n        ensuref(sum_n <= 30000, \"Sum of n over all test cases must not exceed 30000 (current sum_n = %d)\", sum_n);\n        ensuref(sum_m <= 30000, \"Sum of m over all test cases must not exceed 30000 (current sum_m = %d)\", sum_m);\n        ensuref(sum_k <= 200000, \"Sum of k over all test cases must not exceed 200000 (current sum_k = %d)\", sum_k);\n\n        string s = inf.readLine(\"[A-Z]{\" + to_string(k) + \"}\", \"s\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int UPPER_SUM_N = 30000;    // The sum of all n in the test file must not exceed 30000\nstatic const int UPPER_SUM_M = 30000;    // The sum of all m in the test file must not exceed 30000\nstatic const int UPPER_SUM_K = 200000;   // The sum of all k in the test file must not exceed 200000\nstatic const int ALPHABET_SIZE = 26;     // We only need uppercase letters A..Z\n\nint main(int argc, char* argv[]) {\n    // Mandatory init for testlib\n    registerGen(argc, argv, 1);\n\n    // Number of test cases to generate\n    int T = opt<int>(\"t\", 5);          // default 5 test cases\n    // Maximum possible n, m, and k for random generation\n    int maxN = opt<int>(\"maxN\", 10);\n    int maxM = opt<int>(\"maxM\", 10);\n    int maxK = opt<int>(\"maxK\", 20);\n    // Type of tests to generate: \"small\", \"large\", \"mixed\", \"random\", etc.\n    string type = opt<string>(\"type\", \"random\");\n\n    // Keep track of the sum of n, m, k to respect the global constraints\n    long long sumN = 0, sumM = 0, sumK = 0;\n\n    // We will collect all test cases in these vectors\n    vector<int> allN, allM, allK;\n    vector<string> allS;  // the strings s for each test\n\n    // A small utility function to generate a random uppercase string of length len\n    auto generateRandomString = [&](int len) {\n        string s(len, 'A');\n        for (int i = 0; i < len; i++) {\n            s[i] = char('A' + rnd.next(ALPHABET_SIZE));\n        }\n        return s;\n    };\n\n    // Helper: safely push a new test case if it doesn't break the sum limits\n    auto tryPushTest = [&](int n, int m, int k, const string &s) {\n        // Check constraints:\n        // 1) 1 <= n, 1 <= m\n        // 2) n + m <= k\n        // 3) sumN + n <= 30000, sumM + m <= 30000, sumK + k <= 200000\n        // 4) s.size() == k\n        if (n < 1 || m < 1) return false;\n        if (n + m > k) return false;\n        if (sumN + n > UPPER_SUM_N) return false;\n        if (sumM + m > UPPER_SUM_M) return false;\n        if (sumK + k > UPPER_SUM_K) return false;\n        if ((int)s.size() != k) return false;\n\n        sumN += n;\n        sumM += m;\n        sumK += k;\n        allN.push_back(n);\n        allM.push_back(m);\n        allK.push_back(k);\n        allS.push_back(s);\n        return true;\n    };\n\n    // Since we may generate fewer or equal T testcases (if the big constraints force fewer),\n    // we try generation up to T times.\n    int generatedCount = 0;\n\n    // Depending on \"type\", we vary how we pick n, m, k\n    for (int i = 0; i < T; i++) {\n        int n, m, k;\n        string s;\n\n        if (type == \"small\") {\n            // Generate small n and m, e.g. 1..5\n            n = rnd.next(1, min(maxN, 5));\n            m = rnd.next(1, min(maxM, 5));\n            // k must be >= n+m\n            // we'll pick a small range up to min(maxK, 10)\n            int maxSmallK = min(maxK, 10);\n            k = rnd.next(n + m, maxSmallK);\n\n        } else if (type == \"large\") {\n            // Generate n, m close to maxN, maxM\n            // but we must ensure n+m <= maxK\n            // if maxN + maxM > maxK, we reduce them\n            n = rnd.next(max(1, maxN - 5), maxN);\n            m = rnd.next(max(1, maxM - 5), maxM);\n            // Guarantee n+m <= maxK\n            int lowerK = n + m;\n            if (lowerK > maxK) {\n                // forcibly reduce n or m\n                if (n > 1) n = maxN / 2;\n                if (m > 1) m = maxM / 2;\n                lowerK = n + m;\n            }\n            k = rnd.next(lowerK, maxK);\n\n        } else if (type == \"mixed\") {\n            // Some test cases small, others large, others random\n            int mode = rnd.next(3);\n            if (mode == 0) {\n                // small\n                n = rnd.next(1, min(maxN, 10));\n                m = rnd.next(1, min(maxM, 10));\n            } else if (mode == 1) {\n                // large\n                n = rnd.next(max(1, maxN - 5), maxN);\n                m = rnd.next(max(1, maxM - 5), maxM);\n            } else {\n                // random\n                n = rnd.next(1, maxN);\n                m = rnd.next(1, maxM);\n            }\n            // adjust k\n            int lowerK = n + m;\n            if (lowerK > maxK) {\n                // forcibly reduce\n                n = maxN / 2;\n                m = maxM / 2;\n                lowerK = n + m;\n            }\n            k = rnd.next(lowerK, maxK);\n\n        } else { // \"random\"\n            // n, m in [1..maxN], [1..maxM]\n            n = rnd.next(1, maxN);\n            m = rnd.next(1, maxM);\n            // k in [n+m..maxK]\n            int lowerK = n + m;\n            if (lowerK > maxK) {\n                // forcibly reduce n or m\n                // simplest fix: pick smaller\n                n = maxN / 2;\n                m = maxM / 2;\n                lowerK = n + m;\n            }\n            k = rnd.next(lowerK, maxK);\n        }\n\n        // Generate random string s of length k\n        s = generateRandomString(k);\n\n        // Try to push the test\n        if (!tryPushTest(n, m, k, s)) {\n            // If push fails, break early or skip\n            // We won't generate more tests\n            break;\n        }\n        generatedCount++;\n    }\n\n    // Now we have 'generatedCount' test cases\n    // Output them\n    cout << generatedCount << \"\\n\";\n    for (int i = 0; i < generatedCount; i++) {\n        cout << allN[i] << \" \" << allM[i] << \" \" << allK[i] << \"\\n\";\n        cout << allS[i] << \"\\n\";\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int UPPER_SUM_N = 30000;    // The sum of all n in the test file must not exceed 30000\nstatic const int UPPER_SUM_M = 30000;    // The sum of all m in the test file must not exceed 30000\nstatic const int UPPER_SUM_K = 200000;   // The sum of all k in the test file must not exceed 200000\nstatic const int ALPHABET_SIZE = 26;     // We only need uppercase letters A..Z\n\nint main(int argc, char* argv[]) {\n    // Mandatory init for testlib\n    registerGen(argc, argv, 1);\n\n    // Number of test cases to generate\n    int T = opt<int>(\"t\", 5);          // default 5 test cases\n    // Maximum possible n, m, and k for random generation\n    int maxN = opt<int>(\"maxN\", 10);\n    int maxM = opt<int>(\"maxM\", 10);\n    int maxK = opt<int>(\"maxK\", 20);\n    // Type of tests to generate: \"small\", \"large\", \"mixed\", \"random\", etc.\n    string type = opt<string>(\"type\", \"random\");\n\n    // Keep track of the sum of n, m, k to respect the global constraints\n    long long sumN = 0, sumM = 0, sumK = 0;\n\n    // We will collect all test cases in these vectors\n    vector<int> allN, allM, allK;\n    vector<string> allS;  // the strings s for each test\n\n    // A small utility function to generate a random uppercase string of length len\n    auto generateRandomString = [&](int len) {\n        string s(len, 'A');\n        for (int i = 0; i < len; i++) {\n            s[i] = char('A' + rnd.next(ALPHABET_SIZE));\n        }\n        return s;\n    };\n\n    // Helper: safely push a new test case if it doesn't break the sum limits\n    auto tryPushTest = [&](int n, int m, int k, const string &s) {\n        // Check constraints:\n        // 1) 1 <= n, 1 <= m\n        // 2) n + m <= k\n        // 3) sumN + n <= 30000, sumM + m <= 30000, sumK + k <= 200000\n        // 4) s.size() == k\n        if (n < 1 || m < 1) return false;\n        if (n + m > k) return false;\n        if (sumN + n > UPPER_SUM_N) return false;\n        if (sumM + m > UPPER_SUM_M) return false;\n        if (sumK + k > UPPER_SUM_K) return false;\n        if ((int)s.size() != k) return false;\n\n        sumN += n;\n        sumM += m;\n        sumK += k;\n        allN.push_back(n);\n        allM.push_back(m);\n        allK.push_back(k);\n        allS.push_back(s);\n        return true;\n    };\n\n    // Since we may generate fewer or equal T testcases (if the big constraints force fewer),\n    // we try generation up to T times.\n    int generatedCount = 0;\n\n    // Depending on \"type\", we vary how we pick n, m, k\n    for (int i = 0; i < T; i++) {\n        int n, m, k;\n        string s;\n\n        if (type == \"small\") {\n            // Generate small n and m, e.g. 1..5\n            n = rnd.next(1, min(maxN, 5));\n            m = rnd.next(1, min(maxM, 5));\n            // k must be >= n+m\n            // we'll pick a small range up to min(maxK, 10)\n            int maxSmallK = min(maxK, 10);\n            k = rnd.next(n + m, maxSmallK);\n\n        } else if (type == \"large\") {\n            // Generate n, m close to maxN, maxM\n            // but we must ensure n+m <= maxK\n            // if maxN + maxM > maxK, we reduce them\n            n = rnd.next(max(1, maxN - 5), maxN);\n            m = rnd.next(max(1, maxM - 5), maxM);\n            // Guarantee n+m <= maxK\n            int lowerK = n + m;\n            if (lowerK > maxK) {\n                // forcibly reduce n or m\n                if (n > 1) n = maxN / 2;\n                if (m > 1) m = maxM / 2;\n                lowerK = n + m;\n            }\n            k = rnd.next(lowerK, maxK);\n\n        } else if (type == \"mixed\") {\n            // Some test cases small, others large, others random\n            int mode = rnd.next(3);\n            if (mode == 0) {\n                // small\n                n = rnd.next(1, min(maxN, 10));\n                m = rnd.next(1, min(maxM, 10));\n            } else if (mode == 1) {\n                // large\n                n = rnd.next(max(1, maxN - 5), maxN);\n                m = rnd.next(max(1, maxM - 5), maxM);\n            } else {\n                // random\n                n = rnd.next(1, maxN);\n                m = rnd.next(1, maxM);\n            }\n            // adjust k\n            int lowerK = n + m;\n            if (lowerK > maxK) {\n                // forcibly reduce\n                n = maxN / 2;\n                m = maxM / 2;\n                lowerK = n + m;\n            }\n            k = rnd.next(lowerK, maxK);\n\n        } else { // \"random\"\n            // n, m in [1..maxN], [1..maxM]\n            n = rnd.next(1, maxN);\n            m = rnd.next(1, maxM);\n            // k in [n+m..maxK]\n            int lowerK = n + m;\n            if (lowerK > maxK) {\n                // forcibly reduce n or m\n                // simplest fix: pick smaller\n                n = maxN / 2;\n                m = maxM / 2;\n                lowerK = n + m;\n            }\n            k = rnd.next(lowerK, maxK);\n        }\n\n        // Generate random string s of length k\n        s = generateRandomString(k);\n\n        // Try to push the test\n        if (!tryPushTest(n, m, k, s)) {\n            // If push fails, break early or skip\n            // We won't generate more tests\n            break;\n        }\n        generatedCount++;\n    }\n\n    // Now we have 'generatedCount' test cases\n    // Output them\n    cout << generatedCount << \"\\n\";\n    for (int i = 0; i < generatedCount; i++) {\n        cout << allN[i] << \" \" << allM[i] << \" \" << allK[i] << \"\\n\";\n        cout << allS[i] << \"\\n\";\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below is a list of example commands to run this generator.\n# Each command will print the test data (including test cases) to standard output.\n\n# 1) Very small tests, all random\n./gen -t 1 -maxN 1 -maxM 1 -maxK 2 -type random\n./gen -t 2 -maxN 2 -maxM 2 -maxK 4 -type random\n./gen -t 5 -maxN 5 -maxM 5 -maxK 10 -type random\n\n# 2) Testing the \"small\" type\n./gen -t 3 -maxN 10 -maxM 10 -maxK 20 -type small\n./gen -t 5 -maxN 10 -maxM 10 -maxK 20 -type small\n\n# 3) Testing larger boundaries but still random\n./gen -t 3 -maxN 50 -maxM 50 -maxK 100 -type random\n./gen -t 5 -maxN 100 -maxM 100 -maxK 300 -type random\n\n# 4) Mixed type, with moderate sizes\n./gen -t 5 -maxN 50 -maxM 50 -maxK 200 -type mixed\n./gen -t 10 -maxN 80 -maxM 80 -maxK 200 -type mixed\n\n# 5) Large type, ensuring near boundary conditions\n./gen -t 3 -maxN 30000 -maxM 30000 -maxK 60000 -type large\n./gen -t 5 -maxN 30000 -maxM 30000 -maxK 60000 -type large\n\n# 6) More random tests in large domain\n./gen -t 5 -maxN 30000 -maxM 30000 -maxK 60000 -type random\n./gen -t 5 -maxN 30000 -maxM 30000 -maxK 100000 -type random\n\n# 7) Mixed type with large scale\n./gen -t 5 -maxN 30000 -maxM 30000 -maxK 60000 -type mixed\n./gen -t 5 -maxN 30000 -maxM 30000 -maxK 100000 -type mixed\n\n# 8) More tests focusing on small but more testcases\n./gen -t 10 -maxN 5 -maxM 5 -maxK 15 -type small\n./gen -t 10 -maxN 5 -maxM 5 -maxK 15 -type mixed\n\n# 9) Edge scenario: combining small n+m but large k\n./gen -t 3 -maxN 10 -maxM 10 -maxK 200000 -type random\n./gen -t 3 -maxN 10 -maxM 10 -maxK 200000 -type mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:28.181557",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/K",
      "title": "Problem 1070/K",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_equal\") {\n        int c = opt<int>(\"c\", rnd.next(1, 10000));\n        for (int i = 0; i < n; ++i) {\n            a[i] = c;\n        }\n    } else if (type == \"random\") {\n        int max_a = opt<int>(\"maxa\", 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n        // Adjust last element to make sum divisible by k\n        long long total = accumulate(a.begin(), a.end(), 0LL);\n        int remainder = total % k;\n        if (remainder != 0) {\n            int idx = rnd.next(0, n - 1);\n            int adjust = k - remainder;\n            if (a[idx] + adjust <= 10000)\n                a[idx] += adjust;\n            else if (a[idx] - remainder >= 1)\n                a[idx] -= remainder;\n            else {\n                // Cannot adjust, so set a[idx] to a value that makes total divisible by k\n                a[idx] = ((a[idx] + adjust) % 10000) + 1;\n            }\n        }\n    } else if (type == \"no_solution\") {\n        int max_a = opt<int>(\"maxa\", 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n        // Ensure sum is NOT divisible by k\n        long long total = accumulate(a.begin(), a.end(), 0LL);\n        if (total % k == 0) {\n            int idx = rnd.next(0, n - 1);\n            if (a[idx] < 10000) {\n                a[idx]++;\n            } else if (a[idx] > 1) {\n                a[idx]--;\n            } else {\n                a[idx] = 2;\n            }\n        }\n    } else if (type == \"max_durations\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10000;\n        }\n    } else if (type == \"min_durations\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"special_case\") {\n        // Construct durations with carefully designed sums\n        int S = rnd.next(1, 10000);\n        int base_size = n / k;\n        int extra = n % k;\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            int cnt = base_size + (i < extra ? 1 : 0);\n            int sum = S;\n            for (int j = 0; j < cnt; ++j) {\n                if (j < cnt - 1) {\n                    a[idx++] = 1;\n                    sum -= 1;\n                } else {\n                    a[idx++] = sum;\n                }\n            }\n        }\n    } else {\n        // Default random\n        int max_a = opt<int>(\"maxa\", 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_equal\") {\n        int c = opt<int>(\"c\", rnd.next(1, 10000));\n        for (int i = 0; i < n; ++i) {\n            a[i] = c;\n        }\n    } else if (type == \"random\") {\n        int max_a = opt<int>(\"maxa\", 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n        // Adjust last element to make sum divisible by k\n        long long total = accumulate(a.begin(), a.end(), 0LL);\n        int remainder = total % k;\n        if (remainder != 0) {\n            int idx = rnd.next(0, n - 1);\n            int adjust = k - remainder;\n            if (a[idx] + adjust <= 10000)\n                a[idx] += adjust;\n            else if (a[idx] - remainder >= 1)\n                a[idx] -= remainder;\n            else {\n                // Cannot adjust, so set a[idx] to a value that makes total divisible by k\n                a[idx] = ((a[idx] + adjust) % 10000) + 1;\n            }\n        }\n    } else if (type == \"no_solution\") {\n        int max_a = opt<int>(\"maxa\", 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n        // Ensure sum is NOT divisible by k\n        long long total = accumulate(a.begin(), a.end(), 0LL);\n        if (total % k == 0) {\n            int idx = rnd.next(0, n - 1);\n            if (a[idx] < 10000) {\n                a[idx]++;\n            } else if (a[idx] > 1) {\n                a[idx]--;\n            } else {\n                a[idx] = 2;\n            }\n        }\n    } else if (type == \"max_durations\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10000;\n        }\n    } else if (type == \"min_durations\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"special_case\") {\n        // Construct durations with carefully designed sums\n        int S = rnd.next(1, 10000);\n        int base_size = n / k;\n        int extra = n % k;\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            int cnt = base_size + (i < extra ? 1 : 0);\n            int sum = S;\n            for (int j = 0; j < cnt; ++j) {\n                if (j < cnt - 1) {\n                    a[idx++] = 1;\n                    sum -= 1;\n                } else {\n                    a[idx++] = sum;\n                }\n            }\n        }\n    } else {\n        // Default random\n        int max_a = opt<int>(\"maxa\", 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 3 -k 1 -type all_equal\n./gen -n 3 -k 3 -type all_equal\n./gen -n 4 -k 2 -type random\n./gen -n 5 -k 5 -type min_durations\n./gen -n 5 -k 5 -type max_durations\n./gen -n 10 -k 5 -type random\n\n# Edge cases with minimum and maximum n and k\n./gen -n 1 -k 1 -type all_equal\n./gen -n 1 -k 1 -type random\n./gen -n 100000 -k 1 -type all_equal\n./gen -n 100000 -k 100000 -type all_equal\n./gen -n 100000 -k 100000 -type random\n\n# Test cases with no solution\n./gen -n 1000 -k 3 -type no_solution\n./gen -n 99999 -k 2 -type no_solution\n\n# Large random test cases\n./gen -n 100000 -k 2 -type random\n./gen -n 100000 -k 50000 -type random\n./gen -n 100000 -k 99999 -type random\n\n# Maximum durations\n./gen -n 100000 -k 2 -type max_durations\n./gen -n 100000 -k 2 -type min_durations\n\n# Special crafted cases\n./gen -n 1000 -k 10 -type special_case\n./gen -n 10000 -k 100 -type special_case\n\n# More test cases with no solution\n./gen -n 100000 -k 2 -type no_solution -maxa 10000\n./gen -n 99999 -k 99999 -type no_solution\n\n# Medium-sized random test cases\n./gen -n 50000 -k 1 -type random\n./gen -n 50000 -k 25000 -type random\n\n# All equal durations where total duration is not divisible by k\n./gen -n 1000 -k 3 -type all_equal -c 5\n\n# Edge cases with maximum durations\n./gen -n 100000 -k 1 -type max_durations\n./gen -n 1 -k 1 -type max_durations\n\n# Random durations with maximum possible values\n./gen -n 100000 -k 1000 -type random -maxa 10000\n\n# Random durations with small maximum values\n./gen -n 100000 -k 1000 -type random -maxa 10\n\n# Edge case where k is half of n\n./gen -n 100000 -k 50000 -type random\n\n# Test cases with all durations as ones\n./gen -n 100000 -k 50000 -type min_durations\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:30.022654",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/L",
      "title": "L. Odd Federalization",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains one or several test cases. The first input line contains a single integer number tt — number of test cases. Then, tt test cases follow. Solve test cases separately, test cases are completely independent and do not affect each other.Then tt blocks of input data follow. Each block starts from empty line which separates it from the remaining input data. The second line of each block contains two space-separated integers nn, mm (1≤n≤20001≤n≤2000, 0≤m≤100000≤m≤10000) — the number of cities and number of roads in the Berland. Each of the next mm lines contains two space-separated integers — xixi, yiyi (1≤xi,yi≤n1≤xi,yi≤n; xi≠yixi≠yi), which denotes that the ii-th road connects cities xixi and yiyi. Each pair of cities are connected by at most one road. Sum of values nn across all test cases doesn't exceed 20002000. Sum of values mm across all test cases doesn't exceed 1000010000.",
      "output_spec": "OutputFor each test case first print a line containing a single integer rr — smallest possible number of states for which required split is possible. In the next line print nn space-separated integers in range from 11 to rr, inclusive, where the jj-th number denotes number of state for the jj-th city. If there are multiple solutions, print any.",
      "sample_tests": "ExampleInputCopy2 5 31 22 51 5 6 51 22 33 44 24 1OutputCopy11 1 1 1 1 22 1 1 1 1 1",
      "description": "L. Odd Federalization\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe input contains one or several test cases. The first input line contains a single integer number tt — number of test cases. Then, tt test cases follow. Solve test cases separately, test cases are completely independent and do not affect each other.Then tt blocks of input data follow. Each block starts from empty line which separates it from the remaining input data. The second line of each block contains two space-separated integers nn, mm (1≤n≤20001≤n≤2000, 0≤m≤100000≤m≤10000) — the number of cities and number of roads in the Berland. Each of the next mm lines contains two space-separated integers — xixi, yiyi (1≤xi,yi≤n1≤xi,yi≤n; xi≠yixi≠yi), which denotes that the ii-th road connects cities xixi and yiyi. Each pair of cities are connected by at most one road. Sum of values nn across all test cases doesn't exceed 20002000. Sum of values mm across all test cases doesn't exceed 1000010000.\n\nOutputFor each test case first print a line containing a single integer rr — smallest possible number of states for which required split is possible. In the next line print nn space-separated integers in range from 11 to rr, inclusive, where the jj-th number denotes number of state for the jj-th city. If there are multiple solutions, print any.\n\nInputCopy2 5 31 22 51 5 6 51 22 33 44 24 1OutputCopy11 1 1 1 1 22 1 1 1 1 1\n\nInputCopy2 5 31 22 51 5 6 51 22 33 44 24 1\n\nOutputCopy11 1 1 1 1 22 1 1 1 1 1",
      "solutions": [
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces",
          "content": "Hello!ACM-ICPC Southern Subregional Contest (NEERC/Northern Eurasia) 2018 has ended on October 16. There were 72 teams onsite in Saratov, most of them were invited because of their result on the qualification stage.On Saturday, October 20, 2018 at 16:05UTC+8 will start online-mirror 2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred).In this contest I play a role of Cheif Judge and the jury teams consists of ex-participants of ICPC from Saratov and jury members from other cities. Many thanks to all of them! I hope you will like the problems!I invite ACM-ICPC teams and individual participants of Codeforces competitions to take part! Sure, the contest will be unrated.MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62570",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 737
        },
        {
          "title": "Solution to problem M. Algoland and Berland of 2018-2019 ICPC, NEERC - Codeforces",
          "content": "Today, I solved a beautiful problem from the NEERC Subregional Contest: Problem M. Since I didn't find an editorial nor a solution in the comments, I decided to write this blog about my solution. For a visualization of my solution see: Visualization of the program The problem boils down to constructing a spanning tree of a 2D point set with certain constraints. No three points in the point set are collinear. The points have two colors: red and blue. There is at least one blue and one red point. The constraints on the spanning tree are: Edges of the spanning tree can only intersect at the ends, if they are drawn as line segments. Edges of the spanning tree can only connect points with different colors. For each blue point, the degree of the point in the spanning tree should be equal to riri. The constraints on riri are nice: 1≤ri≤# of red points1≤ri≤# of red points. And ∑ri=n−1∑ri=n−1, which is of course needed if the final graph needs to be a tree. It turns out that these conditions are strong enough that it is always possible to construct a spanning tree!Let's prove this by induction on the size of the point set, nn.Base case n=2n=2Because there is at least one red and one blue point, the smallest case is n=2n=2: one red and one blue point. Because of the constraint ∑ri=n−1=1∑ri=n−1=1, this means that the degree of the only blue point left is 1. The trivial solution is to connect the blue and the red point.Induction step n>2n>2:Now the hard part; Let's assume it is possible to make a spanning tree for all 2≤k<n2≤k<n. Now we are given a point set with nn points, how do we construct the spanning tree for it? First, let's sort the points on their x-coordinate. We use the y-coordinate as a tiebreaker. Let's do casework on the colors of the leftmost and rightmost point:Case 1: extreme points have different colorsLet's analyze the convex hull of the point set. As these two points both lie on the convex hull, the convex hull contains at least one red and one blue point. Certainly, there must be an adjacent pair of points on the hull with different colors. Let's connect these with an edge. If riri of the blue point is 1, we delete this point. Else we delete the red point, and lower riri by one. Notice that both the ∑ri∑ri and nn decreased by one, so the resulting riri satisfy all constraints. It can also be verified that at least one red and blue point remain, with some casework. So we can use the induction hypothesis on this smaller point set, which gives us a spanning tree. Could our newly added edge intersect with an existing edge? No, because the edge lies on the convex hull. So in this case we are done.For the last two cases, where both extreme points have the same color, we will use a different technique. Let's give each point a weight, For blue points, we set wi=−1+riwi=−1+ri. For red points we set wi=−1wi=−1. If the sum of weights is -1, that means ∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1. So if we could somehow split the point set with a vertical line through some point, such that the left and right halve both have the sum of weights equal to -1, we could use the induction hypothesis. For this to work we need both sides to have at least one point of each color. Case 2: extreme points are both blueLet's look at the prefix sums of the weights of the point set in sorted order. So the prefix sum is pk=∑i<kwipk=∑i<kwi, where the points are labeled from left to right. Because the total prefix sum is −1−1, and the prefix sum starts at 00, it must cross from nonnegative to negative at some point. Because the weights of all blue points are nonnegative the only place this can happen is at a red point. Because the weight of a red point is −1−1, it will cross from 00 to −1−1, and this is exactly what we wanted, a sum of weight equal to −1−1. Now we can draw a vertical line through this red point, and by the induction hypothesis construct two spanning trees, one containing all points to the left and the mid point, and one with all points to the right and the middle red point. Note that because the red point can't be one of the extreme points, the two point sets are definitely smaller than the initial point set. Since these spanning trees exist in two disjoint regions, they don't intersect. And they connect at the midpoint, so their union is a valid spanning tree of the whole point set! To ensure the regions are disjoint even if there are ties in x-coordinates, we tilt the splitting line slighly.Case 3: extreme points are both redWe do exactly the same, looking for a prefix sum which is equal to −1−1. Now it turns out this is sometimes not possible. But by similar (but inverted) logic as in Case 2, there exists a blue point, such that the prefix sum goes from negative to nonnegative. We again make a vertical splitting line through this point, but now we modify the riri we will use for this blue midpoint in the left and right subproblem. We choose these new riri's such that the sum of weights in the left and right point sets is again −1−1. Then we apply the induction hypothesis to get two valid spanning trees of the left and right side. And the union of these spanning trees will be a valid spanning tree for the entire point set. This concludes the proof.This proof is constructive, so for actually generating a spanning tree we can follow the induction logic backwards until the spanning tree is fully constructed. The easiest way to code this is to make a recursive function that constructs a spanning tree for the point set it's given. Based on the colors of the outermost points we either calculate a convex hull or prefix sums from left to right and call the function recursively. We only recurse nn times, and the complexity per call can be made O(nlogn)O(nlog⁡n), so this gives O(n2logn)O(n2log⁡n). But if we additionally presort the points and ensure the point set stays sorted in the recursive calls, the convex hull calculation can also be done in linear time, resulting in O(n2)O(n2) running time. Although this is not needed, I think this approach can be optimized further by using Smart divide and conquer and Decremental convex hull, and some modifications to quickly find two oppositely colored adjacent points on the convex hull. This would give a recursive formula for the time complexity of T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log(n))=O(nlog2n)T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log⁡(n))=O(nlog2⁡n), but this is definitely not needed to get AC.My code can be found here: submission",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/105126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6546
        }
      ],
      "code_examples": [
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 1",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 2",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 3",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 4",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 5",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) - Codeforces - Code 6",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 2000, \"t\");\n    inf.readEoln();\n\n    int total_n = 0, total_m = 0;\n\n    for (int tc = 0; tc < t; ++tc) {\n        inf.readLine(\"\"); // Read empty line before test case\n\n        int n = inf.readInt(1, 2000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(0, 10000, \"m\");\n        inf.readEoln();\n\n        total_n += n;\n        ensuref(total_n <= 2000, \"Sum of n over all test cases must not exceed 2000.\");\n        total_m += m;\n        ensuref(total_m <= 10000, \"Sum of m over all test cases must not exceed 10000.\");\n\n        set<pair<int,int>> edges;\n\n        for (int i = 0; i < m; ++i) {\n            int x_i = inf.readInt(1, n, \"x_i\");\n            inf.readSpace();\n            int y_i = inf.readInt(1, n, \"y_i\");\n            inf.readEoln();\n\n            ensuref(x_i != y_i, \"Edge connects a city to itself: city %d\", x_i);\n            int u = x_i, v = y_i;\n            if (u > v) swap(u, v);\n            pair<int,int> edge = make_pair(u,v);\n            ensuref(edges.count(edge) == 0, \"Multiple edges between cities %d and %d\", u, v);\n            edges.insert(edge);\n        }\n\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 2000, \"t\");\n    inf.readEoln();\n\n    int total_n = 0, total_m = 0;\n\n    for (int tc = 0; tc < t; ++tc) {\n        inf.readLine(\"\"); // Read empty line before test case\n\n        int n = inf.readInt(1, 2000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(0, 10000, \"m\");\n        inf.readEoln();\n\n        total_n += n;\n        ensuref(total_n <= 2000, \"Sum of n over all test cases must not exceed 2000.\");\n        total_m += m;\n        ensuref(total_m <= 10000, \"Sum of m over all test cases must not exceed 10000.\");\n\n        set<pair<int,int>> edges;\n\n        for (int i = 0; i < m; ++i) {\n            int x_i = inf.readInt(1, n, \"x_i\");\n            inf.readSpace();\n            int y_i = inf.readInt(1, n, \"y_i\");\n            inf.readEoln();\n\n            ensuref(x_i != y_i, \"Edge connects a city to itself: city %d\", x_i);\n            int u = x_i, v = y_i;\n            if (u > v) swap(u, v);\n            pair<int,int> edge = make_pair(u,v);\n            ensuref(edges.count(edge) == 0, \"Multiple edges between cities %d and %d\", u, v);\n            edges.insert(edge);\n        }\n\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 2000, \"t\");\n    inf.readEoln();\n\n    int total_n = 0, total_m = 0;\n\n    for (int tc = 0; tc < t; ++tc) {\n        inf.readLine(\"\"); // Read empty line before test case\n\n        int n = inf.readInt(1, 2000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(0, 10000, \"m\");\n        inf.readEoln();\n\n        total_n += n;\n        ensuref(total_n <= 2000, \"Sum of n over all test cases must not exceed 2000.\");\n        total_m += m;\n        ensuref(total_m <= 10000, \"Sum of m over all test cases must not exceed 10000.\");\n\n        set<pair<int,int>> edges;\n\n        for (int i = 0; i < m; ++i) {\n            int x_i = inf.readInt(1, n, \"x_i\");\n            inf.readSpace();\n            int y_i = inf.readInt(1, n, \"y_i\");\n            inf.readEoln();\n\n            ensuref(x_i != y_i, \"Edge connects a city to itself: city %d\", x_i);\n            int u = x_i, v = y_i;\n            if (u > v) swap(u, v);\n            pair<int,int> edge = make_pair(u,v);\n            ensuref(edges.count(edge) == 0, \"Multiple edges between cities %d and %d\", u, v);\n            edges.insert(edge);\n        }\n\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default -1, meaning m will be set depending on type\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within constraints\n    ensure(1 <= n && n <= 2000);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"random\") {\n        if (m == -1) {\n            m = rnd.next(0, min(10000, n*(n-1)/2));\n        }\n        ensure(0 <= m && m <= min(10000, n*(n-1)/2));\n\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n\n    } else if (type == \"complete\") {\n        m = n*(n-1)/2;\n        ensure(m <= 10000);\n\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u+1; v <= n; ++v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (type == \"path\") {\n        m = n - 1;\n        ensure(0 <= m && m <= 10000);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n    } else if (type == \"cycle_even\") {\n        m = n;\n        ensure(n % 2 == 0);\n        ensure(m <= 10000);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n        edges.push_back(make_pair(n, 1));\n\n    } else if (type == \"cycle_odd\") {\n        m = n;\n        ensure(n % 2 == 1);\n        ensure(m <= 10000);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n        edges.push_back(make_pair(n, 1));\n\n    } else if (type == \"star\") {\n        m = n - 1;\n        ensure(0 <= m && m <= 10000);\n\n        int center = 1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(center, i));\n        }\n\n    } else if (type == \"bipartite_complete\") {\n        if (m == -1) {\n            m = n * n / 4;\n            ensure(0 <= m && m <= 10000);\n        }\n        ensure(n % 2 == 0);\n\n        int n1 = n / 2;\n        int n2 = n - n1;\n\n        vector<int> part1, part2;\n        for (int i = 1; i <= n1; ++i) part1.push_back(i);\n        for (int i = n1+1; i <= n; ++i) part2.push_back(i);\n\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = part1[rnd.next(0, n1 - 1)];\n            int v = part2[rnd.next(0, n2 - 1)];\n            if (u > v) swap(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else {\n        m = 0;\n    }\n\n    printf(\"1\\n\\n\");\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default -1, meaning m will be set depending on type\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within constraints\n    ensure(1 <= n && n <= 2000);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"random\") {\n        if (m == -1) {\n            m = rnd.next(0, min(10000, n*(n-1)/2));\n        }\n        ensure(0 <= m && m <= min(10000, n*(n-1)/2));\n\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n\n    } else if (type == \"complete\") {\n        m = n*(n-1)/2;\n        ensure(m <= 10000);\n\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u+1; v <= n; ++v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (type == \"path\") {\n        m = n - 1;\n        ensure(0 <= m && m <= 10000);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n    } else if (type == \"cycle_even\") {\n        m = n;\n        ensure(n % 2 == 0);\n        ensure(m <= 10000);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n        edges.push_back(make_pair(n, 1));\n\n    } else if (type == \"cycle_odd\") {\n        m = n;\n        ensure(n % 2 == 1);\n        ensure(m <= 10000);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n        edges.push_back(make_pair(n, 1));\n\n    } else if (type == \"star\") {\n        m = n - 1;\n        ensure(0 <= m && m <= 10000);\n\n        int center = 1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(center, i));\n        }\n\n    } else if (type == \"bipartite_complete\") {\n        if (m == -1) {\n            m = n * n / 4;\n            ensure(0 <= m && m <= 10000);\n        }\n        ensure(n % 2 == 0);\n\n        int n1 = n / 2;\n        int n2 = n - n1;\n\n        vector<int> part1, part2;\n        for (int i = 1; i <= n1; ++i) part1.push_back(i);\n        for (int i = n1+1; i <= n; ++i) part2.push_back(i);\n\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = part1[rnd.next(0, n1 - 1)];\n            int v = part2[rnd.next(0, n2 - 1)];\n            if (u > v) swap(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else {\n        m = 0;\n    }\n\n    printf(\"1\\n\\n\");\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases with small n (Total n = 45)\n./gen -n 1 -type random\n./gen -n 2 -type path\n./gen -n 3 -type cycle_odd\n./gen -n 4 -type cycle_even\n./gen -n 5 -type star\n./gen -n 6 -type cycle_even\n./gen -n 7 -type cycle_odd\n./gen -n 8 -type bipartite_complete -m 10\n./gen -n 9 -type random -m 15\n\n# Test cases with moderate n (Total n = 350)\n./gen -n 50 -type random -m 100\n./gen -n 60 -type random -m 200\n./gen -n 70 -type star\n./gen -n 80 -type cycle_even\n./gen -n 90 -type random -m 300\n\n# Test cases with larger n (Total n = 560)\n./gen -n 100 -type path\n./gen -n 100 -type random -m 500\n./gen -n 110 -type random -m 600\n./gen -n 120 -type random -m 700\n./gen -n 130 -type random -m 800\n\n# Test cases pushing the limits (Total n = 850)\n./gen -n 150 -type random -m 900\n./gen -n 160 -type random -m 1000\n./gen -n 170 -type random -m 1000\n./gen -n 180 -type random -m 1000\n./gen -n 190 -type random -m 1000\n\n# Final test case to reach total n ~2000 (Total n = 2000)\n./gen -n 195 -type random -m 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:32.199684",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1070/M",
      "title": "M. Algoland and Berland",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputInput contains one or several test cases. The first input line contains a single integer number tt (1≤t≤30001≤t≤3000) — number of test cases. Then, tt test cases follow. Solve test cases separately, test cases are completely independent and do not affect each other.Each test case starts with a line containing space-separated integers aa and bb (1≤a,b≤30001≤a,b≤3000) — numbers of Algoland cities and number of Berland cities correspondingly.The next line contains bb space-separated integers r1,r2,…,rbr1,r2,…,rb (1≤rb≤a1≤rb≤a) where rjrj is the number of freeways, that should start in the jj-th Berland city. It is guaranteed that r1+r2+⋯+rb=a+b−1r1+r2+⋯+rb=a+b−1.The next aa lines contain coordinates of the Algoland cities — pairs of space-separated integers xai,yaixai,yai (−10000≤xai,yai≤10000−10000≤xai,yai≤10000). The next bb lines contain coordinates of the Berland cities — pairs of space-separated integers xbi,ybixbi,ybi (−10000≤xbi,ybi≤10000−10000≤xbi,ybi≤10000). All cities are located at distinct points, no three of the a+ba+b cities lie on a single straight line.Sum of values aa across all test cases doesn't exceed 30003000. Sum of values bb across all test cases doesn't exceed 30003000.",
      "output_spec": "OutputFor each of the tt test cases, first print \"YES\" if there is an answer or \"NO\" otherwise.If there is an answer, print the freeway building plan in the next a+b−1a+b−1 lines. Each line of the plan should contain two space-separated integers jj and ii which means that a freeway from the jj-th Berland city to the ii-th Algoland city should be built. If there are multiple solutions, print any.",
      "sample_tests": "ExampleInputСкопировать22 31 1 20 01 11 23 24 01 110 00 1OutputСкопироватьYES2 21 23 23 1YES1 1",
      "description": "M. Algoland and Berland\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputInput contains one or several test cases. The first input line contains a single integer number tt (1≤t≤30001≤t≤3000) — number of test cases. Then, tt test cases follow. Solve test cases separately, test cases are completely independent and do not affect each other.Each test case starts with a line containing space-separated integers aa and bb (1≤a,b≤30001≤a,b≤3000) — numbers of Algoland cities and number of Berland cities correspondingly.The next line contains bb space-separated integers r1,r2,…,rbr1,r2,…,rb (1≤rb≤a1≤rb≤a) where rjrj is the number of freeways, that should start in the jj-th Berland city. It is guaranteed that r1+r2+⋯+rb=a+b−1r1+r2+⋯+rb=a+b−1.The next aa lines contain coordinates of the Algoland cities — pairs of space-separated integers xai,yaixai,yai (−10000≤xai,yai≤10000−10000≤xai,yai≤10000). The next bb lines contain coordinates of the Berland cities — pairs of space-separated integers xbi,ybixbi,ybi (−10000≤xbi,ybi≤10000−10000≤xbi,ybi≤10000). All cities are located at distinct points, no three of the a+ba+b cities lie on a single straight line.Sum of values aa across all test cases doesn't exceed 30003000. Sum of values bb across all test cases doesn't exceed 30003000.\n\nOutputFor each of the tt test cases, first print \"YES\" if there is an answer or \"NO\" otherwise.If there is an answer, print the freeway building plan in the next a+b−1a+b−1 lines. Each line of the plan should contain two space-separated integers jj and ii which means that a freeway from the jj-th Berland city to the ii-th Algoland city should be built. If there are multiple solutions, print any.\n\nInputСкопировать22 31 1 20 01 11 23 24 01 110 00 1OutputСкопироватьYES2 21 23 23 1YES1 1\n\nInputСкопировать22 31 1 20 01 11 23 24 01 110 00 1\n\nInputСкопировать\n\nСкопировать\n\nOutputСкопироватьYES2 21 23 23 1YES1 1\n\nOutputСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces",
          "content": "Добрый день!16-го октября завершился Четвертьфинал Южного подрегиона NEERC (Northern Eurasia) чемпионата ICPC. В Саратове встретились 72 команды, многие из которых получили приглашение по результатам квалификационного этапа.Уже в субботу, 20-го октября в 11:05 (МСК) состоится онлайн-зеркало 2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды).Надеюсь, вам понравятся задачи. Председателем жюри этого соревнования являюсь я, а над задачами работал дружный коллектив жюри экс-участников чемпионата из Саратовского ГУ и иногородние члены жюри. Спасибо всем!Приглашаю команды ICPC к участию и просто индивидуальных участников соревнований Codeforces принять участие!Конечно, соревнование будет нерейтинговое.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62570",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 759
        },
        {
          "title": "Solution to problem M. Algoland and Berland of 2018-2019 ICPC, NEERC - Codeforces",
          "content": "Today, I solved a beautiful problem from the NEERC Subregional Contest: Problem M. Since I didn't find an editorial nor a solution in the comments, I decided to write this blog about my solution. For a visualization of my solution see: Visualization of the program The problem boils down to constructing a spanning tree of a 2D point set with certain constraints. No three points in the point set are collinear. The points have two colors: red and blue. There is at least one blue and one red point. The constraints on the spanning tree are: Edges of the spanning tree can only intersect at the ends, if they are drawn as line segments. Edges of the spanning tree can only connect points with different colors. For each blue point, the degree of the point in the spanning tree should be equal to riri. The constraints on riri are nice: 1≤ri≤# of red points1≤ri≤# of red points. And ∑ri=n−1∑ri=n−1, which is of course needed if the final graph needs to be a tree. It turns out that these conditions are strong enough that it is always possible to construct a spanning tree!Let's prove this by induction on the size of the point set, nn.Base case n=2n=2Because there is at least one red and one blue point, the smallest case is n=2n=2: one red and one blue point. Because of the constraint ∑ri=n−1=1∑ri=n−1=1, this means that the degree of the only blue point left is 1. The trivial solution is to connect the blue and the red point.Induction step n>2n>2:Now the hard part; Let's assume it is possible to make a spanning tree for all 2≤k<n2≤k<n. Now we are given a point set with nn points, how do we construct the spanning tree for it? First, let's sort the points on their x-coordinate. We use the y-coordinate as a tiebreaker. Let's do casework on the colors of the leftmost and rightmost point:Case 1: extreme points have different colorsLet's analyze the convex hull of the point set. As these two points both lie on the convex hull, the convex hull contains at least one red and one blue point. Certainly, there must be an adjacent pair of points on the hull with different colors. Let's connect these with an edge. If riri of the blue point is 1, we delete this point. Else we delete the red point, and lower riri by one. Notice that both the ∑ri∑ri and nn decreased by one, so the resulting riri satisfy all constraints. It can also be verified that at least one red and blue point remain, with some casework. So we can use the induction hypothesis on this smaller point set, which gives us a spanning tree. Could our newly added edge intersect with an existing edge? No, because the edge lies on the convex hull. So in this case we are done.For the last two cases, where both extreme points have the same color, we will use a different technique. Let's give each point a weight, For blue points, we set wi=−1+riwi=−1+ri. For red points we set wi=−1wi=−1. If the sum of weights is -1, that means ∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1∑all points−1+∑blue pointsri=−1⟹∑blue pointsri=n−1. So if we could somehow split the point set with a vertical line through some point, such that the left and right halve both have the sum of weights equal to -1, we could use the induction hypothesis. For this to work we need both sides to have at least one point of each color. Case 2: extreme points are both blueLet's look at the prefix sums of the weights of the point set in sorted order. So the prefix sum is pk=∑i<kwipk=∑i<kwi, where the points are labeled from left to right. Because the total prefix sum is −1−1, and the prefix sum starts at 00, it must cross from nonnegative to negative at some point. Because the weights of all blue points are nonnegative the only place this can happen is at a red point. Because the weight of a red point is −1−1, it will cross from 00 to −1−1, and this is exactly what we wanted, a sum of weight equal to −1−1. Now we can draw a vertical line through this red point, and by the induction hypothesis construct two spanning trees, one containing all points to the left and the mid point, and one with all points to the right and the middle red point. Note that because the red point can't be one of the extreme points, the two point sets are definitely smaller than the initial point set. Since these spanning trees exist in two disjoint regions, they don't intersect. And they connect at the midpoint, so their union is a valid spanning tree of the whole point set! To ensure the regions are disjoint even if there are ties in x-coordinates, we tilt the splitting line slighly.Case 3: extreme points are both redWe do exactly the same, looking for a prefix sum which is equal to −1−1. Now it turns out this is sometimes not possible. But by similar (but inverted) logic as in Case 2, there exists a blue point, such that the prefix sum goes from negative to nonnegative. We again make a vertical splitting line through this point, but now we modify the riri we will use for this blue midpoint in the left and right subproblem. We choose these new riri's such that the sum of weights in the left and right point sets is again −1−1. Then we apply the induction hypothesis to get two valid spanning trees of the left and right side. And the union of these spanning trees will be a valid spanning tree for the entire point set. This concludes the proof.This proof is constructive, so for actually generating a spanning tree we can follow the induction logic backwards until the spanning tree is fully constructed. The easiest way to code this is to make a recursive function that constructs a spanning tree for the point set it's given. Based on the colors of the outermost points we either calculate a convex hull or prefix sums from left to right and call the function recursively. We only recurse nn times, and the complexity per call can be made O(nlogn)O(nlog⁡n), so this gives O(n2logn)O(n2log⁡n). But if we additionally presort the points and ensure the point set stays sorted in the recursive calls, the convex hull calculation can also be done in linear time, resulting in O(n2)O(n2) running time. Although this is not needed, I think this approach can be optimized further by using Smart divide and conquer and Decremental convex hull, and some modifications to quickly find two oppositely colored adjacent points on the convex hull. This would give a recursive formula for the time complexity of T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log(n))=O(nlog2n)T(n)=max1≤k<nT(k)+T(n−k)+O(min(k,n−k)log⁡(n))=O(nlog2⁡n), but this is definitely not needed to get AC.My code can be found here: submission",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/105126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6546
        }
      ],
      "code_examples": [
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 1",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 2",
          "code": "7\n+0.0.0.13\n+0.0.0.12/32\n-0.0.0.2/31\n-0.0.0.7/32\n-0.0.0.10\n-0.0.0.9/32\n-0.0.0.8/31",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 3",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 4",
          "code": "2\n0.0.0.0/29\n0.0.0.8/30",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 5",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        },
        {
          "title": "2018-2019 ICPC, NEERC, Южный четвертьфинал (онлайн-трансляция, правила ACM-ICPC, предпочтительно команды) - Codeforces - Code 6",
          "code": "2\n0.0.0.2/29\n0.0.0.10/32",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62570",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct pair_hash {\n    size_t operator () (const pair<int,int>& p) const {\n        return hash<long long>()( ((long long)p.first)<<32 | (unsigned int)p.second );\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 3000, \"t\");\n    inf.readEoln();\n\n    int total_a = 0, total_b = 0;\n\n    for (int test = 0; test < t; ++test) {\n\n        int a = inf.readInt(1, 3000, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, 3000, \"b\");\n        inf.readEoln();\n\n        total_a += a;\n        total_b += b;\n\n        ensuref(total_a <= 3000, \"Sum of a over all test cases must not exceed 3000\");\n        ensuref(total_b <= 3000, \"Sum of b over all test cases must not exceed 3000\");\n\n        vector<int> r = inf.readInts(b, 1, a, \"r_j\");\n        int sum_r = accumulate(r.begin(), r.end(), 0);\n        ensuref(sum_r == a + b -1, \"Sum of r_j must be equal to a + b - 1\");\n        inf.readEoln();\n\n        vector<pair<int,int>> points;\n\n        for (int i = 0; i < a; ++i) {\n            int x = inf.readInt(-10000, 10000, \"x_a\");\n            inf.readSpace();\n            int y = inf.readInt(-10000, 10000, \"y_a\");\n            inf.readEoln();\n\n            points.emplace_back(x, y);\n        }\n\n        for (int i = 0; i < b; ++i) {\n            int x = inf.readInt(-10000, 10000, \"x_b\");\n            inf.readSpace();\n            int y = inf.readInt(-10000, 10000, \"y_b\");\n            inf.readEoln();\n\n            points.emplace_back(x, y);\n        }\n\n        set<pair<int,int>> point_set(points.begin(), points.end());\n        ensuref(point_set.size() == points.size(), \"Cities must have distinct coordinates\");\n\n        int n = points.size();\n\n        for (int i = 0; i < n; ++i) {\n            map<pair<int,int>, int> slope_count;\n            for (int j = i + 1; j < n; ++j) {\n                int dx = points[j].first - points[i].first;\n                int dy = points[j].second - points[i].second;\n                int g = __gcd(abs(dx), abs(dy));\n                if (g != 0) {\n                    dx /= g;\n                    dy /= g;\n                }\n                if (dx < 0) {\n                    dx = -dx;\n                    dy = -dy;\n                } else if (dx == 0 && dy < 0) {\n                    dy = -dy;\n                }\n                pair<int,int> slope = make_pair(dx, dy);\n                int cnt = slope_count[slope];\n                if (cnt >= 1) {\n                    ensuref(false, \"Three cities lie on a single straight line\");\n                }\n                slope_count[slope] = cnt + 1;\n            }\n        }\n\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct pair_hash {\n    size_t operator () (const pair<int,int>& p) const {\n        return hash<long long>()( ((long long)p.first)<<32 | (unsigned int)p.second );\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 3000, \"t\");\n    inf.readEoln();\n\n    int total_a = 0, total_b = 0;\n\n    for (int test = 0; test < t; ++test) {\n\n        int a = inf.readInt(1, 3000, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, 3000, \"b\");\n        inf.readEoln();\n\n        total_a += a;\n        total_b += b;\n\n        ensuref(total_a <= 3000, \"Sum of a over all test cases must not exceed 3000\");\n        ensuref(total_b <= 3000, \"Sum of b over all test cases must not exceed 3000\");\n\n        vector<int> r = inf.readInts(b, 1, a, \"r_j\");\n        int sum_r = accumulate(r.begin(), r.end(), 0);\n        ensuref(sum_r == a + b -1, \"Sum of r_j must be equal to a + b - 1\");\n        inf.readEoln();\n\n        vector<pair<int,int>> points;\n\n        for (int i = 0; i < a; ++i) {\n            int x = inf.readInt(-10000, 10000, \"x_a\");\n            inf.readSpace();\n            int y = inf.readInt(-10000, 10000, \"y_a\");\n            inf.readEoln();\n\n            points.emplace_back(x, y);\n        }\n\n        for (int i = 0; i < b; ++i) {\n            int x = inf.readInt(-10000, 10000, \"x_b\");\n            inf.readSpace();\n            int y = inf.readInt(-10000, 10000, \"y_b\");\n            inf.readEoln();\n\n            points.emplace_back(x, y);\n        }\n\n        set<pair<int,int>> point_set(points.begin(), points.end());\n        ensuref(point_set.size() == points.size(), \"Cities must have distinct coordinates\");\n\n        int n = points.size();\n\n        for (int i = 0; i < n; ++i) {\n            map<pair<int,int>, int> slope_count;\n            for (int j = i + 1; j < n; ++j) {\n                int dx = points[j].first - points[i].first;\n                int dy = points[j].second - points[i].second;\n                int g = __gcd(abs(dx), abs(dy));\n                if (g != 0) {\n                    dx /= g;\n                    dy /= g;\n                }\n                if (dx < 0) {\n                    dx = -dx;\n                    dy = -dy;\n                } else if (dx == 0 && dy < 0) {\n                    dy = -dy;\n                }\n                pair<int,int> slope = make_pair(dx, dy);\n                int cnt = slope_count[slope];\n                if (cnt >= 1) {\n                    ensuref(false, \"Three cities lie on a single straight line\");\n                }\n                slope_count[slope] = cnt + 1;\n            }\n        }\n\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct pair_hash {\n    size_t operator () (const pair<int,int>& p) const {\n        return hash<long long>()( ((long long)p.first)<<32 | (unsigned int)p.second );\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 3000, \"t\");\n    inf.readEoln();\n\n    int total_a = 0, total_b = 0;\n\n    for (int test = 0; test < t; ++test) {\n\n        int a = inf.readInt(1, 3000, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, 3000, \"b\");\n        inf.readEoln();\n\n        total_a += a;\n        total_b += b;\n\n        ensuref(total_a <= 3000, \"Sum of a over all test cases must not exceed 3000\");\n        ensuref(total_b <= 3000, \"Sum of b over all test cases must not exceed 3000\");\n\n        vector<int> r = inf.readInts(b, 1, a, \"r_j\");\n        int sum_r = accumulate(r.begin(), r.end(), 0);\n        ensuref(sum_r == a + b -1, \"Sum of r_j must be equal to a + b - 1\");\n        inf.readEoln();\n\n        vector<pair<int,int>> points;\n\n        for (int i = 0; i < a; ++i) {\n            int x = inf.readInt(-10000, 10000, \"x_a\");\n            inf.readSpace();\n            int y = inf.readInt(-10000, 10000, \"y_a\");\n            inf.readEoln();\n\n            points.emplace_back(x, y);\n        }\n\n        for (int i = 0; i < b; ++i) {\n            int x = inf.readInt(-10000, 10000, \"x_b\");\n            inf.readSpace();\n            int y = inf.readInt(-10000, 10000, \"y_b\");\n            inf.readEoln();\n\n            points.emplace_back(x, y);\n        }\n\n        set<pair<int,int>> point_set(points.begin(), points.end());\n        ensuref(point_set.size() == points.size(), \"Cities must have distinct coordinates\");\n\n        int n = points.size();\n\n        for (int i = 0; i < n; ++i) {\n            map<pair<int,int>, int> slope_count;\n            for (int j = i + 1; j < n; ++j) {\n                int dx = points[j].first - points[i].first;\n                int dy = points[j].second - points[i].second;\n                int g = __gcd(abs(dx), abs(dy));\n                if (g != 0) {\n                    dx /= g;\n                    dy /= g;\n                }\n                if (dx < 0) {\n                    dx = -dx;\n                    dy = -dy;\n                } else if (dx == 0 && dy < 0) {\n                    dy = -dy;\n                }\n                pair<int,int> slope = make_pair(dx, dy);\n                int cnt = slope_count[slope];\n                if (cnt >= 1) {\n                    ensuref(false, \"Three cities lie on a single straight line\");\n                }\n                slope_count[slope] = cnt + 1;\n            }\n        }\n\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nstruct Edge {\n    int u, v; // node indices\n    Point a, b; // Positions\n};\n\n// Function to check the orientation of ordered triplet (p, q, r)\n// Returns:\n// 0 --> p, q and r are colinear\n// 1 --> Clockwise\n// 2 --> Counterclockwise\nint orientation(Point p, Point q, Point r)\n{\n    double val = (q.y - p.y) * (r.x - q.x) -\n                 (q.x - p.x) * (r.y - q.y);\n    if (fabs(val) < 1e-8)\n        return 0; // colinear\n    return (val > 0) ? 1 : 2; // clock or counterclock wise\n}\n\n// Function to check if two segments (p1,q1) and (p2,q2) intersect\nbool segmentsIntersect(Point p1, Point q1, Point p2, Point q2)\n{\n    // Find the four orientations needed for general and special cases\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    // General case\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    // Special Cases are not needed because points are distinct and no three points are colinear\n    return false; // Doesn't fall in any of the above cases\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int t = inf.readInt(1, 3000, \"t\"); // number of test cases\n    long long total_a = 0, total_b = 0;\n    for (int test_case = 1; test_case <= t; test_case++) {\n        setTestCase(test_case);\n        // Read a and b\n        int a = inf.readInt(1, 3000, \"a\");\n        int b = inf.readInt(1, 3000, \"b\");\n        total_a += a;\n        total_b += b;\n        if (total_a > 3000 || total_b > 3000) {\n            quitf(_fail, \"Sum of values a or b exceeds 3000\");\n        }\n        // Read r_j\n        vector<int> r(b);\n        for (int j = 0; j < b; j++) {\n            r[j] = inf.readInt(1, a, format(\"r[%d]\", j+1).c_str());\n        }\n        int total_r = accumulate(r.begin(), r.end(), 0);\n        if (total_r != a + b - 1)\n            quitf(_fail, \"Input invalid: sum of r_j is not equal to a + b - 1\");\n\n        // Read positions of Algoland cities\n        vector<Point> algoland(a);\n        for (int i = 0; i < a; i++) {\n            double x = inf.readInt(-10000, 10000, format(\"Algoland x[%d]\", i+1).c_str());\n            double y = inf.readInt(-10000, 10000, format(\"Algoland y[%d]\", i+1).c_str());\n            algoland[i] = {x, y};\n        }\n        // Read positions of Berland cities\n        vector<Point> berland(b);\n        for (int j = 0; j < b; j++) {\n            double x = inf.readInt(-10000, 10000, format(\"Berland x[%d]\", j+1).c_str());\n            double y = inf.readInt(-10000, 10000, format(\"Berland y[%d]\", j+1).c_str());\n            berland[j] = {x, y};\n        }\n\n        // Read contestant's output from ouf\n        string res = ouf.readToken();\n        if (res != \"YES\" && res != \"NO\") {\n            quitf(_wa, \"Expected YES or NO in test case %d, found '%s'\", test_case, res.c_str());\n        }\n        if (res == \"NO\") {\n            // We accept this output\n            continue;\n        }\n        // res == \"YES\"\n        // Read exactly a + b - 1 lines\n        int m = a + b - 1;\n        vector<Edge> edges(m);\n        // Map to check degrees\n        vector<int> degree(a + b, 0); // total nodes a + b\n        vector<int> berland_degree(b, 0); // degrees of Berland cities\n\n        for (int i = 0; i < m; i++) {\n            int j = ouf.readInt(1, b, format(\"edge[%d] Berland city\", i+1).c_str());\n            int k = ouf.readInt(1, a, format(\"edge[%d] Algoland city\", i+1).c_str());\n            // Adjust indices to zero-based\n            j--; k--;\n            edges[i].u = j; // Berland city index (0-based)\n            edges[i].v = k + b; // Algoland city index\n            edges[i].a = berland[j];\n            edges[i].b = algoland[k];\n\n            degree[j]++; // node u\n            degree[k + b]++; // node v\n            berland_degree[j]++;\n        }\n        // Check degrees of Berland cities\n        for (int j = 0; j < b; j++) {\n            if (berland_degree[j] != r[j]) {\n                quitf(_wa, \"In test case %d: Berland city %d has degree %d, expected %d\", test_case, j+1, berland_degree[j], r[j]);\n            }\n        }\n        // Build adjacency list\n        int n = a + b;\n        vector<vector<int>> adj(n);\n        for (Edge& e : edges) {\n            adj[e.u].push_back(e.v);\n            adj[e.v].push_back(e.u);\n        }\n        // Check connectivity\n        vector<bool> visited(n, false);\n        function<void(int)> dfs = [&](int u) {\n            visited[u] = true;\n            for (int v : adj[u]) {\n                if (!visited[v]) dfs(v);\n            }\n        };\n        dfs(0);\n        bool connected = true;\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                connected = false;\n                break;\n            }\n        }\n        if (!connected) {\n            quitf(_wa, \"In test case %d: The graph is not connected\", test_case);\n        }\n        // Now check for segment intersections\n        for (int i = 0; i < m; i++) {\n            for (int j = i + 1; j < m; j++) {\n                Edge& e1 = edges[i];\n                Edge& e2 = edges[j];\n                // If they share an endpoint, skip\n                if (e1.u == e2.u || e1.u == e2.v || e1.v == e2.u || e1.v == e2.v) continue;\n                // Check for intersection\n                Point p1 = e1.a;\n                Point q1 = e1.b;\n                Point p2 = e2.a;\n                Point q2 = e2.b;\n                // If segments p1-q1 and p2-q2 intersect\n                if (segmentsIntersect(p1, q1, p2, q2)) {\n                    quitf(_wa, \"In test case %d: Freeways %d and %d intersect\", test_case, i+1, j+1);\n                }\n            }\n        }\n        // All checks passed for this test case\n    }\n    // Ensure there's no extra output\n    if (!ouf.seekEof())\n        quitf(_wa, \"Extra output detected after processing all test cases\");\n    // All test cases passed\n    quitf(_ok, \"All test cases passed\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to split integer M into k non-negative integers\nvector<int> split_integer(int M, int k) {\n    vector<int> res(k, 0);\n    for (int i = 0; i < M; ++i) {\n        res[rnd.next(k)]++;\n    }\n    return res;\n}\n\nbool check_colinear(const vector<pair<int,int>>& points) {\n    int n = points.size();\n    // For each point, check slope with every other point and detect duplicates\n    for (int i = 0; i < n; ++i) {\n        map<pair<int,int>, int> slope_count;\n        for (int j = i + 1; j < n; ++j) {\n            int dx = points[j].first - points[i].first;\n            int dy = points[j].second - points[i].second;\n            int g = __gcd(dx, dy);\n            dx /= g;\n            dy /= g;\n            // To handle division by zero and sign\n            if (dx < 0) {\n                dx = -dx;\n                dy = -dy;\n            } else if (dx == 0 && dy < 0) {\n                dy = -dy;\n            }\n            auto key = make_pair(dy, dx);\n            if (++slope_count[key] >= 2) {\n                return true; // Found three colinear points\n            }\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    int min_n = opt<int>(\"min_n\", 1);\n    int max_n = opt<int>(\"max_n\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    int total_a = 0;\n    int total_b = 0;\n    int total_n_limit = 3000;\n\n    vector<int> a_list;\n    vector<int> b_list;\n\n    // Decide on a_list and b_list, ensuring total_a and total_b ≤3000\n    for (int i = 0; i < t; ++i) {\n        int remaining_a = total_n_limit - total_a;\n        int remaining_b = total_n_limit - total_b;\n        if (remaining_a < min_n || remaining_b < min_n) {\n            // Can't proceed further\n            t = i;\n            break;\n        }\n        int max_a = min(remaining_a, max_n);\n        int max_b = min(remaining_b, max_n);\n        int a = rnd.next(min_n, max_a);\n        int b = rnd.next(min_n, max_b);\n        total_a += a;\n        total_b += b;\n        a_list.push_back(a);\n        b_list.push_back(b);\n    }\n\n    t = a_list.size();\n    printf(\"%d\\n\", t);\n\n    for (int test = 0; test < t; ++test) {\n        int a = a_list[test];\n        int b = b_list[test];\n\n        // Generate r_j's\n        int M = a - 1;\n        vector<int> rj = split_integer(M, b);\n        for (int i = 0; i < b; ++i) {\n            rj[i] += 1; // Ensure each r_j ≥ 1\n        }\n\n        // Output a and b\n        printf(\"%d %d\\n\", a, b);\n\n        // Output r_j's\n        for (int i = 0; i < b; ++i) {\n            printf(\"%d%c\", rj[i], (i + 1 == b) ? '\\n' : ' ');\n        }\n\n        // Generate coordinates\n        int n_points = a + b;\n        set<pair<int, int>> used_points;\n        vector<pair<int, int>> points;\n        while (points.size() < n_points) {\n            int x = rnd.next(-10000, 10000);\n            int y = rnd.next(-10000, 10000);\n            if (used_points.insert({x, y}).second) {\n                points.emplace_back(x, y);\n            }\n        }\n\n        // Check for colinear points, retry if needed\n        if (n_points <= 500) {\n            while (check_colinear(points)) {\n                used_points.clear();\n                points.clear();\n                while (points.size() < n_points) {\n                    int x = rnd.next(-10000, 10000);\n                    int y = rnd.next(-10000, 10000);\n                    if (used_points.insert({x, y}).second) {\n                        points.emplace_back(x, y);\n                    }\n                }\n            }\n        }\n\n        // Output coordinates of Algoland cities\n        for (int i = 0; i < a; ++i) {\n            printf(\"%d %d\\n\", points[i].first, points[i].second);\n        }\n\n        // Output coordinates of Berland cities\n        for (int i = a; i < n_points; ++i) {\n            printf(\"%d %d\\n\", points[i].first, points[i].second);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to split integer M into k non-negative integers\nvector<int> split_integer(int M, int k) {\n    vector<int> res(k, 0);\n    for (int i = 0; i < M; ++i) {\n        res[rnd.next(k)]++;\n    }\n    return res;\n}\n\nbool check_colinear(const vector<pair<int,int>>& points) {\n    int n = points.size();\n    // For each point, check slope with every other point and detect duplicates\n    for (int i = 0; i < n; ++i) {\n        map<pair<int,int>, int> slope_count;\n        for (int j = i + 1; j < n; ++j) {\n            int dx = points[j].first - points[i].first;\n            int dy = points[j].second - points[i].second;\n            int g = __gcd(dx, dy);\n            dx /= g;\n            dy /= g;\n            // To handle division by zero and sign\n            if (dx < 0) {\n                dx = -dx;\n                dy = -dy;\n            } else if (dx == 0 && dy < 0) {\n                dy = -dy;\n            }\n            auto key = make_pair(dy, dx);\n            if (++slope_count[key] >= 2) {\n                return true; // Found three colinear points\n            }\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    int min_n = opt<int>(\"min_n\", 1);\n    int max_n = opt<int>(\"max_n\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    int total_a = 0;\n    int total_b = 0;\n    int total_n_limit = 3000;\n\n    vector<int> a_list;\n    vector<int> b_list;\n\n    // Decide on a_list and b_list, ensuring total_a and total_b ≤3000\n    for (int i = 0; i < t; ++i) {\n        int remaining_a = total_n_limit - total_a;\n        int remaining_b = total_n_limit - total_b;\n        if (remaining_a < min_n || remaining_b < min_n) {\n            // Can't proceed further\n            t = i;\n            break;\n        }\n        int max_a = min(remaining_a, max_n);\n        int max_b = min(remaining_b, max_n);\n        int a = rnd.next(min_n, max_a);\n        int b = rnd.next(min_n, max_b);\n        total_a += a;\n        total_b += b;\n        a_list.push_back(a);\n        b_list.push_back(b);\n    }\n\n    t = a_list.size();\n    printf(\"%d\\n\", t);\n\n    for (int test = 0; test < t; ++test) {\n        int a = a_list[test];\n        int b = b_list[test];\n\n        // Generate r_j's\n        int M = a - 1;\n        vector<int> rj = split_integer(M, b);\n        for (int i = 0; i < b; ++i) {\n            rj[i] += 1; // Ensure each r_j ≥ 1\n        }\n\n        // Output a and b\n        printf(\"%d %d\\n\", a, b);\n\n        // Output r_j's\n        for (int i = 0; i < b; ++i) {\n            printf(\"%d%c\", rj[i], (i + 1 == b) ? '\\n' : ' ');\n        }\n\n        // Generate coordinates\n        int n_points = a + b;\n        set<pair<int, int>> used_points;\n        vector<pair<int, int>> points;\n        while (points.size() < n_points) {\n            int x = rnd.next(-10000, 10000);\n            int y = rnd.next(-10000, 10000);\n            if (used_points.insert({x, y}).second) {\n                points.emplace_back(x, y);\n            }\n        }\n\n        // Check for colinear points, retry if needed\n        if (n_points <= 500) {\n            while (check_colinear(points)) {\n                used_points.clear();\n                points.clear();\n                while (points.size() < n_points) {\n                    int x = rnd.next(-10000, 10000);\n                    int y = rnd.next(-10000, 10000);\n                    if (used_points.insert({x, y}).second) {\n                        points.emplace_back(x, y);\n                    }\n                }\n            }\n        }\n\n        // Output coordinates of Algoland cities\n        for (int i = 0; i < a; ++i) {\n            printf(\"%d %d\\n\", points[i].first, points[i].second);\n        }\n\n        // Output coordinates of Berland cities\n        for (int i = a; i < n_points; ++i) {\n            printf(\"%d %d\\n\", points[i].first, points[i].second);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -min_n 1 -max_n 5 -type random\n./gen -t 1 -min_n 1000 -max_n 1000 -type random\n./gen -t 1 -min_n 3000 -max_n 3000 -type random\n./gen -t 5 -min_n 1 -max_n 10 -type random\n./gen -t 10 -min_n 50 -max_n 100 -type random\n./gen -t 1 -min_n 5 -max_n 5 -type impossible\n./gen -t 1 -min_n 2 -max_n 2 -type special\n./gen -t 1 -min_n 3 -max_n 3 -type special\n./gen -t 1 -min_n 500 -max_n 500 -type random\n./gen -t 3 -min_n 1000 -max_n 1000 -type random\n./gen -t 10 -min_n 1 -max_n 300 -type random\n./gen -t 2 -min_n 1500 -max_n 1500 -type random\n./gen -t 1 -min_n 2999 -max_n 2999 -type random\n./gen -t 1 -min_n 100 -max_n 100 -type random\n./gen -t 1 -min_n 1000 -max_n 1000 -type special\n./gen -t 1 -min_n 3000 -max_n 3000 -type special\n./gen -t 10 -min_n 1 -max_n 100 -type random\n./gen -t 5 -min_n 200 -max_n 300 -type random\n./gen -t 1 -min_n 3 -max_n 3 -type impossible\n./gen -t 2 -min_n 10 -max_n 1000 -type random\n./gen -t 3 -min_n 1000 -max_n 2000 -type random\n./gen -t 1 -min_n 2000 -max_n 2000 -type random\n./gen -t 1 -min_n 1 -max_n 1 -type random\n./gen -t 10 -min_n 50 -max_n 50 -type random\n./gen -t 5 -min_n 600 -max_n 600 -type random\n./gen -t 1 -min_n 1500 -max_n 1500 -type random\n./gen -t 1 -min_n 2999 -max_n 2999 -type special\n./gen -t 2 -min_n 1 -max_n 1500 -type random\n./gen -t 7 -min_n 100 -max_n 200 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:34.312063",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1071/A",
      "title": "A. Успеть все",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеЕдинственная строка входных данных содержит два целых числа: aa и bb (0≤a,b≤1090≤a,b≤109) — количество часов, которое Леша может потратить на подготовку к экзамену сегодня, и количество часов, в течение которых Леша может готовиться завтра.",
      "output_spec": "Выходные данныеВ первой строке выведите единственное целое число nn (0≤n≤a0≤n≤a) — количество конспектов, которые Леша должен прочитать в первый день. Во второй строке выведите nn целых различных чисел p1,p2,…,pnp1,p2,…,pn (1≤pi≤a1≤pi≤a), сумма всех pipi должна быть не больше aa.В третьей строке выведите единственное целое число mm (0≤m≤b0≤m≤b) — количество конспектов, которые Леша должен прочитать во второй день. В четвертой строке выведите mm целых различных чисел q1,q2,…,qmq1,q2,…,qm (1≤qi≤b1≤qi≤b), сумма всех qiqi должна быть не больше bb.Среди всех чисел pipi и qiqi не должно быть пары совпадающих чисел. Сумма n+mn+m должна быть максимально возможной.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 3Выходные данныеСкопировать13 22 1 Входные данныеСкопировать9 12Выходные данныеСкопировать23 641 2 4 5",
      "description": "A. Успеть все\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеЕдинственная строка входных данных содержит два целых числа: aa и bb (0≤a,b≤1090≤a,b≤109) — количество часов, которое Леша может потратить на подготовку к экзамену сегодня, и количество часов, в течение которых Леша может готовиться завтра.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите единственное целое число nn (0≤n≤a0≤n≤a) — количество конспектов, которые Леша должен прочитать в первый день. Во второй строке выведите nn целых различных чисел p1,p2,…,pnp1,p2,…,pn (1≤pi≤a1≤pi≤a), сумма всех pipi должна быть не больше aa.В третьей строке выведите единственное целое число mm (0≤m≤b0≤m≤b) — количество конспектов, которые Леша должен прочитать во второй день. В четвертой строке выведите mm целых различных чисел q1,q2,…,qmq1,q2,…,qm (1≤qi≤b1≤qi≤b), сумма всех qiqi должна быть не больше bb.Среди всех чисел pipi и qiqi не должно быть пары совпадающих чисел. Сумма n+mn+m должна быть максимально возможной.\n\nВыходные данные\n\nВходные данныеСкопировать3 3Выходные данныеСкопировать13 22 1 Входные данныеСкопировать9 12Выходные данныеСкопировать23 641 2 4 5\n\nВходные данныеСкопировать3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать13 22 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать9 12\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать23 641 2 4 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Леша в первый день должен прочитать третий конспект за 33 часа, а во второй день должен прочитать первый и второй конспекты за один и два часа соответственно, потратив 33 часа на подготовку. Обратите внимание, что Леша может сделать наоборот, то есть прочитать в первый день первый и второй конспекты, а во второй день прочитать третий конспект.Во втором примере Леша в первый день прочитает третий и шестой конспект, потратив на это 99 часов. Во второй день Леша читает первый, второй, четвертый и пятый конспект за 1212 часов суммарно.",
      "solutions": [
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces",
          "content": "Добрый день!В воскресенье, 21-го октября в 11:05 по московскому времени состоится Отборочный Раунд 2 олимпиады для школьников Технокубок 2019. Раунд будет длиться два часа, участникам будут предложены 6 задач. По его результатам лучшие участники (но не более 45% от общего числа участников раунда) будут приглашены на финальный этап в Москву. Для регистрации на раунд и участия перейдите по ссылке. Не забудьте заранее зарегистрироваться на раунд! Для опоздавших будет открыта дополнительная регистрация (с 11:15 до 13:05). Зарегистрироваться на Отборочный Раунд 2 → Соревнование открыто для всех в виде отдельных раундов для первого и второго дивизионов. Для всех участников всех трех редакций этого соревнования будет пересчитан рейтинг. Параллельно с Отборочным Раундом будут проведены открытые рейтинговые раунды для обоих дивизионов, в них могут принять участие все желающие.Напомним, что согласно правилам раундов Codeforces во время соревнования ваши решения будут тестироваться только на претестах (предварительном и неполном наборе тестов), а системное тестирование состоится после окончания раунда. Обратите внимание, что претесты не покрывают все возможные случаи входных данных, поэтому тщательно тестируйте свои программы! После прохождения претестов у вас будет возможность заблокировать решение, тем самым получив привилегию искать ошибки и взламывать чужие решения, но отказавшись от возможности перепослать ваше решение при каких-либо обстоятельствах (например, даже если вы найдете ошибку или вас взломают). Со временем задачи падают в стоимости. После системного тестирования учитываются только полные решения. Подробнее про правила соревнований можно прочитать по ссылкам: короткое описание формата полное описание формата Регистрация на олимпиаду Технокубок еще открыта. Победителей и призеров олимпиады ждут значительные квоты при поступлении в престижные технические вузы России и ценные призы! Если вы — школьник 8-11 классов и пока не зарегистрировались на Технокубок, то самое время сделать это: Зарегистрироваться на олимпиаду → После регистрации на олимпиаду не забудьте зарегистрироваться на Отборочный Раунд! В финал соревнования будут приглашены лучшие участники каждого из отборочных раундов (но не более 45% от общего числа участников раунда). Авторы задач — Александр Kostroma Останин, Александр Golovanov399 Голованов, Артем komendart Комендантян, Денис Denisson Шпаковский и Дарья Dashk0 Колодзей. Для тех, кто впервые на Codeforces: в таблице ниже вы можете найти примеры решений на всех поддерживаемых языках: Группа языков Языки программирования / компиляторы Примеры C GNU C, GNU C11 10903473, 17029870 C++ GNU C++, GNU C++11, GNU C++14, GNU C++17, MS C++, etc. 23794425, 5456501 C# Mono C#, MS C# 3195513, 3794163 D D 5482410, 2060057 Go Go 7114082, 21366098 Haskell Haskell 455333, 1668418 Java Java 8 25491359, 23678167 JavaScript V8 35963909, 35681818 Kotlin Kotlin 25779271, 25204556 OCaml OCaml 6157159, 1281252 Pascal Delphi, FPC, Pascal.NET 1275798, 1259434 Perl Perl 2519448, 1277556 PHP PHP 413942, 35875300 Python Python 2, Python 3, PyPy2, PyPy3 35883730 (Py2), 36179112 (Py3) Ruby Ruby 1837970, 1289551 Rust Rust 25180002, 35652442 Scala Scala 35847980, 2456025 Удачи!Раунд завершен, поздравляем победителей!Технокубок 2019 - Отборочный Раунд 2 Holidin receed Sonechko radoslav11 scanhex Codeforces Round 517 (Div. 1, основан на Отборочном раунде 2 Технокубка 2019) Radewoosh ainta 300iq TLE RAVEman Codeforces Round 517 (Div. 2, основан на Отборочном раунде 2 Технокубка 2019) cz_yixuanxu orbitingfIea I_Love_Irelia djq_fpc buaads Опубликован разбор.UPD: Лучшие 200 участников отборочного этапа Технокубка приглашаются в Финал олимпиады. Поздравляем победителей!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62594",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3716
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces",
          "content": "1031A - Золотая тарелкаКоличество позолоченных клеток в первом (внешнем) кольце есть количество клеток на границе, то есть, 2(w+h)−42(w+h)−4, во втором кольце — количество клеток на прямоугольнике со сторонами на 4 меньше, то есть, 2(w−4+h−4)−42(w−4+h−4)−4, и так далее. Эту сумму можно посчитать в одном цикле. 1031B - Любопытству нет пределаНаучимся решать задачу, если выполнено условие 0≤ai,bi,ti≤10≤ai,bi,ti≤1, то есть все последовательности состоят из 00 и 11. Переберем t1t1, у нас есть всего два варианта  — 0 или 1, тогда вся оставшаяся часть последовательности восстанавливается однозначно. Если t1=0t1=0 и a1=0a1=0 и b1=0b1=0, то t2t2 = 0; Если t1=0t1=0 и a1=0a1=0 и b1=1b1=1, то подходящего t2t2 не существует. Если t1=0t1=0 и a1=1a1=1 и b1=0b1=0, то t2t2 = 1; Если t1=0t1=0 и a1=1a1=1 и b1=1b1=1, то t2t2 = 1; Если t1=1t1=1 и a1=0a1=0 и b1=0b1=0, то подходящего t2t2 не существует. Если t1=1t1=1 и a1=0a1=0 и b1=1b1=1, то подходящего t2t2 не существует. Если t1=1t1=1 и a1=1a1=1 и b1=0b1=0, то t2t2 = 0; Если t1=1t1=1 и a1=1a1=1 и b1=1b1=1, то t2t2 = 1; Аналогично восстанавливаются все titi (3≤i≤n3≤i≤n) или получается противоречие. Для побитовых операций из условия можно решать задачу независимо по каждому биту, то есть найти подходящую последовательность для каждого бита всех числа (или получить противоречие) и восстановить оригинальную последовательность t1,t2,…,tnt1,t2,…,tn. 1031C - Успеть всеПосмотрим на любой ответ, где n+mn+m максимально возможно. Тогда если использовались числа d1,d2,…,dkd1,d2,…,dk (di>n+mdi>n+m), то не использовались какие-то числа h1,h2,…,hkh1,h2,…,hk (hi≤n+mhi≤n+m). Мы можем заменить все didi на hihi (1≤i≤k1≤i≤k) и не нарушить ограничения на суммарную длительность чтения конспектов в день. То есть в ответ входят все числа от 11 до xx, причем x=n+mx=n+m. Сумма всех чисел от 11 до xx равна x∗(x+1)2x∗(x+1)2. Очевидно, что должно выполняться неравенство x(x+1)2≤a+bx(x+1)2≤a+b. Найдем, например линейным поиском, максимальный xx, для которого верно это неравенство. Ответ не может быть больше xx и мы можем конструктивно построить ответ для xx. Будем перебирать конспекты в порядке убывания их номера, то есть от xx до 11, если мы можем прочитать очередной конспект в первый день, то так и сделаем, иначе если в первый день осталось еще w>0w>0 свободного времени, то прочитаем конспект с номером ww (он еще не был прочитан, так как последний непрочитанный конспект имел номер строго больше ww). Остальные конспекты прочитаем во второй день. Так как в первый день мы использовали всё свободное время и x(x+1)2−a≤bx(x+1)2−a≤b, то все оставшиеся конспекты мы сможем прочитать во второй день. Таким образом, мы смогли прочитать все xx конспектов. 1031D - Минимальный путьВначале найдём число букв a в префиксе ответа. Для этого можно посчитать dp[i][j], равные наименьшему возможному числу букв, не равных a, на пути из начального угла в (i, j). Тогда число букв a в начале ответа есть наибольшее среди всех (i+j)(i+j) для таких клеток (i,j)(i,j), что dp[i][j]≤kdp[i][j]≤k (или 00, если таких нет).Рассмотрим все клетки, куда мы могли перейти сразу после выписывания последней a в префиксе. Повторим следующий процесс до конца: припишем к ответу минимальную из букв в рассматриваемых клетках, выберем клетки, где достигается минимум, и перейдём из них по обоим направлениям, чтобы получить новый список клеток. Легко видеть, что полученный ответ действительно искомый. 1031E - Тройное инвертированиеУ данной задачи может быть много решений, в том числе с сложно доказуемым количеством операций. Опишем одно из авторских решений и как прийти к нему.При маленьких длинах массива можно находить ответ перебором. Например, сгенерировать все возможные арифметические прогресии длины 3 и перебрать, какие будем использовать.Можно проверить вручную или написать перебор на компьютере и удостовериться, что при 3≤n≤73≤n≤7 существуют массивы длины nn, которые невозможно обнулить, а при n=8n=8 (а следовательно и n≥8n≥8) массив можно обнулить всегда.Хотелось бы, чтобы решение состояло из следующих шагов: Если nn маленькое, то сразу запускаем перебор Иначе пытаемся обнулить все элементы массива, кроме первых kk, где k≥8k≥8 достаточно мало, чтобы запустить перебор. Запускаем перебор на первых kk элементах Как делать второй пункт? Попытаемся обнулить три последних элемента в массиве за одну операцию. Очевидно, в операциях можно использовать и предыдущие элементы. То есть если у нас массив …,0,0,1…,0,0,1, то можно поменять значения в первом, четвёртом и седьмом элементе с конца, если длина массива не меньше семи. К сожалению, есть контрпример …,0,1,1…,0,1,1, где нельзя обнулить последние три элемента. Хорошо, тогда попытаемся обнулить шесть последних элементов за две операции. Расписав на листочке или написав перебор, можно понять, что это возможно всегда и достаточно, чтобы во всём массиве было хотя бы одиннадцать элементов.Отсюда получается такой алгоритм решения: Пусть kk – количество первых элементов массива, которые мы ещё не пытались обнулись. Изначально k=nk=n. Пока k≥11k≥11 обнуляем за две операции kk-й, (k−1)(k−1)-й,.., (k−5)(k−5)-й элементы, уменьшаем kk на 6. Если k≤10k≤10, то запускаем перебор на первых десяти элементах (или на всём массиве, если в нём меньше десяти элементов) Какое количество операций в таком решении? Во втором пункте количество операций меньше или равно 2⋅⌊n6⌋≤⌊n3⌋2⋅⌊n6⌋≤⌊n3⌋ В третьем пункте количество операций меньше или равно 6 (проверяется опять же перебором) Следовательно, общее количество операций меньше или равно ⌊n3⌋+6⌊n3⌋+6, что подходит под ограничения задачи 1031F - Знакомые операцииЗаметим, что если a=∏i=1kpxiia=∏i=1kpixi, то d(a)=∏i=1k(xi+1)d(a)=∏i=1k(xi+1). Поэтому можно поставить в соответствие aa и вектор (x1,x2,…,xk)(x1,x2,…,xk), где x1≥x2≥…≥xkx1≥x2≥…≥xk, так как порядок степеней не имеет значения. Операции соответствуют прибавлению 1 к некоторой координате, добавлению 1 в конец или вычитанию 1 из некоторой координаты и сортировке вектора после этого с удалением нулей. Для чисел до 106106 таких векторов получается 289, а значит надо посчитать лишь 41616 расстояний.Первая идея — запустить алгоритм Флойда на этих 289 вершинах, что вполне укладывается по времени. После этого для каждой пары (x,d)(x,d) можно посчитать минимальное число операций, которые нужно сделать для превращения вектора xx в вектор, соответствующий числу с dd делителями. Для нахождения ответа для (x,y)(x,y) можно проитерироваться по всем возможным dd. Однако, бывают хитрые случаи. Например, для чисел 219219 и 22362236 ответ равен 1, так как после умножения первого числа на 2 оба числа имеют по 21 делителю. Но 220>106220>106, и вектора (20)(20) нет среди рассмотренных 289 векторов. Значит, мы должны рассмотреть еще какие-то векторы.В любом случае, можно запустить алгоритм, который найдет ответы для всех пар, если можно использовать только числа до 106106. Оказывается, что желаемого всегда можно добиться за не более 10 операций.Это означает, что в исходной задаче все использованные числа удовлетворяют условию ∑i=1kxi<30∑i=1kxi<30, так как для чисел-запросов сумма не превосходит 19, а операций с каждым числом может быть проделано не больше 10. Это условие дает нам все векторы, которые могут встречаться в оптимальных ответах. Всего таких векторов 28629. Можно запустить 289 bfs-ов на построенном графе со стартом в каждом векторе-возможном запросе, а потом построить такую же структуру данных для пар (x,d)(x,d), как описано выше. Такое решение работает 2.5 секунды на серверах CF, что еще немного медленно. Но теперь мы по крайней мере знаем ответы для всех возможных запросов. Поэтому можно пытаться избавиться от ненужных вершин в графе, проверяя, что ответы для всех запросов не поменялись. Одно из ускорений — рассматривать только векторы, дающие числа с небольшим числом делителей. Точная граница на это число равна 288. Другой подход — уменьшить возможную сумму степеней в векторе, здесь точная граница равна 22. 1071E - Защита от дождяПрежде всего научимся определять, возможно ли поймать все капли, двигаясь со скоростью vv.Предположим, в какой-то момент концы верёвки расположены в (e1,0)(e1,0) и (e2,h)(e2,h). Такому состоянию будем ставить в соответствие точку (e1,e2)(e1,e2) (будем называть это точкой состояния). В дальнейшем мы будем работать с этими точками. Известно, что эта точка может двигаться со скоростью vv независимо в обоих направлениях, то есть, если в какой-то момент tt она находится в (x,y)(x,y), то в момент времени t+dtt+dt она будет находиться в прямоугольнике [x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt][x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt].Оказывается, для каждого ii верно ровно одно из следующих утверждений: мы не можем поймать капли с 11 по ii; мы можем их поймать, и при этом есть только одно место, где может быть точка состояния в момент titi; мы можем их поймать, и геометрическое место возможных точек состояния в момент titi есть некоторый отрезок. Докажем это по индукции. База для t0=0t0=0 очевидна. Переход: Если мы не можем поймать капли с 11 по ii, то до i+1i+1 тем более. Если мы можем их поймать и после этого находимся в каком-то отрезке (возможно, нулевой длины), то в момент ti+1ti+1 точка состояния может находиться в выпуклой оболочке объединения двух квадратов. Эти квадраты представляются в виде [x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt][x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt] для концов (x,y)(x,y) отрезка в момент titi, и здесь dt=ti+1−tidt=ti+1−ti.Мы также знаем, что в момент ti+1ti+1 верёвка должна содержать данную точку, что может быть выражено линейным уравнением от точки состояния в момент ti+1ti+1. Поэтому чтобы получить искомый отрезок для момента ti+1ti+1, надо пересечь прямую с выпуклой оболочкой некоторых 88 точек (на самом деле, это будет не более, чем шестиугольник).Однако это не всё: концы верёвки не должны выходить за пределы реек, то есть, выпуклую оболочку следует сначала пересечь с квадратом [0,w]×[0,w][0,w]×[0,w]. С другой стороны, это можно сделать и после пересечения прямой с многоугольником. Итак, решение заключается в следующем: Вначале проверим, можно ли вообще собрать все капли. Если нельзя, то это возможно лишь в случае, когда одновременно надо накрыть две точки, прямая через которые не пересекает рейки, или надо накрыть три точки, не лежащие на одной прямой. Легчайший способ это проверить — запустить алгоритм выше для скорости ww. Во-первых, для этого (почти) не надо разбирать случаи, во-вторых, нам всё равно пригодится функция, вычисляющая по скорость возможность всё собрать. После этого запустим бинарный поиск, чтобы найти наименьшую скорость, с которой можно собрать все капли. Это была идейная часть. Однако вовсе не очевидно, что с точностью не будет проблем.Рассуждения ниже могут использовать термины, незнакомые большинству читателей. Пожалуйста, не пугайтесь, я объясняю их значение сразу после того, как введу их. Это сделано для того, чтобы знакомые с этими понятиями могли быстрее уловить мысль автора разбора и, возможно, пропустить абзац. Для тех, кто не хочет этого читать, а хочет знать, чем всё закончится: точности long double должно хватать при условии, что аккуратно обработаны пересечения прямых.Определим функцию fi(v)fi(v) как ℓ∞ℓ∞-диаметр множества возможных точек состояния на момент titi для скорости vv, то есть, fi(v)=0fi(v)=0, если это множество пусто или состоит из одной точки; fi(v)=max(|x1−x2|,|y1−y2|)fi(v)=max(|x1−x2|,|y1−y2|), если это отрезок с концами в (x1,y1)(x1,y1) и (x2,y2)(x2,y2). Другими словами, все длины мы теперь будем считать в этой метрике. Так будет удобнее для наших целей.Обозначим через v^v^ правильный ответ, и пусть εε есть достаточно малое положительное вещественное число.Легко видеть, что все titi могут быть разбиты на две группы, различающиеся по смыслу: моменты, в которые надо поймать только одну каплю (или много одинаковых, что неважно), моменты, в которые надо поймать больше одной различной капли. Для первых мы просто пересекаем многоугольник с прямой, но для вторых точка состояния в момент titi определяется однозначно и не зависит от скорости (или такие titi в самом начале говорят нам, что все точки собрать не получится). Назовём капли в моменты первого типа простыми, а остальные — сложными.Докажем следующие леммы:Лемма 1a. Пусть ii — индекс простой капли. Тогда для v=v^+εv=v^+ε каждое fi(v)fi(v) не меньше εε.Лемма 1b. Пусть ii — индекс сложной капли. Тогда для v=v^+εv=v^+ε соответствующая позиция точки состояния в момент titi находится на расстоянии хотя бы εε от границы многоугольника до пересечения с [0,w]×[0,w][0,w]×[0,w].Лемма 2. Пусть idxidx — первая капля, которую нельзя поймать со скоростью, очень близкой к v^v^, но при этом меньше неё. Тогда для v=v^−εv=v^−ε или наш алгоритм завершится раньше, чем дойдёт до idxidx-й капли, или соответствующая прямая для этой капли (или точка, если это сложная капля) находится на расстоянии хотя бы εε от соответствующего многоугольника точек состояния (опять же, в ℓ∞ℓ∞).Очевидно, эти леммы доказывают решение выше. В самом деле, если сравнивать все пересечения прямых с хорошей точностью, то в какой-то момент границы бинпоиска попадут в интервал (v^−ε,v^+ε)(v^−ε,v^+ε), чего достаточно для достаточно малых εε.Доказательство леммы 1 (обоих вариантов). Зафиксируем ii. Мы знаем, что (i−1)(i−1)-е множество Si−1(v)Si−1(v) возможных точек состояния для v=v^v=v^ непусто (из определения v^v^). Легко видеть, что (i−1)(i−1)-е множество для v=v^+εv=v^+ε есть надмножество Si−1(v^)Si−1(v^), например, попросту потому что мы можем двигаться не быстрее, чем v^<v^+εv^<v^+ε. Чтобы получить SiSi, мы можем двигаться из Si−1Si−1 не больше, чем на (ti−ti−1)(v^+ε)≤(ti−ti−1)v^+ε(ti−ti−1)(v^+ε)≤(ti−ti−1)v^+ε. Это завершает доказательство 1b. Поскольку Si(v^)Si(v^) также непусто, Si(v^+ε)Si(v^+ε) есть не меньше, чем отрезок Si(v^)Si(v^), а также все точки на соответствующей ему прямой на расстоянии не больше εε от его концов, то есть, как минимум на εε больше, чем Si(v^)Si(v^), то есть, имеет длину как минимум εε, чтд.Доказательство леммы 2. Предположим, наш алгоритм сделал хотя бы idxidx итерацию. Рассмотрим соответствующий многоугольник точек состояния в момент tidxtidx. Мы знаем, что для v=v^v=v^ этот многоугольник имеет непустое пересечение с соответствующей прямой, но его внутренность не имеет. Это означает, что любая точка соответствующей прямой (или единственная точка, если момент времени соответствует сложной капле) не лежит внутри этого многоугольника. Но тогда если мы уменьшим vv на εε, то расстояние от каждой точки множества точек состояния до этого многоугольника будет хотя бы εε, чтд.Итак, единственные проблемы с точностью, которые могут возникнуть, появляются, когда надо пересечь две прямые и проверить точку из пересечения на принадлежность другой прямой (или многоугольнику). Эта часть решения может быть реализована в целых числах, но всё же разберём это место подробнее.Легко видеть, что капля (x,y)(x,y) лежит на верёвке тогда и только тогда, когдаyx−e1=h−ye2−x,yx−e1=h−ye2−x,или(e2−x)y=(x−e1)(h−y)⇒e1(h−y)+e2y=xh.(e2−x)y=(x−e1)(h−y)⇒e1(h−y)+e2y=xh.Поскольку коэффициенты этого уравнения имеют порядок hh, координаты его решения есть рациональные числа со знаменателем порядка не больше 1/h21/h2. Если мы хотим проверить, что эта точка лежит на другой прямой, нам придётся сравнить рациональное, отличающееся от целого на ≤h2≤h2, с другим целым, то есть, достаточно производить эти вычисления с точностью порядка 1/h21/h2 или лучше.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 1071"
          },
          "content_length": 15369
        }
      ],
      "code_examples": [
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 1",
          "code": "int dp[2001][2001]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 2",
          "code": "dp[i][j] = fillDp(i + 1, j, i, j + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 3",
          "code": "//(x, y) - pointer which is lower, (b, a) - pointer which is to the right\nint fillDp(int y, int x, int b, int a) {\n    if (arr[y][x] < arr[b][a]) return 0; //you can only go down\n    if (arr[y][x] > arr[b][a]) return 1; //only right\n    if (b == y && a == x) return 2; //doesn't really matter which way\n    //if letters are the same and we check different fields\n    //we either move according to dp or (if dp == 2) we move pointers closer to each other\n    if (dp[y][x] == 0) y++;\n    else x++;\n    if (dp[b][a] == 1) a++;\n    else b++;\n    return fillDp(y, x, b, a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 4",
          "code": "//(x, y) - pointer which is lower, (b, a) - pointer which is to the right\nint fillDp(int y, int x, int b, int a) {\n    if (arr[y][x] < arr[b][a]) return 0; //you can only go down\n    if (arr[y][x] > arr[b][a]) return 1; //only right\n    if (b == y && a == x) return 2; //doesn't really matter which way\n    //if letters are the same and we check different fields\n    //we either move according to dp or (if dp == 2) we move pointers closer to each other\n    if (dp[y][x] == 0) y++;\n    else x++;\n    if (dp[b][a] == 1) a++;\n    else b++;\n    return fillDp(y, x, b, a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 5",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 6",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 7",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 8",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 9",
          "code": "1 + 2 + ... + k <= a + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 10",
          "code": "S = 1 + 2 + ... + k <= a + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 11",
          "code": "3\n2 3 4\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 12",
          "code": "3\n2 3 4\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 13",
          "code": "7\n1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 14",
          "code": "7\n1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 15",
          "code": "YES\n3\n3 5 7\n3 4 5\n1 4 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 16",
          "code": "YES\n3\n3 5 7\n3 4 5\n1 4 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 17",
          "code": "YES\n3\n5 6 7\n1 4 7\n4 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 18",
          "code": "YES\n3\n5 6 7\n1 4 7\n4 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 19",
          "code": "100000\n0 1 0 1 0\n...\n0 1 0 1 0\n0 0 0 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 20",
          "code": "100000\n0 1 0 1 0\n...\n0 1 0 1 0\n0 0 0 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 21",
          "code": "125\n1 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 22",
          "code": "125\n1 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 23",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 24",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 25",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Технокубок 2019 — Отборочный Раунд 2 (и открытые рейтинговые раунды Codeforces Round 517 Div.1, Div.2) - Codeforces - Code 26",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 1",
          "code": "100000\n3 3 3 2 3 ...(repeat)\n0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 2",
          "code": "100000\n3 3 3 2 3 ...(repeat)\n0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 3",
          "code": "YES\n1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 4",
          "code": "YES\n1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 5",
          "code": "for(int j = 0;j<=3;j++){ // values of b(i)\n\n        for(int k = 0;k<=3;k++){ // values of t(i+1)\n\n            cout << i << \" \" << j << \" \" << k << \" -> \";\n\n            for(int l = 0;l<=3;l++){ // possible values of t(i) \n                if((k & l )== j && ((k|l) == i)){\n                    cout << l << \" \";\n                }\n            }\n            cout << endl;\n        }\n    }\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 6",
          "code": "wrong answer Integer parameter [name=m] equals to 33346, violates the range [0, 33345]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 7",
          "code": "bcc\ncaa\nggg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 8",
          "code": "bcc\ncaa\nggg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 9",
          "code": "0 0 0 1 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 10",
          "code": "0 0 0 1 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 11",
          "code": "1 0 1 0 1 0 0 0\n0 0 1 0 1 0 1 0 \n1 0 0 1 0 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 12",
          "code": "1 0 1 0 1 0 0 0\n0 0 1 0 1 0 1 0 \n1 0 0 1 0 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 13",
          "code": "0 0 1 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 14",
          "code": "0 0 1 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 15",
          "code": "0 0 1 1 1 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 16",
          "code": "0 0 1 1 1 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 17",
          "code": "0 1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 18",
          "code": "0 1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 19",
          "code": "0 1 0 0 1 0 0 1\n0 0 0 0 1 1 1 0\n0 0 0 0 0 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 20",
          "code": "0 1 0 0 1 0 0 1\n0 0 0 0 1 1 1 0\n0 0 0 0 0 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 21",
          "code": "1 0 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 22",
          "code": "1 0 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 23",
          "code": "1 0 0 1 0 0 1 0\n0 0 0 1 1 1 0 0\n0 0 0 0 1 1 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 24",
          "code": "1 0 0 1 0 0 1 0\n0 0 0 1 1 1 0 0\n0 0 0 0 1 1 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 25",
          "code": "(prod, pos)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 26",
          "code": "(prod / k, pos + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 27",
          "code": "abs(x[pos] - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 28",
          "code": "3 5 5\n3 4\n2 1 0\n4 2 1\n5 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 29",
          "code": "3 5 5\n3 4\n2 1 0\n4 2 1\n5 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 30",
          "code": "2 5 5\n5 0\n1 0 0\n2 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 31",
          "code": "2 5 5\n5 0\n1 0 0\n2 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 32",
          "code": "3 4 4\n2 3\n2 2 2\n4 1 1\n5 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 33",
          "code": "3 4 4\n2 3\n2 2 2\n4 1 1\n5 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 34",
          "code": "3 5 5\n3 2\n2 3 3\n4 3 2\n6 1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Отборочного Раунда 2 Технокубка 2019 и Codeforces Round #517 - Codeforces - Code 35",
          "code": "3 5 5\n3 2\n2 3 3\n4 3 2\n6 1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> nums = inf.readInts(2, 0, 1000000000, \"nums\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> nums = inf.readInts(2, 0, 1000000000, \"nums\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> nums = inf.readInts(2, 0, 1000000000, \"nums\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long a, b;\n\nstruct Answer {\n    int n;\n    vector<long long> p;\n    int m;\n    vector<long long> q;\n};\n\nAnswer readAns(InStream& stream, long long a, long long b) {\n    Answer ans;\n    ans.n = stream.readInt(0, (int)1e9, \"n\");\n    long long sum_p = 0;\n    set<long long> usedNotes;\n    for (int i = 0; i < ans.n; i++) {\n        long long pi = stream.readLong(1, (long long)2e9, format(\"p[%d]\", i + 1).c_str());\n        ans.p.push_back(pi);\n        if (pi > a)\n            stream.quitf(_wa, \"Note %lld is too large to read on day 1\", pi);\n        sum_p += pi;\n        if (sum_p > a)\n            stream.quitf(_wa, \"Total time on day 1 exceeds 'a'\");\n        if (usedNotes.count(pi))\n            stream.quitf(_wa, \"Note %lld is used more than once\", pi);\n        usedNotes.insert(pi);\n    }\n    ans.m = stream.readInt(0, (int)1e9, \"m\");\n    long long sum_q = 0;\n    for (int i = 0; i < ans.m; i++) {\n        long long qi = stream.readLong(1, (long long)2e9, format(\"q[%d]\", i + 1).c_str());\n        ans.q.push_back(qi);\n        if (qi > b)\n            stream.quitf(_wa, \"Note %lld is too large to read on day 2\", qi);\n        sum_q += qi;\n        if (sum_q > b)\n            stream.quitf(_wa, \"Total time on day 2 exceeds 'b'\");\n        if (usedNotes.count(qi))\n            stream.quitf(_wa, \"Note %lld is used more than once\", qi);\n        usedNotes.insert(qi);\n    }\n    return ans;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    a = inf.readLong(0, (long long)1e9, \"a\");\n    b = inf.readLong(0, (long long)1e9, \"b\");\n    Answer juryAns = readAns(ans, a, b);\n    Answer partAns = readAns(ouf, a, b);\n    int juryTotal = juryAns.n + juryAns.m;\n    int partTotal = partAns.n + partAns.m;\n\n    if (partTotal < juryTotal) {\n        quitf(_wa, \"Participant read fewer notes than jury's answer: participant read %d, jury read %d\", partTotal, juryTotal);\n    } else if (partTotal > juryTotal) {\n        quitf(_fail, \"Participant read more notes than jury's answer: participant read %d, jury read %d\", partTotal, juryTotal);\n    } else {\n        quitf(_ok, \"Participant's answer is correct, total notes read: %d\", partTotal);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long maxA = opt<long long>(\"maxA\", 1000000000); // Default maxA = 1e9\n    long long maxB = opt<long long>(\"maxB\", 1000000000); // Default maxB = 1e9\n    string type = opt<string>(\"type\", \"random\");\n\n    long long a, b;\n\n    if (type == \"zero_zero\") {\n        a = 0;\n        b = 0;\n    } else if (type == \"zero_a\") {\n        a = 0;\n        b = rnd.next(1LL, maxB);\n    } else if (type == \"zero_b\") {\n        a = rnd.next(1LL, maxA);\n        b = 0;\n    } else if (type == \"small\") {\n        a = rnd.next(0LL, 100LL);\n        b = rnd.next(0LL, 100LL);\n    } else if (type == \"large\") {\n        a = rnd.next(max(0LL, maxA - 1000), maxA);\n        b = rnd.next(max(0LL, maxB - 1000), maxB);\n    } else if (type == \"max\") {\n        a = maxA;\n        b = maxB;\n    } else if (type == \"max_notes\") {\n        // Maximize the total number of notes\n        long long n = floor((-1 + sqrt(1 + 8.0 * maxA)) / 2);\n        a = n * (n + 1) / 2;\n        long long m = floor((-1 + sqrt(1 + 8.0 * maxB)) / 2);\n        b = m * (m + 1) / 2;\n    } else if (type == \"one_day_large\") {\n        a = maxA;\n        b = 0;\n    } else if (type == \"one_day_small\") {\n        a = 0;\n        b = maxB;\n    } else {\n        // Default to random\n        a = rnd.next(0LL, maxA);\n        b = rnd.next(0LL, maxB);\n    }\n\n    printf(\"%lld %lld\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long maxA = opt<long long>(\"maxA\", 1000000000); // Default maxA = 1e9\n    long long maxB = opt<long long>(\"maxB\", 1000000000); // Default maxB = 1e9\n    string type = opt<string>(\"type\", \"random\");\n\n    long long a, b;\n\n    if (type == \"zero_zero\") {\n        a = 0;\n        b = 0;\n    } else if (type == \"zero_a\") {\n        a = 0;\n        b = rnd.next(1LL, maxB);\n    } else if (type == \"zero_b\") {\n        a = rnd.next(1LL, maxA);\n        b = 0;\n    } else if (type == \"small\") {\n        a = rnd.next(0LL, 100LL);\n        b = rnd.next(0LL, 100LL);\n    } else if (type == \"large\") {\n        a = rnd.next(max(0LL, maxA - 1000), maxA);\n        b = rnd.next(max(0LL, maxB - 1000), maxB);\n    } else if (type == \"max\") {\n        a = maxA;\n        b = maxB;\n    } else if (type == \"max_notes\") {\n        // Maximize the total number of notes\n        long long n = floor((-1 + sqrt(1 + 8.0 * maxA)) / 2);\n        a = n * (n + 1) / 2;\n        long long m = floor((-1 + sqrt(1 + 8.0 * maxB)) / 2);\n        b = m * (m + 1) / 2;\n    } else if (type == \"one_day_large\") {\n        a = maxA;\n        b = 0;\n    } else if (type == \"one_day_small\") {\n        a = 0;\n        b = maxB;\n    } else {\n        // Default to random\n        a = rnd.next(0LL, maxA);\n        b = rnd.next(0LL, maxB);\n    }\n\n    printf(\"%lld %lld\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type zero_zero\n./gen -type zero_a -maxB 1\n./gen -type zero_b -maxA 1\n./gen -type zero_a -maxB 1000000000\n./gen -type zero_b -maxA 1000000000\n./gen -type small\n./gen -type large\n./gen -type max\n./gen -type random\n./gen -type max_notes -maxA 1000000000 -maxB 1000000000\n./gen -type max_notes -maxA 1000000 -maxB 1000000\n./gen -type max_notes -maxA 500000000 -maxB 0\n./gen -type max_notes -maxA 0 -maxB 500000000\n./gen -type max_notes -maxA 999999999 -maxB 123456789\n./gen -type random -maxA 0 -maxB 1000000000\n./gen -type random -maxA 1000000000 -maxB 0\n./gen -type random -maxA 1 -maxB 1\n./gen -type random -maxA 999999999 -maxB 999999999\n./gen -type random -maxA 123456789 -maxB 987654321\n./gen -type random -maxA 1000000000 -maxB 1\n./gen -type random -maxA 1 -maxB 1000000000\n./gen -type random -maxA 500000000 -maxB 500000000\n./gen -type random -maxA 1000000000 -maxB 100\n./gen -type random -maxA 100 -maxB 1000000000\n./gen -type one_day_large -maxA 1000000000\n./gen -type one_day_small -maxB 1000000000\n./gen -type large -maxA 1000000000 -maxB 1000000000\n./gen -type small -maxA 10 -maxB 10\n./gen -type random -maxA 0 -maxB 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:36.073979",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1071/B",
      "title": "B. Minimum path",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and kk (1≤n≤20001≤n≤2000, 0≤k≤n20≤k≤n2) — the size of the matrix and the number of letters you can change.Each of the next nn lines contains a string of nn lowercase English letters denoting one row of the matrix.",
      "output_spec": "OutputOutput the lexicographically smallest string that can be associated with some valid path after changing no more than kk letters in the matrix.",
      "sample_tests": "ExamplesInputCopy4 2abcdbcdebcadbcdeOutputCopyaaabcdeInputCopy5 3bwwwzhrhdhsepspsqfafajbvwOutputCopyaaaepfafwInputCopy7 6ypnxnnppnxonpmnxanpouxnnpmudnhtdudunpmuduhpmutsnzOutputCopyaaaaaaadudsnz",
      "description": "B. Minimum path\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and kk (1≤n≤20001≤n≤2000, 0≤k≤n20≤k≤n2) — the size of the matrix and the number of letters you can change.Each of the next nn lines contains a string of nn lowercase English letters denoting one row of the matrix.\n\nOutputOutput the lexicographically smallest string that can be associated with some valid path after changing no more than kk letters in the matrix.\n\nInputCopy4 2abcdbcdebcadbcdeOutputCopyaaabcdeInputCopy5 3bwwwzhrhdhsepspsqfafajbvwOutputCopyaaaepfafwInputCopy7 6ypnxnnppnxonpmnxanpouxnnpmudnhtdudunpmuduhpmutsnzOutputCopyaaaaaaadudsnz\n\nInputCopy4 2abcdbcdebcadbcde\n\nOutputCopyaaabcde\n\nInputCopy5 3bwwwzhrhdhsepspsqfafajbvw\n\nOutputCopyaaaepfafw\n\nInputCopy7 6ypnxnnppnxonpmnxanpouxnnpmudnhtdudunpmuduhpmutsnz\n\nOutputCopyaaaaaaadudsnz\n\nNoteIn the first sample test case it is possible to change letters 'b' in cells (2,1)(2,1) and (3,1)(3,1) to 'a', then the minimum path contains cells (1,1),(2,1),(3,1),(4,1),(4,2),(4,3),(4,4)(1,1),(2,1),(3,1),(4,1),(4,2),(4,3),(4,4). The first coordinate corresponds to the row and the second coordinate corresponds to the column.",
      "solutions": [
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces",
          "content": "Hi all!This weekend, at Sunday, October 21, 2018 at 16:10UTC+8 we will hold Codeforces Round 517. It is based on problems of Technocup 2019 Elimination Round 2 that will be held at the same time.Technocup is a major olympiad for Russian-speaking high-school students, so if you fall into this category, please register at Technocup 2019 website and take part in the Elimination Round.Div. 1 and Div.2 editions are open and rated for everyone. Register and enjoy the contests!The round authors are Kostroma, Golovanov399, komendart, Denisson and Dashk0.Have fun!The round is over, congratulations to the winners!Technocup 2019 - Elimination Round 2 Holidin receed Sonechko radoslav11 scanhex Codeforces Round 517 (Div. 1, based on Technocup 2019 Elimination Round 2) Radewoosh ainta 300iq TLE RAVEman Codeforces Round 517 (Div. 2, based on Technocup 2019 Elimination Round 2) cz_yixuanxu orbitingfIea I_Love_Irelia djq_fpc buaads The editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62594",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 956
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces",
          "content": "1031A - Golden PlateThe number of gilded cells in the first (outer) ring is the number of border cells, that is, 2(w+h)−42(w+h)−4, in the second ring — the number of border cells of the center rectangle with side lengths 4 less, that is, 2(w−4+h−4)−42(w−4+h−4)−4, and so on. This sum can be calculated in a single loop. 1031B - Curiosity Has No LimitsLet's solve the problem for 0≤ai,bi,ti≤10≤ai,bi,ti≤1, that is, for binary sequences. There are two options for t1t1, the remaining part can be determined one number by one after this: If t1=0t1=0 and a1=0a1=0 and b1=0b1=0 then t2t2 = 0; If t1=0t1=0 and a1=0a1=0 and b1=1b1=1 then there is no such t2t2. If t1=0t1=0 and a1=1a1=1 and b1=0b1=0 then t2t2 = 1; If t1=0t1=0 and a1=1a1=1 and b1=1b1=1 then t2t2 = 1; If t1=1t1=1 and a1=0a1=0 and b1=0b1=0 then there is no such t2t2. If t1=1t1=1 and a1=0a1=0 and b1=1b1=1 then there is no such t2t2. If t1=1t1=1 and a1=1a1=1 and b1=0b1=0 then t2t2 = 0; If t1=1t1=1 and a1=1a1=1 and b1=1b1=1 then t2t2 = 1; One can similarly find all other titi-s (3≤i≤n3≤i≤n) or get a contradiction.For bitwise operations from the statement one can solve the problem independently for every bit and restore the original sequence t1,t2,…,tnt1,t2,…,tn. 1031C - Cram TimeConsider any answer with maximal n+mn+m. If we used numbers d1,d2,…,dkd1,d2,…,dk (di>n+mdi>n+m), then we didn't use some numbers h1,h2,…,hkh1,h2,…,hk (hi≤n+mhi≤n+m). Replacing all didi by hihi (1≤i≤k1≤i≤k) doesn't violate the restriction. That means that we can assume that the answer consists of all numbers from 11 to xx, and x=n+mx=n+m. The sum of all numbers from 11 to xx equals x(x+1)2x(x+1)2. It's clear that the following inequality must hold: x(x+1)2≤a+bx(x+1)2≤a+b. Let's find the maximal xx for which it's true. The answer can't exceed xx, and we can build the answer for xx iteratively. Let's iterate over all lecture notes from xx to 11, and on each step we put it into the first day if we can, otherwise if in the first day we have w>0w>0 free time then we put the lecture note w<xw<x to the first day. All other lecture notes can be read during the second day since the either there are none of them, or the first day is full and hence the second day contains a sufficient amount of hours to read'em all. 1031D - Minimum pathFirst, let's find the number of a-s in the beginning of the answer. To do this one can calculate dp[i][j] standing for the minimal number of non-a-s among all paths from the initial corner to (i, j). The number of a-s is simply the greatest (i+j)(i+j) among all pairs (i,j)(i,j) such that dp[i][j]≤kdp[i][j]≤k (or 00, if there are no).Consider all cells where we can go right after obtaining the prefix of a-s. Now we repeat the following: append the minimal symbol in these cells to the answer, choose those cells and go from them in both possible directions to obtain the new set of cells. One can see that the answer we obtain is indeed the required answer. 1031E - Triple FlipsThis problem has a lot of solutions including those ones which are difficult to prove. Let's describe one of the author's solutions.We can find answer with bruteforce if size of array is rather small. For example we can check all combinations of arithmetic progressions with length equals to three.We can find by hand or bruteforce that for 3≤n≤73≤n≤7 arrays with no solution exists but for n=8n=8 (and consequently for n≥8n≥8) we always can make all elements be equal to zero.We want solution with such steps: If nn is small just run bruteforce Else try to make all elements besides the first kk (k≥8k≥8) be equal to zero Run bruteforce on the first kk elements. How to make the second step? Let's try to make three last elements of array be equal to zero with only one operation. We can use previous elements. So if we have array …,0,0,1…,0,0,1 we can change values of the first, the fourth and the seventh elements from the end. But …,0,1,1…,0,1,1 is counter-example.Ok, let's try to make six last elements of array be equal to zero with two operations. We can check by hand or bruteforce that it can be done and n≥11n≥11 is enough.So we have such solution: Let kk is the number of first elements of array which we didn't try to make be equal to zero. In the start k=nk=n While k≥11k≥11 make kk-th, (k−1)(k−1)-th,.., (k−5)(k−5)-th elements be equal to zero. Subtract 6 from kk. If k≤10k≤10 run bruteforce on the first 1010 elements or on the whole array if n<10n<10. How many operations will be done? In the second item the number of operations is less or equal than 2⋅⌊n6⌋≤⌊n3⌋2⋅⌊n6⌋≤⌊n3⌋ In the third item the number of operations is less or equal than 6 (can be checked by hand or bruteforce) So the total number of operations is less or equal than ⌊n3⌋+6⌊n3⌋+6, what is good enough. 1031F - Familiar OperationsNote that if a=∏i=1kpxiia=∏i=1kpixi then d(a)=∏i=1k(xi+1)d(a)=∏i=1k(xi+1). This implies that we can map aa to vector (x1,x2,…,xk)(x1,x2,…,xk), where x1≥x2≥…≥xkx1≥x2≥…≥xk, because the order of the powers doesn't matter. The operations correspond to adding 1 to some item or appending 1 to the end of the vector or decreasing 1 from some item and sorting the vector after that, erasing zeros. There are only 289 different such vectors for numbers up to 106106, so we need to calculate only 41616 distances.The first thought could be to just run Floyd-Warshall algorithm on these 289 vertices, which would fit in time. After that for each pair (x,d)(x,d) we can find the minimum number of operations needed to make with vector xx so that the generated number has dd divisors. To find the answer for (x,y)(x,y), we could simply iterate over all possible values of dd. But there are some tricky cases. For example, for numbers 219219 and 22362236 the answer is 1, because after multiplying the first number by 2 both numbers have 21 divisors. But the number 220>106220>106, and the vector (20)(20) is not among these 289 vertices. So, we need to consider some other vectors too.Anyway, let's run this algorithm to see what could be the maximal distance between the two numbers up to 106106. It turns out that in 10 operations any two numbers can be led to have the same number of divisors when all numbers in the path don't exceed 106106 too.This means that each possible number in the optimal path satisfies ∑i=1kxi<30∑i=1kxi<30, because for the numbers in the input this sum doesn't exceed 19, and there can be no more than 10 operations with each number. This condition gives us all vectors of powers necessary to consider as middle points for the pairs which can be in the input. There are 28629 such vectors. Now we run 289 bfs instances on the generated graph with the start in each possible vector from the input and build the same data structure for pairs (x,d)(x,d) as explained before, which allows us to find the answers for all vectors of numbers up to 106106. This solution works in 2.5s on cf servers, which is still too slow. But the thing is that we found answers for all pairs of the vectors from the input. So we can try to get rid of some unnecessary vertices and simply check if the sum of answers is unchanged. One of the possible speedups is to consider only vectors generating the number of divisors not more than some reasonable number. The maximum number of divisors of some necessary vector is 288, so magic constants like 300 or more will work. Another possible speedup is to decrease the border on the sum of powers from 30 to 22, which is precise. 1071E - Rain ProtectionFirst, let's find out if we can catch all raindrops for a fixed speed vv.Assume that the endpoints are at (e1,0)(e1,0) and (e2,h)(e2,h) at any moment. Consider the point (e1,e2)(e1,e2) for this state (we call it the state point for this state). From now on we work with these points. We know that this state point can move with speed at most vv in both directions independently, that is, if the state point is (x,y)(x,y) at the moment tt, then it'll be in [x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt][x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt] at the moment t+dtt+dt.It turns out that for each ii one of the following takes place: we cannot catch raindrops from 11 to ii; we can catch these raindrops and there is exactly one possible option for the state point at the moment titi; we can catch these raindrops and there is a segment on the plane such that the state point at the moment titi can be in any point of this segment and nowhere else. Indeed, we prove this by induction. Its basis for t0=0t0=0 is trivial. Let's prove its step. If we cannot catch raindrops from 11 to ii then we cannot catch all raindrops from 11 to i+1i+1. If there is some segment where the state point can be at titi (possibly a segment of length 00) then at the moment ti+1ti+1 the state point can be anywhere inside the convex hull of the union of two squares. The squares are [x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt][x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt] for the endpoints (x,y)(x,y) of the segment at titi, and here dtdt is ti+1−titi+1−ti.But we also know that the rope must contain one particular point at the moment ti+1ti+1, which can be expressed as a linear equation of the state point at the moment ti+1ti+1. So to obtain the required segment for ti+1ti+1 one should intersect a line with a convex hull of 88 points (which is in fact no more than a hexagon).However, it's not all: the endpoints of the rope mustn't leave the rails which means that the convex hull should be first intersected with the rectangle [0,w]×[0,w][0,w]×[0,w]. However, it can be done after intersecting with the required line. So the solution now is the following: First we check if the answer is −1−1. This is the case when there is a triple of non-collinear raindrop points which should be on the rope simultaneously or there is a raindrop which is not on the rope at the moment 00, while it should be. The simplest way to check it is to check if we can catch all raindrops with speed ww. First, it involves no case handling; second, we will use this function later anyway. After this we run a binary search to find the minimal possible value for speed in such a way that it's possible to catch all the raindrops. That's the idea of the solution. Now let's consider precision issues.The explanation below contains some notions which may be new for a particular reader. Please don't be afraid of them, I explain what they mean right after introducing them. I refer to them by their names first for readers familiar with these notions to get the point faster and maybe skip the explanation which follows. For anyone who doesn't want to read the full proof and wants to know the summary: long double precision should be enough to get AC with the solution above (handling lines intersections properly).Define a function fi(v)fi(v) as the ℓ∞ℓ∞-diameter of the set of possible locations of the state point at the moment titi for the speed vv, that is, fi(v)=0fi(v)=0 if this set is empty or consists of a single point; fi(v)=max(|x1−x2|,|y1−y2|)fi(v)=max(|x1−x2|,|y1−y2|) if this set is a segment between (x1,y1)(x1,y1) and (x2,y2)(x2,y2). In other words, every time we calculate the length of any segment, we do it in this metric, since it'll be convenient for our purposes.Let v^v^ be the correct answer, and let εε be a sufficiently small positive number (but still much bigger than the machine epsilon, of course).One can see that all titi-s can be divided into two groups which differ a lot by their meaning: those for which we must catch one raindrop at this moment (or many equal raindrops, which doesn't matter), those for which we must catch more than one raindrop at this moment. For the first ones we basically need to intersect a polygon with a line, but for the second ones the state point at titi can be determined and doesn't depend on the speed (or such titi-s force our algorithm to tell that the goal is impossible in the very beginning). Let's call the raindrops with titi of the first type simple, and the others complicated.Let's prove the following lemmas:Lemma 1a. Let ii be an index of a simple raindrop. For v=v^+εv=v^+ε each fi(v)fi(v) is at least εε.Lemma 1b. Let ii be an index of a complicated raindrop. For v=v^+εv=v^+ε the corresponding state point position at the moment titi is at least εε away from the border of a polygon before intersecting with [0,w]×[0,w][0,w]×[0,w].Lemma 2. Let idxidx be the index of the first raindrop we cannot catch for a value of speed which is very close to v^v^ but is less than it. Then for v=v^−εv=v^−ε either our algorithm halts earlier than it handles the idxidx-th raindrop, or the corresponding line to this raindrop (or the corresponding point if the raindrop is complicated) is at least εε away from the corresponding state points polygon (again, in ℓ∞ℓ∞ metric).One can see that proving these lemmas is sufficient to validate the solution. Indeed, comparing all intersections with quite good precision will move the binary search borders into the (v^−ε,v^+ε)(v^−ε,v^+ε) interval which is enough to stop for some εε.Proof of lemma 1 (both variations). Fix ii. We know that the (i−1)(i−1)-th set Si−1(v)Si−1(v) of possible state points for v=v^v=v^ is not empty (from the definition of v^v^). It's clear that the (i−1)(i−1)-th set for v=v^+εv=v^+ε is a superset of Si−1(v^)Si−1(v^), because we can move no faster than with the speed of v^<v^+εv^<v^+ε. To get SiSi, we move from Si−1Si−1 no more than (ti−ti−1)(v^+ε)≤(ti−ti−1)v^+ε(ti−ti−1)(v^+ε)≤(ti−ti−1)v^+ε. This finishes the proof of 1b. Since Si(v^)Si(v^) is also not empty, Si(v^+ε)Si(v^+ε) is at least the segment Si(v^)Si(v^) plus all the points on the corresponding line at the distance no more than εε, that is, at least εε longer than Si(v^)Si(v^), hence is at least εε long, qed.Proof of lemma 2. Assume our algorithm made at least idxidx iterations. Consider the corresponding polygon at the moment tidxtidx. We know that for v=v^v=v^ this polygon intersects the required line/point, but its interior doesn't. That means that each point of the possible set of state points at the moment isn't inside the polygon. That means that if we reduce vv by εε then the distance from every point of this set to the polygon is at least εε, qed.To summarize, the only precision issue we can meet is when we intersect two or more lines for complicated raindrops. This part can be implemented in integers, but let's dive into this anyway.One can see that catching raindrop at (x,y)(x,y) means thatyx−e1=h−ye2−x,yx−e1=h−ye2−x,or(e2−x)y=(x−e1)(h−y)⇒e1(h−y)+e2y=xh.(e2−x)y=(x−e1)(h−y)⇒e1(h−y)+e2y=xh.Since the coefficients of this line equation are of order hh, the coordinates of its solution are some rationals with the denominator of order 1/h21/h2. If we then want to check if such point belongs to another line, we want to compare some integer divided by another integer which is ≤h2≤h2 with the third integer, so we need an epsilon less than 1/h21/h2.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1071 和字母"
          },
          "content_length": 14869
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 1",
          "code": "int dp[2001][2001]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 2",
          "code": "dp[i][j] = fillDp(i + 1, j, i, j + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 3",
          "code": "//(x, y) - pointer which is lower, (b, a) - pointer which is to the right\nint fillDp(int y, int x, int b, int a) {\n    if (arr[y][x] < arr[b][a]) return 0; //you can only go down\n    if (arr[y][x] > arr[b][a]) return 1; //only right\n    if (b == y && a == x) return 2; //doesn't really matter which way\n    //if letters are the same and we check different fields\n    //we either move according to dp or (if dp == 2) we move pointers closer to each other\n    if (dp[y][x] == 0) y++;\n    else x++;\n    if (dp[b][a] == 1) a++;\n    else b++;\n    return fillDp(y, x, b, a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 4",
          "code": "//(x, y) - pointer which is lower, (b, a) - pointer which is to the right\nint fillDp(int y, int x, int b, int a) {\n    if (arr[y][x] < arr[b][a]) return 0; //you can only go down\n    if (arr[y][x] > arr[b][a]) return 1; //only right\n    if (b == y && a == x) return 2; //doesn't really matter which way\n    //if letters are the same and we check different fields\n    //we either move according to dp or (if dp == 2) we move pointers closer to each other\n    if (dp[y][x] == 0) y++;\n    else x++;\n    if (dp[b][a] == 1) a++;\n    else b++;\n    return fillDp(y, x, b, a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 5",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 6",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 7",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 8",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 9",
          "code": "1 + 2 + ... + k <= a + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 10",
          "code": "S = 1 + 2 + ... + k <= a + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 11",
          "code": "3\n2 3 4\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 12",
          "code": "3\n2 3 4\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 13",
          "code": "7\n1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 14",
          "code": "7\n1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 15",
          "code": "YES\n3\n3 5 7\n3 4 5\n1 4 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 16",
          "code": "YES\n3\n3 5 7\n3 4 5\n1 4 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 17",
          "code": "YES\n3\n5 6 7\n1 4 7\n4 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 18",
          "code": "YES\n3\n5 6 7\n1 4 7\n4 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 19",
          "code": "100000\n0 1 0 1 0\n...\n0 1 0 1 0\n0 0 0 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 20",
          "code": "100000\n0 1 0 1 0\n...\n0 1 0 1 0\n0 0 0 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 21",
          "code": "125\n1 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 22",
          "code": "125\n1 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 23",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 24",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 25",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 26",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 1",
          "code": "100000\n3 3 3 2 3 ...(repeat)\n0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 2",
          "code": "100000\n3 3 3 2 3 ...(repeat)\n0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 3",
          "code": "YES\n1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 4",
          "code": "YES\n1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 5",
          "code": "for(int j = 0;j<=3;j++){ // values of b(i)\n\n        for(int k = 0;k<=3;k++){ // values of t(i+1)\n\n            cout << i << \" \" << j << \" \" << k << \" -> \";\n\n            for(int l = 0;l<=3;l++){ // possible values of t(i) \n                if((k & l )== j && ((k|l) == i)){\n                    cout << l << \" \";\n                }\n            }\n            cout << endl;\n        }\n    }\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 6",
          "code": "bcc\ncaa\nggg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 7",
          "code": "bcc\ncaa\nggg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 8",
          "code": "0 0 0 1 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 9",
          "code": "0 0 0 1 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 10",
          "code": "1 0 1 0 1 0 0 0\n0 0 1 0 1 0 1 0 \n1 0 0 1 0 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 11",
          "code": "1 0 1 0 1 0 0 0\n0 0 1 0 1 0 1 0 \n1 0 0 1 0 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 12",
          "code": "0 0 1 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 13",
          "code": "0 0 1 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 14",
          "code": "0 0 1 1 1 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 15",
          "code": "0 0 1 1 1 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 16",
          "code": "0 1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 17",
          "code": "0 1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 18",
          "code": "0 1 0 0 1 0 0 1\n0 0 0 0 1 1 1 0\n0 0 0 0 0 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 19",
          "code": "0 1 0 0 1 0 0 1\n0 0 0 0 1 1 1 0\n0 0 0 0 0 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 20",
          "code": "1 0 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 21",
          "code": "1 0 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 22",
          "code": "1 0 0 1 0 0 1 0\n0 0 0 1 1 1 0 0\n0 0 0 0 1 1 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 23",
          "code": "1 0 0 1 0 0 1 0\n0 0 0 1 1 1 0 0\n0 0 0 0 1 1 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 24",
          "code": "(prod, pos)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 25",
          "code": "(prod / k, pos + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 26",
          "code": "abs(x[pos] - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 27",
          "code": "3 5 5\n3 4\n2 1 0\n4 2 1\n5 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 28",
          "code": "3 5 5\n3 4\n2 1 0\n4 2 1\n5 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 29",
          "code": "2 5 5\n5 0\n1 0 0\n2 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 30",
          "code": "2 5 5\n5 0\n1 0 0\n2 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 31",
          "code": "3 4 4\n2 3\n2 2 2\n4 1 1\n5 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 32",
          "code": "3 4 4\n2 3\n2 2 2\n4 1 1\n5 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 33",
          "code": "3 5 5\n3 2\n2 3 3\n4 3 2\n6 1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 34",
          "code": "3 5 5\n3 2\n2 3 3\n4 3 2\n6 1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    for(int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    for(int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n    for(int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k == -1) {\n        if (type == \"zero_k\") {\n            k = 0;\n        } else if (type == \"max_k\") {\n            k = n * n;\n        } else if (type == \"small_k\") {\n            k = rnd.next(n * n); // random k between 0 and n*n -1\n        } else {\n            k = rnd.next(n * n + 1); // default random k between 0 and n*n\n        }\n    }\n\n    vector<string> matrix(n, string(n, 'a'));\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                matrix[i][j] = 'a' + rnd.next(26); // random letter from 'a' to 'z'\n            }\n        }\n    } else if (type == \"all_a\") {\n        // already initialized to 'a'\n    } else if (type == \"all_z\") {\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, 'z');\n        }\n    } else if (type == \"diagonal_a\") {\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, 'z');\n        }\n        for (int i = 0; i < n; ++i) {\n            matrix[i][i] = 'a';\n        }\n    } else if (type == \"path_a\") {\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, 'z');\n        }\n        int x = 0, y = 0;\n        matrix[x][y] = 'a';\n        while (x != n - 1 || y != n - 1) {\n            if (x == n - 1) y++;\n            else if (y == n - 1) x++;\n            else if (rnd.next(2)) x++;\n            else y++;\n            matrix[x][y] = 'a';\n        }\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                matrix[i][j] = ((i + j) % 2 == 0) ? 'a' : 'b';\n            }\n        }\n    } else if (type == \"worst_case\") {\n        // Fill the matrix with maximum ('z') letters\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, 'z');\n        }\n        // Randomly place some 'a's\n        int num_a = n / 2;\n        for (int i = 0; i < num_a; ++i) {\n            int x = rnd.next(n);\n            int y = rnd.next(n);\n            matrix[x][y] = 'a';\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output the matrix\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", matrix[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k == -1) {\n        if (type == \"zero_k\") {\n            k = 0;\n        } else if (type == \"max_k\") {\n            k = n * n;\n        } else if (type == \"small_k\") {\n            k = rnd.next(n * n); // random k between 0 and n*n -1\n        } else {\n            k = rnd.next(n * n + 1); // default random k between 0 and n*n\n        }\n    }\n\n    vector<string> matrix(n, string(n, 'a'));\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                matrix[i][j] = 'a' + rnd.next(26); // random letter from 'a' to 'z'\n            }\n        }\n    } else if (type == \"all_a\") {\n        // already initialized to 'a'\n    } else if (type == \"all_z\") {\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, 'z');\n        }\n    } else if (type == \"diagonal_a\") {\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, 'z');\n        }\n        for (int i = 0; i < n; ++i) {\n            matrix[i][i] = 'a';\n        }\n    } else if (type == \"path_a\") {\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, 'z');\n        }\n        int x = 0, y = 0;\n        matrix[x][y] = 'a';\n        while (x != n - 1 || y != n - 1) {\n            if (x == n - 1) y++;\n            else if (y == n - 1) x++;\n            else if (rnd.next(2)) x++;\n            else y++;\n            matrix[x][y] = 'a';\n        }\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                matrix[i][j] = ((i + j) % 2 == 0) ? 'a' : 'b';\n            }\n        }\n    } else if (type == \"worst_case\") {\n        // Fill the matrix with maximum ('z') letters\n        for (int i = 0; i < n; ++i) {\n            matrix[i] = string(n, 'z');\n        }\n        // Randomly place some 'a's\n        int num_a = n / 2;\n        for (int i = 0; i < num_a; ++i) {\n            int x = rnd.next(n);\n            int y = rnd.next(n);\n            matrix[x][y] = 'a';\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output the matrix\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", matrix[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type all_a\n./gen -n 1 -k 0 -type all_z\n\n./gen -n 2 -k 0 -type checkerboard\n./gen -n 2 -k 1 -type path_a\n./gen -n 2 -k 2 -type random\n\n./gen -n 10 -k 0 -type random\n./gen -n 10 -k 20 -type random\n./gen -n 10 -k 100 -type random\n\n./gen -n 50 -k 0 -type all_z\n./gen -n 50 -k 2500 -type all_z\n\n./gen -n 50 -k 0 -type path_a\n./gen -n 50 -k 0 -type checkerboard\n./gen -n 50 -k 2000 -type path_a\n\n./gen -n 100 -k 0 -type random\n./gen -n 100 -k 5000 -type random\n./gen -n 100 -k 10000 -type random\n\n./gen -n 500 -k 0 -type all_z\n./gen -n 500 -k 250000 -type all_z\n\n./gen -n 500 -k 0 -type path_a\n./gen -n 500 -k 0 -type checkerboard\n./gen -n 500 -k 100000 -type path_a\n\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 500000 -type random\n./gen -n 1000 -k 1000000 -type random\n\n./gen -n 2000 -k 0 -type all_z\n./gen -n 2000 -k 4000000 -type all_z\n\n./gen -n 2000 -k 0 -type path_a\n./gen -n 2000 -k 4000000 -type path_a\n\n./gen -n 2000 -k 0 -type checkerboard\n./gen -n 2000 -k 4000000 -type checkerboard\n\n./gen -n 2000 -k 0 -type worst_case\n./gen -n 2000 -k 4000000 -type worst_case\n\n./gen -n 2000 -k 0 -type random\n./gen -n 2000 -k 2000000 -type random\n./gen -n 2000 -k 4000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:38.176602",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1071/C",
      "title": "C. Triple Flips",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer nn (3≤n≤1053≤n≤105) — the length of the array.The second line contains nn integers a1,a2,…,ana1,a2,…,an (0≤ai≤10≤ai≤1) — the elements of the array.",
      "output_spec": "OutputPrint \"YES\" (without quotes) if the answer exists, otherwise print \"NO\" (without quotes). You can print each letter in any case (upper or lower).If there is an answer, in the second line print an integer mm (0≤m≤(⌊n3⌋+12)0≤m≤(⌊n3⌋+12)) — the number of operations in your answer.After that in (i+2i+2)-th line print the ii-th operations — the integers xi,yi,zixi,yi,zi. You can print them in arbitrary order.",
      "sample_tests": "ExamplesInputCopy51 1 0 1 1OutputCopyYES21 3 52 3 4InputCopy30 1 0OutputCopyNO",
      "description": "C. Triple Flips\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer nn (3≤n≤1053≤n≤105) — the length of the array.The second line contains nn integers a1,a2,…,ana1,a2,…,an (0≤ai≤10≤ai≤1) — the elements of the array.\n\nOutputPrint \"YES\" (without quotes) if the answer exists, otherwise print \"NO\" (without quotes). You can print each letter in any case (upper or lower).If there is an answer, in the second line print an integer mm (0≤m≤(⌊n3⌋+12)0≤m≤(⌊n3⌋+12)) — the number of operations in your answer.After that in (i+2i+2)-th line print the ii-th operations — the integers xi,yi,zixi,yi,zi. You can print them in arbitrary order.\n\nInputCopy51 1 0 1 1OutputCopyYES21 3 52 3 4InputCopy30 1 0OutputCopyNO\n\nInputCopy51 1 0 1 1\n\nOutputCopyYES21 3 52 3 4\n\nInputCopy30 1 0\n\nOutputCopyNO\n\nNoteIn the first sample the shown output corresponds to the following solution:   1 1 0 1 1 (initial state);  0 1 1 1 0 (the flipped positions are the first, the third and the fifth elements);  0 0 0 0 0 (the flipped positions are the second, the third and the fourth elements). Other answers are also possible. In this test the number of operations should not exceed ⌊53⌋+12=1+12=13⌊53⌋+12=1+12=13.In the second sample the only available operation is to flip all the elements. This way it is only possible to obtain the arrays 0 1 0 and 1 0 1, but it is impossible to make all elements equal to zero.",
      "solutions": [
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces",
          "content": "Hi all!This weekend, at Sunday, October 21, 2018 at 16:10UTC+8 we will hold Codeforces Round 517. It is based on problems of Technocup 2019 Elimination Round 2 that will be held at the same time.Technocup is a major olympiad for Russian-speaking high-school students, so if you fall into this category, please register at Technocup 2019 website and take part in the Elimination Round.Div. 1 and Div.2 editions are open and rated for everyone. Register and enjoy the contests!The round authors are Kostroma, Golovanov399, komendart, Denisson and Dashk0.Have fun!The round is over, congratulations to the winners!Technocup 2019 - Elimination Round 2 Holidin receed Sonechko radoslav11 scanhex Codeforces Round 517 (Div. 1, based on Technocup 2019 Elimination Round 2) Radewoosh ainta 300iq TLE RAVEman Codeforces Round 517 (Div. 2, based on Technocup 2019 Elimination Round 2) cz_yixuanxu orbitingfIea I_Love_Irelia djq_fpc buaads The editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62594",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 956
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces",
          "content": "1031A - Golden PlateThe number of gilded cells in the first (outer) ring is the number of border cells, that is, 2(w+h)−42(w+h)−4, in the second ring — the number of border cells of the center rectangle with side lengths 4 less, that is, 2(w−4+h−4)−42(w−4+h−4)−4, and so on. This sum can be calculated in a single loop. 1031B - Curiosity Has No LimitsLet's solve the problem for 0≤ai,bi,ti≤10≤ai,bi,ti≤1, that is, for binary sequences. There are two options for t1t1, the remaining part can be determined one number by one after this: If t1=0t1=0 and a1=0a1=0 and b1=0b1=0 then t2t2 = 0; If t1=0t1=0 and a1=0a1=0 and b1=1b1=1 then there is no such t2t2. If t1=0t1=0 and a1=1a1=1 and b1=0b1=0 then t2t2 = 1; If t1=0t1=0 and a1=1a1=1 and b1=1b1=1 then t2t2 = 1; If t1=1t1=1 and a1=0a1=0 and b1=0b1=0 then there is no such t2t2. If t1=1t1=1 and a1=0a1=0 and b1=1b1=1 then there is no such t2t2. If t1=1t1=1 and a1=1a1=1 and b1=0b1=0 then t2t2 = 0; If t1=1t1=1 and a1=1a1=1 and b1=1b1=1 then t2t2 = 1; One can similarly find all other titi-s (3≤i≤n3≤i≤n) or get a contradiction.For bitwise operations from the statement one can solve the problem independently for every bit and restore the original sequence t1,t2,…,tnt1,t2,…,tn. 1031C - Cram TimeConsider any answer with maximal n+mn+m. If we used numbers d1,d2,…,dkd1,d2,…,dk (di>n+mdi>n+m), then we didn't use some numbers h1,h2,…,hkh1,h2,…,hk (hi≤n+mhi≤n+m). Replacing all didi by hihi (1≤i≤k1≤i≤k) doesn't violate the restriction. That means that we can assume that the answer consists of all numbers from 11 to xx, and x=n+mx=n+m. The sum of all numbers from 11 to xx equals x(x+1)2x(x+1)2. It's clear that the following inequality must hold: x(x+1)2≤a+bx(x+1)2≤a+b. Let's find the maximal xx for which it's true. The answer can't exceed xx, and we can build the answer for xx iteratively. Let's iterate over all lecture notes from xx to 11, and on each step we put it into the first day if we can, otherwise if in the first day we have w>0w>0 free time then we put the lecture note w<xw<x to the first day. All other lecture notes can be read during the second day since the either there are none of them, or the first day is full and hence the second day contains a sufficient amount of hours to read'em all. 1031D - Minimum pathFirst, let's find the number of a-s in the beginning of the answer. To do this one can calculate dp[i][j] standing for the minimal number of non-a-s among all paths from the initial corner to (i, j). The number of a-s is simply the greatest (i+j)(i+j) among all pairs (i,j)(i,j) such that dp[i][j]≤kdp[i][j]≤k (or 00, if there are no).Consider all cells where we can go right after obtaining the prefix of a-s. Now we repeat the following: append the minimal symbol in these cells to the answer, choose those cells and go from them in both possible directions to obtain the new set of cells. One can see that the answer we obtain is indeed the required answer. 1031E - Triple FlipsThis problem has a lot of solutions including those ones which are difficult to prove. Let's describe one of the author's solutions.We can find answer with bruteforce if size of array is rather small. For example we can check all combinations of arithmetic progressions with length equals to three.We can find by hand or bruteforce that for 3≤n≤73≤n≤7 arrays with no solution exists but for n=8n=8 (and consequently for n≥8n≥8) we always can make all elements be equal to zero.We want solution with such steps: If nn is small just run bruteforce Else try to make all elements besides the first kk (k≥8k≥8) be equal to zero Run bruteforce on the first kk elements. How to make the second step? Let's try to make three last elements of array be equal to zero with only one operation. We can use previous elements. So if we have array …,0,0,1…,0,0,1 we can change values of the first, the fourth and the seventh elements from the end. But …,0,1,1…,0,1,1 is counter-example.Ok, let's try to make six last elements of array be equal to zero with two operations. We can check by hand or bruteforce that it can be done and n≥11n≥11 is enough.So we have such solution: Let kk is the number of first elements of array which we didn't try to make be equal to zero. In the start k=nk=n While k≥11k≥11 make kk-th, (k−1)(k−1)-th,.., (k−5)(k−5)-th elements be equal to zero. Subtract 6 from kk. If k≤10k≤10 run bruteforce on the first 1010 elements or on the whole array if n<10n<10. How many operations will be done? In the second item the number of operations is less or equal than 2⋅⌊n6⌋≤⌊n3⌋2⋅⌊n6⌋≤⌊n3⌋ In the third item the number of operations is less or equal than 6 (can be checked by hand or bruteforce) So the total number of operations is less or equal than ⌊n3⌋+6⌊n3⌋+6, what is good enough. 1031F - Familiar OperationsNote that if a=∏i=1kpxiia=∏i=1kpixi then d(a)=∏i=1k(xi+1)d(a)=∏i=1k(xi+1). This implies that we can map aa to vector (x1,x2,…,xk)(x1,x2,…,xk), where x1≥x2≥…≥xkx1≥x2≥…≥xk, because the order of the powers doesn't matter. The operations correspond to adding 1 to some item or appending 1 to the end of the vector or decreasing 1 from some item and sorting the vector after that, erasing zeros. There are only 289 different such vectors for numbers up to 106106, so we need to calculate only 41616 distances.The first thought could be to just run Floyd-Warshall algorithm on these 289 vertices, which would fit in time. After that for each pair (x,d)(x,d) we can find the minimum number of operations needed to make with vector xx so that the generated number has dd divisors. To find the answer for (x,y)(x,y), we could simply iterate over all possible values of dd. But there are some tricky cases. For example, for numbers 219219 and 22362236 the answer is 1, because after multiplying the first number by 2 both numbers have 21 divisors. But the number 220>106220>106, and the vector (20)(20) is not among these 289 vertices. So, we need to consider some other vectors too.Anyway, let's run this algorithm to see what could be the maximal distance between the two numbers up to 106106. It turns out that in 10 operations any two numbers can be led to have the same number of divisors when all numbers in the path don't exceed 106106 too.This means that each possible number in the optimal path satisfies ∑i=1kxi<30∑i=1kxi<30, because for the numbers in the input this sum doesn't exceed 19, and there can be no more than 10 operations with each number. This condition gives us all vectors of powers necessary to consider as middle points for the pairs which can be in the input. There are 28629 such vectors. Now we run 289 bfs instances on the generated graph with the start in each possible vector from the input and build the same data structure for pairs (x,d)(x,d) as explained before, which allows us to find the answers for all vectors of numbers up to 106106. This solution works in 2.5s on cf servers, which is still too slow. But the thing is that we found answers for all pairs of the vectors from the input. So we can try to get rid of some unnecessary vertices and simply check if the sum of answers is unchanged. One of the possible speedups is to consider only vectors generating the number of divisors not more than some reasonable number. The maximum number of divisors of some necessary vector is 288, so magic constants like 300 or more will work. Another possible speedup is to decrease the border on the sum of powers from 30 to 22, which is precise. 1071E - Rain ProtectionFirst, let's find out if we can catch all raindrops for a fixed speed vv.Assume that the endpoints are at (e1,0)(e1,0) and (e2,h)(e2,h) at any moment. Consider the point (e1,e2)(e1,e2) for this state (we call it the state point for this state). From now on we work with these points. We know that this state point can move with speed at most vv in both directions independently, that is, if the state point is (x,y)(x,y) at the moment tt, then it'll be in [x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt][x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt] at the moment t+dtt+dt.It turns out that for each ii one of the following takes place: we cannot catch raindrops from 11 to ii; we can catch these raindrops and there is exactly one possible option for the state point at the moment titi; we can catch these raindrops and there is a segment on the plane such that the state point at the moment titi can be in any point of this segment and nowhere else. Indeed, we prove this by induction. Its basis for t0=0t0=0 is trivial. Let's prove its step. If we cannot catch raindrops from 11 to ii then we cannot catch all raindrops from 11 to i+1i+1. If there is some segment where the state point can be at titi (possibly a segment of length 00) then at the moment ti+1ti+1 the state point can be anywhere inside the convex hull of the union of two squares. The squares are [x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt][x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt] for the endpoints (x,y)(x,y) of the segment at titi, and here dtdt is ti+1−titi+1−ti.But we also know that the rope must contain one particular point at the moment ti+1ti+1, which can be expressed as a linear equation of the state point at the moment ti+1ti+1. So to obtain the required segment for ti+1ti+1 one should intersect a line with a convex hull of 88 points (which is in fact no more than a hexagon).However, it's not all: the endpoints of the rope mustn't leave the rails which means that the convex hull should be first intersected with the rectangle [0,w]×[0,w][0,w]×[0,w]. However, it can be done after intersecting with the required line. So the solution now is the following: First we check if the answer is −1−1. This is the case when there is a triple of non-collinear raindrop points which should be on the rope simultaneously or there is a raindrop which is not on the rope at the moment 00, while it should be. The simplest way to check it is to check if we can catch all raindrops with speed ww. First, it involves no case handling; second, we will use this function later anyway. After this we run a binary search to find the minimal possible value for speed in such a way that it's possible to catch all the raindrops. That's the idea of the solution. Now let's consider precision issues.The explanation below contains some notions which may be new for a particular reader. Please don't be afraid of them, I explain what they mean right after introducing them. I refer to them by their names first for readers familiar with these notions to get the point faster and maybe skip the explanation which follows. For anyone who doesn't want to read the full proof and wants to know the summary: long double precision should be enough to get AC with the solution above (handling lines intersections properly).Define a function fi(v)fi(v) as the ℓ∞ℓ∞-diameter of the set of possible locations of the state point at the moment titi for the speed vv, that is, fi(v)=0fi(v)=0 if this set is empty or consists of a single point; fi(v)=max(|x1−x2|,|y1−y2|)fi(v)=max(|x1−x2|,|y1−y2|) if this set is a segment between (x1,y1)(x1,y1) and (x2,y2)(x2,y2). In other words, every time we calculate the length of any segment, we do it in this metric, since it'll be convenient for our purposes.Let v^v^ be the correct answer, and let εε be a sufficiently small positive number (but still much bigger than the machine epsilon, of course).One can see that all titi-s can be divided into two groups which differ a lot by their meaning: those for which we must catch one raindrop at this moment (or many equal raindrops, which doesn't matter), those for which we must catch more than one raindrop at this moment. For the first ones we basically need to intersect a polygon with a line, but for the second ones the state point at titi can be determined and doesn't depend on the speed (or such titi-s force our algorithm to tell that the goal is impossible in the very beginning). Let's call the raindrops with titi of the first type simple, and the others complicated.Let's prove the following lemmas:Lemma 1a. Let ii be an index of a simple raindrop. For v=v^+εv=v^+ε each fi(v)fi(v) is at least εε.Lemma 1b. Let ii be an index of a complicated raindrop. For v=v^+εv=v^+ε the corresponding state point position at the moment titi is at least εε away from the border of a polygon before intersecting with [0,w]×[0,w][0,w]×[0,w].Lemma 2. Let idxidx be the index of the first raindrop we cannot catch for a value of speed which is very close to v^v^ but is less than it. Then for v=v^−εv=v^−ε either our algorithm halts earlier than it handles the idxidx-th raindrop, or the corresponding line to this raindrop (or the corresponding point if the raindrop is complicated) is at least εε away from the corresponding state points polygon (again, in ℓ∞ℓ∞ metric).One can see that proving these lemmas is sufficient to validate the solution. Indeed, comparing all intersections with quite good precision will move the binary search borders into the (v^−ε,v^+ε)(v^−ε,v^+ε) interval which is enough to stop for some εε.Proof of lemma 1 (both variations). Fix ii. We know that the (i−1)(i−1)-th set Si−1(v)Si−1(v) of possible state points for v=v^v=v^ is not empty (from the definition of v^v^). It's clear that the (i−1)(i−1)-th set for v=v^+εv=v^+ε is a superset of Si−1(v^)Si−1(v^), because we can move no faster than with the speed of v^<v^+εv^<v^+ε. To get SiSi, we move from Si−1Si−1 no more than (ti−ti−1)(v^+ε)≤(ti−ti−1)v^+ε(ti−ti−1)(v^+ε)≤(ti−ti−1)v^+ε. This finishes the proof of 1b. Since Si(v^)Si(v^) is also not empty, Si(v^+ε)Si(v^+ε) is at least the segment Si(v^)Si(v^) plus all the points on the corresponding line at the distance no more than εε, that is, at least εε longer than Si(v^)Si(v^), hence is at least εε long, qed.Proof of lemma 2. Assume our algorithm made at least idxidx iterations. Consider the corresponding polygon at the moment tidxtidx. We know that for v=v^v=v^ this polygon intersects the required line/point, but its interior doesn't. That means that each point of the possible set of state points at the moment isn't inside the polygon. That means that if we reduce vv by εε then the distance from every point of this set to the polygon is at least εε, qed.To summarize, the only precision issue we can meet is when we intersect two or more lines for complicated raindrops. This part can be implemented in integers, but let's dive into this anyway.One can see that catching raindrop at (x,y)(x,y) means thatyx−e1=h−ye2−x,yx−e1=h−ye2−x,or(e2−x)y=(x−e1)(h−y)⇒e1(h−y)+e2y=xh.(e2−x)y=(x−e1)(h−y)⇒e1(h−y)+e2y=xh.Since the coefficients of this line equation are of order hh, the coordinates of its solution are some rationals with the denominator of order 1/h21/h2. If we then want to check if such point belongs to another line, we want to compare some integer divided by another integer which is ≤h2≤h2 with the third integer, so we need an epsilon less than 1/h21/h2.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1071 和字母"
          },
          "content_length": 14869
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 1",
          "code": "int dp[2001][2001]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 2",
          "code": "dp[i][j] = fillDp(i + 1, j, i, j + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 3",
          "code": "//(x, y) - pointer which is lower, (b, a) - pointer which is to the right\nint fillDp(int y, int x, int b, int a) {\n    if (arr[y][x] < arr[b][a]) return 0; //you can only go down\n    if (arr[y][x] > arr[b][a]) return 1; //only right\n    if (b == y && a == x) return 2; //doesn't really matter which way\n    //if letters are the same and we check different fields\n    //we either move according to dp or (if dp == 2) we move pointers closer to each other\n    if (dp[y][x] == 0) y++;\n    else x++;\n    if (dp[b][a] == 1) a++;\n    else b++;\n    return fillDp(y, x, b, a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 4",
          "code": "//(x, y) - pointer which is lower, (b, a) - pointer which is to the right\nint fillDp(int y, int x, int b, int a) {\n    if (arr[y][x] < arr[b][a]) return 0; //you can only go down\n    if (arr[y][x] > arr[b][a]) return 1; //only right\n    if (b == y && a == x) return 2; //doesn't really matter which way\n    //if letters are the same and we check different fields\n    //we either move according to dp or (if dp == 2) we move pointers closer to each other\n    if (dp[y][x] == 0) y++;\n    else x++;\n    if (dp[b][a] == 1) a++;\n    else b++;\n    return fillDp(y, x, b, a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 5",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 6",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 7",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 8",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 9",
          "code": "1 + 2 + ... + k <= a + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 10",
          "code": "S = 1 + 2 + ... + k <= a + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 11",
          "code": "3\n2 3 4\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 12",
          "code": "3\n2 3 4\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 13",
          "code": "7\n1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 14",
          "code": "7\n1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 15",
          "code": "YES\n3\n3 5 7\n3 4 5\n1 4 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 16",
          "code": "YES\n3\n3 5 7\n3 4 5\n1 4 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 17",
          "code": "YES\n3\n5 6 7\n1 4 7\n4 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 18",
          "code": "YES\n3\n5 6 7\n1 4 7\n4 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 19",
          "code": "100000\n0 1 0 1 0\n...\n0 1 0 1 0\n0 0 0 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 20",
          "code": "100000\n0 1 0 1 0\n...\n0 1 0 1 0\n0 0 0 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 21",
          "code": "125\n1 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 22",
          "code": "125\n1 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 23",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 24",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 25",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 26",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 1",
          "code": "100000\n3 3 3 2 3 ...(repeat)\n0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 2",
          "code": "100000\n3 3 3 2 3 ...(repeat)\n0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 3",
          "code": "YES\n1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 4",
          "code": "YES\n1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 5",
          "code": "for(int j = 0;j<=3;j++){ // values of b(i)\n\n        for(int k = 0;k<=3;k++){ // values of t(i+1)\n\n            cout << i << \" \" << j << \" \" << k << \" -> \";\n\n            for(int l = 0;l<=3;l++){ // possible values of t(i) \n                if((k & l )== j && ((k|l) == i)){\n                    cout << l << \" \";\n                }\n            }\n            cout << endl;\n        }\n    }\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 6",
          "code": "bcc\ncaa\nggg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 7",
          "code": "bcc\ncaa\nggg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 8",
          "code": "0 0 0 1 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 9",
          "code": "0 0 0 1 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 10",
          "code": "1 0 1 0 1 0 0 0\n0 0 1 0 1 0 1 0 \n1 0 0 1 0 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 11",
          "code": "1 0 1 0 1 0 0 0\n0 0 1 0 1 0 1 0 \n1 0 0 1 0 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 12",
          "code": "0 0 1 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 13",
          "code": "0 0 1 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 14",
          "code": "0 0 1 1 1 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 15",
          "code": "0 0 1 1 1 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 16",
          "code": "0 1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 17",
          "code": "0 1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 18",
          "code": "0 1 0 0 1 0 0 1\n0 0 0 0 1 1 1 0\n0 0 0 0 0 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 19",
          "code": "0 1 0 0 1 0 0 1\n0 0 0 0 1 1 1 0\n0 0 0 0 0 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 20",
          "code": "1 0 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 21",
          "code": "1 0 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 22",
          "code": "1 0 0 1 0 0 1 0\n0 0 0 1 1 1 0 0\n0 0 0 0 1 1 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 23",
          "code": "1 0 0 1 0 0 1 0\n0 0 0 1 1 1 0 0\n0 0 0 0 1 1 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 24",
          "code": "(prod, pos)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 25",
          "code": "(prod / k, pos + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 26",
          "code": "abs(x[pos] - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 27",
          "code": "3 5 5\n3 4\n2 1 0\n4 2 1\n5 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 28",
          "code": "3 5 5\n3 4\n2 1 0\n4 2 1\n5 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 29",
          "code": "2 5 5\n5 0\n1 0 0\n2 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 30",
          "code": "2 5 5\n5 0\n1 0 0\n2 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 31",
          "code": "3 4 4\n2 3\n2 2 2\n4 1 1\n5 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 32",
          "code": "3 4 4\n2 3\n2 2 2\n4 1 1\n5 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 33",
          "code": "3 5 5\n3 2\n2 3 3\n4 3 2\n6 1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 34",
          "code": "3 5 5\n3 2\n2 3 3\n4 3 2\n6 1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read the input array from 'inf'\n    int n = inf.readInt();\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readInt();\n    }\n    \n    // Read the jury's answer from 'ans'\n    string jury_answer = ans.readToken();\n    jury_answer = upperCase(jury_answer);\n    if (jury_answer != \"YES\" && jury_answer != \"NO\") {\n        ans.quitf(_fail, \"Jury output is neither YES nor NO\");\n    }\n    bool jury_yes = (jury_answer == \"YES\");\n\n    // Read the participant's answer from 'ouf'\n    string participant_answer = ouf.readToken();\n    participant_answer = upperCase(participant_answer);\n    if (participant_answer != \"YES\" && participant_answer != \"NO\") {\n        ouf.quitf(_pe, \"Your answer is neither YES nor NO\");\n    }\n    bool participant_yes = (participant_answer == \"YES\");\n    \n    if (jury_yes != participant_yes) {\n        if (jury_yes && !participant_yes) {\n            quitf(_wa, \"Participant says NO but a solution exists\");\n        } else {\n            quitf(_wa, \"Participant says YES but impossible to achieve all zeros\");\n        }\n    }\n    if (!jury_yes && !participant_yes) {\n        quitf(_ok, \"Correct: No solution exists\");\n    }\n\n    // Both say YES, need to validate participant's output\n    // Read m (number of operations)\n    int max_operations = n / 3 + 12;\n    int m = ouf.readInt(0, max_operations, \"number of operations\");\n    vector<int> array = a; // Copy of initial array\n\n    for (int i = 1; i <= m; i++) {\n        int x = ouf.readInt(1, n, format(\"operation #%d x\", i).c_str());\n        int y = ouf.readInt(1, n, format(\"operation #%d y\", i).c_str());\n        int z = ouf.readInt(1, n, format(\"operation #%d z\", i).c_str());\n        if (!(x < y && y < z)) {\n            ouf.quitf(_wa, \"In operation #%d, indices not strictly increasing: x = %d, y = %d, z = %d\", i, x, y, z);\n        }\n        if (y - x != z - y) {\n            ouf.quitf(_wa, \"In operation #%d, x, y, z do not form an arithmetic progression\", i);\n        }\n        // Flip the elements at positions x-1, y-1, z-1\n        array[x - 1] ^= 1;\n        array[y - 1] ^= 1;\n        array[z - 1] ^= 1;\n    }\n    // After all operations, check that array is all zeros\n    for (int i = 0; i < n; i++) {\n        if (array[i] != 0) {\n            ouf.quitf(_wa, \"After operations, array[%d] = %d, should be 0\", i + 1, array[i]);\n        }\n    }\n\n    // Participant should not output any extra data\n    ouf.skipBlanks();\n    if (!ouf.eof()) {\n        ouf.quitf(_pe, \"Extra data found in output\");\n    }\n    quitf(_ok, \"Correct: Solution found with %d operations\", m);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        /* All elements are zero */\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_one\") {\n        /* All elements are one */\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternating_0_start\") {\n        /* Elements alternate between 0 and 1, starting with 0 */\n        for (int i = 0; i < n; ++i)\n            a[i] = i % 2;\n    } else if (type == \"alternating_1_start\") {\n        /* Elements alternate between 1 and 0, starting with 1 */\n        for (int i = 0; i < n; ++i)\n            a[i] = (i + 1) % 2;\n    } else if (type == \"random\") {\n        /* Random zeros and ones */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1);\n    } else if (type == \"impossible_small\") {\n        /* An impossible case for small n */\n        n = 3;\n        a = {0, 1, 0};\n    } else if (type == \"impossible_large\") {\n        /* An impossible case for large n */\n        if (n < 3) n = 3;\n        fill(a.begin(), a.end(), 0);\n        a[rnd.next(0, n - 1)] = 1; // Only one 1 in the array\n    } else if (type == \"random_high_density_ones\") {\n        /* Random array with high density of ones */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100) < 80 ? 1 : 0;\n    } else if (type == \"random_low_density_ones\") {\n        /* Random array with low density of ones */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100) < 20 ? 1 : 0;\n    } else if (type == \"half_zeros_half_ones\") {\n        /* Half zeros, half ones */\n        int cnt_ones = n / 2;\n        for (int i = 0; i < n; ++i)\n            a[i] = i < cnt_ones ? 1 : 0;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"ones_in_groups\") {\n        /* Ones are clustered in groups */\n        int groups = rnd.next(1, min(n / 2, 10));\n        int idx = 0;\n        while (idx < n) {\n            int len_zero = rnd.next(1, n / groups);\n            for (int i = 0; i < len_zero && idx + i < n; ++i)\n                a[idx + i] = 0;\n            idx += len_zero;\n            int len_one = rnd.next(1, n / groups);\n            for (int i = 0; i < len_one && idx + i < n; ++i)\n                a[idx + i] = 1;\n            idx += len_one;\n        }\n    } else {\n        /* Default to random */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the array */\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        /* All elements are zero */\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_one\") {\n        /* All elements are one */\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternating_0_start\") {\n        /* Elements alternate between 0 and 1, starting with 0 */\n        for (int i = 0; i < n; ++i)\n            a[i] = i % 2;\n    } else if (type == \"alternating_1_start\") {\n        /* Elements alternate between 1 and 0, starting with 1 */\n        for (int i = 0; i < n; ++i)\n            a[i] = (i + 1) % 2;\n    } else if (type == \"random\") {\n        /* Random zeros and ones */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1);\n    } else if (type == \"impossible_small\") {\n        /* An impossible case for small n */\n        n = 3;\n        a = {0, 1, 0};\n    } else if (type == \"impossible_large\") {\n        /* An impossible case for large n */\n        if (n < 3) n = 3;\n        fill(a.begin(), a.end(), 0);\n        a[rnd.next(0, n - 1)] = 1; // Only one 1 in the array\n    } else if (type == \"random_high_density_ones\") {\n        /* Random array with high density of ones */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100) < 80 ? 1 : 0;\n    } else if (type == \"random_low_density_ones\") {\n        /* Random array with low density of ones */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100) < 20 ? 1 : 0;\n    } else if (type == \"half_zeros_half_ones\") {\n        /* Half zeros, half ones */\n        int cnt_ones = n / 2;\n        for (int i = 0; i < n; ++i)\n            a[i] = i < cnt_ones ? 1 : 0;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"ones_in_groups\") {\n        /* Ones are clustered in groups */\n        int groups = rnd.next(1, min(n / 2, 10));\n        int idx = 0;\n        while (idx < n) {\n            int len_zero = rnd.next(1, n / groups);\n            for (int i = 0; i < len_zero && idx + i < n; ++i)\n                a[idx + i] = 0;\n            idx += len_zero;\n            int len_one = rnd.next(1, n / groups);\n            for (int i = 0; i < len_one && idx + i < n; ++i)\n                a[idx + i] = 1;\n            idx += len_one;\n        }\n    } else {\n        /* Default to random */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the array */\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type all_zero\n./gen -n 3 -type all_one\n./gen -n 3 -type alternating_0_start\n./gen -n 3 -type impossible_small\n\n./gen -n 10 -type all_zero\n./gen -n 10 -type all_one\n./gen -n 10 -type alternating_1_start\n./gen -n 10 -type random\n./gen -n 10 -type half_zeros_half_ones\n\n./gen -n 100 -type random\n./gen -n 100 -type random_high_density_ones\n./gen -n 100 -type random_low_density_ones\n./gen -n 100 -type ones_in_groups\n\n./gen -n 1000 -type all_zero\n./gen -n 1000 -type all_one\n./gen -n 1000 -type alternating_0_start\n./gen -n 1000 -type random\n\n./gen -n 10000 -type random\n./gen -n 10000 -type random_high_density_ones\n./gen -n 10000 -type random_low_density_ones\n./gen -n 10000 -type ones_in_groups\n\n./gen -n 100000 -type all_zero\n./gen -n 100000 -type all_one\n./gen -n 100000 -type random\n./gen -n 100000 -type random_high_density_ones\n./gen -n 100000 -type random_low_density_ones\n./gen -n 100000 -type ones_in_groups\n./gen -n 100000 -type half_zeros_half_ones\n\n./gen -n 99999 -type random\n./gen -n 99998 -type random\n./gen -n 99997 -type random\n\n./gen -n 100000 -type impossible_large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:40.351174",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1071/D",
      "title": "D. Familiar Operations",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer tt (1≤t≤1051≤t≤105) — the number of pairs of integers for which you are to find the answer.Each of the next tt lines contain two integers aiai and bibi (1≤ai,bi≤1061≤ai,bi≤106).",
      "output_spec": "OutputOutput tt lines — the ii-th of them should contain the answer for the pair aiai, bibi.",
      "sample_tests": "ExampleInputCopy89 10100 17220 7017 194 1832 20100 32224 385OutputCopy13101011",
      "description": "D. Familiar Operations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer tt (1≤t≤1051≤t≤105) — the number of pairs of integers for which you are to find the answer.Each of the next tt lines contain two integers aiai and bibi (1≤ai,bi≤1061≤ai,bi≤106).\n\nOutputOutput tt lines — the ii-th of them should contain the answer for the pair aiai, bibi.\n\nInputCopy89 10100 17220 7017 194 1832 20100 32224 385OutputCopy13101011\n\nInputCopy89 10100 17220 7017 194 1832 20100 32224 385\n\nOutputCopy13101011\n\nNoteThese are the numbers with equal number of divisors, which are optimal to obtain in the sample test case:   (27,10)(27,10), 4 divisors  (100,1156)(100,1156), 9 divisors  (220,140)(220,140), 12 divisors  (17,19)(17,19), 2 divisors  (12,18)(12,18), 6 divisors  (50,32)(50,32), 6 divisors  (224,1925)(224,1925), 12 divisors Note that there can be several optimal pairs of numbers.",
      "solutions": [
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces",
          "content": "Hi all!This weekend, at Sunday, October 21, 2018 at 16:10UTC+8 we will hold Codeforces Round 517. It is based on problems of Technocup 2019 Elimination Round 2 that will be held at the same time.Technocup is a major olympiad for Russian-speaking high-school students, so if you fall into this category, please register at Technocup 2019 website and take part in the Elimination Round.Div. 1 and Div.2 editions are open and rated for everyone. Register and enjoy the contests!The round authors are Kostroma, Golovanov399, komendart, Denisson and Dashk0.Have fun!The round is over, congratulations to the winners!Technocup 2019 - Elimination Round 2 Holidin receed Sonechko radoslav11 scanhex Codeforces Round 517 (Div. 1, based on Technocup 2019 Elimination Round 2) Radewoosh ainta 300iq TLE RAVEman Codeforces Round 517 (Div. 2, based on Technocup 2019 Elimination Round 2) cz_yixuanxu orbitingfIea I_Love_Irelia djq_fpc buaads The editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62594",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 956
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces",
          "content": "1031A - Golden PlateThe number of gilded cells in the first (outer) ring is the number of border cells, that is, 2(w+h)−42(w+h)−4, in the second ring — the number of border cells of the center rectangle with side lengths 4 less, that is, 2(w−4+h−4)−42(w−4+h−4)−4, and so on. This sum can be calculated in a single loop. 1031B - Curiosity Has No LimitsLet's solve the problem for 0≤ai,bi,ti≤10≤ai,bi,ti≤1, that is, for binary sequences. There are two options for t1t1, the remaining part can be determined one number by one after this: If t1=0t1=0 and a1=0a1=0 and b1=0b1=0 then t2t2 = 0; If t1=0t1=0 and a1=0a1=0 and b1=1b1=1 then there is no such t2t2. If t1=0t1=0 and a1=1a1=1 and b1=0b1=0 then t2t2 = 1; If t1=0t1=0 and a1=1a1=1 and b1=1b1=1 then t2t2 = 1; If t1=1t1=1 and a1=0a1=0 and b1=0b1=0 then there is no such t2t2. If t1=1t1=1 and a1=0a1=0 and b1=1b1=1 then there is no such t2t2. If t1=1t1=1 and a1=1a1=1 and b1=0b1=0 then t2t2 = 0; If t1=1t1=1 and a1=1a1=1 and b1=1b1=1 then t2t2 = 1; One can similarly find all other titi-s (3≤i≤n3≤i≤n) or get a contradiction.For bitwise operations from the statement one can solve the problem independently for every bit and restore the original sequence t1,t2,…,tnt1,t2,…,tn. 1031C - Cram TimeConsider any answer with maximal n+mn+m. If we used numbers d1,d2,…,dkd1,d2,…,dk (di>n+mdi>n+m), then we didn't use some numbers h1,h2,…,hkh1,h2,…,hk (hi≤n+mhi≤n+m). Replacing all didi by hihi (1≤i≤k1≤i≤k) doesn't violate the restriction. That means that we can assume that the answer consists of all numbers from 11 to xx, and x=n+mx=n+m. The sum of all numbers from 11 to xx equals x(x+1)2x(x+1)2. It's clear that the following inequality must hold: x(x+1)2≤a+bx(x+1)2≤a+b. Let's find the maximal xx for which it's true. The answer can't exceed xx, and we can build the answer for xx iteratively. Let's iterate over all lecture notes from xx to 11, and on each step we put it into the first day if we can, otherwise if in the first day we have w>0w>0 free time then we put the lecture note w<xw<x to the first day. All other lecture notes can be read during the second day since the either there are none of them, or the first day is full and hence the second day contains a sufficient amount of hours to read'em all. 1031D - Minimum pathFirst, let's find the number of a-s in the beginning of the answer. To do this one can calculate dp[i][j] standing for the minimal number of non-a-s among all paths from the initial corner to (i, j). The number of a-s is simply the greatest (i+j)(i+j) among all pairs (i,j)(i,j) such that dp[i][j]≤kdp[i][j]≤k (or 00, if there are no).Consider all cells where we can go right after obtaining the prefix of a-s. Now we repeat the following: append the minimal symbol in these cells to the answer, choose those cells and go from them in both possible directions to obtain the new set of cells. One can see that the answer we obtain is indeed the required answer. 1031E - Triple FlipsThis problem has a lot of solutions including those ones which are difficult to prove. Let's describe one of the author's solutions.We can find answer with bruteforce if size of array is rather small. For example we can check all combinations of arithmetic progressions with length equals to three.We can find by hand or bruteforce that for 3≤n≤73≤n≤7 arrays with no solution exists but for n=8n=8 (and consequently for n≥8n≥8) we always can make all elements be equal to zero.We want solution with such steps: If nn is small just run bruteforce Else try to make all elements besides the first kk (k≥8k≥8) be equal to zero Run bruteforce on the first kk elements. How to make the second step? Let's try to make three last elements of array be equal to zero with only one operation. We can use previous elements. So if we have array …,0,0,1…,0,0,1 we can change values of the first, the fourth and the seventh elements from the end. But …,0,1,1…,0,1,1 is counter-example.Ok, let's try to make six last elements of array be equal to zero with two operations. We can check by hand or bruteforce that it can be done and n≥11n≥11 is enough.So we have such solution: Let kk is the number of first elements of array which we didn't try to make be equal to zero. In the start k=nk=n While k≥11k≥11 make kk-th, (k−1)(k−1)-th,.., (k−5)(k−5)-th elements be equal to zero. Subtract 6 from kk. If k≤10k≤10 run bruteforce on the first 1010 elements or on the whole array if n<10n<10. How many operations will be done? In the second item the number of operations is less or equal than 2⋅⌊n6⌋≤⌊n3⌋2⋅⌊n6⌋≤⌊n3⌋ In the third item the number of operations is less or equal than 6 (can be checked by hand or bruteforce) So the total number of operations is less or equal than ⌊n3⌋+6⌊n3⌋+6, what is good enough. 1031F - Familiar OperationsNote that if a=∏i=1kpxiia=∏i=1kpixi then d(a)=∏i=1k(xi+1)d(a)=∏i=1k(xi+1). This implies that we can map aa to vector (x1,x2,…,xk)(x1,x2,…,xk), where x1≥x2≥…≥xkx1≥x2≥…≥xk, because the order of the powers doesn't matter. The operations correspond to adding 1 to some item or appending 1 to the end of the vector or decreasing 1 from some item and sorting the vector after that, erasing zeros. There are only 289 different such vectors for numbers up to 106106, so we need to calculate only 41616 distances.The first thought could be to just run Floyd-Warshall algorithm on these 289 vertices, which would fit in time. After that for each pair (x,d)(x,d) we can find the minimum number of operations needed to make with vector xx so that the generated number has dd divisors. To find the answer for (x,y)(x,y), we could simply iterate over all possible values of dd. But there are some tricky cases. For example, for numbers 219219 and 22362236 the answer is 1, because after multiplying the first number by 2 both numbers have 21 divisors. But the number 220>106220>106, and the vector (20)(20) is not among these 289 vertices. So, we need to consider some other vectors too.Anyway, let's run this algorithm to see what could be the maximal distance between the two numbers up to 106106. It turns out that in 10 operations any two numbers can be led to have the same number of divisors when all numbers in the path don't exceed 106106 too.This means that each possible number in the optimal path satisfies ∑i=1kxi<30∑i=1kxi<30, because for the numbers in the input this sum doesn't exceed 19, and there can be no more than 10 operations with each number. This condition gives us all vectors of powers necessary to consider as middle points for the pairs which can be in the input. There are 28629 such vectors. Now we run 289 bfs instances on the generated graph with the start in each possible vector from the input and build the same data structure for pairs (x,d)(x,d) as explained before, which allows us to find the answers for all vectors of numbers up to 106106. This solution works in 2.5s on cf servers, which is still too slow. But the thing is that we found answers for all pairs of the vectors from the input. So we can try to get rid of some unnecessary vertices and simply check if the sum of answers is unchanged. One of the possible speedups is to consider only vectors generating the number of divisors not more than some reasonable number. The maximum number of divisors of some necessary vector is 288, so magic constants like 300 or more will work. Another possible speedup is to decrease the border on the sum of powers from 30 to 22, which is precise. 1071E - Rain ProtectionFirst, let's find out if we can catch all raindrops for a fixed speed vv.Assume that the endpoints are at (e1,0)(e1,0) and (e2,h)(e2,h) at any moment. Consider the point (e1,e2)(e1,e2) for this state (we call it the state point for this state). From now on we work with these points. We know that this state point can move with speed at most vv in both directions independently, that is, if the state point is (x,y)(x,y) at the moment tt, then it'll be in [x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt][x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt] at the moment t+dtt+dt.It turns out that for each ii one of the following takes place: we cannot catch raindrops from 11 to ii; we can catch these raindrops and there is exactly one possible option for the state point at the moment titi; we can catch these raindrops and there is a segment on the plane such that the state point at the moment titi can be in any point of this segment and nowhere else. Indeed, we prove this by induction. Its basis for t0=0t0=0 is trivial. Let's prove its step. If we cannot catch raindrops from 11 to ii then we cannot catch all raindrops from 11 to i+1i+1. If there is some segment where the state point can be at titi (possibly a segment of length 00) then at the moment ti+1ti+1 the state point can be anywhere inside the convex hull of the union of two squares. The squares are [x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt][x−v⋅dt,x+v⋅dt]×[y−v⋅dt,y+v⋅dt] for the endpoints (x,y)(x,y) of the segment at titi, and here dtdt is ti+1−titi+1−ti.But we also know that the rope must contain one particular point at the moment ti+1ti+1, which can be expressed as a linear equation of the state point at the moment ti+1ti+1. So to obtain the required segment for ti+1ti+1 one should intersect a line with a convex hull of 88 points (which is in fact no more than a hexagon).However, it's not all: the endpoints of the rope mustn't leave the rails which means that the convex hull should be first intersected with the rectangle [0,w]×[0,w][0,w]×[0,w]. However, it can be done after intersecting with the required line. So the solution now is the following: First we check if the answer is −1−1. This is the case when there is a triple of non-collinear raindrop points which should be on the rope simultaneously or there is a raindrop which is not on the rope at the moment 00, while it should be. The simplest way to check it is to check if we can catch all raindrops with speed ww. First, it involves no case handling; second, we will use this function later anyway. After this we run a binary search to find the minimal possible value for speed in such a way that it's possible to catch all the raindrops. That's the idea of the solution. Now let's consider precision issues.The explanation below contains some notions which may be new for a particular reader. Please don't be afraid of them, I explain what they mean right after introducing them. I refer to them by their names first for readers familiar with these notions to get the point faster and maybe skip the explanation which follows. For anyone who doesn't want to read the full proof and wants to know the summary: long double precision should be enough to get AC with the solution above (handling lines intersections properly).Define a function fi(v)fi(v) as the ℓ∞ℓ∞-diameter of the set of possible locations of the state point at the moment titi for the speed vv, that is, fi(v)=0fi(v)=0 if this set is empty or consists of a single point; fi(v)=max(|x1−x2|,|y1−y2|)fi(v)=max(|x1−x2|,|y1−y2|) if this set is a segment between (x1,y1)(x1,y1) and (x2,y2)(x2,y2). In other words, every time we calculate the length of any segment, we do it in this metric, since it'll be convenient for our purposes.Let v^v^ be the correct answer, and let εε be a sufficiently small positive number (but still much bigger than the machine epsilon, of course).One can see that all titi-s can be divided into two groups which differ a lot by their meaning: those for which we must catch one raindrop at this moment (or many equal raindrops, which doesn't matter), those for which we must catch more than one raindrop at this moment. For the first ones we basically need to intersect a polygon with a line, but for the second ones the state point at titi can be determined and doesn't depend on the speed (or such titi-s force our algorithm to tell that the goal is impossible in the very beginning). Let's call the raindrops with titi of the first type simple, and the others complicated.Let's prove the following lemmas:Lemma 1a. Let ii be an index of a simple raindrop. For v=v^+εv=v^+ε each fi(v)fi(v) is at least εε.Lemma 1b. Let ii be an index of a complicated raindrop. For v=v^+εv=v^+ε the corresponding state point position at the moment titi is at least εε away from the border of a polygon before intersecting with [0,w]×[0,w][0,w]×[0,w].Lemma 2. Let idxidx be the index of the first raindrop we cannot catch for a value of speed which is very close to v^v^ but is less than it. Then for v=v^−εv=v^−ε either our algorithm halts earlier than it handles the idxidx-th raindrop, or the corresponding line to this raindrop (or the corresponding point if the raindrop is complicated) is at least εε away from the corresponding state points polygon (again, in ℓ∞ℓ∞ metric).One can see that proving these lemmas is sufficient to validate the solution. Indeed, comparing all intersections with quite good precision will move the binary search borders into the (v^−ε,v^+ε)(v^−ε,v^+ε) interval which is enough to stop for some εε.Proof of lemma 1 (both variations). Fix ii. We know that the (i−1)(i−1)-th set Si−1(v)Si−1(v) of possible state points for v=v^v=v^ is not empty (from the definition of v^v^). It's clear that the (i−1)(i−1)-th set for v=v^+εv=v^+ε is a superset of Si−1(v^)Si−1(v^), because we can move no faster than with the speed of v^<v^+εv^<v^+ε. To get SiSi, we move from Si−1Si−1 no more than (ti−ti−1)(v^+ε)≤(ti−ti−1)v^+ε(ti−ti−1)(v^+ε)≤(ti−ti−1)v^+ε. This finishes the proof of 1b. Since Si(v^)Si(v^) is also not empty, Si(v^+ε)Si(v^+ε) is at least the segment Si(v^)Si(v^) plus all the points on the corresponding line at the distance no more than εε, that is, at least εε longer than Si(v^)Si(v^), hence is at least εε long, qed.Proof of lemma 2. Assume our algorithm made at least idxidx iterations. Consider the corresponding polygon at the moment tidxtidx. We know that for v=v^v=v^ this polygon intersects the required line/point, but its interior doesn't. That means that each point of the possible set of state points at the moment isn't inside the polygon. That means that if we reduce vv by εε then the distance from every point of this set to the polygon is at least εε, qed.To summarize, the only precision issue we can meet is when we intersect two or more lines for complicated raindrops. This part can be implemented in integers, but let's dive into this anyway.One can see that catching raindrop at (x,y)(x,y) means thatyx−e1=h−ye2−x,yx−e1=h−ye2−x,or(e2−x)y=(x−e1)(h−y)⇒e1(h−y)+e2y=xh.(e2−x)y=(x−e1)(h−y)⇒e1(h−y)+e2y=xh.Since the coefficients of this line equation are of order hh, the coordinates of its solution are some rationals with the denominator of order 1/h21/h2. If we then want to check if such point belongs to another line, we want to compare some integer divided by another integer which is ≤h2≤h2 with the third integer, so we need an epsilon less than 1/h21/h2.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1071 和字母"
          },
          "content_length": 14869
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 1",
          "code": "int dp[2001][2001]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 2",
          "code": "dp[i][j] = fillDp(i + 1, j, i, j + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 3",
          "code": "//(x, y) - pointer which is lower, (b, a) - pointer which is to the right\nint fillDp(int y, int x, int b, int a) {\n    if (arr[y][x] < arr[b][a]) return 0; //you can only go down\n    if (arr[y][x] > arr[b][a]) return 1; //only right\n    if (b == y && a == x) return 2; //doesn't really matter which way\n    //if letters are the same and we check different fields\n    //we either move according to dp or (if dp == 2) we move pointers closer to each other\n    if (dp[y][x] == 0) y++;\n    else x++;\n    if (dp[b][a] == 1) a++;\n    else b++;\n    return fillDp(y, x, b, a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 4",
          "code": "//(x, y) - pointer which is lower, (b, a) - pointer which is to the right\nint fillDp(int y, int x, int b, int a) {\n    if (arr[y][x] < arr[b][a]) return 0; //you can only go down\n    if (arr[y][x] > arr[b][a]) return 1; //only right\n    if (b == y && a == x) return 2; //doesn't really matter which way\n    //if letters are the same and we check different fields\n    //we either move according to dp or (if dp == 2) we move pointers closer to each other\n    if (dp[y][x] == 0) y++;\n    else x++;\n    if (dp[b][a] == 1) a++;\n    else b++;\n    return fillDp(y, x, b, a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 5",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 6",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 7",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 8",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 9",
          "code": "1 + 2 + ... + k <= a + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 10",
          "code": "S = 1 + 2 + ... + k <= a + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 11",
          "code": "3\n2 3 4\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 12",
          "code": "3\n2 3 4\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 13",
          "code": "7\n1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 14",
          "code": "7\n1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 15",
          "code": "YES\n3\n3 5 7\n3 4 5\n1 4 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 16",
          "code": "YES\n3\n3 5 7\n3 4 5\n1 4 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 17",
          "code": "YES\n3\n5 6 7\n1 4 7\n4 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 18",
          "code": "YES\n3\n5 6 7\n1 4 7\n4 5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 19",
          "code": "100000\n0 1 0 1 0\n...\n0 1 0 1 0\n0 0 0 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 20",
          "code": "100000\n0 1 0 1 0\n...\n0 1 0 1 0\n0 0 0 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 21",
          "code": "125\n1 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 22",
          "code": "125\n1 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0\n1 0 1 0 1\n0 1 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 23",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 24",
          "code": "100000\n3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 3 3 3 2 3 ...(repeat)\n0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 25",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round 517 (and Technocup 2019 — Elimination Round 2) - Codeforces - Code 26",
          "code": "YES\n1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62594",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 1",
          "code": "100000\n3 3 3 2 3 ...(repeat)\n0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 2",
          "code": "100000\n3 3 3 2 3 ...(repeat)\n0 2 0 0 0 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 3",
          "code": "YES\n1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 4",
          "code": "YES\n1 2 3 0 2 ...(repeat)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 5",
          "code": "for(int j = 0;j<=3;j++){ // values of b(i)\n\n        for(int k = 0;k<=3;k++){ // values of t(i+1)\n\n            cout << i << \" \" << j << \" \" << k << \" -> \";\n\n            for(int l = 0;l<=3;l++){ // possible values of t(i) \n                if((k & l )== j && ((k|l) == i)){\n                    cout << l << \" \";\n                }\n            }\n            cout << endl;\n        }\n    }\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 6",
          "code": "bcc\ncaa\nggg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 7",
          "code": "bcc\ncaa\nggg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 8",
          "code": "0 0 0 1 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 9",
          "code": "0 0 0 1 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 10",
          "code": "1 0 1 0 1 0 0 0\n0 0 1 0 1 0 1 0 \n1 0 0 1 0 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 11",
          "code": "1 0 1 0 1 0 0 0\n0 0 1 0 1 0 1 0 \n1 0 0 1 0 0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 12",
          "code": "0 0 1 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 13",
          "code": "0 0 1 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 14",
          "code": "0 0 1 1 1 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 15",
          "code": "0 0 1 1 1 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 16",
          "code": "0 1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 17",
          "code": "0 1 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 18",
          "code": "0 1 0 0 1 0 0 1\n0 0 0 0 1 1 1 0\n0 0 0 0 0 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 19",
          "code": "0 1 0 0 1 0 0 1\n0 0 0 0 1 1 1 0\n0 0 0 0 0 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 20",
          "code": "1 0 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 21",
          "code": "1 0 0 0 0 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 22",
          "code": "1 0 0 1 0 0 1 0\n0 0 0 1 1 1 0 0\n0 0 0 0 1 1 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 23",
          "code": "1 0 0 1 0 0 1 0\n0 0 0 1 1 1 0 0\n0 0 0 0 1 1 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 24",
          "code": "(prod, pos)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 25",
          "code": "(prod / k, pos + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 26",
          "code": "abs(x[pos] - k)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 27",
          "code": "3 5 5\n3 4\n2 1 0\n4 2 1\n5 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 28",
          "code": "3 5 5\n3 4\n2 1 0\n4 2 1\n5 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 29",
          "code": "2 5 5\n5 0\n1 0 0\n2 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 30",
          "code": "2 5 5\n5 0\n1 0 0\n2 4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 31",
          "code": "3 4 4\n2 3\n2 2 2\n4 1 1\n5 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 32",
          "code": "3 4 4\n2 3\n2 2 2\n4 1 1\n5 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 33",
          "code": "3 5 5\n3 2\n2 3 3\n4 3 2\n6 1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #517 and Technocup 2019 Elimination Round 2 Editorial - Codeforces - Code 34",
          "code": "3 5 5\n3 2\n2 3 3\n4 3 2\n6 1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int a_i = inf.readInt(1, 1000000, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, 1000000, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int a_i = inf.readInt(1, 1000000, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, 1000000, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int a_i = inf.readInt(1, 1000000, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, 1000000, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");  // Number of test cases\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n\n    if (type == \"min\") {\n        // All a_i and b_i are 1\n        for (int i = 0; i < t; ++i) {\n            printf(\"1 1\\n\");\n        }\n    } else if (type == \"max\") {\n        // All a_i and b_i are 1e6\n        for (int i = 0; i < t; ++i) {\n            printf(\"1000000 1000000\\n\");\n        }\n    } else if (type == \"random\") {\n        // Random a_i and b_i in [1, 1e6]\n        for (int i = 0; i < t; ++i) {\n            int a = rnd.next(1, 1000000);\n            int b = rnd.next(1, 1000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"same\") {\n        // a_i == b_i\n        for (int i = 0; i < t; ++i) {\n            int a = rnd.next(1, 1000000);\n            printf(\"%d %d\\n\", a, a);\n        }\n    } else if (type == \"primes\") {\n        // a_i and b_i are random primes in [2, 1e6]\n        // Generate primes up to 1e6\n        const int MAXN = 1000000;\n        vector<int> primes;\n        vector<bool> is_prime(MAXN+1, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= MAXN; ++i){\n            if(is_prime[i]){\n                primes.push_back(i);\n                if(1LL * i * i <= MAXN){\n                    for(int j = i * i; j <= MAXN; j += i){\n                        is_prime[j] = false;\n                    }\n                }\n            }\n        }\n\n        for(int i = 0; i < t; ++i){\n            int a = primes[rnd.next(0, (int)primes.size() - 1)];\n            int b = primes[rnd.next(0, (int)primes.size() - 1)];\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"powers\") {\n        // a_i and b_i are powers of two\n        vector<int> powers;\n        for(int i = 0; (1<<i) <= 1000000; ++i){\n            powers.push_back(1<<i);\n        }\n        for(int i = 0; i < t; ++i){\n            int a = powers[rnd.next(0, (int)powers.size() - 1)];\n            int b = powers[rnd.next(0, (int)powers.size() - 1)];\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"almost_same_divisors\") {\n        // Generate numbers which have close number of divisors\n        for(int i = 0; i < t; ++i){\n            int n = rnd.next(2, 1000000 - 1);\n            printf(\"%d %d\\n\", n, n+1);\n        }\n    } else if (type == \"max_divisors\") {\n        // Generate numbers with maximal number of divisors\n        vector<int> rich_numbers = {5040, 7560, 15120, 27720, 45360, 498960, 83160}; // High-divisor numbers ≤ 1e6\n        for(int i = 0; i < t; ++i){\n            int a = rich_numbers[rnd.next(0, (int)rich_numbers.size() - 1)];\n            int b = rich_numbers[rnd.next(0, (int)rich_numbers.size() - 1)];\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"small_numbers\") {\n        // a_i and b_i between 1 and 10\n        for (int i = 0; i < t; ++i) {\n            int a = rnd.next(1, 10);\n            int b = rnd.next(1, 10);\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"large_numbers_with_same_divisors\") {\n        // Generate large numbers with the same number of divisors\n        vector<pair<int,int>> pairs = {{5040, 7560}, {83160, 498960}};\n        for(int i = 0; i < t; ++i){\n            int idx = rnd.next(0, (int)pairs.size()-1);\n            printf(\"%d %d\\n\", pairs[idx].first, pairs[idx].second);\n        }\n    } else if (type == \"max_operations_needed\") {\n        // Generate numbers where maximum operations are needed\n        // Use one prime and one composite number with many divisors\n        const int MAXN = 1000000;\n        vector<int> primes;\n        vector<bool> is_prime(MAXN+1, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= MAXN; ++i){\n            if(is_prime[i]){\n                primes.push_back(i);\n                if(1LL * i * i <= MAXN){\n                    for(int j = i * i; j <= MAXN; j += i){\n                        is_prime[j] = false;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < t; ++i){\n            int a = primes[rnd.next(0, (int)primes.size() - 1)];\n            int b = 5040; // A number with many divisors\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < t; ++i) {\n            int a = rnd.next(1, 1000000);\n            int b = rnd.next(1, 1000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");  // Number of test cases\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n\n    if (type == \"min\") {\n        // All a_i and b_i are 1\n        for (int i = 0; i < t; ++i) {\n            printf(\"1 1\\n\");\n        }\n    } else if (type == \"max\") {\n        // All a_i and b_i are 1e6\n        for (int i = 0; i < t; ++i) {\n            printf(\"1000000 1000000\\n\");\n        }\n    } else if (type == \"random\") {\n        // Random a_i and b_i in [1, 1e6]\n        for (int i = 0; i < t; ++i) {\n            int a = rnd.next(1, 1000000);\n            int b = rnd.next(1, 1000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"same\") {\n        // a_i == b_i\n        for (int i = 0; i < t; ++i) {\n            int a = rnd.next(1, 1000000);\n            printf(\"%d %d\\n\", a, a);\n        }\n    } else if (type == \"primes\") {\n        // a_i and b_i are random primes in [2, 1e6]\n        // Generate primes up to 1e6\n        const int MAXN = 1000000;\n        vector<int> primes;\n        vector<bool> is_prime(MAXN+1, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= MAXN; ++i){\n            if(is_prime[i]){\n                primes.push_back(i);\n                if(1LL * i * i <= MAXN){\n                    for(int j = i * i; j <= MAXN; j += i){\n                        is_prime[j] = false;\n                    }\n                }\n            }\n        }\n\n        for(int i = 0; i < t; ++i){\n            int a = primes[rnd.next(0, (int)primes.size() - 1)];\n            int b = primes[rnd.next(0, (int)primes.size() - 1)];\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"powers\") {\n        // a_i and b_i are powers of two\n        vector<int> powers;\n        for(int i = 0; (1<<i) <= 1000000; ++i){\n            powers.push_back(1<<i);\n        }\n        for(int i = 0; i < t; ++i){\n            int a = powers[rnd.next(0, (int)powers.size() - 1)];\n            int b = powers[rnd.next(0, (int)powers.size() - 1)];\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"almost_same_divisors\") {\n        // Generate numbers which have close number of divisors\n        for(int i = 0; i < t; ++i){\n            int n = rnd.next(2, 1000000 - 1);\n            printf(\"%d %d\\n\", n, n+1);\n        }\n    } else if (type == \"max_divisors\") {\n        // Generate numbers with maximal number of divisors\n        vector<int> rich_numbers = {5040, 7560, 15120, 27720, 45360, 498960, 83160}; // High-divisor numbers ≤ 1e6\n        for(int i = 0; i < t; ++i){\n            int a = rich_numbers[rnd.next(0, (int)rich_numbers.size() - 1)];\n            int b = rich_numbers[rnd.next(0, (int)rich_numbers.size() - 1)];\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"small_numbers\") {\n        // a_i and b_i between 1 and 10\n        for (int i = 0; i < t; ++i) {\n            int a = rnd.next(1, 10);\n            int b = rnd.next(1, 10);\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"large_numbers_with_same_divisors\") {\n        // Generate large numbers with the same number of divisors\n        vector<pair<int,int>> pairs = {{5040, 7560}, {83160, 498960}};\n        for(int i = 0; i < t; ++i){\n            int idx = rnd.next(0, (int)pairs.size()-1);\n            printf(\"%d %d\\n\", pairs[idx].first, pairs[idx].second);\n        }\n    } else if (type == \"max_operations_needed\") {\n        // Generate numbers where maximum operations are needed\n        // Use one prime and one composite number with many divisors\n        const int MAXN = 1000000;\n        vector<int> primes;\n        vector<bool> is_prime(MAXN+1, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= MAXN; ++i){\n            if(is_prime[i]){\n                primes.push_back(i);\n                if(1LL * i * i <= MAXN){\n                    for(int j = i * i; j <= MAXN; j += i){\n                        is_prime[j] = false;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < t; ++i){\n            int a = primes[rnd.next(0, (int)primes.size() - 1)];\n            int b = 5040; // A number with many divisors\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < t; ++i) {\n            int a = rnd.next(1, 1000000);\n            int b = rnd.next(1, 1000000);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type min\n./gen -t 1 -type max\n./gen -t 1 -type random\n./gen -t 1 -type same\n./gen -t 1 -type primes\n./gen -t 1 -type powers\n./gen -t 1 -type small_numbers\n./gen -t 1 -type large_numbers_with_same_divisors\n./gen -t 1 -type almost_same_divisors\n./gen -t 1 -type max_operations_needed\n\n./gen -t 10 -type random\n./gen -t 10 -type primes\n./gen -t 10 -type powers\n./gen -t 10 -type small_numbers\n./gen -t 10 -type large_numbers_with_same_divisors\n./gen -t 10 -type almost_same_divisors\n./gen -t 10 -type max_operations_needed\n\n./gen -t 100 -type random\n./gen -t 100 -type primes\n./gen -t 100 -type powers\n./gen -t 100 -type same\n\n./gen -t 1000 -type random\n./gen -t 1000 -type primes\n./gen -t 1000 -type powers\n./gen -t 1000 -type small_numbers\n\n./gen -t 10000 -type random\n./gen -t 10000 -type max\n./gen -t 10000 -type min\n./gen -t 10000 -type same\n\n./gen -t 100000 -type random\n./gen -t 100000 -type primes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:42.423937",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1071/E",
      "title": "Problem 1071/E",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(2, 1000, \"h\"); // h must be at least 2 to allow y_i in (0, h)\n    inf.readEoln();\n\n    int e1 = inf.readInt(0, w, \"e_1\");\n    inf.readSpace();\n    int e2 = inf.readInt(0, w, \"e_2\");\n    inf.readEoln();\n\n    int prev_ti = -1;\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 100000, \"t_i\");\n        if (i > 0) {\n            ensuref(prev_ti <= ti, \"t_i should be non-decreasing at line %d: t_i=%d, prev_ti=%d\", i+3, ti, prev_ti);\n        }\n        prev_ti = ti;\n        inf.readSpace();\n        int xi = inf.readInt(0, w, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, h - 1, \"y_i\"); // y_i ∈ (0, h), so 1 ≤ y_i ≤ h−1\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(2, 1000, \"h\"); // h must be at least 2 to allow y_i in (0, h)\n    inf.readEoln();\n\n    int e1 = inf.readInt(0, w, \"e_1\");\n    inf.readSpace();\n    int e2 = inf.readInt(0, w, \"e_2\");\n    inf.readEoln();\n\n    int prev_ti = -1;\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 100000, \"t_i\");\n        if (i > 0) {\n            ensuref(prev_ti <= ti, \"t_i should be non-decreasing at line %d: t_i=%d, prev_ti=%d\", i+3, ti, prev_ti);\n        }\n        prev_ti = ti;\n        inf.readSpace();\n        int xi = inf.readInt(0, w, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, h - 1, \"y_i\"); // y_i ∈ (0, h), so 1 ≤ y_i ≤ h−1\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(2, 1000, \"h\"); // h must be at least 2 to allow y_i in (0, h)\n    inf.readEoln();\n\n    int e1 = inf.readInt(0, w, \"e_1\");\n    inf.readSpace();\n    int e2 = inf.readInt(0, w, \"e_2\");\n    inf.readEoln();\n\n    int prev_ti = -1;\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 100000, \"t_i\");\n        if (i > 0) {\n            ensuref(prev_ti <= ti, \"t_i should be non-decreasing at line %d: t_i=%d, prev_ti=%d\", i+3, ti, prev_ti);\n        }\n        prev_ti = ti;\n        inf.readSpace();\n        int xi = inf.readInt(0, w, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, h - 1, \"y_i\"); // y_i ∈ (0, h), so 1 ≤ y_i ≤ h−1\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int w = opt<int>(\"w\", 0); // If w == 0, then set w randomly between 1 and 1000\n    int h = opt<int>(\"h\", 0); // Same for h\n\n    if (w == 0) w = rnd.next(1, 1000);\n    if (h == 0) h = rnd.next(1, 1000);\n\n    if (type == \"impossible\") {\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        int t0 = 1;\n        for (int i = 0; i < n; ++i) {\n            int x_i, y_i;\n\n            if (i == 0) {\n                x_i = 0;\n                y_i = rnd.next(1, h - 1);\n            } else if (i == 1) {\n                x_i = w / 2;\n                y_i = rnd.next(1, h - 1);\n            } else if (i ==2) {\n                x_i = w;\n                y_i = rnd.next(1, h - 1);\n            } else {\n                x_i = rnd.next(0, w);\n                y_i = rnd.next(1, h - 1);\n            }\n\n            printf(\"%d %d %d\\n\", t0, x_i, y_i);\n        }\n    } else if (type == \"same_time\") {\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        int t0 = rnd.next(1, 100000);\n\n        for (int i = 0; i < n; ++i) {\n            int x_i = rnd.next(0, w);\n            int y_i = rnd.next(1, h - 1);\n            printf(\"%d %d %d\\n\", t0, x_i, y_i);\n        }\n    } else if (type == \"edge_cases\") {\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        vector<int> t(n);\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 100000);\n        }\n        sort(t.begin(), t.end());\n\n        for (int i = 0; i < n; ++i) {\n            int x_i = rnd.next(0, w);\n            int y_i;\n            if (rnd.next(2))\n                y_i = rnd.next(1); // y_i near 0\n            else\n                y_i = h - rnd.next(1); // y_i near h\n            printf(\"%d %d %d\\n\", t[i], x_i, y_i);\n        }\n    } else if (type == \"minimal_speed\") {\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        int t = 1;\n        for (int i = 0; i < n; ++i) {\n            int y_i = rnd.next(1, h - 1);\n            int x_i = (long long)(e1) * (h - y_i) + (long long)(e2) * y_i;\n            x_i /= h;\n            printf(\"%d %d %d\\n\", t, x_i, y_i);\n            t += rnd.next(1, 10);\n        }\n    } else if (type == \"max_n\") {\n        n = 100000;\n        w = 1000;\n        h = 1000;\n\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        vector<int> t(n);\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 100000);\n        }\n        sort(t.begin(), t.end());\n\n        for (int i = 0; i < n; ++i) {\n            int x_i = rnd.next(0, w);\n            int y_i = rnd.next(1, h - 1);\n            printf(\"%d %d %d\\n\", t[i], x_i, y_i);\n        }\n    } else {\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        vector<int> t(n);\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 100000);\n        }\n        sort(t.begin(), t.end());\n\n        for (int i = 0; i < n; ++i) {\n            int x_i = rnd.next(0, w);\n            int y_i = rnd.next(1, h - 1);\n            printf(\"%d %d %d\\n\", t[i], x_i, y_i);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int w = opt<int>(\"w\", 0); // If w == 0, then set w randomly between 1 and 1000\n    int h = opt<int>(\"h\", 0); // Same for h\n\n    if (w == 0) w = rnd.next(1, 1000);\n    if (h == 0) h = rnd.next(1, 1000);\n\n    if (type == \"impossible\") {\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        int t0 = 1;\n        for (int i = 0; i < n; ++i) {\n            int x_i, y_i;\n\n            if (i == 0) {\n                x_i = 0;\n                y_i = rnd.next(1, h - 1);\n            } else if (i == 1) {\n                x_i = w / 2;\n                y_i = rnd.next(1, h - 1);\n            } else if (i ==2) {\n                x_i = w;\n                y_i = rnd.next(1, h - 1);\n            } else {\n                x_i = rnd.next(0, w);\n                y_i = rnd.next(1, h - 1);\n            }\n\n            printf(\"%d %d %d\\n\", t0, x_i, y_i);\n        }\n    } else if (type == \"same_time\") {\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        int t0 = rnd.next(1, 100000);\n\n        for (int i = 0; i < n; ++i) {\n            int x_i = rnd.next(0, w);\n            int y_i = rnd.next(1, h - 1);\n            printf(\"%d %d %d\\n\", t0, x_i, y_i);\n        }\n    } else if (type == \"edge_cases\") {\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        vector<int> t(n);\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 100000);\n        }\n        sort(t.begin(), t.end());\n\n        for (int i = 0; i < n; ++i) {\n            int x_i = rnd.next(0, w);\n            int y_i;\n            if (rnd.next(2))\n                y_i = rnd.next(1); // y_i near 0\n            else\n                y_i = h - rnd.next(1); // y_i near h\n            printf(\"%d %d %d\\n\", t[i], x_i, y_i);\n        }\n    } else if (type == \"minimal_speed\") {\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        int t = 1;\n        for (int i = 0; i < n; ++i) {\n            int y_i = rnd.next(1, h - 1);\n            int x_i = (long long)(e1) * (h - y_i) + (long long)(e2) * y_i;\n            x_i /= h;\n            printf(\"%d %d %d\\n\", t, x_i, y_i);\n            t += rnd.next(1, 10);\n        }\n    } else if (type == \"max_n\") {\n        n = 100000;\n        w = 1000;\n        h = 1000;\n\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        vector<int> t(n);\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 100000);\n        }\n        sort(t.begin(), t.end());\n\n        for (int i = 0; i < n; ++i) {\n            int x_i = rnd.next(0, w);\n            int y_i = rnd.next(1, h - 1);\n            printf(\"%d %d %d\\n\", t[i], x_i, y_i);\n        }\n    } else {\n        int e1 = rnd.next(0, w);\n        int e2 = rnd.next(0, w);\n\n        printf(\"%d %d %d\\n\", n, w, h);\n        printf(\"%d %d\\n\", e1, e2);\n\n        vector<int> t(n);\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 100000);\n        }\n        sort(t.begin(), t.end());\n\n        for (int i = 0; i < n; ++i) {\n            int x_i = rnd.next(0, w);\n            int y_i = rnd.next(1, h - 1);\n            printf(\"%d %d %d\\n\", t[i], x_i, y_i);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal_speed\n./gen -n 5 -type minimal_speed\n./gen -n 10 -type minimal_speed\n./gen -n 100 -type minimal_speed\n./gen -n 1000 -type minimal_speed\n\n./gen -n 3 -type impossible\n./gen -n 10 -type impossible\n./gen -n 100 -type impossible\n./gen -n 1000 -type impossible\n\n./gen -n 10 -type same_time\n./gen -n 1000 -type same_time\n./gen -n 10000 -type same_time\n\n./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n\n./gen -n 3 -type edge_cases\n./gen -n 10 -type edge_cases\n./gen -n 100 -type edge_cases\n./gen -n 1000 -type edge_cases\n\n./gen -n 100000 -type max_n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:44.036037",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1073/A",
      "title": "A. Diverse Substring",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer nn (1≤n≤10001≤n≤1000) — the length of string ss.The second line is the string ss, consisting of exactly nn lowercase Latin letters.",
      "output_spec": "OutputPrint \"NO\" if there is no diverse substring in the string ss.Otherwise the first line should contain \"YES\". The second line should contain any diverse substring of string ss.",
      "sample_tests": "ExamplesInputCopy10codeforcesOutputCopyYEScodeInputCopy5aaaaaOutputCopyNO",
      "description": "A. Diverse Substring\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer nn (1≤n≤10001≤n≤1000) — the length of string ss.The second line is the string ss, consisting of exactly nn lowercase Latin letters.\n\nOutputPrint \"NO\" if there is no diverse substring in the string ss.Otherwise the first line should contain \"YES\". The second line should contain any diverse substring of string ss.\n\nInputCopy10codeforcesOutputCopyYEScodeInputCopy5aaaaaOutputCopyNO\n\nInputCopy10codeforces\n\nOutputCopyYEScode\n\nInputCopy5aaaaa\n\nOutputCopyNO\n\nNoteThe first example has lots of correct answers. Please, restrain yourself from asking if some specific answer is correct for some specific test or not, these questions always lead to \"No comments\" answer.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces",
          "content": "On Thursday, October 25, 2018 at 22:35UTC+8 Educational Codeforces Round 53 (Rated for Div. 2) will start.Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. The penalty for each incorrect submission until the submission with a full solution is 10 minutes. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Roman Roms Glazov, Adilbek adedalic Dalabaev, Vladimir vovuh Petrov, Ivan BledDest Androsov and me.Good luck to all participants!Our friends at Harbour.Space also have a message for you:Hey Codeforces! We want to remind you that the Scholarship for the Master’s in Robotics programme, which starts on January 7th 2019, has an application deadline of November 12th, 2018.Harbour.Space University and Remy Robotics are collaborating to offer graduate students from anywhere in the world a once in a lifetime opportunity, a fully funded scholarship for Harbour.Space University’s Master’s Programme in Robotics. The scholarship value is €34.900 and it includes: Complete coverage of the University tuition fee (€22,900) Internship at Remy Robotics (20h per week during 1 year) €1,000 per month during 1 year (Internship earnings) Apply hereUPD: vovuh and me will be waiting for you on the community Discord server shortly after the contest to discuss the problems.Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 pekempey 7 305 2 ko_osaga 7 578 3 Lewin 6 216 4 fanache99 6 226 5 natsugiri 6 257 Congratulations to the best hackers: Rank Competitor Hack Count 1 halyavin 238:-15 2 Laggy 64:-14 3 MarcosK 59:-9 4 Mistra 8:-1 5 LordVoldebug 7:-1 482 successful hacks and 684 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A Dalgerok 0:01 B dorijanlendvaj 0:02 C fanache99 0:10 D bazsi700 0:13 E DAyamaCTF 0:21 F Noam527 0:48 G ko_osaga 0:24 UPD2: Editorial is published",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62683",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2335
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces",
          "content": "1073A - Diverse Substring Tutorial1073A - Diverse SubstringNotice that the string of two distinct letter is already diverse. That implies that the answer is \"NO\" if and only if all the letters in the string are the same. Otherwise you can check all pairs of adjacent letters in O(n)O(n).Overall complexity: O(n)O(n). Solution (PikMike)n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")1073B - Vasya and Books Tutorial1073B - Vasya and BooksLet's maintain the pointer pospos to the topmost non-deleted book and whether each book whether is removed from the stack or not. Initially, all books are in a stack, and pospos is 0 (if we store the array 0-indexed). We will process the array BB in the order b1,b2,…bnb1,b2,…bn. If the current book bibi is removed from the stack, then the answer for it is zero. Otherwise, we will increment the pointer pospos until the equality apos=biapos=bi is satisfied, while marking all the intermediate books in the array uu. After that, the answer for the book bibi will be the number of marked books in the uu array (including itself).Since the pointer pospos shifts nn times at total, we get a solution with an O(n)O(n) complexity. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n for(int i = 0; i < n; ++i) {\n \tscanf(\"%d\", a + i);\n }\n for(int i = 0; i < n; ++i){\n \tscanf(\"%d\", b + i);\n }\n\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t} \n\n\tputs(\"\");\n return 0;\n}1073C - Vasya and Robot Tutorial1073C - Vasya and RobotDenote d=|x|+|y​|d=|x|+|y​|. If d>nd>n, then the answer is -1, since the robot will not have the time to reach (x,y)(x,y) cell in nn steps. Also, if dd and nn have different parity, then the answer is also -1, as in one move the robot changes the parity of the sum of its coordinates.In all other cases, the answer exists. Let's use binary search to solve this problem. Consider all segments of length lenlen. For a fixed length of the segment lenlen, let's iterate over the position of the beginning of the segment ll. At the same time, we will maintain the cell that the robot will stop at if it execute all commands, except commands with indices l,l+1,…,l+len−1l,l+1,…,l+len−1. We denote this position as (x0,y0)(x0,y0). We also calculate the distances from the cell (x0,y0)(x0,y0) to the cell (x,y)(x,y) — the value d0=|x−x0|+|y​​−y0|d0=|x−x0|+|y​​−y0|. If there is at least one position of the beginning of the segment for which d0≤lend0≤len, then we can change the segment of length lenlen so that the robot comes to the (x,y)(x,y) cell, otherwise it can't. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tcout << r << endl;\n return 0;\n}1073D - Berland Fair Tutorial1073D - Berland FairLet's code the following process. Go one circle across the booths, calculate the total cost CC of sweets bought and the number SS of sweets bought. Now you can decrease you money down to T=T mod CT=T mod C and add S⋅(T div C)S⋅(T div C) to answer. It represents that you went maximum number of such circles. The later circles will have smaller cost. Let's continue this process until TT becomes smaller than the minimum priced sweet.The number of operations made is O(logT)O(log⁡T). Let TcurTcur be the amount of money before some operation, CcurCcur be the total cost of sweets bought on that operation and Tnew=Tcur mod CcurTnew=Tcur mod Ccur. TnewTnew is actually smaller than CcurCcur (that's how modulo works) and smaller than Tcur−CcurTcur−Ccur (that's also how modulo works). And these inequalities imply that Tnew<Tcur2Tnew<Tcur2. That leads to about O(logT)O(log⁡T) steps to reach the minimal price.Overall complexity: O(nlogT)O(nlog⁡T). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}1073E - Segment Sum Tutorial1073E - Segment SumLet's calculate the answer as the sum of suitable numbers in range [1;r][1;r] minus the sum of suitable numbers in range [1;l−1][1;l−1]. Now our problem is to calculate the sum of suitable numbers in range [1;n][1;n].The main approach for this problem is digit DP. Let's calculate two dynamic programmings dppos,mask,fdppos,mask,f and dpspos,mask,fdpspos,mask,f. pospos means that now we are at the pospos-th digit of the number nn (at the digit corresponding to 10len−pos−110len−pos−1, where lenlen is the decimal length of a number), maskmask is a binary mask describing digits we already use and ff equals 11 if the current prefix of number we trying to obtain is the same as the prefix of number nn (otherwise ff equals 00).So what means dppos,mask,fdppos,mask,f? It means the count of numbers (in general, not numbers but their prefixes) in range [1;n][1;n] of length exactly |n||n| without leading zeroes corresponding to this state. So what the point of this DP? Its point is helping us to calculate the main DP, dpspos,mask,fdpspos,mask,f, which means the sum of numbers (in general, not numbers but their prefixes) in range [1;n][1;n] of length exactly |n||n| without leading zeroes corresponding to this state.How do we calculate the answer? Firstly, let lenlen be the length of nn. Let calc(n)calc(n) be the function calculating the sum of numbers from 11 to nn containing at most kk different digits. How to calculate it? Let calcdp(x)calcdp(x) be the sum of numbers from 11 to xx containing at most kk different digits and having length exactly |x||x|. Then calc(n)calc(n) seems to be pretty easy: for each length ii from 11 to len−1len−1 add to the answer calcdp(10i−1)calcdp(10i−1). And the last step is to add to the answer calcdp(n)calcdp(n).How to calculate dynamic programmings? Initially, all states are zeroes (excluding dp0,0,1dp0,0,1, which is 11).Firstly, let's calculate dpdp. After calculating it we can calculate dpsdps in almost the same way. Let's iterate over all possible lengths and over all possible masks. Let the current state is dppos,mask,0dppos,mask,0. Then let's iterate over next digit we will place in this number and place it. If pos=0pos=0 then dig=1…9dig=1…9 otherwise dig=0…9dig=0…9. The transition is pretty easy: dppos+1,mask|2dig,0+=dppos,mask,0dppos+1,mask|2dig,0+=dppos,mask,0. There || is the bitwise OR operation. For f=1f=1 transitions are almost the same expect the restrictions on digit we place and the state we update. If we now at the position pospos with mask maskmask and f=1f=1 then the current digit of nn is nposnpos. Then let's iterate over next digit: dig=1…nposdig=1…npos if pos=0pos=0 otherwise dig=0…nposdig=0…npos. The transition is also easy: dppos+1,mask|2dig,dig=npos+=dppos,mask,fdppos+1,mask|2dig,dig=npos+=dppos,mask,f.After calculating the previous DP we can calculate dpsdps. All the process is the same as in the previous dynamic programming expect the value we will add in transitions. In the previous DP this value was equal dppos,mask,fdppos,mask,f, in the current DP this value equals to val=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,fval=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,f. Don't forget to calculate it modulo 998244353998244353!So after calculating all the values of DPs, what is the answer for calcdp(n)calcdp(n)? It is ∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1 for all masks with at most kk bits.I'm pretty sure that there is another way to avoid leading zeroes in calculating these DPs but this one is very straight-forward and simple. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\n\treturn 0;\n}1073F - Choosing Two Paths Tutorial1073F - Choosing Two PathsFirstly, let's call a path from uu to vv good, if uu is a leaf, vv is a vertex of degree at least 33 (the number of their neighbors is at least 33) and there are no other vertices of degree at least 33 on this path expect the vertex vv.The first step of the solution is to remove all the good paths from uu to vv (but we should not remove the vertex vv) and remember for each vertex vv the sum of two maximum lengths of good paths which end in the vertex vv. Let this value for the vertex vv be valvvalv. For example, if for some vertex vv there are 33 good paths with end in it of lengths 22, 33 and 55 correspondingly, then valvvalv will be 5+3=85+3=8.Okay, it is easy to see that the maximum intersection of two paths in the answer will be equal to the length of the diameter of the obtained tree. But we can not take any diameter of this tree and call it the answer because of the second constraint: we need to find some diameter from xx to yy such that the sum valx+valyvalx+valy is maximum possible. How do we do that?There is such an awesome (and well-known) fact that the center of a tree belongs to all diameters of this tree. Let's root the tree by the center of a tree (if the length of the diameter is odd (the center of a tree is an edge) then let's root the tree by any end of this edge, it does not matter).There is one case when the length of the diameter is 11 but it is pretty trivial to handle it.Now our problem is to find two neighbors of the root of the new tree such that in their subtrees are vertices which form some diameter of this tree and the sum of values of these vertices is maximum possible. Let's calculate the vertex with the maximum distance from a root (and with the maximum possible valvvalv for equals distances) by simple DFS for each neighbor of a root. It can be done in O(n)O(n) and the last part is to find two maximums of this list, it also can be done in O(n)O(n) or O(nlogn)O(nlog⁡n), depends on implementation. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\n\tpt ans = calc(path[size(path) / 2]);\n\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\n\treturn 0;\n}1073G - Yet Another LCP Problem Tutorial1073G - Yet Another LCP ProblemAt first, implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough. For example, it's a Suffix Array + linear LCP + Sparse Table. Now we can compare two suffixes ii and jj by finding l=lcp(i,j)l=lcp(i,j) and comparing s[i+l]s[i+l] with s[j+l]s[j+l].We will process queries online. Let current query be a pair of arrays aa (|a|=k|a|=k) and bb (|b|=l|b|=l). We will calculate answer in two parts: ∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).To calculate the first sum we can sort all c=a+bc=a+b suffixes in lexicographical order and maintain some information for prefixes of cc. What information we need to maintain? We need some Data Structure which will hold lcplcp of suffixes from aa. When we process some ci=bjci=bj we need just a total sum of all lcplcp in the DS. If ci=ajci=aj, we should add to the DS length of ajaj-th suffix. And when we move from cici to ci+1ci+1 we must recalculate some lcplcp. Since cc is sorted, all we need is to set lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n]))lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n])).In fact, this Data Structure is just a mapmap. In this mapmap we will hold for each length ll number of suffixes with lcp=llcp=l (we will hold only non-zero values). When we should add some suffix ajaj, we manually increase some value by one. Setting minmin with v=lcp(s[ci…n],s[ci+1…n])v=lcp(s[ci…n],s[ci+1…n]) can be done with decreasing maximum in mapmap while its more than vv. It can be proven, that there will be O(|a|+|b|)O(|a|+|b|) operations with mapmap for one query. The total sum can be maintained in some global variable, which will be recalculated each time mapmap changes.To calculate the second sum we can just reverse cc and run the same algorithm. So total complexity is O(nlog2n+(∑i=1i=qki+∑i=1i=qli)logn)O(nlog2⁡n+(∑i=1i=qki+∑i=1i=qli)log⁡n). Solution (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\n\tif(read()) {\n\t\tsolve();\n\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62742",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1073\\s*A"
          },
          "content_length": 21562
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 5",
          "code": "O(n * logn)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 6",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 1",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 2",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 15",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 16",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z]{\" + to_string(n) + \"}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z]{\" + to_string(n) + \"}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken(\"[a-z]{\" + to_string(n) + \"}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a diverse substring exists in the string s\nbool hasDiverseSubstring(const string& s) {\n    set<char> uniqueLetters(s.begin(), s.end());\n    return uniqueLetters.size() >= 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read input\n    int n = inf.readInt(1, 1000, \"n\");\n    string s = inf.readToken();\n    if ((int)s.length() != n) {\n        quitf(_fail, \"Input string length does not match n\");\n    }\n    // Read contestant output\n    string cansFirstLine = ouf.readToken();\n    if (cansFirstLine == \"NO\") {\n        if (hasDiverseSubstring(s)) {\n            quitf(_wa, \"Contestant output 'NO' but diverse substring exists\");\n        } else {\n            quitf(_ok, \"Correct output 'NO'\");\n        }\n    } else if (cansFirstLine == \"YES\") {\n        if (ouf.seekEof()) {\n            // Contestant didn't provide a substring after 'YES'\n            quitf(_wa, \"Contestant output 'YES' but no substring provided\");\n        }\n        string t = ouf.readLine();\n        // Remove any leading and trailing spaces from the substring\n        t = trim(t);\n        // Check if the substring consists only of lowercase letters\n        if (!regex_match(t, regex(\"[a-z]+\"))) {\n            quitf(_wa, \"Substring should consist of lowercase letters only\");\n        }\n        if (s.find(t) == string::npos) {\n            quitf(_wa, \"Substring '%s' is not a substring of s\", t.c_str());\n        }\n        // Check if the substring is diverse\n        int freq[26] = {0};\n        for (char c : t) {\n            freq[c - 'a']++;\n        }\n        int maxFreq = *max_element(freq, freq + 26);\n        int len_t = t.length();\n        if (maxFreq > len_t / 2) {\n            quitf(_wa, \"Substring '%s' is not diverse\", t.c_str());\n        } else {\n            quitf(_ok, \"Found correct diverse substring\");\n        }\n    } else {\n        quitf(_wa, \"First line of output is neither 'YES' nor 'NO'\");\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of length n\n        for(int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"onechar\") {\n        // Generate a string consisting of one character\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"twomajor\") {\n        // Generate a string where one character appears more than n/2 times\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while(c2 == c1) {\n            c2 = 'a' + rnd.next(26);\n        }\n        int c1_count = n / 2 + 1;\n        int c2_count = n - c1_count;\n        vector<char> chars;\n        for(int i = 0; i < c1_count; ++i) {\n            chars.push_back(c1);\n        }\n        for(int i = 0; i < c2_count; ++i) {\n            chars.push_back(c2);\n        }\n        // Shuffle the characters\n        shuffle(chars.begin(), chars.end());\n        // Build the string\n        for(char c : chars) {\n            s += c;\n        }\n    } else if (type == \"twobalanced\") {\n        // Generate a string where two characters appear equally (or nearly equally if n is odd)\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while(c2 == c1) {\n            c2 = 'a' + rnd.next(26);\n        }\n        int c1_count = n / 2;\n        int c2_count = n - c1_count;\n        vector<char> chars;\n        for(int i = 0; i < c1_count; ++i) {\n            chars.push_back(c1);\n        }\n        for(int i = 0; i < c2_count; ++i) {\n            chars.push_back(c2);\n        }\n        // Shuffle the characters\n        shuffle(chars.begin(), chars.end());\n        // Build the string\n        for(char c : chars) {\n            s += c;\n        }\n    } else if (type == \"maxdiverse\") {\n        // Generate a string with as many unique letters as possible\n        vector<char> chars;\n        for(int i = 0; i < min(n,26); ++i) {\n            chars.push_back('a' + i);\n        }\n        // Repeat letters if n > 26\n        while((int)chars.size() < n) {\n            chars.push_back(chars[rnd.next(26)]);\n        }\n        // Shuffle the characters\n        shuffle(chars.begin(), chars.end());\n        // Build the string\n        for(char c : chars) {\n            s += c;\n        }\n    } else if (type == \"n=1\") {\n        // Generate test case where n=1\n        n = 1;\n        char c = 'a' + rnd.next(26);\n        s = string(1, c);\n    } else if (type == \"maxlen\") {\n        // Generate test case with n=1000\n        n = 1000;\n        for(int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"nodiverse\") {\n        // Generate a string where there is no diverse substring\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else {\n        // Default to random string\n        for(int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    }\n\n    // Output n and s\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of length n\n        for(int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"onechar\") {\n        // Generate a string consisting of one character\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"twomajor\") {\n        // Generate a string where one character appears more than n/2 times\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while(c2 == c1) {\n            c2 = 'a' + rnd.next(26);\n        }\n        int c1_count = n / 2 + 1;\n        int c2_count = n - c1_count;\n        vector<char> chars;\n        for(int i = 0; i < c1_count; ++i) {\n            chars.push_back(c1);\n        }\n        for(int i = 0; i < c2_count; ++i) {\n            chars.push_back(c2);\n        }\n        // Shuffle the characters\n        shuffle(chars.begin(), chars.end());\n        // Build the string\n        for(char c : chars) {\n            s += c;\n        }\n    } else if (type == \"twobalanced\") {\n        // Generate a string where two characters appear equally (or nearly equally if n is odd)\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while(c2 == c1) {\n            c2 = 'a' + rnd.next(26);\n        }\n        int c1_count = n / 2;\n        int c2_count = n - c1_count;\n        vector<char> chars;\n        for(int i = 0; i < c1_count; ++i) {\n            chars.push_back(c1);\n        }\n        for(int i = 0; i < c2_count; ++i) {\n            chars.push_back(c2);\n        }\n        // Shuffle the characters\n        shuffle(chars.begin(), chars.end());\n        // Build the string\n        for(char c : chars) {\n            s += c;\n        }\n    } else if (type == \"maxdiverse\") {\n        // Generate a string with as many unique letters as possible\n        vector<char> chars;\n        for(int i = 0; i < min(n,26); ++i) {\n            chars.push_back('a' + i);\n        }\n        // Repeat letters if n > 26\n        while((int)chars.size() < n) {\n            chars.push_back(chars[rnd.next(26)]);\n        }\n        // Shuffle the characters\n        shuffle(chars.begin(), chars.end());\n        // Build the string\n        for(char c : chars) {\n            s += c;\n        }\n    } else if (type == \"n=1\") {\n        // Generate test case where n=1\n        n = 1;\n        char c = 'a' + rnd.next(26);\n        s = string(1, c);\n    } else if (type == \"maxlen\") {\n        // Generate test case with n=1000\n        n = 1000;\n        for(int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"nodiverse\") {\n        // Generate a string where there is no diverse substring\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else {\n        // Default to random string\n        for(int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    }\n\n    // Output n and s\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type onechar\n./gen -n 1 -type nodiverse\n\n./gen -n 2 -type random\n./gen -n 2 -type onechar\n./gen -n 2 -type twobalanced\n./gen -n 2 -type twomajor\n./gen -n 2 -type nodiverse\n\n./gen -n 10 -type random\n./gen -n 10 -type onechar\n./gen -n 10 -type twobalanced\n./gen -n 10 -type twomajor\n./gen -n 10 -type nodiverse\n./gen -n 10 -type maxdiverse\n\n./gen -n 100 -type random\n./gen -n 100 -type onechar\n./gen -n 100 -type twobalanced\n./gen -n 100 -type twomajor\n./gen -n 100 -type nodiverse\n./gen -n 100 -type maxdiverse\n\n./gen -n 500 -type random\n./gen -n 500 -type maxdiverse\n\n./gen -n 1000 -type random\n./gen -n 1000 -type onechar\n./gen -n 1000 -type twobalanced\n./gen -n 1000 -type twomajor\n./gen -n 1000 -type nodiverse\n./gen -n 1000 -type maxdiverse\n./gen -n 1000 -type maxlen\n\n# Edge cases\n./gen -n 999 -type random\n./gen -n 999 -type onechar\n./gen -n 1 -type n=1\n./gen -n 1000 -type n=1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:46.157452",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1073/B",
      "title": "B. Вася и книги",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит число n (1≤n≤2⋅105)n (1≤n≤2⋅105) — количество книг в стопке.Вторая строка содержит nn различных чисел a1,a2,…,an (1≤ai≤n)a1,a2,…,an (1≤ai≤n) — описание стопки книг.Третья строка содержит nn различных чисел b1,b2,…,bn (1≤bi≤n)b1,b2,…,bn (1≤bi≤n) — порядок шагов, сделанных Васей.Гарантируется, что все числа a1…ana1…an различны, и что все числа b1…bnb1…bn различны.",
      "output_spec": "Выходные данныеВыведите nn чисел. ii-е число должно равняться количеству книг, которые Вася переложит в рюкзак на ii-м шаге.",
      "sample_tests": "ПримерыВходные данныеСкопировать31 2 32 1 3Выходные данныеСкопировать2 0 1 Входные данныеСкопировать53 1 4 2 54 5 1 3 2Выходные данныеСкопировать3 2 0 0 0 Входные данныеСкопировать66 5 4 3 2 16 5 3 4 2 1Выходные данныеСкопировать1 1 2 0 1 1",
      "description": "B. Вася и книги\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит число n (1≤n≤2⋅105)n (1≤n≤2⋅105) — количество книг в стопке.Вторая строка содержит nn различных чисел a1,a2,…,an (1≤ai≤n)a1,a2,…,an (1≤ai≤n) — описание стопки книг.Третья строка содержит nn различных чисел b1,b2,…,bn (1≤bi≤n)b1,b2,…,bn (1≤bi≤n) — порядок шагов, сделанных Васей.Гарантируется, что все числа a1…ana1…an различны, и что все числа b1…bnb1…bn различны.\n\nВходные данные\n\nВыходные данныеВыведите nn чисел. ii-е число должно равняться количеству книг, которые Вася переложит в рюкзак на ii-м шаге.\n\nВыходные данные\n\nВходные данныеСкопировать31 2 32 1 3Выходные данныеСкопировать2 0 1 Входные данныеСкопировать53 1 4 2 54 5 1 3 2Выходные данныеСкопировать3 2 0 0 0 Входные данныеСкопировать66 5 4 3 2 16 5 3 4 2 1Выходные данныеСкопировать1 1 2 0 1 1\n\nВходные данныеСкопировать31 2 32 1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 0 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать53 1 4 2 54 5 1 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 2 0 0 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать66 5 4 3 2 16 5 3 4 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 1 2 0 1 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПервый тестовый пример разобран в условии задачи.Во втором тестовом примере на первом шаге Вася переложит три книги с номерами [3,1,4][3,1,4]. После этого в стопке останутся две книги 22 и 55 (книга 22 будет лежать на книге 55). На втором шаге Вася переложит две книги с номерами 22 и 55. После этого в стопке не останется книг, и в каждый из последующих шагов Вася не переложит ни одной книги.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces",
          "content": "Привет, Codeforces!В четверг, 25 октября 2018 г. в 22:35UTC+8 состоится Educational Codeforces Round 53 (рейтинговый для Див. 2).Продолжается серия образовательных раундов в рамках инициативы Harbour.Space University! Подробности о сотрудничестве Harbour.Space University и Codeforces можно прочитать в посте.Этот раунд будет рейтинговым для участников с рейтингом менее 2100. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. Штраф за каждую неверную посылку до посылки, являющейся полным решением, равен 10 минутам. После окончания раунда будет период времени длительностью в 12 часов, в течение которого вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования.Вам будет предложено 7 задач на 2 часа. Мы надеемся, что вам они покажутся интересными.Задачи вместе со мной придумывали и готовили Роман Roms Глазов, Адилбек adedalic Далабаев, Владимир vovuh Петров и Иван BledDest Андросов.Удачи в раунде! Успешных решений!А вот сообщение от наших друзей из Harbour.Space:Hey Codeforces! We want to remind you that the Scholarship for the Master’s in Robotics programme, which starts on January 7th 2019, has an application deadline of November 12th, 2018.Harbour.Space University and Remy Robotics are collaborating to offer graduate students from anywhere in the world a once in a lifetime opportunity, a fully funded scholarship for Harbour.Space University’s Master’s Programme in Robotics. The scholarship value is €34.900 and it includes: Complete coverage of the University tuition fee (€22,900) Internship at Remy Robotics (20h per week during 1 year) €1,000 per month during 1 year (Internship earnings) Apply hereUPD: Мы с vovuh будем ждать всех желающих в местном Discord сервере сразу после контеста для обсуждения задач.Поздравляем победителей: Место Участник Задач решено Штраф 1 pekempey 7 305 2 ko_osaga 7 578 3 Lewin 6 216 4 fanache99 6 226 5 natsugiri 6 257 Поздравляем лучших взломщиков: Место Участник Число взломов 1 halyavin 238:-15 2 Laggy 64:-14 3 MarcosK 59:-9 4 Mistra 8:-1 5 LordVoldebug 7:-1 Было сделано 482 успешных и 684 неудачных взломов.И, наконец, поздравляем людей, отправивших первое полное решение по задаче: Задача Участник Штраф A Dalgerok 0:01 B dorijanlendvaj 0:02 C fanache99 0:10 D bazsi700 0:13 E DAyamaCTF 0:21 F Noam527 0:48 G ko_osaga 0:24 UPD2: Разбор опубликован",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62683",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2433
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces",
          "content": "1073A - Разнообразная подстрока Разбор1073A - Разнообразная подстрокаЗаметим, что строка, состоящая из двух различных букв, уже разнообразная. Из этого следует, что ответ «NO» происходит тогда и только тогда, когда все буквы в строке одинаковые. Иначе можно проверить все пары соседних букв за O(n)O(n).Асимптотика решения: O(n)O(n). Решение (PikMike)n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")1073B - Вася и книги Разбор1073B - Вася и книгиДля решения задачи в масcиве uu будем поддерживать для каждой книги, удалена ли она из стопки, и указатель pospos на самую верхнюю не удаленную книгу. Изначально все книги есть в стопке, а pospos равен 0 (если мы храним массив в 0-индексации). Теперь рассмотрим массив BB в порядке b1,b2,…bnb1,b2,…bn. Если текущая книга bibi удалена из стопки, то ответ для неё равен нулю. Иначе будем увеличивать указатель pospos, пока не будет выполняться равенство apos=biapos=bi, при этом помечая все промежуточные книги в массиве uu. После этого, ответом для книги bibi будет количество помеченных книг в массиве uu (включая её саму).Так как указатель pospos сдвинется максимум nn раз, мы получаем решение с асимптотикой O(n)O(n). Решение (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n for(int i = 0; i < n; ++i) {\n \tscanf(\"%d\", a + i);\n }\n for(int i = 0; i < n; ++i){\n \tscanf(\"%d\", b + i);\n }\n\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t} \n\n\tputs(\"\");\n return 0;\n}1073C - Вася и робот Разбор1073C - Вася и роботОбозначим d=|x|+|y|d=|x|+|y|. Если d>nd>n, то ответ равен -1, так как робот не успеет за nn шагов дойти до клетки (x,y)(x,y). Также, если dd и nn имеют разную четность, то ответ тоже равен -1, так за один ход робот меняет четность суммы своих координат.Во всех остальных случаях ответ существует. Давайте перебирать его бинарным поиском. Пусть сейчас мы рассматриваем отрезок длины lenlen. Для зафиксированной длины отрезка lenlen переберем позицию начала отрезка ll. При этом будем поддерживать клетку робота, исполнившего все команды, кроме команд с индексами l,l+1,…,l+len−1l,l+1,…,l+len−1. Обозначим эту позицию как (x0,y0)(x0,y0). Так же вычислим расстояния от клетки (x0,y0)(x0,y0) до клетки (x,y)(x,y) — значение d0=|x−x0|+|y−y0|d0=|x−x0|+|y−y0|. Если найдется хотя бы одна позиция начала отрезка, для которой выполняется d0≤lend0≤len, то мы можем изменить отрезок длины lenlen так, чтобы робот пришел в клетку (x,y)(x,y), а иначе — не можем. Решение (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tcout << r << endl;\n return 0;\n}1073D - Берляндская ярмарка Разбор1073D - Берляндская ярмаркаПросимулируем следующий процесс. Пройдем один круг по киоскам, посчитаем суммарную стоимость CC купленных конфет и количество SS купленных конфет. Теперь уменьшаем деньги к T=T mod CT=T mod C и добавляем S⋅(T div C)S⋅(T div C) к ответу. Это соответствует проходу по максимальному количеству таких кругов. Следующие круги будут иметь меньшую стоимость. Продолжим процесс, пока TT не станет меньше, чем цена минимальной конфеты.Количество проведенных операций равно O(logT)O(log⁡T). Пусть TcurTcur будет количеством денег до начала какой-либо операции. CcurCcur — суммарной стоимостью купленных на этой операции конфет и Tnew=Tcur mod CcurTnew=Tcur mod Ccur. TnewTnew, на самом деле, меньше, чем CcurCcur (потому что так работает взятие по модулю) и меньше, чем Tcur−CcurTcur−Ccur (по той же причине). И эти неравенства позволяют получить, что Tnew<Tcur2Tnew<Tcur2. Из этого следует оценка в O(logT)O(log⁡T) шагов для достижения минимальной цены.Асимптотика решения: O(nlogT)O(nlog⁡T). Решение (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}1073E - Сумма на отрезке Разбор1073E - Сумма на отрезкеДавайте будем считать ответ как сумму подходящих чисел в отрезке [1;r][1;r] минус сумма подходящих чисел в отрезке [1;l−1][1;l−1]. Теперь наша задача — научиться считать сумму подходящих чисел в отрезке [1;n][1;n].Главным подходом для этой задачи является ДП по цифрам. Давайте будем считать два динамических программирования dppos,mask,fdppos,mask,f и dpspos,mask,fdpspos,mask,f. pospos означает, что сейчас мы находимся на pospos-й цифре числа nn (на цифре, соответствующей 10len−pos−110len−pos−1, где lenlen — десятичная длина числа), maskmask — двоичная маска, означающая цифры, которые мы уже использовали и ff равняется 11, если текущий префикс числа, которое мы пытаемся получить, совпадает с префиксом числа nn (иначе ff равно 00).Итак, что значит dppos,mask,fdppos,mask,f? Оно равно количеству чисел (в общем случае не чисел, а их префиксов) в отрезке [1;n][1;n] длины ровно |n||n| без лидирующих нулей таких, которые соответствуют этому состоянию. Итак, какой смысл в этом ДП? Его смысл в том, чтобы помочь нам посчитать главное ДП, dpspos,mask,fdpspos,mask,f, которое равно сумме чисел (в общем случае не чисел, а их префиксов) в отрезке [1;n][1;n] длины ровно |n||n| без лидирующих нулей таких, которые соответствуют этому состоянию.Как нам посчитать ответ? Сначала, пусть lenlen равно длине nn. Пусть calc(n)calc(n) — это функция, считающая сумму чисел от 11 до nn, состоящих из не более kk различных цифр. Как ее посчитать? Пусть calcdp(x)calcdp(x) — сумма чисел от 11 до xx, состоящих из не более kk различных цифр и имеющих длину ровно |x||x|. Тогда calc(n)calc(n) выглядит довольно легко: для каждой длины ii от 11 до len−1len−1 добавим к ответу calcdp(10i−1)calcdp(10i−1). И последним шагом добавим к ответу calcdp(n)calcdp(n).Как считать динамические программирования? Изначально все состояния равны нулю (кроме dp0,0,1dp0,0,1, которое равно 11).Сначала давайте посчитаем dpdp. После того, как мы сделаем это, мы сможем посчитать dpsdps почти таким же образом. Переберем все возможные длины и все возможные маски. Пусть текущее состояние — это dppos,mask,0dppos,mask,0. Теперь переберем следующую цифру, которую мы хотим поставить в этом числе, и поставим ее. Если pos=0pos=0, то dig=1…9dig=1…9, иначе dig=0…9dig=0…9. Переход выглядит довольно просто: dppos+1,mask|2dig,0+=dppos,mask,0dppos+1,mask|2dig,0+=dppos,mask,0. Здесь || означает операцию побитового ИЛИ. Для f=1f=1 переходы почти такие же, за исключением ограничений на цифру, которую мы ставим, и состояния, которое мы обновляем. Если сейчас мы находимся на позиции pospos с маской maskmask и f=1f=1, то текущая цифра числа nn равна nposnpos. Тогда давайте переберем следующую цифру нашего числа: dig=1…nposdig=1…npos, если pos=0pos=0, иначе dig=0…nposdig=0…npos. Переход опять же довольно простой: dppos+1,mask|2dig,dig=npos+=dppos,mask,fdppos+1,mask|2dig,dig=npos+=dppos,mask,f.После подсчета предыдущего ДП мы можем посчитать dpsdps. Весь процесс вычисления совпадает с процессом вычисления предыдущего динамического программирования, кроме значения, добавляемого в переходах. В прошлом ДП это значение было равно dppos,mask,fdppos,mask,f, в текущем ДП это значение равно val=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,fval=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,f. Не забывайте считать его по модулю 998244353998244353!Итак, чему равен ответ для calcdp(n)calcdp(n) после вычислений всех значений ДП? Он равен ∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1 для всех масок с не более kk битами.Я уверен, что есть другой способ избежать проблем с лидирующими нулями при подсчете этих ДП, но этот показался мне очень простым в понимании и реализации. Решение (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\n\treturn 0;\n}1073F - Выбери два пути Разбор1073F - Выбери два путиДавайте назовем путь от uu до vv хорошим, если uu является листом, vv является вершиной степени хотя бы 33 (количество ее соседей не менее 33) и на этом пути нет других вершин степени хотя бы 33 кроме вершины vv.Первый шаг решения заключается в том, чтобы удалить все хорошие пути от uu до vv (но мы не должны удалять вершину vv) и запомнить для каждой вершины vv сумму двух максимальных длин хороших путей, которые заканчиваются в вершине vv. Для вершины vv назовем это значение valvvalv. Например, если для какой-то вершины vv существует 33 хороших пути, заканчивающихся в ней, длин 22, 33 и 55 соответственно, тогда valvvalv будет равно 5+3=85+3=8.Окей, легко заметить, что максимальное пересечение двух путей в ответе будет равно длине диаметра получившегося дерева. Но мы не можем брать любой диаметр этого дерева и называть его ответом из-за второго ограничения: нам необходимо найти какой-то диаметр от xx до yy, что сумма valx+valyvalx+valy является максимально возможной. Как мы можем сделать это?Есть один очень потрясающий (и известный) факт, что центр дерева принадлежит всем диаметрам этого дерева. Подвесим дерево за его центр (если длина диаметра нечетна (центром дерева является ребро), то подвесим дерево за любой конец этого ребра, это не важно).Существует один особый случай, когда длина диаметра равна 11, но обработать его достаточно легко.Теперь наша задача состоит в том, чтобы найти два соседа корня нового дерева таких, что в их поддеревьях находятся вершины, образующие какой-то диаметр этого дерева и сумма значений этих вершин максимально возможная. Давайте посчитаем вершину с максимальным расстоянием от корня (и с максимально возможным значением valvvalv при равных расстояниях) при помощи простого DFS для каждого соседа корня. Это можно сделать за O(n)O(n) и последняя часть решения заключается в том, чтобы найти два максимума этого списка, это можно сделать за O(n)O(n) или O(nlogn)O(nlog⁡n), зависит от реализации. Решение (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\n\tpt ans = calc(path[size(path) / 2]);\n\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\n\treturn 0;\n}1073G - Очередная задача на строки Разбор1073G - Очередная задача на строкиВо-первых, напишите свою любимую суффиксную структуру для того, чтобы уметь быстро сравнивать два суффикса лексикографически. Например, Суффиксный Массив + линейное LCP + Sparse Table. Теперь можно сравнивать два суффикса ii и jj, находя l=lcp(i,j)l=lcp(i,j) и сравнивая только s[i+l]s[i+l] с s[j+l]s[j+l].Будем обрабатывать запросы онлайн. Пусть текущий запрос характеризуется массивами aa (|a|=k|a|=k) и bb (|b|=l|b|=l). Будем считать ответ разделив его на две части: ∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).Для подсчета первой суммы можно отсортировать все c=a+bc=a+b суффиксов лексикографически и поддерживать некоторую информацию для префиксов массива cc. Что именно нужно знать? Необходимо поддерживать некоторую Структуру Данных, в которой будут хранится lcplcp суффиксов из aa. Когда обрабатываем ci=bjci=bj, то необходимо только узнать суммарную длину всех lcplcp из ДС. Если же ci=ajci=aj, то необходимо добавить в ДС длину ajaj-го суффикса. И при переходе от cici к ci+1ci+1 необходимо пересчитать некоторые lcplcp. Так как массив cc отсортирован, то все, что нужно сделать, это присвоить lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n]))lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n])).На самом деле, данная ДС — это просто mapmap. В данном mapmap мы будем поддерживать для для каждой длины ll количество суффиксов с lcp=llcp=l (конечно будем поддерживать только ненулевые значения). Когда необходимо добавить суффикс ajaj, то просто увеличиваем на 1 нужное значение. Операция minmin с некоторым v=lcp(s[ci…n],s[ci+1…n])v=lcp(s[ci…n],s[ci+1…n]) может быть сделана путем уменьшения максимума в mapmap пока он больше чем vv. Можно доказать, что всего будет порядка O(|a|+|b|)O(|a|+|b|) операций с mapmap для текущего запроса. Общую сумму же можно поддерживать в глобальной переменной, пересчитывая ее при каждом изменении mapmap.Для подсчета второй суммы достаточно реверснуть cc и запустить тот же самый алгоритм. Поэтому, результирующая асимптотика равна O(nlog2n+(∑i=1i=qki+∑i=1i=qli)logn)O(nlog2⁡n+(∑i=1i=qki+∑i=1i=qli)log⁡n). Решение (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\n\tif(read()) {\n\t\tsolve();\n\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62742",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1073\\s*B"
          },
          "content_length": 21758
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 1",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 2",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 5",
          "code": "O(n * logn)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 6",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 1",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 2",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 15",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 16",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 200000);\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a(n);\n    set<int> a_set;\n    a[0] = inf.readInt(1, n);\n    ensuref(a_set.count(a[0]) == 0, \"Duplicate value %d in a_i at position %d\", a[0], 1);\n    a_set.insert(a[0]);\n    for (int i = 1; i < n; i++) {\n        inf.readSpace();\n        a[i] = inf.readInt(1, n);\n        ensuref(a_set.count(a[i]) == 0, \"Duplicate value %d in a_i at position %d\", a[i], i + 1);\n        a_set.insert(a[i]);\n    }\n    inf.readEoln();\n\n    // Read b_i\n    vector<int> b(n);\n    set<int> b_set;\n    b[0] = inf.readInt(1, n);\n    ensuref(b_set.count(b[0]) == 0, \"Duplicate value %d in b_i at position %d\", b[0], 1);\n    b_set.insert(b[0]);\n    for (int i = 1; i < n; i++) {\n        inf.readSpace();\n        b[i] = inf.readInt(1, n);\n        ensuref(b_set.count(b[i]) == 0, \"Duplicate value %d in b_i at position %d\", b[i], i + 1);\n        b_set.insert(b[i]);\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 200000);\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a(n);\n    set<int> a_set;\n    a[0] = inf.readInt(1, n);\n    ensuref(a_set.count(a[0]) == 0, \"Duplicate value %d in a_i at position %d\", a[0], 1);\n    a_set.insert(a[0]);\n    for (int i = 1; i < n; i++) {\n        inf.readSpace();\n        a[i] = inf.readInt(1, n);\n        ensuref(a_set.count(a[i]) == 0, \"Duplicate value %d in a_i at position %d\", a[i], i + 1);\n        a_set.insert(a[i]);\n    }\n    inf.readEoln();\n\n    // Read b_i\n    vector<int> b(n);\n    set<int> b_set;\n    b[0] = inf.readInt(1, n);\n    ensuref(b_set.count(b[0]) == 0, \"Duplicate value %d in b_i at position %d\", b[0], 1);\n    b_set.insert(b[0]);\n    for (int i = 1; i < n; i++) {\n        inf.readSpace();\n        b[i] = inf.readInt(1, n);\n        ensuref(b_set.count(b[i]) == 0, \"Duplicate value %d in b_i at position %d\", b[i], i + 1);\n        b_set.insert(b[i]);\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 200000);\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a(n);\n    set<int> a_set;\n    a[0] = inf.readInt(1, n);\n    ensuref(a_set.count(a[0]) == 0, \"Duplicate value %d in a_i at position %d\", a[0], 1);\n    a_set.insert(a[0]);\n    for (int i = 1; i < n; i++) {\n        inf.readSpace();\n        a[i] = inf.readInt(1, n);\n        ensuref(a_set.count(a[i]) == 0, \"Duplicate value %d in a_i at position %d\", a[i], i + 1);\n        a_set.insert(a[i]);\n    }\n    inf.readEoln();\n\n    // Read b_i\n    vector<int> b(n);\n    set<int> b_set;\n    b[0] = inf.readInt(1, n);\n    ensuref(b_set.count(b[0]) == 0, \"Duplicate value %d in b_i at position %d\", b[0], 1);\n    b_set.insert(b[0]);\n    for (int i = 1; i < n; i++) {\n        inf.readSpace();\n        b[i] = inf.readInt(1, n);\n        ensuref(b_set.count(b[i]) == 0, \"Duplicate value %d in b_i at position %d\", b[i], i + 1);\n        b_set.insert(b[i]);\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n); // Stack of books\n    vector<int> b(n); // Order in which Vasya wants to move books\n\n    if (type == \"random\") {\n        // Random permutations of 1..n\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        for(int i = 0; i < n; ++i)\n            b[i] = i + 1;\n        shuffle(b.begin(), b.end());\n    } else if (type == \"sorted\") {\n        // a_i is sorted in increasing order\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        // b_i is random\n        for(int i = 0; i < n; ++i)\n            b[i] = i + 1;\n        shuffle(b.begin(), b.end());\n    } else if (type == \"reversed\") {\n        // a_i is sorted in decreasing order\n        for(int i = 0; i < n; ++i)\n            a[i] = n - i;\n        // b_i is random\n        for(int i = 0; i < n; ++i)\n            b[i] = i + 1;\n        shuffle(b.begin(), b.end());\n    } else if (type == \"same\") {\n        // a_i and b_i are the same\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        b = a;\n    } else if (type == \"reverse_order\") {\n        // a_i increasing, b_i decreasing\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        for(int i = 0; i < n; ++i)\n            b[i] = n - i;\n    } else if (type == \"all_in_first\") {\n        // All books are moved in the first step\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        // Set b_1 to the bottom book, which is a[n - 1]\n        b[0] = a[n - 1];\n        // Remaining books can be in any order\n        vector<int> remaining;\n        for(int i = 1; i <= n; ++i)\n            if(i != b[0])\n                remaining.push_back(i);\n        shuffle(remaining.begin(), remaining.end());\n        for(int i = 1; i < n; ++i)\n            b[i] = remaining[i - 1];\n    } else if (type == \"one_each_step\") {\n        // Vasya moves one book each time\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1; // Stack is in increasing order\n        // b_i is the same as a_i\n        b = a;\n    } else if (type == \"alternating\") {\n        // Create a_i in an alternating order\n        int left = 1, right = n;\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = left++;\n            else\n                a[i] = right--;\n        }\n        // b_i is random\n        for(int i = 0; i < n; ++i)\n            b[i] = i + 1;\n        shuffle(b.begin(), b.end());\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        for(int i = 0; i < n; ++i)\n            b[i] = i + 1;\n        shuffle(b.begin(), b.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a_1 to a_n\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    // Output b_1 to b_n\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n); // Stack of books\n    vector<int> b(n); // Order in which Vasya wants to move books\n\n    if (type == \"random\") {\n        // Random permutations of 1..n\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        for(int i = 0; i < n; ++i)\n            b[i] = i + 1;\n        shuffle(b.begin(), b.end());\n    } else if (type == \"sorted\") {\n        // a_i is sorted in increasing order\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        // b_i is random\n        for(int i = 0; i < n; ++i)\n            b[i] = i + 1;\n        shuffle(b.begin(), b.end());\n    } else if (type == \"reversed\") {\n        // a_i is sorted in decreasing order\n        for(int i = 0; i < n; ++i)\n            a[i] = n - i;\n        // b_i is random\n        for(int i = 0; i < n; ++i)\n            b[i] = i + 1;\n        shuffle(b.begin(), b.end());\n    } else if (type == \"same\") {\n        // a_i and b_i are the same\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        b = a;\n    } else if (type == \"reverse_order\") {\n        // a_i increasing, b_i decreasing\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        for(int i = 0; i < n; ++i)\n            b[i] = n - i;\n    } else if (type == \"all_in_first\") {\n        // All books are moved in the first step\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        // Set b_1 to the bottom book, which is a[n - 1]\n        b[0] = a[n - 1];\n        // Remaining books can be in any order\n        vector<int> remaining;\n        for(int i = 1; i <= n; ++i)\n            if(i != b[0])\n                remaining.push_back(i);\n        shuffle(remaining.begin(), remaining.end());\n        for(int i = 1; i < n; ++i)\n            b[i] = remaining[i - 1];\n    } else if (type == \"one_each_step\") {\n        // Vasya moves one book each time\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1; // Stack is in increasing order\n        // b_i is the same as a_i\n        b = a;\n    } else if (type == \"alternating\") {\n        // Create a_i in an alternating order\n        int left = 1, right = n;\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = left++;\n            else\n                a[i] = right--;\n        }\n        // b_i is random\n        for(int i = 0; i < n; ++i)\n            b[i] = i + 1;\n        shuffle(b.begin(), b.end());\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        for(int i = 0; i < n; ++i)\n            b[i] = i + 1;\n        shuffle(b.begin(), b.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a_1 to a_n\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    // Output b_1 to b_n\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 100000 -type random\n./gen -n 200000 -type random\n\n./gen -n 5 -type sorted\n./gen -n 200000 -type sorted\n\n./gen -n 10 -type reversed\n./gen -n 200000 -type reversed\n\n./gen -n 200000 -type reverse_order\n\n./gen -n 200000 -type same\n\n./gen -n 200000 -type all_in_first\n\n./gen -n 200000 -type one_each_step\n\n./gen -n 200000 -type alternating\n\n./gen -n 1 -type random\n./gen -n 1 -type sorted\n./gen -n 1 -type reversed\n\n./gen -n 199999 -type random\n\n./gen -n 2 -type same\n./gen -n 2 -type reverse_order\n\n./gen -n 1000 -type one_each_step\n./gen -n 1000 -type all_in_first\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:48.363082",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1073/C",
      "title": "C. Vasya and Robot",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer number n (1≤n≤2⋅105)n (1≤n≤2⋅105) — the number of operations.The second line contains the sequence of operations — a string of nn characters. Each character is either U, D, L or R.The third line contains two integers x,y (−109≤x,y≤109)x,y (−109≤x,y≤109) — the coordinates of the cell where the robot should end its path.",
      "output_spec": "OutputPrint one integer — the minimum possible length of subsegment that can be changed so the resulting sequence of operations moves the robot from (0,0)(0,0) to (x,y)(x,y). If this change is impossible, print −1−1.",
      "sample_tests": "ExamplesInputCopy5RURUU-2 3OutputCopy3InputCopy4RULR1 1OutputCopy0InputCopy3UUU100 100OutputCopy-1",
      "description": "C. Vasya and Robot\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one integer number n (1≤n≤2⋅105)n (1≤n≤2⋅105) — the number of operations.The second line contains the sequence of operations — a string of nn characters. Each character is either U, D, L or R.The third line contains two integers x,y (−109≤x,y≤109)x,y (−109≤x,y≤109) — the coordinates of the cell where the robot should end its path.\n\nOutputPrint one integer — the minimum possible length of subsegment that can be changed so the resulting sequence of operations moves the robot from (0,0)(0,0) to (x,y)(x,y). If this change is impossible, print −1−1.\n\nInputCopy5RURUU-2 3OutputCopy3InputCopy4RULR1 1OutputCopy0InputCopy3UUU100 100OutputCopy-1\n\nInputCopy5RURUU-2 3\n\nOutputCopy3\n\nInputCopy4RULR1 1\n\nOutputCopy0\n\nInputCopy3UUU100 100\n\nOutputCopy-1\n\nNoteIn the first example the sequence can be changed to LULUU. So the length of the changed subsegment is 3−1+1=33−1+1=3.In the second example the given sequence already leads the robot to (x,y)(x,y), so the length of the changed subsegment is 00.In the third example the robot can't end his path in the cell (x,y)(x,y).",
      "solutions": [
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces",
          "content": "On Thursday, October 25, 2018 at 22:35UTC+8 Educational Codeforces Round 53 (Rated for Div. 2) will start.Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. The penalty for each incorrect submission until the submission with a full solution is 10 minutes. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Roman Roms Glazov, Adilbek adedalic Dalabaev, Vladimir vovuh Petrov, Ivan BledDest Androsov and me.Good luck to all participants!Our friends at Harbour.Space also have a message for you:Hey Codeforces! We want to remind you that the Scholarship for the Master’s in Robotics programme, which starts on January 7th 2019, has an application deadline of November 12th, 2018.Harbour.Space University and Remy Robotics are collaborating to offer graduate students from anywhere in the world a once in a lifetime opportunity, a fully funded scholarship for Harbour.Space University’s Master’s Programme in Robotics. The scholarship value is €34.900 and it includes: Complete coverage of the University tuition fee (€22,900) Internship at Remy Robotics (20h per week during 1 year) €1,000 per month during 1 year (Internship earnings) Apply hereUPD: vovuh and me will be waiting for you on the community Discord server shortly after the contest to discuss the problems.Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 pekempey 7 305 2 ko_osaga 7 578 3 Lewin 6 216 4 fanache99 6 226 5 natsugiri 6 257 Congratulations to the best hackers: Rank Competitor Hack Count 1 halyavin 238:-15 2 Laggy 64:-14 3 MarcosK 59:-9 4 Mistra 8:-1 5 LordVoldebug 7:-1 482 successful hacks and 684 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A Dalgerok 0:01 B dorijanlendvaj 0:02 C fanache99 0:10 D bazsi700 0:13 E DAyamaCTF 0:21 F Noam527 0:48 G ko_osaga 0:24 UPD2: Editorial is published",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62683",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2335
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces",
          "content": "1073A - Diverse Substring Tutorial1073A - Diverse SubstringNotice that the string of two distinct letter is already diverse. That implies that the answer is \"NO\" if and only if all the letters in the string are the same. Otherwise you can check all pairs of adjacent letters in O(n)O(n).Overall complexity: O(n)O(n). Solution (PikMike)n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")1073B - Vasya and Books Tutorial1073B - Vasya and BooksLet's maintain the pointer pospos to the topmost non-deleted book and whether each book whether is removed from the stack or not. Initially, all books are in a stack, and pospos is 0 (if we store the array 0-indexed). We will process the array BB in the order b1,b2,…bnb1,b2,…bn. If the current book bibi is removed from the stack, then the answer for it is zero. Otherwise, we will increment the pointer pospos until the equality apos=biapos=bi is satisfied, while marking all the intermediate books in the array uu. After that, the answer for the book bibi will be the number of marked books in the uu array (including itself).Since the pointer pospos shifts nn times at total, we get a solution with an O(n)O(n) complexity. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n for(int i = 0; i < n; ++i) {\n \tscanf(\"%d\", a + i);\n }\n for(int i = 0; i < n; ++i){\n \tscanf(\"%d\", b + i);\n }\n\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t} \n\n\tputs(\"\");\n return 0;\n}1073C - Vasya and Robot Tutorial1073C - Vasya and RobotDenote d=|x|+|y​|d=|x|+|y​|. If d>nd>n, then the answer is -1, since the robot will not have the time to reach (x,y)(x,y) cell in nn steps. Also, if dd and nn have different parity, then the answer is also -1, as in one move the robot changes the parity of the sum of its coordinates.In all other cases, the answer exists. Let's use binary search to solve this problem. Consider all segments of length lenlen. For a fixed length of the segment lenlen, let's iterate over the position of the beginning of the segment ll. At the same time, we will maintain the cell that the robot will stop at if it execute all commands, except commands with indices l,l+1,…,l+len−1l,l+1,…,l+len−1. We denote this position as (x0,y0)(x0,y0). We also calculate the distances from the cell (x0,y0)(x0,y0) to the cell (x,y)(x,y) — the value d0=|x−x0|+|y​​−y0|d0=|x−x0|+|y​​−y0|. If there is at least one position of the beginning of the segment for which d0≤lend0≤len, then we can change the segment of length lenlen so that the robot comes to the (x,y)(x,y) cell, otherwise it can't. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tcout << r << endl;\n return 0;\n}1073D - Berland Fair Tutorial1073D - Berland FairLet's code the following process. Go one circle across the booths, calculate the total cost CC of sweets bought and the number SS of sweets bought. Now you can decrease you money down to T=T mod CT=T mod C and add S⋅(T div C)S⋅(T div C) to answer. It represents that you went maximum number of such circles. The later circles will have smaller cost. Let's continue this process until TT becomes smaller than the minimum priced sweet.The number of operations made is O(logT)O(log⁡T). Let TcurTcur be the amount of money before some operation, CcurCcur be the total cost of sweets bought on that operation and Tnew=Tcur mod CcurTnew=Tcur mod Ccur. TnewTnew is actually smaller than CcurCcur (that's how modulo works) and smaller than Tcur−CcurTcur−Ccur (that's also how modulo works). And these inequalities imply that Tnew<Tcur2Tnew<Tcur2. That leads to about O(logT)O(log⁡T) steps to reach the minimal price.Overall complexity: O(nlogT)O(nlog⁡T). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}1073E - Segment Sum Tutorial1073E - Segment SumLet's calculate the answer as the sum of suitable numbers in range [1;r][1;r] minus the sum of suitable numbers in range [1;l−1][1;l−1]. Now our problem is to calculate the sum of suitable numbers in range [1;n][1;n].The main approach for this problem is digit DP. Let's calculate two dynamic programmings dppos,mask,fdppos,mask,f and dpspos,mask,fdpspos,mask,f. pospos means that now we are at the pospos-th digit of the number nn (at the digit corresponding to 10len−pos−110len−pos−1, where lenlen is the decimal length of a number), maskmask is a binary mask describing digits we already use and ff equals 11 if the current prefix of number we trying to obtain is the same as the prefix of number nn (otherwise ff equals 00).So what means dppos,mask,fdppos,mask,f? It means the count of numbers (in general, not numbers but their prefixes) in range [1;n][1;n] of length exactly |n||n| without leading zeroes corresponding to this state. So what the point of this DP? Its point is helping us to calculate the main DP, dpspos,mask,fdpspos,mask,f, which means the sum of numbers (in general, not numbers but their prefixes) in range [1;n][1;n] of length exactly |n||n| without leading zeroes corresponding to this state.How do we calculate the answer? Firstly, let lenlen be the length of nn. Let calc(n)calc(n) be the function calculating the sum of numbers from 11 to nn containing at most kk different digits. How to calculate it? Let calcdp(x)calcdp(x) be the sum of numbers from 11 to xx containing at most kk different digits and having length exactly |x||x|. Then calc(n)calc(n) seems to be pretty easy: for each length ii from 11 to len−1len−1 add to the answer calcdp(10i−1)calcdp(10i−1). And the last step is to add to the answer calcdp(n)calcdp(n).How to calculate dynamic programmings? Initially, all states are zeroes (excluding dp0,0,1dp0,0,1, which is 11).Firstly, let's calculate dpdp. After calculating it we can calculate dpsdps in almost the same way. Let's iterate over all possible lengths and over all possible masks. Let the current state is dppos,mask,0dppos,mask,0. Then let's iterate over next digit we will place in this number and place it. If pos=0pos=0 then dig=1…9dig=1…9 otherwise dig=0…9dig=0…9. The transition is pretty easy: dppos+1,mask|2dig,0+=dppos,mask,0dppos+1,mask|2dig,0+=dppos,mask,0. There || is the bitwise OR operation. For f=1f=1 transitions are almost the same expect the restrictions on digit we place and the state we update. If we now at the position pospos with mask maskmask and f=1f=1 then the current digit of nn is nposnpos. Then let's iterate over next digit: dig=1…nposdig=1…npos if pos=0pos=0 otherwise dig=0…nposdig=0…npos. The transition is also easy: dppos+1,mask|2dig,dig=npos+=dppos,mask,fdppos+1,mask|2dig,dig=npos+=dppos,mask,f.After calculating the previous DP we can calculate dpsdps. All the process is the same as in the previous dynamic programming expect the value we will add in transitions. In the previous DP this value was equal dppos,mask,fdppos,mask,f, in the current DP this value equals to val=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,fval=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,f. Don't forget to calculate it modulo 998244353998244353!So after calculating all the values of DPs, what is the answer for calcdp(n)calcdp(n)? It is ∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1 for all masks with at most kk bits.I'm pretty sure that there is another way to avoid leading zeroes in calculating these DPs but this one is very straight-forward and simple. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\n\treturn 0;\n}1073F - Choosing Two Paths Tutorial1073F - Choosing Two PathsFirstly, let's call a path from uu to vv good, if uu is a leaf, vv is a vertex of degree at least 33 (the number of their neighbors is at least 33) and there are no other vertices of degree at least 33 on this path expect the vertex vv.The first step of the solution is to remove all the good paths from uu to vv (but we should not remove the vertex vv) and remember for each vertex vv the sum of two maximum lengths of good paths which end in the vertex vv. Let this value for the vertex vv be valvvalv. For example, if for some vertex vv there are 33 good paths with end in it of lengths 22, 33 and 55 correspondingly, then valvvalv will be 5+3=85+3=8.Okay, it is easy to see that the maximum intersection of two paths in the answer will be equal to the length of the diameter of the obtained tree. But we can not take any diameter of this tree and call it the answer because of the second constraint: we need to find some diameter from xx to yy such that the sum valx+valyvalx+valy is maximum possible. How do we do that?There is such an awesome (and well-known) fact that the center of a tree belongs to all diameters of this tree. Let's root the tree by the center of a tree (if the length of the diameter is odd (the center of a tree is an edge) then let's root the tree by any end of this edge, it does not matter).There is one case when the length of the diameter is 11 but it is pretty trivial to handle it.Now our problem is to find two neighbors of the root of the new tree such that in their subtrees are vertices which form some diameter of this tree and the sum of values of these vertices is maximum possible. Let's calculate the vertex with the maximum distance from a root (and with the maximum possible valvvalv for equals distances) by simple DFS for each neighbor of a root. It can be done in O(n)O(n) and the last part is to find two maximums of this list, it also can be done in O(n)O(n) or O(nlogn)O(nlog⁡n), depends on implementation. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\n\tpt ans = calc(path[size(path) / 2]);\n\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\n\treturn 0;\n}1073G - Yet Another LCP Problem Tutorial1073G - Yet Another LCP ProblemAt first, implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough. For example, it's a Suffix Array + linear LCP + Sparse Table. Now we can compare two suffixes ii and jj by finding l=lcp(i,j)l=lcp(i,j) and comparing s[i+l]s[i+l] with s[j+l]s[j+l].We will process queries online. Let current query be a pair of arrays aa (|a|=k|a|=k) and bb (|b|=l|b|=l). We will calculate answer in two parts: ∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).To calculate the first sum we can sort all c=a+bc=a+b suffixes in lexicographical order and maintain some information for prefixes of cc. What information we need to maintain? We need some Data Structure which will hold lcplcp of suffixes from aa. When we process some ci=bjci=bj we need just a total sum of all lcplcp in the DS. If ci=ajci=aj, we should add to the DS length of ajaj-th suffix. And when we move from cici to ci+1ci+1 we must recalculate some lcplcp. Since cc is sorted, all we need is to set lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n]))lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n])).In fact, this Data Structure is just a mapmap. In this mapmap we will hold for each length ll number of suffixes with lcp=llcp=l (we will hold only non-zero values). When we should add some suffix ajaj, we manually increase some value by one. Setting minmin with v=lcp(s[ci…n],s[ci+1…n])v=lcp(s[ci…n],s[ci+1…n]) can be done with decreasing maximum in mapmap while its more than vv. It can be proven, that there will be O(|a|+|b|)O(|a|+|b|) operations with mapmap for one query. The total sum can be maintained in some global variable, which will be recalculated each time mapmap changes.To calculate the second sum we can just reverse cc and run the same algorithm. So total complexity is O(nlog2n+(∑i=1i=qki+∑i=1i=qli)logn)O(nlog2⁡n+(∑i=1i=qki+∑i=1i=qli)log⁡n). Solution (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\n\tif(read()) {\n\t\tsolve();\n\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62742",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1073\\s*C"
          },
          "content_length": 21562
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 5",
          "code": "O(n * logn)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 6",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 1",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 2",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 15",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 16",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"The length of s must be n, but it is %d instead of %d\", int(s.length()), n);\n\n    for (char c : s) {\n        ensuref(c == 'U' || c == 'D' || c == 'L' || c == 'R', \"Invalid character in s: '%c'\", c);\n    }\n\n    int x = inf.readInt(-1000000000, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000000000, 1000000000, \"y\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"The length of s must be n, but it is %d instead of %d\", int(s.length()), n);\n\n    for (char c : s) {\n        ensuref(c == 'U' || c == 'D' || c == 'L' || c == 'R', \"Invalid character in s: '%c'\", c);\n    }\n\n    int x = inf.readInt(-1000000000, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000000000, 1000000000, \"y\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"The length of s must be n, but it is %d instead of %d\", int(s.length()), n);\n\n    for (char c : s) {\n        ensuref(c == 'U' || c == 'D' || c == 'L' || c == 'R', \"Invalid character in s: '%c'\", c);\n    }\n\n    int x = inf.readInt(-1000000000, 1000000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000000000, 1000000000, \"y\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int x = opt<int>(\"x\", INT_MAX);\n    int y = opt<int>(\"y\", INT_MAX);\n\n    if (type == \"random\") {\n        // Generate a random sequence of length n\n        string s;\n        string ops = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += ops[rnd.next(4)];\n        }\n        // Generate random x and y if not provided\n        if (x == INT_MAX) x = rnd.next(-1000000000, 1000000000);\n        if (y == INT_MAX) y = rnd.next(-1000000000, 1000000000);\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"impossible\") {\n        // Generate a target that is impossible to reach\n        int max_movement = n;\n        int delta = rnd.next(max_movement + 1, max_movement + 1000);\n        // Randomly decide x and y\n        int dx = rnd.next(-delta, delta);\n        int dy = delta - abs(dx);\n        if (rnd.next(2)) dy = -dy;\n        x = dx;\n        y = dy;\n        // Generate random sequence\n        string s;\n        string ops = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += ops[rnd.next(4)];\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"zero\") {\n        // Generate a sequence that already reaches (x, y)\n        if (x == INT_MAX) x = rnd.next(-1000000000, 1000000000);\n        if (y == INT_MAX) y = rnd.next(-1000000000, 1000000000);\n        // Generate s that moves from (0,0) to (x,y)\n        string s;\n        if (x > 0) s += string(x, 'R');\n        else s += string(-x, 'L');\n        if (y > 0) s += string(y, 'U');\n        else s += string(-y, 'D');\n        // Fill the rest with random operations\n        while ((int)s.size() < n) {\n            s += \"LRUD\"[rnd.next(4)];\n        }\n        // Shuffle s\n        shuffle(s.begin(), s.end());\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"edge_n1\") {\n        // Edge case where n = 1\n        n = 1;\n        string s;\n        s += \"LRUD\"[rnd.next(4)];\n        if (x == INT_MAX) x = rnd.next(-1, 1);\n        if (y == INT_MAX) y = rnd.next(-1, 1);\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"minimal_change_n\") {\n        // Need to change the entire sequence to reach (x, y)\n        if (x == INT_MAX) x = rnd.next(-1000000000, 1000000000);\n        if (y == INT_MAX) y = rnd.next(-1000000000, 1000000000);\n        // Generate a sequence that does not help in getting to (x, y)\n        string s(n, 'U'); // All 'U's\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"random_fixed_target\") {\n        // Random sequence with fixed target x and y\n        if (x == INT_MAX) x = rnd.next(-1000000000, 1000000000);\n        if (y == INT_MAX) y = rnd.next(-1000000000, 1000000000);\n        string s;\n        string ops = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += ops[rnd.next(4)];\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else {\n        // Default to random\n        string s;\n        string ops = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += ops[rnd.next(4)];\n        }\n        if (x == INT_MAX) x = rnd.next(-1000000000, 1000000000);\n        if (y == INT_MAX) y = rnd.next(-1000000000, 1000000000);\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int x = opt<int>(\"x\", INT_MAX);\n    int y = opt<int>(\"y\", INT_MAX);\n\n    if (type == \"random\") {\n        // Generate a random sequence of length n\n        string s;\n        string ops = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += ops[rnd.next(4)];\n        }\n        // Generate random x and y if not provided\n        if (x == INT_MAX) x = rnd.next(-1000000000, 1000000000);\n        if (y == INT_MAX) y = rnd.next(-1000000000, 1000000000);\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"impossible\") {\n        // Generate a target that is impossible to reach\n        int max_movement = n;\n        int delta = rnd.next(max_movement + 1, max_movement + 1000);\n        // Randomly decide x and y\n        int dx = rnd.next(-delta, delta);\n        int dy = delta - abs(dx);\n        if (rnd.next(2)) dy = -dy;\n        x = dx;\n        y = dy;\n        // Generate random sequence\n        string s;\n        string ops = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += ops[rnd.next(4)];\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"zero\") {\n        // Generate a sequence that already reaches (x, y)\n        if (x == INT_MAX) x = rnd.next(-1000000000, 1000000000);\n        if (y == INT_MAX) y = rnd.next(-1000000000, 1000000000);\n        // Generate s that moves from (0,0) to (x,y)\n        string s;\n        if (x > 0) s += string(x, 'R');\n        else s += string(-x, 'L');\n        if (y > 0) s += string(y, 'U');\n        else s += string(-y, 'D');\n        // Fill the rest with random operations\n        while ((int)s.size() < n) {\n            s += \"LRUD\"[rnd.next(4)];\n        }\n        // Shuffle s\n        shuffle(s.begin(), s.end());\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"edge_n1\") {\n        // Edge case where n = 1\n        n = 1;\n        string s;\n        s += \"LRUD\"[rnd.next(4)];\n        if (x == INT_MAX) x = rnd.next(-1, 1);\n        if (y == INT_MAX) y = rnd.next(-1, 1);\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"minimal_change_n\") {\n        // Need to change the entire sequence to reach (x, y)\n        if (x == INT_MAX) x = rnd.next(-1000000000, 1000000000);\n        if (y == INT_MAX) y = rnd.next(-1000000000, 1000000000);\n        // Generate a sequence that does not help in getting to (x, y)\n        string s(n, 'U'); // All 'U's\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"random_fixed_target\") {\n        // Random sequence with fixed target x and y\n        if (x == INT_MAX) x = rnd.next(-1000000000, 1000000000);\n        if (y == INT_MAX) y = rnd.next(-1000000000, 1000000000);\n        string s;\n        string ops = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += ops[rnd.next(4)];\n        }\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    } else {\n        // Default to random\n        string s;\n        string ops = \"UDLR\";\n        for (int i = 0; i < n; ++i) {\n            s += ops[rnd.next(4)];\n        }\n        if (x == INT_MAX) x = rnd.next(-1000000000, 1000000000);\n        if (y == INT_MAX) y = rnd.next(-1000000000, 1000000000);\n        // Output\n        printf(\"%d\\n\", n);\n        printf(\"%s\\n\", s.c_str());\n        printf(\"%d %d\\n\", x, y);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random\n./gen -n 1 -type edge_n1\n./gen -n 200000 -type random\n./gen -n 200000 -type random_fixed_target -x 1000000000 -y -1000000000\n./gen -n 200000 -type impossible\n./gen -n 10 -type impossible\n./gen -n 100 -type zero -x 0 -y 0\n./gen -n 1000 -type zero -x -500 -y 500\n./gen -n 10000 -type zero -x 10000 -y -10000\n./gen -n 200000 -type minimal_change_n -x 1000000000 -y 1000000000\n./gen -n 100000 -type minimal_change_n -x -1000000000 -y -1000000000\n./gen -n 200000 -type random\n./gen -n 200000 -type random\n./gen -n 200000 -type random\n./gen -n 200000 -type random_fixed_target -x 0 -y 0\n./gen -n 7 -type random\n./gen -n 3 -type random\n./gen -n 2 -type edge_n1 -x 1 -y 0\n./gen -n 200000 -type random_fixed_target -x -999999999 -y 999999999\n./gen -n 200000 -type impossible -x 2000000000 -y 0\n./gen -n 200000 -type impossible -x 0 -y 2000000000\n./gen -n 50 -type zero -x 25 -y 25\n./gen -n 100000 -type zero -x -50000 -y 50000\n./gen -n 200000 -type impossible -x 0 -y 300000000\n./gen -n 1 -type edge_n1 -x 0 -y 0\n./gen -n 200000 -type minimal_change_n -x 0 -y 0\n./gen -n 200000 -type minimal_change_n -x 999999999 -y -999999999\n./gen -n 200000 -type random_fixed_target -x 123456789 -y -987654321\n./gen -n 200000 -type random\n./gen -n 200000 -type random\n./gen -n 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:50.258342",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1073/D",
      "title": "D. Берляндская ярмарка",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа nn и TT (1≤n≤2⋅1051≤n≤2⋅105, 1≤T≤10181≤T≤1018) — количество киосков на ярмарке и начальное количество бурлей у Поликарпа.Во второй строке записаны nn целых чисел a1,a2,…,ana1,a2,…,an (1≤ai≤1091≤ai≤109) — цена одной конфеты в киоске номер ii.",
      "output_spec": "Выходные данныеВыведите одно целое число — итоговое количество конфет, которые купит Поликарп.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 385 2 5Выходные данныеСкопировать10Входные данныеСкопировать5 212 4 100 2 6Выходные данныеСкопировать6",
      "description": "D. Берляндская ярмарка\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записаны два целых числа nn и TT (1≤n≤2⋅1051≤n≤2⋅105, 1≤T≤10181≤T≤1018) — количество киосков на ярмарке и начальное количество бурлей у Поликарпа.Во второй строке записаны nn целых чисел a1,a2,…,ana1,a2,…,an (1≤ai≤1091≤ai≤109) — цена одной конфеты в киоске номер ii.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — итоговое количество конфет, которые купит Поликарп.\n\nВыходные данные\n\nВходные данныеСкопировать3 385 2 5Выходные данныеСкопировать10Входные данныеСкопировать5 212 4 100 2 6Выходные данныеСкопировать6\n\nВходные данныеСкопировать3 385 2 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 212 4 100 2 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый пример. Какие ходы делал Поликарп, пока у него не закончились деньги:  Киоск 11, покупает конфету за 55, T=33T=33;  Киоск 22, покупает конфету за 22, T=31T=31;  Киоск 33, покупает конфету за 55, T=26T=26;  Киоск 11, покупает конфету за 55, T=21T=21;  Киоск 22, покупает конфету за 22, T=19T=19;  Киоск 33, покупает конфету за 55, T=14T=14;  Киоск 11, покупает конфету за 55, T=9T=9;  Киоск 22, покупает конфету за 22, T=7T=7;  Киоск 33, покупает конфету за 55, T=2T=2;  Киоск 11, не покупает конфету, недостаточно денег;  Киоск 22, покупает конфету за 22, T=0T=0. Больше нельзя купить конфет. Итоговое число купленных конфет — 1010.Во втором примере у него остается 11 бурль после посещения киосков, нельзя купить ни одну конфету за столько.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces",
          "content": "Привет, Codeforces!В четверг, 25 октября 2018 г. в 22:35UTC+8 состоится Educational Codeforces Round 53 (рейтинговый для Див. 2).Продолжается серия образовательных раундов в рамках инициативы Harbour.Space University! Подробности о сотрудничестве Harbour.Space University и Codeforces можно прочитать в посте.Этот раунд будет рейтинговым для участников с рейтингом менее 2100. Соревнование будет проводиться по немного расширенным правилам ACM ICPC. Штраф за каждую неверную посылку до посылки, являющейся полным решением, равен 10 минутам. После окончания раунда будет период времени длительностью в 12 часов, в течение которого вы можете попробовать взломать абсолютно любое решение (в том числе свое). Причем исходный код будет предоставлен не только для чтения, но и для копирования.Вам будет предложено 7 задач на 2 часа. Мы надеемся, что вам они покажутся интересными.Задачи вместе со мной придумывали и готовили Роман Roms Глазов, Адилбек adedalic Далабаев, Владимир vovuh Петров и Иван BledDest Андросов.Удачи в раунде! Успешных решений!А вот сообщение от наших друзей из Harbour.Space:Hey Codeforces! We want to remind you that the Scholarship for the Master’s in Robotics programme, which starts on January 7th 2019, has an application deadline of November 12th, 2018.Harbour.Space University and Remy Robotics are collaborating to offer graduate students from anywhere in the world a once in a lifetime opportunity, a fully funded scholarship for Harbour.Space University’s Master’s Programme in Robotics. The scholarship value is €34.900 and it includes: Complete coverage of the University tuition fee (€22,900) Internship at Remy Robotics (20h per week during 1 year) €1,000 per month during 1 year (Internship earnings) Apply hereUPD: Мы с vovuh будем ждать всех желающих в местном Discord сервере сразу после контеста для обсуждения задач.Поздравляем победителей: Место Участник Задач решено Штраф 1 pekempey 7 305 2 ko_osaga 7 578 3 Lewin 6 216 4 fanache99 6 226 5 natsugiri 6 257 Поздравляем лучших взломщиков: Место Участник Число взломов 1 halyavin 238:-15 2 Laggy 64:-14 3 MarcosK 59:-9 4 Mistra 8:-1 5 LordVoldebug 7:-1 Было сделано 482 успешных и 684 неудачных взломов.И, наконец, поздравляем людей, отправивших первое полное решение по задаче: Задача Участник Штраф A Dalgerok 0:01 B dorijanlendvaj 0:02 C fanache99 0:10 D bazsi700 0:13 E DAyamaCTF 0:21 F Noam527 0:48 G ko_osaga 0:24 UPD2: Разбор опубликован",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62683",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2433
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces",
          "content": "1073A - Разнообразная подстрока Разбор1073A - Разнообразная подстрокаЗаметим, что строка, состоящая из двух различных букв, уже разнообразная. Из этого следует, что ответ «NO» происходит тогда и только тогда, когда все буквы в строке одинаковые. Иначе можно проверить все пары соседних букв за O(n)O(n).Асимптотика решения: O(n)O(n). Решение (PikMike)n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")1073B - Вася и книги Разбор1073B - Вася и книгиДля решения задачи в масcиве uu будем поддерживать для каждой книги, удалена ли она из стопки, и указатель pospos на самую верхнюю не удаленную книгу. Изначально все книги есть в стопке, а pospos равен 0 (если мы храним массив в 0-индексации). Теперь рассмотрим массив BB в порядке b1,b2,…bnb1,b2,…bn. Если текущая книга bibi удалена из стопки, то ответ для неё равен нулю. Иначе будем увеличивать указатель pospos, пока не будет выполняться равенство apos=biapos=bi, при этом помечая все промежуточные книги в массиве uu. После этого, ответом для книги bibi будет количество помеченных книг в массиве uu (включая её саму).Так как указатель pospos сдвинется максимум nn раз, мы получаем решение с асимптотикой O(n)O(n). Решение (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n for(int i = 0; i < n; ++i) {\n \tscanf(\"%d\", a + i);\n }\n for(int i = 0; i < n; ++i){\n \tscanf(\"%d\", b + i);\n }\n\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t} \n\n\tputs(\"\");\n return 0;\n}1073C - Вася и робот Разбор1073C - Вася и роботОбозначим d=|x|+|y|d=|x|+|y|. Если d>nd>n, то ответ равен -1, так как робот не успеет за nn шагов дойти до клетки (x,y)(x,y). Также, если dd и nn имеют разную четность, то ответ тоже равен -1, так за один ход робот меняет четность суммы своих координат.Во всех остальных случаях ответ существует. Давайте перебирать его бинарным поиском. Пусть сейчас мы рассматриваем отрезок длины lenlen. Для зафиксированной длины отрезка lenlen переберем позицию начала отрезка ll. При этом будем поддерживать клетку робота, исполнившего все команды, кроме команд с индексами l,l+1,…,l+len−1l,l+1,…,l+len−1. Обозначим эту позицию как (x0,y0)(x0,y0). Так же вычислим расстояния от клетки (x0,y0)(x0,y0) до клетки (x,y)(x,y) — значение d0=|x−x0|+|y−y0|d0=|x−x0|+|y−y0|. Если найдется хотя бы одна позиция начала отрезка, для которой выполняется d0≤lend0≤len, то мы можем изменить отрезок длины lenlen так, чтобы робот пришел в клетку (x,y)(x,y), а иначе — не можем. Решение (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tcout << r << endl;\n return 0;\n}1073D - Берляндская ярмарка Разбор1073D - Берляндская ярмаркаПросимулируем следующий процесс. Пройдем один круг по киоскам, посчитаем суммарную стоимость CC купленных конфет и количество SS купленных конфет. Теперь уменьшаем деньги к T=T mod CT=T mod C и добавляем S⋅(T div C)S⋅(T div C) к ответу. Это соответствует проходу по максимальному количеству таких кругов. Следующие круги будут иметь меньшую стоимость. Продолжим процесс, пока TT не станет меньше, чем цена минимальной конфеты.Количество проведенных операций равно O(logT)O(log⁡T). Пусть TcurTcur будет количеством денег до начала какой-либо операции. CcurCcur — суммарной стоимостью купленных на этой операции конфет и Tnew=Tcur mod CcurTnew=Tcur mod Ccur. TnewTnew, на самом деле, меньше, чем CcurCcur (потому что так работает взятие по модулю) и меньше, чем Tcur−CcurTcur−Ccur (по той же причине). И эти неравенства позволяют получить, что Tnew<Tcur2Tnew<Tcur2. Из этого следует оценка в O(logT)O(log⁡T) шагов для достижения минимальной цены.Асимптотика решения: O(nlogT)O(nlog⁡T). Решение (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}1073E - Сумма на отрезке Разбор1073E - Сумма на отрезкеДавайте будем считать ответ как сумму подходящих чисел в отрезке [1;r][1;r] минус сумма подходящих чисел в отрезке [1;l−1][1;l−1]. Теперь наша задача — научиться считать сумму подходящих чисел в отрезке [1;n][1;n].Главным подходом для этой задачи является ДП по цифрам. Давайте будем считать два динамических программирования dppos,mask,fdppos,mask,f и dpspos,mask,fdpspos,mask,f. pospos означает, что сейчас мы находимся на pospos-й цифре числа nn (на цифре, соответствующей 10len−pos−110len−pos−1, где lenlen — десятичная длина числа), maskmask — двоичная маска, означающая цифры, которые мы уже использовали и ff равняется 11, если текущий префикс числа, которое мы пытаемся получить, совпадает с префиксом числа nn (иначе ff равно 00).Итак, что значит dppos,mask,fdppos,mask,f? Оно равно количеству чисел (в общем случае не чисел, а их префиксов) в отрезке [1;n][1;n] длины ровно |n||n| без лидирующих нулей таких, которые соответствуют этому состоянию. Итак, какой смысл в этом ДП? Его смысл в том, чтобы помочь нам посчитать главное ДП, dpspos,mask,fdpspos,mask,f, которое равно сумме чисел (в общем случае не чисел, а их префиксов) в отрезке [1;n][1;n] длины ровно |n||n| без лидирующих нулей таких, которые соответствуют этому состоянию.Как нам посчитать ответ? Сначала, пусть lenlen равно длине nn. Пусть calc(n)calc(n) — это функция, считающая сумму чисел от 11 до nn, состоящих из не более kk различных цифр. Как ее посчитать? Пусть calcdp(x)calcdp(x) — сумма чисел от 11 до xx, состоящих из не более kk различных цифр и имеющих длину ровно |x||x|. Тогда calc(n)calc(n) выглядит довольно легко: для каждой длины ii от 11 до len−1len−1 добавим к ответу calcdp(10i−1)calcdp(10i−1). И последним шагом добавим к ответу calcdp(n)calcdp(n).Как считать динамические программирования? Изначально все состояния равны нулю (кроме dp0,0,1dp0,0,1, которое равно 11).Сначала давайте посчитаем dpdp. После того, как мы сделаем это, мы сможем посчитать dpsdps почти таким же образом. Переберем все возможные длины и все возможные маски. Пусть текущее состояние — это dppos,mask,0dppos,mask,0. Теперь переберем следующую цифру, которую мы хотим поставить в этом числе, и поставим ее. Если pos=0pos=0, то dig=1…9dig=1…9, иначе dig=0…9dig=0…9. Переход выглядит довольно просто: dppos+1,mask|2dig,0+=dppos,mask,0dppos+1,mask|2dig,0+=dppos,mask,0. Здесь || означает операцию побитового ИЛИ. Для f=1f=1 переходы почти такие же, за исключением ограничений на цифру, которую мы ставим, и состояния, которое мы обновляем. Если сейчас мы находимся на позиции pospos с маской maskmask и f=1f=1, то текущая цифра числа nn равна nposnpos. Тогда давайте переберем следующую цифру нашего числа: dig=1…nposdig=1…npos, если pos=0pos=0, иначе dig=0…nposdig=0…npos. Переход опять же довольно простой: dppos+1,mask|2dig,dig=npos+=dppos,mask,fdppos+1,mask|2dig,dig=npos+=dppos,mask,f.После подсчета предыдущего ДП мы можем посчитать dpsdps. Весь процесс вычисления совпадает с процессом вычисления предыдущего динамического программирования, кроме значения, добавляемого в переходах. В прошлом ДП это значение было равно dppos,mask,fdppos,mask,f, в текущем ДП это значение равно val=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,fval=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,f. Не забывайте считать его по модулю 998244353998244353!Итак, чему равен ответ для calcdp(n)calcdp(n) после вычислений всех значений ДП? Он равен ∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1 для всех масок с не более kk битами.Я уверен, что есть другой способ избежать проблем с лидирующими нулями при подсчете этих ДП, но этот показался мне очень простым в понимании и реализации. Решение (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\n\treturn 0;\n}1073F - Выбери два пути Разбор1073F - Выбери два путиДавайте назовем путь от uu до vv хорошим, если uu является листом, vv является вершиной степени хотя бы 33 (количество ее соседей не менее 33) и на этом пути нет других вершин степени хотя бы 33 кроме вершины vv.Первый шаг решения заключается в том, чтобы удалить все хорошие пути от uu до vv (но мы не должны удалять вершину vv) и запомнить для каждой вершины vv сумму двух максимальных длин хороших путей, которые заканчиваются в вершине vv. Для вершины vv назовем это значение valvvalv. Например, если для какой-то вершины vv существует 33 хороших пути, заканчивающихся в ней, длин 22, 33 и 55 соответственно, тогда valvvalv будет равно 5+3=85+3=8.Окей, легко заметить, что максимальное пересечение двух путей в ответе будет равно длине диаметра получившегося дерева. Но мы не можем брать любой диаметр этого дерева и называть его ответом из-за второго ограничения: нам необходимо найти какой-то диаметр от xx до yy, что сумма valx+valyvalx+valy является максимально возможной. Как мы можем сделать это?Есть один очень потрясающий (и известный) факт, что центр дерева принадлежит всем диаметрам этого дерева. Подвесим дерево за его центр (если длина диаметра нечетна (центром дерева является ребро), то подвесим дерево за любой конец этого ребра, это не важно).Существует один особый случай, когда длина диаметра равна 11, но обработать его достаточно легко.Теперь наша задача состоит в том, чтобы найти два соседа корня нового дерева таких, что в их поддеревьях находятся вершины, образующие какой-то диаметр этого дерева и сумма значений этих вершин максимально возможная. Давайте посчитаем вершину с максимальным расстоянием от корня (и с максимально возможным значением valvvalv при равных расстояниях) при помощи простого DFS для каждого соседа корня. Это можно сделать за O(n)O(n) и последняя часть решения заключается в том, чтобы найти два максимума этого списка, это можно сделать за O(n)O(n) или O(nlogn)O(nlog⁡n), зависит от реализации. Решение (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\n\tpt ans = calc(path[size(path) / 2]);\n\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\n\treturn 0;\n}1073G - Очередная задача на строки Разбор1073G - Очередная задача на строкиВо-первых, напишите свою любимую суффиксную структуру для того, чтобы уметь быстро сравнивать два суффикса лексикографически. Например, Суффиксный Массив + линейное LCP + Sparse Table. Теперь можно сравнивать два суффикса ii и jj, находя l=lcp(i,j)l=lcp(i,j) и сравнивая только s[i+l]s[i+l] с s[j+l]s[j+l].Будем обрабатывать запросы онлайн. Пусть текущий запрос характеризуется массивами aa (|a|=k|a|=k) и bb (|b|=l|b|=l). Будем считать ответ разделив его на две части: ∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).Для подсчета первой суммы можно отсортировать все c=a+bc=a+b суффиксов лексикографически и поддерживать некоторую информацию для префиксов массива cc. Что именно нужно знать? Необходимо поддерживать некоторую Структуру Данных, в которой будут хранится lcplcp суффиксов из aa. Когда обрабатываем ci=bjci=bj, то необходимо только узнать суммарную длину всех lcplcp из ДС. Если же ci=ajci=aj, то необходимо добавить в ДС длину ajaj-го суффикса. И при переходе от cici к ci+1ci+1 необходимо пересчитать некоторые lcplcp. Так как массив cc отсортирован, то все, что нужно сделать, это присвоить lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n]))lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n])).На самом деле, данная ДС — это просто mapmap. В данном mapmap мы будем поддерживать для для каждой длины ll количество суффиксов с lcp=llcp=l (конечно будем поддерживать только ненулевые значения). Когда необходимо добавить суффикс ajaj, то просто увеличиваем на 1 нужное значение. Операция minmin с некоторым v=lcp(s[ci…n],s[ci+1…n])v=lcp(s[ci…n],s[ci+1…n]) может быть сделана путем уменьшения максимума в mapmap пока он больше чем vv. Можно доказать, что всего будет порядка O(|a|+|b|)O(|a|+|b|) операций с mapmap для текущего запроса. Общую сумму же можно поддерживать в глобальной переменной, пересчитывая ее при каждом изменении mapmap.Для подсчета второй суммы достаточно реверснуть cc и запустить тот же самый алгоритм. Поэтому, результирующая асимптотика равна O(nlog2n+(∑i=1i=qki+∑i=1i=qli)logn)O(nlog2⁡n+(∑i=1i=qki+∑i=1i=qli)log⁡n). Решение (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\n\tif(read()) {\n\t\tsolve();\n\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62742",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1073\\s*D"
          },
          "content_length": 21758
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 1",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 2",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 5",
          "code": "O(n * logn)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [рейтинговый для Div. 2] - Codeforces - Code 6",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 1",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 2",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 15",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Разбор Educational Codeforces Round 53 - Codeforces - Code 16",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    long long T = inf.readLong(1LL, 1000000000000000000LL, \"T\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    long long T = inf.readLong(1LL, 1000000000000000000LL, \"T\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    long long T = inf.readLong(1LL, 1000000000000000000LL, \"T\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    // T is optional, depends on type\n    long long T = 0;\n\n    vector<int> a(n);\n\n    if (type == \"max_prices\") {\n        // All prices are maximum\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1'000'000'000; // Max price\n        }\n        T = opt<long long>(\"T\", 1'000'000'000'000'000'000LL);\n    } else if (type == \"min_prices\") {\n        // All prices are minimum\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1; // Min price\n        }\n        T = opt<long long>(\"T\", 1'000'000'000'000'000'000LL);\n    } else if (type == \"alternating_prices\") {\n        // Prices alternate between 1 and max\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 1;\n            else\n                a[i] = 1'000'000'000;\n        }\n        T = opt<long long>(\"T\", 1'000'000'000'000'000'000LL);\n    } else if (type == \"random\") {\n        // Random prices between 1 and 1e9\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000'000);\n        }\n        T = opt<long long>(\"T\", rnd.next(1LL, 1'000'000'000'000'000'000LL));\n    } else if(type == \"all_same_price\") {\n        // All prices are the same, optionally given as a parameter\n        int price = opt<int>(\"price\", 1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = price;\n        }\n        T = opt<long long>(\"T\", 1'000'000'000'000'000'000LL);\n    } else if(type == \"cannot_buy_any\") {\n        // Set T less than the minimum price\n        int min_price = rnd.next(2, 1'000'000'000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = min_price + rnd.next(0, 1'000'000'000 - min_price);\n        }\n        T = rnd.next(1, min_price - 1);\n    } else if(type == \"can_buy_all\") {\n        // All prices are less than T, set T to sum of a_i * k\n        for(int i = 0; i < n; ++i) {\n            // Keep prices reasonable to avoid sum exceeding T\n            a[i] = rnd.next(1, 1'000'000);\n        }\n        // Now compute sum of prices\n        long long sum_prices = 0;\n        for(int i = 0; i < n; ++i)\n            sum_prices += a[i];\n        // Decide a number of cycles 'k', we can make k random\n        long long max_k = min(1'000'000'000'000'000'000LL / sum_prices, 1'000'000'000'000LL);\n        long long k = rnd.next(1LL, max_k);\n        T = sum_prices * k;\n    } else if(type == \"max_T\") {\n        // T is maximum, prices are random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000'000);\n        }\n        T = 1'000'000'000'000'000'000LL; // Max T\n    } else if (type == \"single_expensive\") {\n        // all prices are cheap except one\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        int idx = rnd.next(0, n-1);\n        a[idx] = 1'000'000'000;\n        T = opt<long long>(\"T\", 1'000'000'000'000'000'000LL);\n    } else if (type == \"max_n\") {\n        // n is maximum, prices are random, T is maximum\n        n = 200'000;\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000'000);\n        }\n        T = 1'000'000'000'000'000'000LL;\n    } else if (type == \"n_equals_one\") {\n        // n =1\n        n = 1;\n        a.resize(n);\n        T = opt<long long>(\"T\", rnd.next(1LL, 1'000'000'000'000'000'000LL));\n        a[0] = rnd.next(1, 1'000'000'000);\n    } else {\n        // Default is random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000'000);\n        }\n        T = opt<long long>(\"T\", rnd.next(1LL, 1'000'000'000'000'000'000LL));\n    }\n\n    printf(\"%d %lld\\n\", n, T);\n\n    // Output the prices\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    // T is optional, depends on type\n    long long T = 0;\n\n    vector<int> a(n);\n\n    if (type == \"max_prices\") {\n        // All prices are maximum\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1'000'000'000; // Max price\n        }\n        T = opt<long long>(\"T\", 1'000'000'000'000'000'000LL);\n    } else if (type == \"min_prices\") {\n        // All prices are minimum\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1; // Min price\n        }\n        T = opt<long long>(\"T\", 1'000'000'000'000'000'000LL);\n    } else if (type == \"alternating_prices\") {\n        // Prices alternate between 1 and max\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 1;\n            else\n                a[i] = 1'000'000'000;\n        }\n        T = opt<long long>(\"T\", 1'000'000'000'000'000'000LL);\n    } else if (type == \"random\") {\n        // Random prices between 1 and 1e9\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000'000);\n        }\n        T = opt<long long>(\"T\", rnd.next(1LL, 1'000'000'000'000'000'000LL));\n    } else if(type == \"all_same_price\") {\n        // All prices are the same, optionally given as a parameter\n        int price = opt<int>(\"price\", 1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = price;\n        }\n        T = opt<long long>(\"T\", 1'000'000'000'000'000'000LL);\n    } else if(type == \"cannot_buy_any\") {\n        // Set T less than the minimum price\n        int min_price = rnd.next(2, 1'000'000'000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = min_price + rnd.next(0, 1'000'000'000 - min_price);\n        }\n        T = rnd.next(1, min_price - 1);\n    } else if(type == \"can_buy_all\") {\n        // All prices are less than T, set T to sum of a_i * k\n        for(int i = 0; i < n; ++i) {\n            // Keep prices reasonable to avoid sum exceeding T\n            a[i] = rnd.next(1, 1'000'000);\n        }\n        // Now compute sum of prices\n        long long sum_prices = 0;\n        for(int i = 0; i < n; ++i)\n            sum_prices += a[i];\n        // Decide a number of cycles 'k', we can make k random\n        long long max_k = min(1'000'000'000'000'000'000LL / sum_prices, 1'000'000'000'000LL);\n        long long k = rnd.next(1LL, max_k);\n        T = sum_prices * k;\n    } else if(type == \"max_T\") {\n        // T is maximum, prices are random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000'000);\n        }\n        T = 1'000'000'000'000'000'000LL; // Max T\n    } else if (type == \"single_expensive\") {\n        // all prices are cheap except one\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        int idx = rnd.next(0, n-1);\n        a[idx] = 1'000'000'000;\n        T = opt<long long>(\"T\", 1'000'000'000'000'000'000LL);\n    } else if (type == \"max_n\") {\n        // n is maximum, prices are random, T is maximum\n        n = 200'000;\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000'000);\n        }\n        T = 1'000'000'000'000'000'000LL;\n    } else if (type == \"n_equals_one\") {\n        // n =1\n        n = 1;\n        a.resize(n);\n        T = opt<long long>(\"T\", rnd.next(1LL, 1'000'000'000'000'000'000LL));\n        a[0] = rnd.next(1, 1'000'000'000);\n    } else {\n        // Default is random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000'000);\n        }\n        T = opt<long long>(\"T\", rnd.next(1LL, 1'000'000'000'000'000'000LL));\n    }\n\n    printf(\"%d %lld\\n\", n, T);\n\n    // Output the prices\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type n_equals_one -T 1\n./gen -n 1 -type n_equals_one -T 1000000000000000000\n\n./gen -n 2 -type cannot_buy_any\n./gen -n 2 -type can_buy_all\n\n./gen -n 10 -T 100 -type random\n./gen -n 10 -T 100 -type min_prices\n./gen -n 10 -T 100 -type max_prices\n\n./gen -n 1000 -T 1000000000 -type random\n./gen -n 1000 -T 1000000000000 -type alternating_prices\n\n./gen -n 1000 -type cannot_buy_any\n\n./gen -n 100000 -type max_T\n./gen -n 100000 -type can_buy_all\n\n./gen -n 200000 -type max_n\n\n./gen -n 200000 -type single_expensive -T 1000000000000000000\n\n./gen -n 200000 -T 1000000000000000000 -type min_prices\n\n./gen -n 200000 -type all_same_price -price 1000000000 -T 1000000000000000000\n\n./gen -n 200000 -type all_same_price -price 1\n\n./gen -n 3 -type all_same_price -price 1000000000 -T 1\n\n./gen -n 1 -type n_equals_one -T 1\n\n./gen -n 200000 -type alternating_prices -T 1000000000000000000\n\n./gen -n 200000 -type alternating_prices -T 1\n\n./gen -n 200000 -type random\n\n./gen -n 200000 -type random -T 1000000000000000000\n\n./gen -n 200000 -type random -T 1\n\n./gen -n 200000 -type can_buy_all\n\n./gen -n 100000 -type cannot_buy_any\n\n./gen -n 199999 -type max_prices -T 1000000000000000000\n\n./gen -n 200000 -type all_same_price -price 1\n\n./gen -n 200000 -type all_same_price -price 1000000000 -T 1\n\n./gen -n 1 -type max_prices -T 1000000000000000000\n\n./gen -n 1 -type min_prices -T 1\n\n./gen -n 2 -type single_expensive -T 1\n\n./gen -n 100000 -type single_expensive -T 1000000000\n\n./gen -n 200000 -type cannot_buy_any\n\n./gen -n 200000 -type can_buy_all\n\n./gen -n 200000 -type random -T 500000000000000000\n\n./gen -n 200000 -type random -T 1000000\n\n./gen -n 200000 -type all_same_price -price 500000000 -T 100000000000000\n\n./gen -n 1 -type n_equals_one -T 500000000000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:52.038426",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1073/E",
      "title": "E. Segment Sum",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of the input contains three integers ll, rr and kk (1≤l≤r<1018,1≤k≤101≤l≤r<1018,1≤k≤10) — the borders of the segment and the maximum number of different digits.",
      "output_spec": "OutputPrint one integer — the sum of numbers from ll to rr such that each number contains at most kk different digits, modulo 998244353998244353.",
      "sample_tests": "ExamplesInputCopy10 50 2OutputCopy1230InputCopy1 2345 10OutputCopy2750685InputCopy101 154 2OutputCopy2189",
      "description": "E. Segment Sum\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line of the input contains three integers ll, rr and kk (1≤l≤r<1018,1≤k≤101≤l≤r<1018,1≤k≤10) — the borders of the segment and the maximum number of different digits.\n\nOutputPrint one integer — the sum of numbers from ll to rr such that each number contains at most kk different digits, modulo 998244353998244353.\n\nInputCopy10 50 2OutputCopy1230InputCopy1 2345 10OutputCopy2750685InputCopy101 154 2OutputCopy2189\n\nInputCopy10 50 2\n\nOutputCopy1230\n\nInputCopy1 2345 10\n\nOutputCopy2750685\n\nInputCopy101 154 2\n\nOutputCopy2189\n\nNoteFor the first example the answer is just the sum of numbers from ll to rr which equals to 50⋅512−9⋅102=123050⋅512−9⋅102=1230. This example also explained in the problem statement but for k=1k=1.For the second example the answer is just the sum of numbers from ll to rr which equals to 2345⋅23462=27506852345⋅23462=2750685.For the third example the answer is 101+110+111+112+113+114+115+116+117+118+119+121+122+131+133+141+144+151=2189101+110+111+112+113+114+115+116+117+118+119+121+122+131+133+141+144+151=2189.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces",
          "content": "On Thursday, October 25, 2018 at 22:35UTC+8 Educational Codeforces Round 53 (Rated for Div. 2) will start.Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. The penalty for each incorrect submission until the submission with a full solution is 10 minutes. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Roman Roms Glazov, Adilbek adedalic Dalabaev, Vladimir vovuh Petrov, Ivan BledDest Androsov and me.Good luck to all participants!Our friends at Harbour.Space also have a message for you:Hey Codeforces! We want to remind you that the Scholarship for the Master’s in Robotics programme, which starts on January 7th 2019, has an application deadline of November 12th, 2018.Harbour.Space University and Remy Robotics are collaborating to offer graduate students from anywhere in the world a once in a lifetime opportunity, a fully funded scholarship for Harbour.Space University’s Master’s Programme in Robotics. The scholarship value is €34.900 and it includes: Complete coverage of the University tuition fee (€22,900) Internship at Remy Robotics (20h per week during 1 year) €1,000 per month during 1 year (Internship earnings) Apply hereUPD: vovuh and me will be waiting for you on the community Discord server shortly after the contest to discuss the problems.Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 pekempey 7 305 2 ko_osaga 7 578 3 Lewin 6 216 4 fanache99 6 226 5 natsugiri 6 257 Congratulations to the best hackers: Rank Competitor Hack Count 1 halyavin 238:-15 2 Laggy 64:-14 3 MarcosK 59:-9 4 Mistra 8:-1 5 LordVoldebug 7:-1 482 successful hacks and 684 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A Dalgerok 0:01 B dorijanlendvaj 0:02 C fanache99 0:10 D bazsi700 0:13 E DAyamaCTF 0:21 F Noam527 0:48 G ko_osaga 0:24 UPD2: Editorial is published",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62683",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2335
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces",
          "content": "1073A - Diverse Substring Tutorial1073A - Diverse SubstringNotice that the string of two distinct letter is already diverse. That implies that the answer is \"NO\" if and only if all the letters in the string are the same. Otherwise you can check all pairs of adjacent letters in O(n)O(n).Overall complexity: O(n)O(n). Solution (PikMike)n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")1073B - Vasya and Books Tutorial1073B - Vasya and BooksLet's maintain the pointer pospos to the topmost non-deleted book and whether each book whether is removed from the stack or not. Initially, all books are in a stack, and pospos is 0 (if we store the array 0-indexed). We will process the array BB in the order b1,b2,…bnb1,b2,…bn. If the current book bibi is removed from the stack, then the answer for it is zero. Otherwise, we will increment the pointer pospos until the equality apos=biapos=bi is satisfied, while marking all the intermediate books in the array uu. After that, the answer for the book bibi will be the number of marked books in the uu array (including itself).Since the pointer pospos shifts nn times at total, we get a solution with an O(n)O(n) complexity. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n for(int i = 0; i < n; ++i) {\n \tscanf(\"%d\", a + i);\n }\n for(int i = 0; i < n; ++i){\n \tscanf(\"%d\", b + i);\n }\n\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t} \n\n\tputs(\"\");\n return 0;\n}1073C - Vasya and Robot Tutorial1073C - Vasya and RobotDenote d=|x|+|y​|d=|x|+|y​|. If d>nd>n, then the answer is -1, since the robot will not have the time to reach (x,y)(x,y) cell in nn steps. Also, if dd and nn have different parity, then the answer is also -1, as in one move the robot changes the parity of the sum of its coordinates.In all other cases, the answer exists. Let's use binary search to solve this problem. Consider all segments of length lenlen. For a fixed length of the segment lenlen, let's iterate over the position of the beginning of the segment ll. At the same time, we will maintain the cell that the robot will stop at if it execute all commands, except commands with indices l,l+1,…,l+len−1l,l+1,…,l+len−1. We denote this position as (x0,y0)(x0,y0). We also calculate the distances from the cell (x0,y0)(x0,y0) to the cell (x,y)(x,y) — the value d0=|x−x0|+|y​​−y0|d0=|x−x0|+|y​​−y0|. If there is at least one position of the beginning of the segment for which d0≤lend0≤len, then we can change the segment of length lenlen so that the robot comes to the (x,y)(x,y) cell, otherwise it can't. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tcout << r << endl;\n return 0;\n}1073D - Berland Fair TutorialTutorial is loading... Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}1073E - Segment Sum Tutorial1073E - Segment SumLet's calculate the answer as the sum of suitable numbers in range [1;r][1;r] minus the sum of suitable numbers in range [1;l−1][1;l−1]. Now our problem is to calculate the sum of suitable numbers in range [1;n][1;n].The main approach for this problem is digit DP. Let's calculate two dynamic programmings dppos,mask,fdppos,mask,f and dpspos,mask,fdpspos,mask,f. pospos means that now we are at the pospos-th digit of the number nn (at the digit corresponding to 10len−pos−110len−pos−1, where lenlen is the decimal length of a number), maskmask is a binary mask describing digits we already use and ff equals 11 if the current prefix of number we trying to obtain is the same as the prefix of number nn (otherwise ff equals 00).So what means dppos,mask,fdppos,mask,f? It means the count of numbers (in general, not numbers but their prefixes) in range [1;n][1;n] of length exactly |n||n| without leading zeroes corresponding to this state. So what the point of this DP? Its point is helping us to calculate the main DP, dpspos,mask,fdpspos,mask,f, which means the sum of numbers (in general, not numbers but their prefixes) in range [1;n][1;n] of length exactly |n||n| without leading zeroes corresponding to this state.How do we calculate the answer? Firstly, let lenlen be the length of nn. Let calc(n)calc(n) be the function calculating the sum of numbers from 11 to nn containing at most kk different digits. How to calculate it? Let calcdp(x)calcdp(x) be the sum of numbers from 11 to xx containing at most kk different digits and having length exactly |x||x|. Then calc(n)calc(n) seems to be pretty easy: for each length ii from 11 to len−1len−1 add to the answer calcdp(10i−1)calcdp(10i−1). And the last step is to add to the answer calcdp(n)calcdp(n).How to calculate dynamic programmings? Initially, all states are zeroes (excluding dp0,0,1dp0,0,1, which is 11).Firstly, let's calculate dpdp. After calculating it we can calculate dpsdps in almost the same way. Let's iterate over all possible lengths and over all possible masks. Let the current state is dppos,mask,0dppos,mask,0. Then let's iterate over next digit we will place in this number and place it. If pos=0pos=0 then dig=1…9dig=1…9 otherwise dig=0…9dig=0…9. The transition is pretty easy: dppos+1,mask|2dig,0+=dppos,mask,0dppos+1,mask|2dig,0+=dppos,mask,0. There || is the bitwise OR operation. For f=1f=1 transitions are almost the same expect the restrictions on digit we place and the state we update. If we now at the position pospos with mask maskmask and f=1f=1 then the current digit of nn is nposnpos. Then let's iterate over next digit: dig=1…nposdig=1…npos if pos=0pos=0 otherwise dig=0…nposdig=0…npos. The transition is also easy: dppos+1,mask|2dig,dig=npos+=dppos,mask,fdppos+1,mask|2dig,dig=npos+=dppos,mask,f.After calculating the previous DP we can calculate dpsdps. All the process is the same as in the previous dynamic programming expect the value we will add in transitions. In the previous DP this value was equal dppos,mask,fdppos,mask,f, in the current DP this value equals to val=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,fval=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,f. Don't forget to calculate it modulo 998244353998244353!So after calculating all the values of DPs, what is the answer for calcdp(n)calcdp(n)? It is ∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1 for all masks with at most kk bits.I'm pretty sure that there is another way to avoid leading zeroes in calculating these DPs but this one is very straight-forward and simple. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\n\treturn 0;\n}1073F - Choosing Two Paths TutorialTutorial is loading... Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\n\tpt ans = calc(path[size(path) / 2]);\n\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\n\treturn 0;\n}1073G - Yet Another LCP Problem Tutorial1073G - Yet Another LCP ProblemAt first, implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough. For example, it's a Suffix Array + linear LCP + Sparse Table. Now we can compare two suffixes ii and jj by finding l=lcp(i,j)l=lcp(i,j) and comparing s[i+l]s[i+l] with s[j+l]s[j+l].We will process queries online. Let current query be a pair of arrays aa (|a|=k|a|=k) and bb (|b|=l|b|=l). We will calculate answer in two parts: ∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).To calculate the first sum we can sort all c=a+bc=a+b suffixes in lexicographical order and maintain some information for prefixes of cc. What information we need to maintain? We need some Data Structure which will hold lcplcp of suffixes from aa. When we process some ci=bjci=bj we need just a total sum of all lcplcp in the DS. If ci=ajci=aj, we should add to the DS length of ajaj-th suffix. And when we move from cici to ci+1ci+1 we must recalculate some lcplcp. Since cc is sorted, all we need is to set lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n]))lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n])).In fact, this Data Structure is just a mapmap. In this mapmap we will hold for each length ll number of suffixes with lcp=llcp=l (we will hold only non-zero values). When we should add some suffix ajaj, we manually increase some value by one. Setting minmin with v=lcp(s[ci…n],s[ci+1…n])v=lcp(s[ci…n],s[ci+1…n]) can be done with decreasing maximum in mapmap while its more than vv. It can be proven, that there will be O(|a|+|b|)O(|a|+|b|) operations with mapmap for one query. The total sum can be maintained in some global variable, which will be recalculated each time mapmap changes.To calculate the second sum we can just reverse cc and run the same algorithm. So total complexity is O(nlog2n+(∑i=1i=qki+∑i=1i=qli)logn)O(nlog2⁡n+(∑i=1i=qki+∑i=1i=qli)log⁡n). Solution (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\n\tif(read()) {\n\t\tsolve();\n\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62742",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1073\\s*E"
          },
          "content_length": 18656
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 5",
          "code": "O(n * logn)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 6",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 1",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 2",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 15",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 16",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", rnd.next(1,10)); // k defaults to random between 1 and 10 if not provided\n    int n = opt<int>(\"n\", rnd.next(1,18)); // n defaults to random between 1 and 18 if not provided\n\n    // Ensure n is within the valid range\n    n = max(1, min(n, 18));\n\n    // Precompute powers of 10\n    long long pow10[19];\n    pow10[0] = 1;\n    for (int i = 1; i <= 18; i++)\n        pow10[i] = pow10[i-1] * 10;\n\n    long long l = 1, r = 1;\n\n    if (type == \"min_case\") {\n        l = 1;\n        r = 1;\n    } else if (type == \"max_case\") {\n        l = 1;\n        r = pow10[18]-1;\n    } else if (type == \"equal_lr\") {\n        l = rnd.next(pow10[n-1], pow10[n]-1);\n        r = l;\n    } else if (type == \"k_equals_1\") {\n        k = 1;\n        l = rnd.next(pow10[n-1], pow10[n]-1);\n        r = rnd.next(l, pow10[n]-1);\n    } else if (type == \"k_equals_10\") {\n        k = 10;\n        l = rnd.next(pow10[n-1], pow10[n]-1);\n        r = rnd.next(l, pow10[n]-1);\n    } else if (type == \"small_numbers\") {\n        l = rnd.next(1LL, 1000LL);\n        r = rnd.next(l, 1000LL);\n    } else if (type == \"large_numbers\") {\n        l = rnd.next(pow10[n-1], pow10[n]-1);\n        r = rnd.next(l, pow10[n]-1);\n    } else {\n        // default random\n        l = rnd.next(1LL, pow10[n]-1);\n        r = rnd.next(l, pow10[n]-1);\n    }\n    // Ensure k is within valid range\n    k = max(1, min(k, 10));\n    printf(\"%lld %lld %d\\n\", l, r, k);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", rnd.next(1,10)); // k defaults to random between 1 and 10 if not provided\n    int n = opt<int>(\"n\", rnd.next(1,18)); // n defaults to random between 1 and 18 if not provided\n\n    // Ensure n is within the valid range\n    n = max(1, min(n, 18));\n\n    // Precompute powers of 10\n    long long pow10[19];\n    pow10[0] = 1;\n    for (int i = 1; i <= 18; i++)\n        pow10[i] = pow10[i-1] * 10;\n\n    long long l = 1, r = 1;\n\n    if (type == \"min_case\") {\n        l = 1;\n        r = 1;\n    } else if (type == \"max_case\") {\n        l = 1;\n        r = pow10[18]-1;\n    } else if (type == \"equal_lr\") {\n        l = rnd.next(pow10[n-1], pow10[n]-1);\n        r = l;\n    } else if (type == \"k_equals_1\") {\n        k = 1;\n        l = rnd.next(pow10[n-1], pow10[n]-1);\n        r = rnd.next(l, pow10[n]-1);\n    } else if (type == \"k_equals_10\") {\n        k = 10;\n        l = rnd.next(pow10[n-1], pow10[n]-1);\n        r = rnd.next(l, pow10[n]-1);\n    } else if (type == \"small_numbers\") {\n        l = rnd.next(1LL, 1000LL);\n        r = rnd.next(l, 1000LL);\n    } else if (type == \"large_numbers\") {\n        l = rnd.next(pow10[n-1], pow10[n]-1);\n        r = rnd.next(l, pow10[n]-1);\n    } else {\n        // default random\n        l = rnd.next(1LL, pow10[n]-1);\n        r = rnd.next(l, pow10[n]-1);\n    }\n    // Ensure k is within valid range\n    k = max(1, min(k, 10));\n    printf(\"%lld %lld %d\\n\", l, r, k);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_case -n 1 -k 1\n./gen -type max_case -n 18 -k 10\n./gen -type equal_lr -n 5 -k 2\n./gen -type equal_lr -n 18 -k 5\n./gen -type k_equals_1 -n 3\n./gen -type k_equals_1 -n 18\n./gen -type k_equals_10 -n 3\n./gen -type k_equals_10 -n 18\n./gen -type small_numbers -k 2\n./gen -type small_numbers -k 10\n./gen -type large_numbers -n 15 -k 2\n./gen -type large_numbers -n 18 -k 10\n./gen -type random -n 1 -k 1\n./gen -type random -n 1 -k 10\n./gen -type random -n 9 -k 2\n./gen -type random -n 12 -k 2\n./gen -type random -n 5 -k 3\n./gen -type random -n 10 -k 5\n./gen -type random -n 18 -k 7\n./gen -type random -n 18 -k 10\n./gen -type random -n 18 -k 1\n./gen -type random\n./gen -type random -k 5\n./gen -type random -n 5\n./gen -type random -n 18 -k 1\n./gen -type random -n 18 -k 10\n./gen -type random -n 2 -k 2\n./gen -type random -n 18 -k 9\n./gen -type random -n 18 -k 2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:53.689543",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1073/F",
      "title": "F. Choosing Two Paths",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer nn — the number of vertices in the tree (6≤n≤2⋅1056≤n≤2⋅105).Each of the next n−1n−1 lines describes the edges of the tree.Edge ii is denoted by two integers uiui and vivi, the labels of vertices it connects (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi).It is guaranteed that the given edges form a tree.It is guaranteed that the answer with at least two common vertices exists for the given tree.",
      "output_spec": "OutputPrint any two pairs of vertices satisfying the conditions described in the problem statement.It is guaranteed that it is possible to choose such pairs for the given tree.",
      "sample_tests": "ExamplesInputCopy71 41 51 62 32 44 7OutputCopy3 67 5InputCopy99 33 51 24 34 71 74 63 8OutputCopy2 96 8InputCopy106 810 33 75 81 77 22 92 81 4OutputCopy10 64 5InputCopy111 22 33 41 51 66 75 85 94 104 11OutputCopy9 118 10",
      "description": "F. Choosing Two Paths\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains an integer nn — the number of vertices in the tree (6≤n≤2⋅1056≤n≤2⋅105).Each of the next n−1n−1 lines describes the edges of the tree.Edge ii is denoted by two integers uiui and vivi, the labels of vertices it connects (1≤ui,vi≤n1≤ui,vi≤n, ui≠viui≠vi).It is guaranteed that the given edges form a tree.It is guaranteed that the answer with at least two common vertices exists for the given tree.\n\nOutputPrint any two pairs of vertices satisfying the conditions described in the problem statement.It is guaranteed that it is possible to choose such pairs for the given tree.\n\nInputCopy71 41 51 62 32 44 7OutputCopy3 67 5InputCopy99 33 51 24 34 71 74 63 8OutputCopy2 96 8InputCopy106 810 33 75 81 77 22 92 81 4OutputCopy10 64 5InputCopy111 22 33 41 51 66 75 85 94 104 11OutputCopy9 118 10\n\nInputCopy71 41 51 62 32 44 7\n\nOutputCopy3 67 5\n\nInputCopy99 33 51 24 34 71 74 63 8\n\nOutputCopy2 96 8\n\nInputCopy106 810 33 75 81 77 22 92 81 4\n\nOutputCopy10 64 5\n\nInputCopy111 22 33 41 51 66 75 85 94 104 11\n\nOutputCopy9 118 10\n\nNoteThe picture corresponding to the first example: The intersection of two paths is 22 (vertices 11 and 44) and the total length is 4+3=74+3=7.The picture corresponding to the second example: The intersection of two paths is 22 (vertices 33 and 44) and the total length is 5+3=85+3=8.The picture corresponding to the third example: The intersection of two paths is 33 (vertices 22, 77 and 88) and the total length is 5+5=105+5=10.The picture corresponding to the fourth example: The intersection of two paths is 55 (vertices 11, 22, 33, 44 and 55) and the total length is 6+6=126+6=12.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces",
          "content": "On Thursday, October 25, 2018 at 22:35UTC+8 Educational Codeforces Round 53 (Rated for Div. 2) will start.Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. The penalty for each incorrect submission until the submission with a full solution is 10 minutes. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Roman Roms Glazov, Adilbek adedalic Dalabaev, Vladimir vovuh Petrov, Ivan BledDest Androsov and me.Good luck to all participants!Our friends at Harbour.Space also have a message for you:Hey Codeforces! We want to remind you that the Scholarship for the Master’s in Robotics programme, which starts on January 7th 2019, has an application deadline of November 12th, 2018.Harbour.Space University and Remy Robotics are collaborating to offer graduate students from anywhere in the world a once in a lifetime opportunity, a fully funded scholarship for Harbour.Space University’s Master’s Programme in Robotics. The scholarship value is €34.900 and it includes: Complete coverage of the University tuition fee (€22,900) Internship at Remy Robotics (20h per week during 1 year) €1,000 per month during 1 year (Internship earnings) Apply hereUPD: vovuh and me will be waiting for you on the community Discord server shortly after the contest to discuss the problems.Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 pekempey 7 305 2 ko_osaga 7 578 3 Lewin 6 216 4 fanache99 6 226 5 natsugiri 6 257 Congratulations to the best hackers: Rank Competitor Hack Count 1 halyavin 238:-15 2 Laggy 64:-14 3 MarcosK 59:-9 4 Mistra 8:-1 5 LordVoldebug 7:-1 482 successful hacks and 684 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A Dalgerok 0:01 B dorijanlendvaj 0:02 C fanache99 0:10 D bazsi700 0:13 E DAyamaCTF 0:21 F Noam527 0:48 G ko_osaga 0:24 UPD2: Editorial is published",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62683",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2335
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces",
          "content": "1073A - Diverse Substring Tutorial1073A - Diverse SubstringNotice that the string of two distinct letter is already diverse. That implies that the answer is \"NO\" if and only if all the letters in the string are the same. Otherwise you can check all pairs of adjacent letters in O(n)O(n).Overall complexity: O(n)O(n). Solution (PikMike)n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")1073B - Vasya and Books Tutorial1073B - Vasya and BooksLet's maintain the pointer pospos to the topmost non-deleted book and whether each book whether is removed from the stack or not. Initially, all books are in a stack, and pospos is 0 (if we store the array 0-indexed). We will process the array BB in the order b1,b2,…bnb1,b2,…bn. If the current book bibi is removed from the stack, then the answer for it is zero. Otherwise, we will increment the pointer pospos until the equality apos=biapos=bi is satisfied, while marking all the intermediate books in the array uu. After that, the answer for the book bibi will be the number of marked books in the uu array (including itself).Since the pointer pospos shifts nn times at total, we get a solution with an O(n)O(n) complexity. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n for(int i = 0; i < n; ++i) {\n \tscanf(\"%d\", a + i);\n }\n for(int i = 0; i < n; ++i){\n \tscanf(\"%d\", b + i);\n }\n\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t} \n\n\tputs(\"\");\n return 0;\n}1073C - Vasya and Robot Tutorial1073C - Vasya and RobotDenote d=|x|+|y​|d=|x|+|y​|. If d>nd>n, then the answer is -1, since the robot will not have the time to reach (x,y)(x,y) cell in nn steps. Also, if dd and nn have different parity, then the answer is also -1, as in one move the robot changes the parity of the sum of its coordinates.In all other cases, the answer exists. Let's use binary search to solve this problem. Consider all segments of length lenlen. For a fixed length of the segment lenlen, let's iterate over the position of the beginning of the segment ll. At the same time, we will maintain the cell that the robot will stop at if it execute all commands, except commands with indices l,l+1,…,l+len−1l,l+1,…,l+len−1. We denote this position as (x0,y0)(x0,y0). We also calculate the distances from the cell (x0,y0)(x0,y0) to the cell (x,y)(x,y) — the value d0=|x−x0|+|y​​−y0|d0=|x−x0|+|y​​−y0|. If there is at least one position of the beginning of the segment for which d0≤lend0≤len, then we can change the segment of length lenlen so that the robot comes to the (x,y)(x,y) cell, otherwise it can't. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tcout << r << endl;\n return 0;\n}1073D - Berland Fair Tutorial1073D - Berland FairLet's code the following process. Go one circle across the booths, calculate the total cost CC of sweets bought and the number SS of sweets bought. Now you can decrease you money down to T=T mod CT=T mod C and add S⋅(T div C)S⋅(T div C) to answer. It represents that you went maximum number of such circles. The later circles will have smaller cost. Let's continue this process until TT becomes smaller than the minimum priced sweet.The number of operations made is O(logT)O(log⁡T). Let TcurTcur be the amount of money before some operation, CcurCcur be the total cost of sweets bought on that operation and Tnew=Tcur mod CcurTnew=Tcur mod Ccur. TnewTnew is actually smaller than CcurCcur (that's how modulo works) and smaller than Tcur−CcurTcur−Ccur (that's also how modulo works). And these inequalities imply that Tnew<Tcur2Tnew<Tcur2. That leads to about O(logT)O(log⁡T) steps to reach the minimal price.Overall complexity: O(nlogT)O(nlog⁡T). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}1073E - Segment Sum Tutorial1073E - Segment SumLet's calculate the answer as the sum of suitable numbers in range [1;r][1;r] minus the sum of suitable numbers in range [1;l−1][1;l−1]. Now our problem is to calculate the sum of suitable numbers in range [1;n][1;n].The main approach for this problem is digit DP. Let's calculate two dynamic programmings dppos,mask,fdppos,mask,f and dpspos,mask,fdpspos,mask,f. pospos means that now we are at the pospos-th digit of the number nn (at the digit corresponding to 10len−pos−110len−pos−1, where lenlen is the decimal length of a number), maskmask is a binary mask describing digits we already use and ff equals 11 if the current prefix of number we trying to obtain is the same as the prefix of number nn (otherwise ff equals 00).So what means dppos,mask,fdppos,mask,f? It means the count of numbers (in general, not numbers but their prefixes) in range [1;n][1;n] of length exactly |n||n| without leading zeroes corresponding to this state. So what the point of this DP? Its point is helping us to calculate the main DP, dpspos,mask,fdpspos,mask,f, which means the sum of numbers (in general, not numbers but their prefixes) in range [1;n][1;n] of length exactly |n||n| without leading zeroes corresponding to this state.How do we calculate the answer? Firstly, let lenlen be the length of nn. Let calc(n)calc(n) be the function calculating the sum of numbers from 11 to nn containing at most kk different digits. How to calculate it? Let calcdp(x)calcdp(x) be the sum of numbers from 11 to xx containing at most kk different digits and having length exactly |x||x|. Then calc(n)calc(n) seems to be pretty easy: for each length ii from 11 to len−1len−1 add to the answer calcdp(10i−1)calcdp(10i−1). And the last step is to add to the answer calcdp(n)calcdp(n).How to calculate dynamic programmings? Initially, all states are zeroes (excluding dp0,0,1dp0,0,1, which is 11).Firstly, let's calculate dpdp. After calculating it we can calculate dpsdps in almost the same way. Let's iterate over all possible lengths and over all possible masks. Let the current state is dppos,mask,0dppos,mask,0. Then let's iterate over next digit we will place in this number and place it. If pos=0pos=0 then dig=1…9dig=1…9 otherwise dig=0…9dig=0…9. The transition is pretty easy: dppos+1,mask|2dig,0+=dppos,mask,0dppos+1,mask|2dig,0+=dppos,mask,0. There || is the bitwise OR operation. For f=1f=1 transitions are almost the same expect the restrictions on digit we place and the state we update. If we now at the position pospos with mask maskmask and f=1f=1 then the current digit of nn is nposnpos. Then let's iterate over next digit: dig=1…nposdig=1…npos if pos=0pos=0 otherwise dig=0…nposdig=0…npos. The transition is also easy: dppos+1,mask|2dig,dig=npos+=dppos,mask,fdppos+1,mask|2dig,dig=npos+=dppos,mask,f.After calculating the previous DP we can calculate dpsdps. All the process is the same as in the previous dynamic programming expect the value we will add in transitions. In the previous DP this value was equal dppos,mask,fdppos,mask,f, in the current DP this value equals to val=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,fval=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,f. Don't forget to calculate it modulo 998244353998244353!So after calculating all the values of DPs, what is the answer for calcdp(n)calcdp(n)? It is ∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1 for all masks with at most kk bits.I'm pretty sure that there is another way to avoid leading zeroes in calculating these DPs but this one is very straight-forward and simple. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\n\treturn 0;\n}1073F - Choosing Two Paths Tutorial1073F - Choosing Two PathsFirstly, let's call a path from uu to vv good, if uu is a leaf, vv is a vertex of degree at least 33 (the number of their neighbors is at least 33) and there are no other vertices of degree at least 33 on this path expect the vertex vv.The first step of the solution is to remove all the good paths from uu to vv (but we should not remove the vertex vv) and remember for each vertex vv the sum of two maximum lengths of good paths which end in the vertex vv. Let this value for the vertex vv be valvvalv. For example, if for some vertex vv there are 33 good paths with end in it of lengths 22, 33 and 55 correspondingly, then valvvalv will be 5+3=85+3=8.Okay, it is easy to see that the maximum intersection of two paths in the answer will be equal to the length of the diameter of the obtained tree. But we can not take any diameter of this tree and call it the answer because of the second constraint: we need to find some diameter from xx to yy such that the sum valx+valyvalx+valy is maximum possible. How do we do that?There is such an awesome (and well-known) fact that the center of a tree belongs to all diameters of this tree. Let's root the tree by the center of a tree (if the length of the diameter is odd (the center of a tree is an edge) then let's root the tree by any end of this edge, it does not matter).There is one case when the length of the diameter is 11 but it is pretty trivial to handle it.Now our problem is to find two neighbors of the root of the new tree such that in their subtrees are vertices which form some diameter of this tree and the sum of values of these vertices is maximum possible. Let's calculate the vertex with the maximum distance from a root (and with the maximum possible valvvalv for equals distances) by simple DFS for each neighbor of a root. It can be done in O(n)O(n) and the last part is to find two maximums of this list, it also can be done in O(n)O(n) or O(nlogn)O(nlog⁡n), depends on implementation. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\n\tpt ans = calc(path[size(path) / 2]);\n\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\n\treturn 0;\n}1073G - Yet Another LCP Problem Tutorial1073G - Yet Another LCP ProblemAt first, implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough. For example, it's a Suffix Array + linear LCP + Sparse Table. Now we can compare two suffixes ii and jj by finding l=lcp(i,j)l=lcp(i,j) and comparing s[i+l]s[i+l] with s[j+l]s[j+l].We will process queries online. Let current query be a pair of arrays aa (|a|=k|a|=k) and bb (|b|=l|b|=l). We will calculate answer in two parts: ∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).To calculate the first sum we can sort all c=a+bc=a+b suffixes in lexicographical order and maintain some information for prefixes of cc. What information we need to maintain? We need some Data Structure which will hold lcplcp of suffixes from aa. When we process some ci=bjci=bj we need just a total sum of all lcplcp in the DS. If ci=ajci=aj, we should add to the DS length of ajaj-th suffix. And when we move from cici to ci+1ci+1 we must recalculate some lcplcp. Since cc is sorted, all we need is to set lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n]))lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n])).In fact, this Data Structure is just a mapmap. In this mapmap we will hold for each length ll number of suffixes with lcp=llcp=l (we will hold only non-zero values). When we should add some suffix ajaj, we manually increase some value by one. Setting minmin with v=lcp(s[ci…n],s[ci+1…n])v=lcp(s[ci…n],s[ci+1…n]) can be done with decreasing maximum in mapmap while its more than vv. It can be proven, that there will be O(|a|+|b|)O(|a|+|b|) operations with mapmap for one query. The total sum can be maintained in some global variable, which will be recalculated each time mapmap changes.To calculate the second sum we can just reverse cc and run the same algorithm. So total complexity is O(nlog2n+(∑i=1i=qki+∑i=1i=qli)logn)O(nlog2⁡n+(∑i=1i=qki+∑i=1i=qli)log⁡n). Solution (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\n\tif(read()) {\n\t\tsolve();\n\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/62742",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1073\\s*F"
          },
          "content_length": 21562
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 5",
          "code": "O(n * logn)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 6",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 1",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 2",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 15",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 16",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(6, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (x != parent[x]) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge should connect different vertices\");\n\n        pair<int, int> edge = make_pair(min(u, v), max(u, v));\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between vertices %d and %d\", u, v);\n        edgeSet.insert(edge);\n\n        inf.readEoln();\n\n        // Check for cycles\n        int pu = find(u);\n        int pv = find(v);\n        ensuref(pu != pv, \"Graph must be acyclic\");\n        parent[pu] = pv;\n    }\n\n    // After reading all edges, check that the graph is connected.\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph must be connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(6, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (x != parent[x]) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge should connect different vertices\");\n\n        pair<int, int> edge = make_pair(min(u, v), max(u, v));\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between vertices %d and %d\", u, v);\n        edgeSet.insert(edge);\n\n        inf.readEoln();\n\n        // Check for cycles\n        int pu = find(u);\n        int pv = find(v);\n        ensuref(pu != pv, \"Graph must be acyclic\");\n        parent[pu] = pv;\n    }\n\n    // After reading all edges, check that the graph is connected.\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph must be connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(6, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (x != parent[x]) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge should connect different vertices\");\n\n        pair<int, int> edge = make_pair(min(u, v), max(u, v));\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between vertices %d and %d\", u, v);\n        edgeSet.insert(edge);\n\n        inf.readEoln();\n\n        // Check for cycles\n        int pu = find(u);\n        int pv = find(v);\n        ensuref(pu != pv, \"Graph must be acyclic\");\n        parent[pu] = pv;\n    }\n\n    // After reading all edges, check that the graph is connected.\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph must be connected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const long long INF64 = (long long)(1E18 + 7);\n\nstruct AnswerData {\n    long long intersectionSize;\n    long long totalLength;\n};\n\n// Global adjacency list\nstatic vector<vector<int>> adj;\nstatic int n;\n\n// Returns the simple path (unique in a tree) from start to end (0-based).\n// Uses BFS (could use DFS as well). If something is wrong (not found), it quits.\nvector<int> getPath(int start, int end, InStream &stream) {\n    vector<int> parent(n, -1);\n    queue<int> q;\n    parent[start] = start;\n    q.push(start);\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        if (cur == end) break;\n        for (int nx: adj[cur]) {\n            if (parent[nx] == -1) {\n                parent[nx] = cur;\n                q.push(nx);\n            }\n        }\n    }\n    if (parent[end] == -1) {\n        // Should not happen in a tree, but just in case\n        stream.quitf(_wa, \"no path found between %d and %d in a tree\", start + 1, end + 1);\n    }\n    // Reconstruct the path\n    vector<int> path;\n    for (int v = end; v != start; v = parent[v]) {\n        path.push_back(v);\n    }\n    path.push_back(start);\n    reverse(path.begin(), path.end());\n    return path;\n}\n\n// Reads and checks one contestant/jury answer from stream.\n// Returns { intersectionSize, totalLength } if valid, otherwise quits with _wa (or _fail for jury).\nAnswerData readAns(InStream& stream) {\n    // The problem statement requires us to print 2 pairs of vertices (each pair on its own line).\n    // But it also allows them to be on e.g. just two lines total. We'll just read 4 ints either way.\n    // read x1,y1 on one line, x2,y2 on next line.\n    // Or possibly all 4 on same line, or 4 lines, etc. We treat them as tokens.\n\n    // Read four vertices (1-based), convert to 0-based\n    int x1 = stream.readInt(1, n, \"x1\") - 1;\n    int y1 = stream.readInt(1, n, \"y1\") - 1;\n    int x2 = stream.readInt(1, n, \"x2\") - 1;\n    int y2 = stream.readInt(1, n, \"y2\") - 1;\n\n    // Check that all chosen vertices are distinct\n    // (x1, y1, x2, y2 must be pairwise distinct)\n    {\n        set<int> st{ x1, y1, x2, y2 };\n        if ((int)st.size() < 4) {\n            stream.quitf(_wa, \"the two pairs do not consist of 4 distinct vertices\");\n        }\n    }\n\n    // Get the paths in the tree\n    vector<int> path1 = getPath(x1, y1, stream);\n    vector<int> path2 = getPath(x2, y2, stream);\n\n    // Check that path1 does not contain x2 or y2\n    // and path2 does not contain x1 or y1\n    // (The statement: \"neither x1 nor y1 belong to the simple path from x2 to y2\n    //  and neither x2 nor y2 belong to the simple path from x1 to y1\")\n    {\n        // For quick membership checks, store path1 and path2 in sets\n        unordered_set<int> s1(path1.begin(), path1.end());\n        unordered_set<int> s2(path2.begin(), path2.end());\n\n        if (s1.count(x2) || s1.count(y2)) {\n            stream.quitf(_wa, \"path from x1 to y1 contains x2 or y2\");\n        }\n        if (s2.count(x1) || s2.count(y1)) {\n            stream.quitf(_wa, \"path from x2 to y2 contains x1 or y1\");\n        }\n    }\n\n    // Compute number of common vertices (intersection of path1 and path2)\n    // and total length = (path1.size() - 1) + (path2.size() - 1).\n    long long totalLen = (long long)(path1.size() - 1) + (long long)(path2.size() - 1);\n\n    unordered_set<int> s1(path1.begin(), path1.end());\n    long long intersectCount = 0;\n    for (int v: path2) {\n        if (s1.count(v)) {\n            intersectCount++;\n        }\n    }\n\n    AnswerData res;\n    res.intersectionSize = intersectCount;\n    res.totalLength = totalLen;\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(6, 200000, \"n\"); // read number of vertices\n\n    adj.assign(n, {});\n\n    // read the edges\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u\") - 1;\n        int v = inf.readInt(1, n, \"v\") - 1;\n        // build adjacency\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Read official answer\n    AnswerData jurySol = readAns(ans);\n\n    // Validate that official solution is not obviously invalid\n    // (We rely on readAns to have done the quitf if it's invalid.)\n    // But we can still ensure it has at least intersection >= 2,\n    // since problem states \"It is guaranteed that the answer with at least two common vertices exists\".\n    if (jurySol.intersectionSize < 2) {\n        // If the official solution doesn't have at least 2 in the intersection, fail.\n        quitf(_fail,\n            \"Jury's official solution intersection size is %lld, but the statement guarantees >= 2\",\n            jurySol.intersectionSize);\n    }\n\n    // Read participant's answer\n    AnswerData partSol = readAns(ouf);\n\n    // Compare participant's solution with official solution in terms of:\n    // (1) intersection size\n    // (2) among solutions with equal intersection, total length\n    if (jurySol.intersectionSize > partSol.intersectionSize) {\n        quitf(_wa,\n            \"participant's intersection size (%lld) is less than the jury's (%lld)\",\n            partSol.intersectionSize, jurySol.intersectionSize);\n    } else if (jurySol.intersectionSize < partSol.intersectionSize) {\n        quitf(_fail,\n            \"participant's intersection size (%lld) is greater than the jury's (%lld)\",\n            partSol.intersectionSize, jurySol.intersectionSize);\n    } else {\n        // intersection sizes are equal\n        if (jurySol.totalLength > partSol.totalLength) {\n            quitf(_wa,\n                \"intersection size is the same (%lld), but participant's total length (%lld) is less than jury's (%lld)\",\n                jurySol.intersectionSize, partSol.totalLength, jurySol.totalLength);\n        } else if (jurySol.totalLength < partSol.totalLength) {\n            quitf(_fail,\n                \"intersection size is the same (%lld), but participant's total length (%lld) is greater than jury's (%lld)\",\n                jurySol.intersectionSize, partSol.totalLength, jurySol.totalLength);\n        } else {\n            // Exactly the same intersection size and total length\n            quitf(_ok,\n                \"OK: intersection=%lld, totalLength=%lld\",\n                partSol.intersectionSize, partSol.totalLength);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int> > edges;\n    vector<int> nodes;\n\n    if (n < 6) {\n        fprintf(stderr, \"Error: n must be at least 6.\\n\");\n        return 1;\n    }\n\n    if (type == \"chain\") {\n        // Generate a chain (path)\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({i - 1, i});\n    } else if (type == \"star\") {\n        // Generate a star\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for(int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"special\") {\n        if (n < 10) {\n            fprintf(stderr, \"Error: n must be at least 10 for special type.\\n\");\n            return 1;\n        }\n        // Generate a special tree designed to satisfy the problem's conditions\n        int centralPathLength = n / 5;\n        if (centralPathLength < 5) centralPathLength = 5;\n        vector<int> centralPathNodes;\n        int nodeId = 1;\n        for(int i = 0; i < centralPathLength; ++i) {\n            centralPathNodes.push_back(nodeId++);\n            if (i > 0)\n                edges.push_back({centralPathNodes[i - 1], centralPathNodes[i]});\n        }\n\n        // Branches from central path\n        int mid = centralPathLength / 2;\n        int x1 = nodeId++;\n        int y1 = nodeId++;\n        int x2 = nodeId++;\n        int y2 = nodeId++;\n\n        edges.push_back({centralPathNodes[mid], x1});\n        edges.push_back({centralPathNodes[mid], x2});\n        edges.push_back({centralPathNodes[mid + 1], y1});\n        edges.push_back({centralPathNodes[mid + 1], y2});\n\n        // Additional nodes connected randomly\n        while (nodeId <= n) {\n            int u = nodeId++;\n            int v = rnd.any(centralPathNodes);\n            edges.push_back({u, v});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n + 1); // Node labels from 1 to n\n    for(int i = 1; i <= n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Relabel edges\n    for(auto &e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int> > edges;\n    vector<int> nodes;\n\n    if (n < 6) {\n        fprintf(stderr, \"Error: n must be at least 6.\\n\");\n        return 1;\n    }\n\n    if (type == \"chain\") {\n        // Generate a chain (path)\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({i - 1, i});\n    } else if (type == \"star\") {\n        // Generate a star\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for(int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"special\") {\n        if (n < 10) {\n            fprintf(stderr, \"Error: n must be at least 10 for special type.\\n\");\n            return 1;\n        }\n        // Generate a special tree designed to satisfy the problem's conditions\n        int centralPathLength = n / 5;\n        if (centralPathLength < 5) centralPathLength = 5;\n        vector<int> centralPathNodes;\n        int nodeId = 1;\n        for(int i = 0; i < centralPathLength; ++i) {\n            centralPathNodes.push_back(nodeId++);\n            if (i > 0)\n                edges.push_back({centralPathNodes[i - 1], centralPathNodes[i]});\n        }\n\n        // Branches from central path\n        int mid = centralPathLength / 2;\n        int x1 = nodeId++;\n        int y1 = nodeId++;\n        int x2 = nodeId++;\n        int y2 = nodeId++;\n\n        edges.push_back({centralPathNodes[mid], x1});\n        edges.push_back({centralPathNodes[mid], x2});\n        edges.push_back({centralPathNodes[mid + 1], y1});\n        edges.push_back({centralPathNodes[mid + 1], y2});\n\n        // Additional nodes connected randomly\n        while (nodeId <= n) {\n            int u = nodeId++;\n            int v = rnd.any(centralPathNodes);\n            edges.push_back({u, v});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n + 1); // Node labels from 1 to n\n    for(int i = 1; i <= n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Relabel edges\n    for(auto &e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 6 -type chain\n./gen -n 6 -type star\n./gen -n 6 -type random\n./gen -n 6 -type special\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type random\n./gen -n 10 -type special\n\n./gen -n 50 -type chain\n./gen -n 50 -type star\n./gen -n 50 -type random\n./gen -n 50 -type special\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type random\n./gen -n 100 -type special\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type random\n./gen -n 1000 -type special\n\n./gen -n 10000 -type chain\n./gen -n 10000 -type star\n./gen -n 10000 -type random\n./gen -n 10000 -type special\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type random\n./gen -n 100000 -type special\n\n./gen -n 200000 -type random\n./gen -n 200000 -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:55.627079",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1073/G",
      "title": "G. Yet Another LCP Problem",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and qq (1≤n,q≤2⋅1051≤n,q≤2⋅105) — the length of string ss and the number of queries, respectively.The second line contains a string ss consisting of lowercase Latin letters (|s|=n|s|=n).Next 3q3q lines contains descriptions of queries — three lines per query. The first line of each query contains two integers kiki and lili (1≤ki,li≤n1≤ki,li≤n) — sizes of sets aa and bb respectively.The second line of each query contains kiki integers a1,a2,…akia1,a2,…aki (1≤a1<a2<⋯<aki≤n1≤a1<a2<⋯<aki≤n) — set aa.The third line of each query contains lili integers b1,b2,…blib1,b2,…bli (1≤b1<b2<⋯<bli≤n1≤b1<b2<⋯<bli≤n) — set bb.It is guaranteed that ∑i=1i=qki≤2⋅105∑i=1i=qki≤2⋅105 and ∑i=1i=qli≤2⋅105∑i=1i=qli≤2⋅105.",
      "output_spec": "OutputPrint qq integers — answers for the queries in the same order queries are given in the input.",
      "sample_tests": "ExampleInputCopy7 4abacaba2 21 21 23 11 2 371 711 2 3 4 5 6 72 21 51 5OutputCopy1321216",
      "description": "G. Yet Another LCP Problem\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and qq (1≤n,q≤2⋅1051≤n,q≤2⋅105) — the length of string ss and the number of queries, respectively.The second line contains a string ss consisting of lowercase Latin letters (|s|=n|s|=n).Next 3q3q lines contains descriptions of queries — three lines per query. The first line of each query contains two integers kiki and lili (1≤ki,li≤n1≤ki,li≤n) — sizes of sets aa and bb respectively.The second line of each query contains kiki integers a1,a2,…akia1,a2,…aki (1≤a1<a2<⋯<aki≤n1≤a1<a2<⋯<aki≤n) — set aa.The third line of each query contains lili integers b1,b2,…blib1,b2,…bli (1≤b1<b2<⋯<bli≤n1≤b1<b2<⋯<bli≤n) — set bb.It is guaranteed that ∑i=1i=qki≤2⋅105∑i=1i=qki≤2⋅105 and ∑i=1i=qli≤2⋅105∑i=1i=qli≤2⋅105.\n\nOutputPrint qq integers — answers for the queries in the same order queries are given in the input.\n\nInputCopy7 4abacaba2 21 21 23 11 2 371 711 2 3 4 5 6 72 21 51 5OutputCopy1321216\n\nInputCopy7 4abacaba2 21 21 23 11 2 371 711 2 3 4 5 6 72 21 51 5\n\nOutputCopy1321216\n\nNoteDescription of queries:   In the first query s[1…7]=abacabas[1…7]=abacaba and s[2…7]=bacabas[2…7]=bacaba are considered. The answer for the query is LCP(abacaba,abacaba)+LCP(abacaba,bacaba)+LCP(bacaba,abacaba)+LCP(bacaba,bacaba)=7+0+0+6=13LCP(abacaba,abacaba)+LCP(abacaba,bacaba)+LCP(bacaba,abacaba)+LCP(bacaba,bacaba)=7+0+0+6=13. In the second query s[1…7]=abacabas[1…7]=abacaba, s[2…7]=bacabas[2…7]=bacaba, s[3…7]=acabas[3…7]=acaba and s[7…7]=as[7…7]=a are considered. The answer for the query is LCP(abacaba,a)+LCP(bacaba,a)+LCP(acaba,a)=1+0+1=2LCP(abacaba,a)+LCP(bacaba,a)+LCP(acaba,a)=1+0+1=2. In the third query s[1…7]=abacabas[1…7]=abacaba are compared with all suffixes. The answer is the sum of non-zero values: LCP(abacaba,abacaba)+LCP(abacaba,acaba)+LCP(abacaba,aba)+LCP(abacaba,a)=7+1+3+1=12LCP(abacaba,abacaba)+LCP(abacaba,acaba)+LCP(abacaba,aba)+LCP(abacaba,a)=7+1+3+1=12. In the fourth query s[1…7]=abacabas[1…7]=abacaba and s[5…7]=abas[5…7]=aba are considered. The answer for the query is LCP(abacaba,abacaba)+LCP(abacaba,aba)+LCP(aba,abacaba)+LCP(aba,aba)=7+3+3+3=16LCP(abacaba,abacaba)+LCP(abacaba,aba)+LCP(aba,abacaba)+LCP(aba,aba)=7+3+3+3=16.",
      "solutions": [
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces",
          "content": "On Thursday, October 25, 2018 at 22:35UTC+8 Educational Codeforces Round 53 (Rated for Div. 2) will start.Series of Educational Rounds continue being held as Harbour.Space University initiative! You can read the details about the cooperation between Harbour.Space University and Codeforces in the blog post.This round will be rated for the participants with rating lower than 2100. It will be held on extented ACM ICPC rules. The penalty for each incorrect submission until the submission with a full solution is 10 minutes. After the end of the contest you will have 12 hours to hack any solution you want. You will have access to copy any solution and test it locally.You will be given 7 problems and 2 hours to solve them.The problems were invented and prepared by Roman Roms Glazov, Adilbek adedalic Dalabaev, Vladimir vovuh Petrov, Ivan BledDest Androsov and me.Good luck to all participants!Our friends at Harbour.Space also have a message for you:Hey Codeforces! We want to remind you that the Scholarship for the Master’s in Robotics programme, which starts on January 7th 2019, has an application deadline of November 12th, 2018.Harbour.Space University and Remy Robotics are collaborating to offer graduate students from anywhere in the world a once in a lifetime opportunity, a fully funded scholarship for Harbour.Space University’s Master’s Programme in Robotics. The scholarship value is €34.900 and it includes: Complete coverage of the University tuition fee (€22,900) Internship at Remy Robotics (20h per week during 1 year) €1,000 per month during 1 year (Internship earnings) Apply hereUPD: vovuh and me will be waiting for you on the community Discord server shortly after the contest to discuss the problems.Congratulations to the winners: Rank Competitor Problems Solved Penalty 1 pekempey 7 305 2 ko_osaga 7 578 3 Lewin 6 216 4 fanache99 6 226 5 natsugiri 6 257 Congratulations to the best hackers: Rank Competitor Hack Count 1 halyavin 238:-15 2 Laggy 64:-14 3 MarcosK 59:-9 4 Mistra 8:-1 5 LordVoldebug 7:-1 482 successful hacks and 684 unsuccessful hacks were made in total!And finally people who were the first to solve each problem: Problem Competitor Penalty A Dalgerok 0:01 B dorijanlendvaj 0:02 C fanache99 0:10 D bazsi700 0:13 E DAyamaCTF 0:21 F Noam527 0:48 G ko_osaga 0:24 UPD2: Editorial is published",
          "author": "awoo",
          "url": "https://codeforces.com/blog/entry/62683",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2335
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces",
          "content": "1073A - Diverse Substring Tutorial1073A - Diverse SubstringNotice that the string of two distinct letter is already diverse. That implies that the answer is \"NO\" if and only if all the letters in the string are the same. Otherwise you can check all pairs of adjacent letters in O(n)O(n).Overall complexity: O(n)O(n). Solution (PikMike)n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")1073B - Vasya and Books Tutorial1073B - Vasya and BooksLet's maintain the pointer pospos to the topmost non-deleted book and whether each book whether is removed from the stack or not. Initially, all books are in a stack, and pospos is 0 (if we store the array 0-indexed). We will process the array BB in the order b1,b2,…bnb1,b2,…bn. If the current book bibi is removed from the stack, then the answer for it is zero. Otherwise, we will increment the pointer pospos until the equality apos=biapos=bi is satisfied, while marking all the intermediate books in the array uu. After that, the answer for the book bibi will be the number of marked books in the uu array (including itself).Since the pointer pospos shifts nn times at total, we get a solution with an O(n)O(n) complexity. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n for(int i = 0; i < n; ++i) {\n \tscanf(\"%d\", a + i);\n }\n for(int i = 0; i < n; ++i){\n \tscanf(\"%d\", b + i);\n }\n\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t} \n\n\tputs(\"\");\n return 0;\n}1073C - Vasya and Robot Tutorial1073C - Vasya and RobotDenote d=|x|+|y​|d=|x|+|y​|. If d>nd>n, then the answer is -1, since the robot will not have the time to reach (x,y)(x,y) cell in nn steps. Also, if dd and nn have different parity, then the answer is also -1, as in one move the robot changes the parity of the sum of its coordinates.In all other cases, the answer exists. Let's use binary search to solve this problem. Consider all segments of length lenlen. For a fixed length of the segment lenlen, let's iterate over the position of the beginning of the segment ll. At the same time, we will maintain the cell that the robot will stop at if it execute all commands, except commands with indices l,l+1,…,l+len−1l,l+1,…,l+len−1. We denote this position as (x0,y0)(x0,y0). We also calculate the distances from the cell (x0,y0)(x0,y0) to the cell (x,y)(x,y) — the value d0=|x−x0|+|y​​−y0|d0=|x−x0|+|y​​−y0|. If there is at least one position of the beginning of the segment for which d0≤lend0≤len, then we can change the segment of length lenlen so that the robot comes to the (x,y)(x,y) cell, otherwise it can't. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tcout << r << endl;\n return 0;\n}1073D - Berland Fair Tutorial1073D - Berland FairLet's code the following process. Go one circle across the booths, calculate the total cost CC of sweets bought and the number SS of sweets bought. Now you can decrease you money down to T=T mod CT=T mod C and add S⋅(T div C)S⋅(T div C) to answer. It represents that you went maximum number of such circles. The later circles will have smaller cost. Let's continue this process until TT becomes smaller than the minimum priced sweet.The number of operations made is O(logT)O(log⁡T). Let TcurTcur be the amount of money before some operation, CcurCcur be the total cost of sweets bought on that operation and Tnew=Tcur mod CcurTnew=Tcur mod Ccur. TnewTnew is actually smaller than CcurCcur (that's how modulo works) and smaller than Tcur−CcurTcur−Ccur (that's also how modulo works). And these inequalities imply that Tnew<Tcur2Tnew<Tcur2. That leads to about O(logT)O(log⁡T) steps to reach the minimal price.Overall complexity: O(nlogT)O(nlog⁡T). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}1073E - Segment Sum Tutorial1073E - Segment SumLet's calculate the answer as the sum of suitable numbers in range [1;r][1;r] minus the sum of suitable numbers in range [1;l−1][1;l−1]. Now our problem is to calculate the sum of suitable numbers in range [1;n][1;n].The main approach for this problem is digit DP. Let's calculate two dynamic programmings dppos,mask,fdppos,mask,f and dpspos,mask,fdpspos,mask,f. pospos means that now we are at the pospos-th digit of the number nn (at the digit corresponding to 10len−pos−110len−pos−1, where lenlen is the decimal length of a number), maskmask is a binary mask describing digits we already use and ff equals 11 if the current prefix of number we trying to obtain is the same as the prefix of number nn (otherwise ff equals 00).So what means dppos,mask,fdppos,mask,f? It means the count of numbers (in general, not numbers but their prefixes) in range [1;n][1;n] of length exactly |n||n| without leading zeroes corresponding to this state. So what the point of this DP? Its point is helping us to calculate the main DP, dpspos,mask,fdpspos,mask,f, which means the sum of numbers (in general, not numbers but their prefixes) in range [1;n][1;n] of length exactly |n||n| without leading zeroes corresponding to this state.How do we calculate the answer? Firstly, let lenlen be the length of nn. Let calc(n)calc(n) be the function calculating the sum of numbers from 11 to nn containing at most kk different digits. How to calculate it? Let calcdp(x)calcdp(x) be the sum of numbers from 11 to xx containing at most kk different digits and having length exactly |x||x|. Then calc(n)calc(n) seems to be pretty easy: for each length ii from 11 to len−1len−1 add to the answer calcdp(10i−1)calcdp(10i−1). And the last step is to add to the answer calcdp(n)calcdp(n).How to calculate dynamic programmings? Initially, all states are zeroes (excluding dp0,0,1dp0,0,1, which is 11).Firstly, let's calculate dpdp. After calculating it we can calculate dpsdps in almost the same way. Let's iterate over all possible lengths and over all possible masks. Let the current state is dppos,mask,0dppos,mask,0. Then let's iterate over next digit we will place in this number and place it. If pos=0pos=0 then dig=1…9dig=1…9 otherwise dig=0…9dig=0…9. The transition is pretty easy: dppos+1,mask|2dig,0+=dppos,mask,0dppos+1,mask|2dig,0+=dppos,mask,0. There || is the bitwise OR operation. For f=1f=1 transitions are almost the same expect the restrictions on digit we place and the state we update. If we now at the position pospos with mask maskmask and f=1f=1 then the current digit of nn is nposnpos. Then let's iterate over next digit: dig=1…nposdig=1…npos if pos=0pos=0 otherwise dig=0…nposdig=0…npos. The transition is also easy: dppos+1,mask|2dig,dig=npos+=dppos,mask,fdppos+1,mask|2dig,dig=npos+=dppos,mask,f.After calculating the previous DP we can calculate dpsdps. All the process is the same as in the previous dynamic programming expect the value we will add in transitions. In the previous DP this value was equal dppos,mask,fdppos,mask,f, in the current DP this value equals to val=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,fval=dpspos,mask,f+dig⋅10len−pos−1⋅dppos,mask,f. Don't forget to calculate it modulo 998244353998244353!So after calculating all the values of DPs, what is the answer for calcdp(n)calcdp(n)? It is ∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1∑mask=0210−1dps|n|,mask,0+dps|n|,mask,1 for all masks with at most kk bits.I'm pretty sure that there is another way to avoid leading zeroes in calculating these DPs but this one is very straight-forward and simple. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\n\treturn 0;\n}1073F - Choosing Two Paths Tutorial1073F - Choosing Two PathsFirstly, let's call a path from uu to vv good, if uu is a leaf, vv is a vertex of degree at least 33 (the number of their neighbors is at least 33) and there are no other vertices of degree at least 33 on this path expect the vertex vv.The first step of the solution is to remove all the good paths from uu to vv (but we should not remove the vertex vv) and remember for each vertex vv the sum of two maximum lengths of good paths which end in the vertex vv. Let this value for the vertex vv be valvvalv. For example, if for some vertex vv there are 33 good paths with end in it of lengths 22, 33 and 55 correspondingly, then valvvalv will be 5+3=85+3=8.Okay, it is easy to see that the maximum intersection of two paths in the answer will be equal to the length of the diameter of the obtained tree. But we can not take any diameter of this tree and call it the answer because of the second constraint: we need to find some diameter from xx to yy such that the sum valx+valyvalx+valy is maximum possible. How do we do that?There is such an awesome (and well-known) fact that the center of a tree belongs to all diameters of this tree. Let's root the tree by the center of a tree (if the length of the diameter is odd (the center of a tree is an edge) then let's root the tree by any end of this edge, it does not matter).There is one case when the length of the diameter is 11 but it is pretty trivial to handle it.Now our problem is to find two neighbors of the root of the new tree such that in their subtrees are vertices which form some diameter of this tree and the sum of values of these vertices is maximum possible. Let's calculate the vertex with the maximum distance from a root (and with the maximum possible valvvalv for equals distances) by simple DFS for each neighbor of a root. It can be done in O(n)O(n) and the last part is to find two maximums of this list, it also can be done in O(n)O(n) or O(nlogn)O(nlog⁡n), depends on implementation. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\n\tpt ans = calc(path[size(path) / 2]);\n\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\n\treturn 0;\n}1073G - Yet Another LCP Problem Tutorial1073G - Yet Another LCP ProblemAt first, implement your favourite string suffix structure for comparing pair of suffixes lexicographically fast enough. For example, it's a Suffix Array + linear LCP + Sparse Table. Now we can compare two suffixes ii and jj by finding l=lcp(i,j)l=lcp(i,j) and comparing s[i+l]s[i+l] with s[j+l]s[j+l].We will process queries online. Let current query be a pair of arrays aa (|a|=k|a|=k) and bb (|b|=l|b|=l). We will calculate answer in two parts: ∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).∑s[ai…n]<s[bj…n]lcp(s[ai…n],s[bj…n])+∑s[ai…n]≥s[bj…n]lcp(s[ai…n],s[bj…n]).To calculate the first sum we can sort all c=a+bc=a+b suffixes in lexicographical order and maintain some information for prefixes of cc. What information we need to maintain? We need some Data Structure which will hold lcplcp of suffixes from aa. When we process some ci=bjci=bj we need just a total sum of all lcplcp in the DS. If ci=ajci=aj, we should add to the DS length of ajaj-th suffix. And when we move from cici to ci+1ci+1 we must recalculate some lcplcp. Since cc is sorted, all we need is to set lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n]))lcpk=min(lcpk,lcp(s[ci…n],s[ci+1…n])).In fact, this Data Structure is just a mapmap. In this mapmap we will hold for each length ll number of suffixes with lcp=llcp=l (we will hold only non-zero values). When we should add some suffix ajaj, we manually increase some value by one. Setting minmin with v=lcp(s[ci…n],s[ci+1…n])v=lcp(s[ci…n],s[ci+1…n]) can be done with decreasing maximum in mapmap while its more than vv. It can be proven, that there will be O(|a|+|b|)O(|a|+|b|) operations with mapmap for one query. The total sum can be maintained in some global variable, which will be recalculated each time mapmap changes.To calculate the second sum we can just reverse cc and run the same algorithm. So total complexity is O(nlog2n+(∑i=1i=qki+∑i=1i=qli)logn)O(nlog2⁡n+(∑i=1i=qki+∑i=1i=qli)log⁡n). Solution (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\n\tif(read()) {\n\t\tsolve();\n\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62742",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1073\\s*G"
          },
          "content_length": 21562
        }
      ],
      "code_examples": [
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 1",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 2",
          "code": "stk.erase(x);\nst.erase((*x).S);\nx++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n#define mp(a,b)   make_pair(a,b)\n#define ll        long long\n#define mp(a,b)   make_pair(a,b)\n#define si(n)     scanf(\"%d\",&n)\n#define sl(n)     scanf(\"%lld\",&n)\n#define pi(n)     printf(\"%d\\n\",n)\n#define pl(n)     printf(\"%lld\\n\",n)\n#define           newline cout << endl;\n#define           ff first\n#define           ss second\n#define           pii pair<int, int>\n#define           pll pair<ll, ll>\nusing namespace std;\n\ntemplate<typename S, typename T> \nostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.ff<<\", \"<<p.ss<<')';return out;}\n\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> const& v){\nint l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}\n\ntemplate<typename T>\nvoid trace(const char* name, T&& arg1){cout<<name<<\" : \"<<arg1<<endl;}\n\ntemplate<typename T, typename... Args>\nvoid trace(const char* names, T&& arg1, Args&&... args){\nconst char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<\" : \"<<arg1<<\" | \";trace(comma+1,args...);}\n\nint main(){\n  //clock_t tStart = clock();\n  int n;\n  string s;\n  ll endx,endy;\n  cin >> n >> s >> endx >> endy;\n  ll x=0,y=0;\n  int cntl=0,cntr=0,cntu=0,cntd=0;\n  for(int i=0;i<n;i++){\n    if(s[i]=='U'){\n      y++;\n      cntu++;\n    }\n    if(s[i]=='D'){\n      y--;\n      cntd++;\n    }\n    if(s[i]=='R'){\n      x++;\n      cntr++;\n    }\n    if(s[i]=='L'){\n      x--;\n      cntl++;\n    }\n  }\n  if(x==endx && y==endy){\n    cout << \"0\\n\";\n  }\n  else{\n    char char1,char2;\n    ll cnt1=-1,cnt2=-1;\n    bool f = 0;\n    if(x>endx){\n      char1='R';\n    }\n    else{\n      char1='L';\n    }\n    if(y>endy){\n      char2='U';\n    }\n    else{\n      char2='D';\n    }\n    ll diff1 = abs(x-endx);\n    ll diff2 = abs(y-endy);\n    if(diff1%2!=0 || diff2%2!=0){\n      f=1;\n    }\n    else{\n      cnt1 = diff1/2;\n      cnt2 = diff2/2;\n    }\n    if(char1=='L' && char2=='U'){\n      if(cntl<cnt1 || cntu<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='L' && char2=='D'){\n      if(cntl<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n    else if(char1=='R' && char2=='U'){\n      if(cntr<cnt1 || cntu<cnt2){\n        f=1;\n      }  \n    }\n    else if(char1=='R' && char2=='D'){\n      if(cntr<cnt1 || cntd<cnt2){\n        f=1;\n      }\n    }\n\n    if(cnt1==0) char1='X';\n    if(cnt2==0) char2='X';\n\n\n    if(f==1){\n      cout << \"-1\\n\";\n      return 0;\n    }\n    ll start=0,e=0,len=1e18, tc1=0,tc2=0;\n    while(start<n){\n      for(;e<n;e++){\n        if(tc1<cnt1 || tc2<cnt2){\n          if(s[e]==char1){\n            tc1++;\n          }\n          if(s[e]==char2){\n            tc2++;\n          }\n        }\n        else{\n          break;\n        }\n      }\n      if(tc1==cnt1 && tc2==cnt2)\n        len = min(len,e-start);\n      if(s[start]==char1) tc1--;\n      if(s[start]==char2) tc2--;\n      start++;\n    }\n    if(len==1e18) len=-1;\n    cout << len << endl;\n  }\n  //printf(\"Time taken: %.2fs\\n\", (double)(clock() - tStart)/CLOCKS_PER_SEC);\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 5",
          "code": "O(n * logn)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 [Rated for Div. 2] - Codeforces - Code 6",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62683",
          "author": "awoo"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 1",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 2",
          "code": "n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 7",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 8",
          "code": "#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 13;\n\ntypedef long long li;\n\nint n;\nint a[N];\n\nvoid get(li T, li& pr, li& cnt){\n\tpr = 0, cnt = 0;\n\tforn(i, n){\n\t\tif (T >= a[i]){\n\t\t\tT -= a[i];\n\t\t\tpr += a[i];\n\t\t\t++cnt;\n\t\t}\n\t}\n}\n\nint main() {\n\tli T;\n\tscanf(\"%d%lld\", &n, &T);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tint mn = *min_element(a, a + n);\n\tli ans = 0;\n\twhile (T >= mn){\n\t\tli pr, cnt;\n\t\tget(T, pr, cnt);\n\t\tans += cnt * (T / pr);\n\t\tT %= pr;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 9",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 10",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<long long, int> pt;\n\nconst int N = 20;\nconst int M = 1 << 10;\nconst int MOD = 998244353;\n\nint k;\nint pw10[N];\nint bitCnt[M];\n\npt dp[N][M][2];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn a * 1ll * b % MOD;\n}\n\nint calc(const string &s) {\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) {\n\t\t\tdp[i][j][0] = dp[i][j][1] = { 0ll, 0 };\n\t\t}\n\t}\n\t\n\tint len = s.size();\n\tdp[0][0][1] = { 1ll, 0 };\n\tfor (int i = 0; i < len; ++i) {\n\t\tint cdig = s[i] - '0';\n\t\tfor (int mask = 0; mask < M; ++mask) {\n\t\t\tif (dp[i][mask][0].x == 0 && dp[i][mask][1].x == 0) continue;\n\t\t\tfor (int dig = (i == 0); dig <= 9; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][0].x;\n\t\t\t\tint sum = add(dp[i][mask][0].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][0].x += cnt;\n\t\t\t\tdp[i + 1][nmask][0].y = add(dp[i + 1][nmask][0].y, sum);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dig = (i == 0); dig <= cdig; ++dig) {\n\t\t\t\tint nmask = mask | (1 << dig);\n\t\t\t\tlong long cnt = dp[i][mask][1].x;\n\t\t\t\tint sum = add(dp[i][mask][1].y, mul(dig, mul(pw10[len - i - 1], cnt % MOD)));\n\t\t\t\tdp[i + 1][nmask][dig == cdig].x += cnt;\n\t\t\t\tdp[i + 1][nmask][dig == cdig].y = add(dp[i + 1][nmask][dig == cdig].y, sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int mask = 0; mask < M; ++mask) {\n\t\tif (bitCnt[mask] > k) continue;\n\t\tans = add(ans, dp[len][mask][0].y);\n\t\tans = add(ans, dp[len][mask][1].y);\n\t}\n\treturn ans;\n}\n\nint calc(long long n) {\n\tint len = to_string(n).size();\n\tint ans = 0;\n\tfor (int l = 1; l < len; ++l) {\n\t\tans = add(ans, calc(string(l, '9')));\n\t}\n\tans = add(ans, calc(to_string(n)));\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tpw10[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tpw10[i] = mul(pw10[i - 1], 10);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tbitCnt[i] = __builtin_popcount(i);\n\t}\n\t\n\tlong long l, r;\n\tcin >> l >> r >> k;\n\tint ans = add(calc(r), -calc(l - 1));\n\tcout << ans << endl;\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 11",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 12",
          "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define size(a) int((a).size())\n\ntypedef pair<int, int> pt;\n\nconst int N = 200 * 1000 + 11;\n\nint n;\nvector<int> g[N];\n\nint p[N];\nint dist[N];\n\nbool bad[N];\nint value[N];\npt res[N];\nvector<pt> best[N];\n\nvoid dfs(int v, int par = -1, int d = 0) {\n\tp[v] = par;\n\tdist[v] = d;\n\tfor (auto to : g[v]) {\n\t\tif (to == par) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nint getFarthest(int v) {\n\tdfs(v);\n\tint res = v;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bad[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (dist[res] < dist[i]) {\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\npt get(int v) {\n\treturn { dist[v], value[v] };\n}\n\nint getBetter(int v, int u) {\n\tif (get(v) > get(u)) {\n\t\treturn v;\n\t}\n\treturn u;\n}\n\nint getBest(int v, int par) {\n\tint res = v;\n\tfor (auto to : g[v]) {\n\t\tif (to == par || bad[to]) {\n\t\t\tcontinue;\n\t\t}\n\t\tres = getBetter(res, getBest(to, v));\n\t}\n\treturn res;\n}\n\npt calc(int v) {\n\tdfs(v);\n\t\n\tvector<int> ch;\n\tfor (auto to : g[v]) {\n\t\tif (!bad[to]) {\n\t\t\tch.push_back(to);\n\t\t}\n\t}\n\tif (size(ch) == 1) {\n\t\treturn { v, ch[0] };\n\t}\n\t\n\tvector<int> pref(size(ch));\n\tvector<int> suf(size(ch));\n\tvector<int> best(size(ch));\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint to = ch[i];\n\t\tbest[i] = pref[i] = suf[i] = getBest(to, v);\n\t}\n\tfor (int i = 1; i < size(ch); ++i) {\n\t\tpref[i] = getBetter(pref[i], pref[i - 1]);\n\t\tsuf[size(ch) - i - 1] = getBetter(suf[size(ch) - i - 1], suf[size(ch) - i]);\n\t}\n\t\n\tpt ans = { -1, -1 };\n\tpt res = { 0, 0 };\n\tfor (int i = 0; i < size(ch); ++i) {\n\t\tint bst = -1;\n\t\tif (i == 0) {\n\t\t\tbst = suf[i + 1];\n\t\t} else if (i + 1 == size(ch)) {\n\t\t\tbst = pref[i - 1];\n\t\t} else {\n\t\t\tbst = getBetter(pref[i - 1], suf[i + 1]);\n\t\t}\n\t\tpt curRes = { dist[bst] + dist[best[i]], value[bst] + value[best[i]] };\n\t\tif (res < curRes) {\n\t\t\tres = curRes;\n\t\t\tans = { best[i], bst };\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\t\n\tint root = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) > 2) {\n\t\t\troot = i;\n\t\t\tdfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(g[i]) != 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint v = i;\n\t\twhile (size(g[v]) < 3) {\n\t\t\tbad[v] = true;\n\t\t\tv = p[v];\n\t\t}\n\t\tbest[v].push_back({dist[i] - dist[v], i});\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (size(best[i]) >= 2) {\n\t\t\tsort(best[i].rbegin(), best[i].rend());\n\t\t\tvalue[i] = best[i][0].first + best[i][1].first;\n\t\t\tres[i] = { best[i][0].second, best[i][1].second };\n\t\t}\n\t}\n\t\n\tint u = getFarthest(root);\n\tint v = getFarthest(u);\n\tvector<int> path;\n\twhile (v != u) {\n\t\tpath.push_back(v);\n\t\tv = p[v];\n\t}\n\tpath.push_back(u);\n\t\n\tpt ans = calc(path[size(path) / 2]);\n\t\n\tprintf(\"%d %d\\n\", res[ans.x].x + 1, res[ans.y].x + 1);\n\tprintf(\"%d %d\\n\", res[ans.x].y + 1, res[ans.y].y + 1);\n\t\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 13",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 14",
          "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\n#define x first\n#define y second\n\ntypedef long long li;\ntypedef pair<int, int> pt;\n\ntemplate<class A, class B> ostream& operator <<(ostream &out, const pair<A, B> &p) {\n\treturn out << \"(\" << p.x << \", \" << p.y << \")\";\n}\ntemplate<class A> ostream& operator <<(ostream &out, const vector<A> &v) {\n\tout << \"[\";\n\tfore(i, 0, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nconst int N = 200 * 1000 + 555;\nconst int LOGN = 18;\n\nint n, q;\nchar s[N];\n\nbool read() {\n\tif(!(cin >> n >> q))\n\t\treturn false;\n\tassert(scanf(\"%s\", s) == 1);\n\treturn true;\n}\n\nint c[N], id[N], lcp[N];\nint mn[LOGN][N];\nint lg2[N];\n\nvoid buildSuffArray() {\n\ts[n++] = '$';\n\t\n\tfor(int l = 1; l < 2 * n; l <<= 1) {\n\t\tvector< pair<pt, int> > d;\n\t\tfore(i, 0, n)\n\t\t\td.emplace_back(l == 1 ? pt(s[i], 0) : pt(c[i], c[(i + (l >> 1)) % n]), i);\n\t\tstable_sort(d.begin(), d.end());\n\t\t\n\t\tc[d[0].y] = 0;\n\t\tfore(i, 1, n)\n\t\t\tc[d[i].y] = c[d[i - 1].y] + (d[i].x != d[i - 1].x);\n\t\tif(c[d.back().y] == n - 1)\n\t\t\tbreak;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tid[c[i]] = i;\n\t\t\n\tint l = 0;\n\tfore(i, 0, n) {\n\t\tif(c[i] == n - 1)\n\t\t\tcontinue;\n\t\tl = max(0, l - 1);\n\t\tint j = id[c[i] + 1];\n\t\t\n\t\twhile(i + l < n && j + l < n && s[i + l] == s[j + l])\n\t\t\tl++;\n\t\tlcp[c[i]] = l;\n\t}\n\t\n\tn--;\n\tlg2[0] = lg2[1] = 0;\n\tfore(i, 2, N) {\n\t\tlg2[i] = lg2[i - 1];\n\t\tif((1 << (lg2[i] + 1)) <= i)\n\t\t\tlg2[i]++;\n\t}\n\t\n\tfore(i, 0, n)\n\t\tmn[0][i] = lcp[i];\n\tfore(pw, 1, LOGN) fore(i, 0, n) {\n\t\tmn[pw][i] = mn[pw - 1][i];\n\t\tif(i + (1 << (pw - 1)) < n)\n\t\t\tmn[pw][i] = min(mn[pw][i], mn[pw - 1][i + (1 << (pw - 1))]);\n\t}\n}\n\nint getMin(int l, int r) {\n\tint ln = lg2[r - l];\n\treturn min(mn[ln][l], mn[ln][r - (1 << ln)]);\n}\n\nint getLCP(int i, int j) {\n\tif(i == j) return n - i;\n\ti = c[i], j = c[j];\n\treturn getMin(min(i, j), max(i, j));\n}\n\nbool cmp(const pt &a, const pt &b) {\n\tif(a.x == b.x)\n\t\treturn a.y < b.y;\n\tint l = getLCP(a.x, b.x);\n\treturn s[a.x + l] < s[b.x + l];\n}\n\nvoid solve() {\n\tbuildSuffArray();\n\t\n\tfore(_, 0, q) {\n\t\tint k, l;\n\t\tassert(scanf(\"%d%d\", &k, &l) == 2);\n\t\tvector<int> a(k), b(l);\n\t\tfore(i, 0, k)\n\t\t\tassert(scanf(\"%d\", &a[i]) == 1), a[i]--;\n\t\tfore(j, 0, l)\n\t\t\tassert(scanf(\"%d\", &b[j]) == 1), b[j]--;\n\t\t\t\n\t\tli ans = 0;\n\t\tvector<pt> c;\n\t\tfor(auto v : a)\n\t\t\tc.emplace_back(v, 1);\n\t\tfor(auto v : b)\n\t\t\tc.emplace_back(v, 0);\n\t\tsort(c.begin(), c.end(), cmp);\n\t\t\n\t\tfore(k, 0, 2) {\n\t\t\tli sum = 0;\n\t\t\tmap<int, int> cnt;\n\t\t\t\n\t\t\tfore(i, 0, sz(c)) {\n\t\t\t\tint id = c[i].x, tp = c[i].y;\n\t\t\t\tif(tp == 0)\n\t\t\t\t\tans += sum;\n\t\t\t\telse {\n\t\t\t\t\tcnt[n - id]++;\n\t\t\t\t\tsum += (n - id);\n\t\t\t\t}\n\t\t\t\tif(i + 1 < sz(c)) {\n\t\t\t\t\tint len = getLCP(c[i].x, c[i + 1].x);\n\t\t\t\t\twhile(!cnt.empty()) {\n\t\t\t\t\t\tauto it = --cnt.end();\n\t\t\t\t\t\tif(it->x <= len)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum -= it->x * 1ll * it->y;\n\t\t\t\t\t\tcnt[len] += it->y;\n\t\t\t\t\t\tsum += it->y * 1ll * len;\n\t\t\t\t\t\tcnt.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(c.begin(), c.end());\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\tcout << fixed << setprecision(15);\n\t\n\tif(read()) {\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 15",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        },
        {
          "title": "Educational Codeforces Round 53 Editorial - Codeforces - Code 16",
          "code": "6 999999998\n1 999999999 1 999999999 1 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62742",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2 * 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 2 * 100000, \"q\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[a-z]+\", \"s\");\n    ensuref(int(s.size()) == n, \"The length of s must be equal to n (%d), but s.size() = %d\", n, int(s.size()));\n    inf.readEoln();\n\n    long long sum_k = 0, sum_l = 0;\n    for (int i = 0; i < q; ++i) {\n        int k_i = inf.readInt(1, n, \"k_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readEoln();\n\n        sum_k += k_i;\n        sum_l += l_i;\n\n        ensuref(sum_k <= 2 * 100000, \"Sum of k_i exceeds 200000 after query %d\", i+1);\n        ensuref(sum_l <= 2 * 100000, \"Sum of l_i exceeds 200000 after query %d\", i+1);\n\n        vector<int> a = inf.readInts(k_i, 1, n, \"a_i\");\n        inf.readEoln();\n\n        for (int j = 0; j < k_i -1; ++j) {\n            ensuref(a[j] < a[j+1], \"a_i sequence not strictly increasing at position %d in query %d\", j+1, i+1);\n        }\n\n        vector<int> b = inf.readInts(l_i, 1, n, \"b_i\");\n        inf.readEoln();\n\n        for (int j = 0; j < l_i -1; ++j) {\n            ensuref(b[j] < b[j+1], \"b_i sequence not strictly increasing at position %d in query %d\", j+1, i+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2 * 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 2 * 100000, \"q\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[a-z]+\", \"s\");\n    ensuref(int(s.size()) == n, \"The length of s must be equal to n (%d), but s.size() = %d\", n, int(s.size()));\n    inf.readEoln();\n\n    long long sum_k = 0, sum_l = 0;\n    for (int i = 0; i < q; ++i) {\n        int k_i = inf.readInt(1, n, \"k_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readEoln();\n\n        sum_k += k_i;\n        sum_l += l_i;\n\n        ensuref(sum_k <= 2 * 100000, \"Sum of k_i exceeds 200000 after query %d\", i+1);\n        ensuref(sum_l <= 2 * 100000, \"Sum of l_i exceeds 200000 after query %d\", i+1);\n\n        vector<int> a = inf.readInts(k_i, 1, n, \"a_i\");\n        inf.readEoln();\n\n        for (int j = 0; j < k_i -1; ++j) {\n            ensuref(a[j] < a[j+1], \"a_i sequence not strictly increasing at position %d in query %d\", j+1, i+1);\n        }\n\n        vector<int> b = inf.readInts(l_i, 1, n, \"b_i\");\n        inf.readEoln();\n\n        for (int j = 0; j < l_i -1; ++j) {\n            ensuref(b[j] < b[j+1], \"b_i sequence not strictly increasing at position %d in query %d\", j+1, i+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2 * 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 2 * 100000, \"q\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[a-z]+\", \"s\");\n    ensuref(int(s.size()) == n, \"The length of s must be equal to n (%d), but s.size() = %d\", n, int(s.size()));\n    inf.readEoln();\n\n    long long sum_k = 0, sum_l = 0;\n    for (int i = 0; i < q; ++i) {\n        int k_i = inf.readInt(1, n, \"k_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readEoln();\n\n        sum_k += k_i;\n        sum_l += l_i;\n\n        ensuref(sum_k <= 2 * 100000, \"Sum of k_i exceeds 200000 after query %d\", i+1);\n        ensuref(sum_l <= 2 * 100000, \"Sum of l_i exceeds 200000 after query %d\", i+1);\n\n        vector<int> a = inf.readInts(k_i, 1, n, \"a_i\");\n        inf.readEoln();\n\n        for (int j = 0; j < k_i -1; ++j) {\n            ensuref(a[j] < a[j+1], \"a_i sequence not strictly increasing at position %d in query %d\", j+1, i+1);\n        }\n\n        vector<int> b = inf.readInts(l_i, 1, n, \"b_i\");\n        inf.readEoln();\n\n        for (int j = 0; j < l_i -1; ++j) {\n            ensuref(b[j] < b[j+1], \"b_i sequence not strictly increasing at position %d in query %d\", j+1, i+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generate_unique_positions(int n, int k) {\n    assert(k <= n);\n    set<int> positions;\n    while (int(positions.size()) < k) {\n        positions.insert(rnd.next(1, n));\n    }\n    vector<int> result(positions.begin(), positions.end());\n    sort(result.begin(), result.end());\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate the string s according to s_type\n    string s;\n    if (s_type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(0, 25);\n        }\n    } else if (s_type == \"same_char\") {\n        char c = 'a' + rnd.next(0, 25);\n        s = string(n, c);\n    } else if (s_type == \"palindrome\") {\n        string half;\n        int half_len = n / 2;\n        for (int i = 0; i < half_len; ++i) {\n            half += 'a' + rnd.next(0, 25);\n        }\n        s = half;\n        if (n % 2 == 1) {\n            s += 'a' + rnd.next(0, 25);\n        }\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (s_type == \"double_string\") {\n        string t;\n        int t_len = n / 2;\n        for (int i = 0; i < t_len; ++i) {\n            t += 'a' + rnd.next(0, 25);\n        }\n        s = t + t;\n        if (s.size() < n) {\n            s += 'a' + rnd.next(0, 25);\n        }\n    } else if (s_type == \"alternating\") {\n        char c1 = 'a' + rnd.next(0, 25);\n        char c2 = c1;\n        while (c2 == c1)\n            c2 = 'a' + rnd.next(0, 25);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (s_type == \"binary\") {\n        char c1 = 'a' + rnd.next(0, 25);\n        char c2 = c1;\n        while (c2 == c1)\n            c2 = 'a' + rnd.next(0, 25);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(0, 1) == 0) ? c1 : c2;\n        }\n    } else {\n        // Default to random\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(0, 25);\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n    printf(\"%s\\n\", s.c_str());\n\n    // Generate the queries according to query_type\n    int total_allowed_k = 200000;\n    int total_allowed_l = 200000;\n    vector<int> k_values(q), l_values(q);\n\n    if (query_type == \"max_size\") {\n        // Distribute total_allowed_k and total_allowed_l over queries equally\n        int avg_k = total_allowed_k / q;\n        int remainder_k = total_allowed_k % q;\n\n        int avg_l = total_allowed_l / q;\n        int remainder_l = total_allowed_l % q;\n\n        for (int i = 0; i < q; ++i) {\n            k_values[i] = avg_k;\n            l_values[i] = avg_l;\n        }\n\n        for (int i = 0; i < remainder_k; ++i) {\n            k_values[i]++;\n        }\n\n        for (int i = 0; i < remainder_l; ++i) {\n            l_values[i]++;\n        }\n\n        // Ensure k_i ≤ n\n        for (int i = 0; i < q; ++i) {\n            k_values[i] = min(k_values[i], n);\n            l_values[i] = min(l_values[i], n);\n        }\n\n    } else if (query_type == \"min_size\") {\n        fill(k_values.begin(), k_values.end(), 1);\n        fill(l_values.begin(), l_values.end(), 1);\n    } else { // Random or other query_types\n        int remaining_k = total_allowed_k;\n        int remaining_l = total_allowed_l;\n\n        for (int i = 0; i < q; ++i) {\n            int remaining_queries = q - i;\n            int max_k_i = min(n, remaining_k - (remaining_queries - 1)); // Ensure at least 1 per remaining query\n            int max_l_i = min(n, remaining_l - (remaining_queries - 1));\n\n            int min_k_i = 1;\n            int min_l_i = 1;\n\n            k_values[i] = rnd.next(min_k_i, max_k_i);\n            remaining_k -= k_values[i];\n\n            l_values[i] = rnd.next(min_l_i, max_l_i);\n            remaining_l -= l_values[i];\n        }\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int k_i = k_values[i];\n        int l_i = l_values[i];\n\n        vector<int> a_i, b_i;\n\n        if (query_type == \"same_positions\") {\n            int positions_size = max(k_i, l_i);\n            vector<int> positions = generate_unique_positions(n, positions_size);\n            a_i.assign(positions.begin(), positions.begin() + k_i);\n            b_i.assign(positions.begin(), positions.begin() + l_i);\n        } else if (query_type == \"overlapping\") {\n            int overlap_size = rnd.next(1, min(k_i, l_i));\n            vector<int> overlap_positions = generate_unique_positions(n, overlap_size);\n\n            int a_remaining = k_i - overlap_size;\n            int b_remaining = l_i - overlap_size;\n\n            vector<int> a_positions = overlap_positions;\n            vector<int> b_positions = overlap_positions;\n\n            if (a_remaining > 0) {\n                vector<int> a_extra = generate_unique_positions(n, a_remaining);\n                a_positions.insert(a_positions.end(), a_extra.begin(), a_extra.end());\n            }\n\n            if (b_remaining > 0) {\n                vector<int> b_extra = generate_unique_positions(n, b_remaining);\n                b_positions.insert(b_positions.end(), b_extra.begin(), b_extra.end());\n            }\n\n            sort(a_positions.begin(), a_positions.end());\n            a_positions.erase(unique(a_positions.begin(), a_positions.end()), a_positions.end());\n            while (int(a_positions.size()) < k_i) {\n                int new_pos = rnd.next(1, n);\n                a_positions.push_back(new_pos);\n                sort(a_positions.begin(), a_positions.end());\n                a_positions.erase(unique(a_positions.begin(), a_positions.end()), a_positions.end());\n            }\n\n            sort(b_positions.begin(), b_positions.end());\n            b_positions.erase(unique(b_positions.begin(), b_positions.end()), b_positions.end());\n            while (int(b_positions.size()) < l_i) {\n                int new_pos = rnd.next(1, n);\n                b_positions.push_back(new_pos);\n                sort(b_positions.begin(), b_positions.end());\n                b_positions.erase(unique(b_positions.begin(), b_positions.end()), b_positions.end());\n            }\n\n            a_i = a_positions;\n            b_i = b_positions;\n        } else { // Random or other types\n            a_i = generate_unique_positions(n, k_i);\n            b_i = generate_unique_positions(n, l_i);\n        }\n\n        // Output k_i and l_i\n        printf(\"%d %d\\n\", k_i, l_i);\n        // Output a_i\n        for (int j = 0; j < k_i; ++j) {\n            printf(\"%d%c\", a_i[j], j == k_i - 1 ? '\\n' : ' ');\n        }\n        // Output b_i\n        for (int j = 0; j < l_i; ++j) {\n            printf(\"%d%c\", b_i[j], j == l_i - 1 ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> generate_unique_positions(int n, int k) {\n    assert(k <= n);\n    set<int> positions;\n    while (int(positions.size()) < k) {\n        positions.insert(rnd.next(1, n));\n    }\n    vector<int> result(positions.begin(), positions.end());\n    sort(result.begin(), result.end());\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate the string s according to s_type\n    string s;\n    if (s_type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(0, 25);\n        }\n    } else if (s_type == \"same_char\") {\n        char c = 'a' + rnd.next(0, 25);\n        s = string(n, c);\n    } else if (s_type == \"palindrome\") {\n        string half;\n        int half_len = n / 2;\n        for (int i = 0; i < half_len; ++i) {\n            half += 'a' + rnd.next(0, 25);\n        }\n        s = half;\n        if (n % 2 == 1) {\n            s += 'a' + rnd.next(0, 25);\n        }\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (s_type == \"double_string\") {\n        string t;\n        int t_len = n / 2;\n        for (int i = 0; i < t_len; ++i) {\n            t += 'a' + rnd.next(0, 25);\n        }\n        s = t + t;\n        if (s.size() < n) {\n            s += 'a' + rnd.next(0, 25);\n        }\n    } else if (s_type == \"alternating\") {\n        char c1 = 'a' + rnd.next(0, 25);\n        char c2 = c1;\n        while (c2 == c1)\n            c2 = 'a' + rnd.next(0, 25);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (s_type == \"binary\") {\n        char c1 = 'a' + rnd.next(0, 25);\n        char c2 = c1;\n        while (c2 == c1)\n            c2 = 'a' + rnd.next(0, 25);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (rnd.next(0, 1) == 0) ? c1 : c2;\n        }\n    } else {\n        // Default to random\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(0, 25);\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n    printf(\"%s\\n\", s.c_str());\n\n    // Generate the queries according to query_type\n    int total_allowed_k = 200000;\n    int total_allowed_l = 200000;\n    vector<int> k_values(q), l_values(q);\n\n    if (query_type == \"max_size\") {\n        // Distribute total_allowed_k and total_allowed_l over queries equally\n        int avg_k = total_allowed_k / q;\n        int remainder_k = total_allowed_k % q;\n\n        int avg_l = total_allowed_l / q;\n        int remainder_l = total_allowed_l % q;\n\n        for (int i = 0; i < q; ++i) {\n            k_values[i] = avg_k;\n            l_values[i] = avg_l;\n        }\n\n        for (int i = 0; i < remainder_k; ++i) {\n            k_values[i]++;\n        }\n\n        for (int i = 0; i < remainder_l; ++i) {\n            l_values[i]++;\n        }\n\n        // Ensure k_i ≤ n\n        for (int i = 0; i < q; ++i) {\n            k_values[i] = min(k_values[i], n);\n            l_values[i] = min(l_values[i], n);\n        }\n\n    } else if (query_type == \"min_size\") {\n        fill(k_values.begin(), k_values.end(), 1);\n        fill(l_values.begin(), l_values.end(), 1);\n    } else { // Random or other query_types\n        int remaining_k = total_allowed_k;\n        int remaining_l = total_allowed_l;\n\n        for (int i = 0; i < q; ++i) {\n            int remaining_queries = q - i;\n            int max_k_i = min(n, remaining_k - (remaining_queries - 1)); // Ensure at least 1 per remaining query\n            int max_l_i = min(n, remaining_l - (remaining_queries - 1));\n\n            int min_k_i = 1;\n            int min_l_i = 1;\n\n            k_values[i] = rnd.next(min_k_i, max_k_i);\n            remaining_k -= k_values[i];\n\n            l_values[i] = rnd.next(min_l_i, max_l_i);\n            remaining_l -= l_values[i];\n        }\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int k_i = k_values[i];\n        int l_i = l_values[i];\n\n        vector<int> a_i, b_i;\n\n        if (query_type == \"same_positions\") {\n            int positions_size = max(k_i, l_i);\n            vector<int> positions = generate_unique_positions(n, positions_size);\n            a_i.assign(positions.begin(), positions.begin() + k_i);\n            b_i.assign(positions.begin(), positions.begin() + l_i);\n        } else if (query_type == \"overlapping\") {\n            int overlap_size = rnd.next(1, min(k_i, l_i));\n            vector<int> overlap_positions = generate_unique_positions(n, overlap_size);\n\n            int a_remaining = k_i - overlap_size;\n            int b_remaining = l_i - overlap_size;\n\n            vector<int> a_positions = overlap_positions;\n            vector<int> b_positions = overlap_positions;\n\n            if (a_remaining > 0) {\n                vector<int> a_extra = generate_unique_positions(n, a_remaining);\n                a_positions.insert(a_positions.end(), a_extra.begin(), a_extra.end());\n            }\n\n            if (b_remaining > 0) {\n                vector<int> b_extra = generate_unique_positions(n, b_remaining);\n                b_positions.insert(b_positions.end(), b_extra.begin(), b_extra.end());\n            }\n\n            sort(a_positions.begin(), a_positions.end());\n            a_positions.erase(unique(a_positions.begin(), a_positions.end()), a_positions.end());\n            while (int(a_positions.size()) < k_i) {\n                int new_pos = rnd.next(1, n);\n                a_positions.push_back(new_pos);\n                sort(a_positions.begin(), a_positions.end());\n                a_positions.erase(unique(a_positions.begin(), a_positions.end()), a_positions.end());\n            }\n\n            sort(b_positions.begin(), b_positions.end());\n            b_positions.erase(unique(b_positions.begin(), b_positions.end()), b_positions.end());\n            while (int(b_positions.size()) < l_i) {\n                int new_pos = rnd.next(1, n);\n                b_positions.push_back(new_pos);\n                sort(b_positions.begin(), b_positions.end());\n                b_positions.erase(unique(b_positions.begin(), b_positions.end()), b_positions.end());\n            }\n\n            a_i = a_positions;\n            b_i = b_positions;\n        } else { // Random or other types\n            a_i = generate_unique_positions(n, k_i);\n            b_i = generate_unique_positions(n, l_i);\n        }\n\n        // Output k_i and l_i\n        printf(\"%d %d\\n\", k_i, l_i);\n        // Output a_i\n        for (int j = 0; j < k_i; ++j) {\n            printf(\"%d%c\", a_i[j], j == k_i - 1 ? '\\n' : ' ');\n        }\n        // Output b_i\n        for (int j = 0; j < l_i; ++j) {\n            printf(\"%d%c\", b_i[j], j == l_i - 1 ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -q 5 -s_type random -query_type random\n./gen -n 10 -q 5 -s_type same_char -query_type same_positions\n./gen -n 10 -q 5 -s_type palindrome -query_type overlapping\n./gen -n 50 -q 10 -s_type alternating -query_type min_size\n./gen -n 50 -q 10 -s_type binary -query_type max_size\n\n./gen -n 1000 -q 20 -s_type random -query_type random\n./gen -n 1000 -q 20 -s_type same_char -query_type overlapping\n./gen -n 1000 -q 20 -s_type palindrome -query_type same_positions\n./gen -n 1000 -q 20 -s_type alternating -query_type min_size\n./gen -n 1000 -q 20 -s_type binary -query_type max_size\n\n./gen -n 200000 -q 200000 -s_type random -query_type random\n./gen -n 200000 -q 200000 -s_type same_char -query_type overlapping\n./gen -n 200000 -q 200000 -s_type palindrome -query_type same_positions\n./gen -n 200000 -q 200000 -s_type alternating -query_type min_size\n./gen -n 200000 -q 200000 -s_type binary -query_type max_size\n\n./gen -n 200000 -q 1 -s_type palindrome -query_type max_size\n./gen -n 1 -q 1 -s_type same_char -query_type min_size\n./gen -n 100 -q 500 -s_type alternating -query_type overlapping\n./gen -n 150000 -q 50000 -s_type random -query_type random\n./gen -n 200000 -q 1 -s_type double_string -query_type max_size\n\n./gen -n 100000 -q 100000 -s_type random -query_type random\n./gen -n 50000 -q 100000 -s_type alternating -query_type overlapping\n./gen -n 200000 -q 5 -s_type same_char -query_type max_size\n./gen -n 10000 -q 20000 -s_type palindrome -query_type same_positions\n./gen -n 150000 -q 1 -s_type binary -query_type max_size\n\n./gen -n 200000 -q 200000 -s_type random -query_type min_size\n./gen -n 200000 -q 200000 -s_type random -query_type overlapping\n./gen -n 200000 -q 200000 -s_type random -query_type same_positions\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:57.422238",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1075/A",
      "title": "A. The King's Race",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer nn (2≤n≤10182≤n≤1018) — the length of the side of the chess field.The second line contains two integers xx and yy (1≤x,y≤n1≤x,y≤n) — coordinates of the cell, where the coin fell.",
      "output_spec": "OutputIn a single line print the answer \"White\" (without quotes), if the white king will win, or \"Black\" (without quotes), if the black king will win.You can print each letter in any case (upper or lower).",
      "sample_tests": "ExamplesInputCopy42 3OutputCopyWhiteInputCopy53 5OutputCopyBlackInputCopy22 2OutputCopyBlack",
      "description": "A. The King's Race\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer nn (2≤n≤10182≤n≤1018) — the length of the side of the chess field.The second line contains two integers xx and yy (1≤x,y≤n1≤x,y≤n) — coordinates of the cell, where the coin fell.\n\nOutputIn a single line print the answer \"White\" (without quotes), if the white king will win, or \"Black\" (without quotes), if the black king will win.You can print each letter in any case (upper or lower).\n\nInputCopy42 3OutputCopyWhiteInputCopy53 5OutputCopyBlackInputCopy22 2OutputCopyBlack\n\nInputCopy42 3\n\nOutputCopyWhite\n\nInputCopy53 5\n\nOutputCopyBlack\n\nInputCopy22 2\n\nOutputCopyBlack\n\nNoteAn example of the race from the first sample where both the white king and the black king move optimally: The white king moves from the cell (1,1)(1,1) into the cell (2,2)(2,2). The black king moves form the cell (4,4)(4,4) into the cell (3,3)(3,3). The white king moves from the cell (2,2)(2,2) into the cell (2,3)(2,3). This is cell containing the coin, so the white king wins.  An example of the race from the second sample where both the white king and the black king move optimally: The white king moves from the cell (1,1)(1,1) into the cell (2,2)(2,2). The black king moves form the cell (5,5)(5,5) into the cell (4,4)(4,4). The white king moves from the cell (2,2)(2,2) into the cell (3,3)(3,3). The black king moves from the cell (4,4)(4,4) into the cell (3,5)(3,5). This is the cell, where the coin fell, so the black king wins.  In the third example, the coin fell in the starting cell of the black king, so the black king immediately wins.",
      "solutions": [
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces",
          "content": "1075A - The King's RaceLet's find the minimum time needed for the white king to reach the coin.It is obvious that it is always optimal to move only towards the coin. In case of white king it means that we should move only up, right or up-right diagonally. During one move we can only add 11 or 00 to any of our coordinates (or to both of them), it means that the length of the optimal path can not be smaller than max(x−1,y−1)max(x−1,y−1).Let's show that we can reach the coin with max(x−1,y−1)max(x−1,y−1) moves.First step. Let zz be equal to min(x,y)min(x,y). The king does z−1z−1 up-right moves, so after that the king will be in the cell (z,z)(z,z). Second step. Let's assume that x≤yx≤y (the case when x>yx>y is proved in a similar way). So z=xz=x. It means that the king is in the cell (x,x)(x,x). Now the king can do y−xy−x up moves, after which he would be in the cell (x,y)(x,y). It took him (x−1)+(y−x)=y−1(x−1)+(y−x)=y−1 moves to reach the coin. If xx was greater than yy he would need x−1x−1 moves (could be proved the same way). So now we proved that it takes max(x−1,y−1)max(x−1,y−1) moves for the white king to reach the coin.In the same way we can prove that it takes max(n−x,n−y)max(n−x,n−y) steps for the black king to reach the coin.The king, which is closer to the coin, wins. If the distances is equal, than the white king wins, because he moves first.Final description of the algorithm:If max(n−x,n−y)<max(x−1,y−1)max(n−x,n−y)<max(x−1,y−1) then the answer is \"Black\", otherwise the answer is \"White\".It is also can be proven that instead of comparing minimal distances between the coin and the kings we can compare manhattan distances between them. I will leave the proof as homework task.Author: arsijoDeveloper: stanislav.bezkorovainyi 1075B - Taxi drivers and LyftLet's find for each rider the taxi driver that will get his call.To do this we can find for each rider the nearest taxi driver at right and the nearest taxi driver at left. Let's define the nearest taxi driver at left for ii-th citizen as lili and at the right as riri.The computations can be done with the following algorithm:Let's define l0=0l0=0 and rn+m+1=n+m+1rn+m+1=n+m+1. And x0=−2∗109x0=−2∗109, xn+m+1=2∗109xn+m+1=2∗109.In order to find lili for each ii we should iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a taxi driver, then he/she is obviously the nearest taxi driver to himself/herself. If the ii-th citizen is a rider, then li=li−1li=li−1In order to find riri for each ii we should iterate through the citizens from n+mn+m to 11. If the ii-th citizen is a taxi driver, then ri=iri=i, else ri=ri+1ri=ri+1.Now it's time to compute the answer.Let's denote bibi as the number of citizens, whose calls the ii-th citizen will get (if the ii-th citizen is a rider, then bi=0bi=0).In order to do compute the values of array bb we should iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a rider, then if the xri−xi<xi−xlixri−xi<xi−xli (distance between the nearest taxi driver at right and the ii-th citizen is smaller than distance between the nearest taxi driver at the left and the citizen), then taxi driver riri will get the call, otherwise the taxi driver lili will get the call. So if xri−xi<xi−xlixri−xi<xi−xli, then bri:=bri+1bri:=bri+1, else bli:=bli+1bli:=bli+1. In order to print out the answer we iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a taxi driver, than we should print bibi.The algorithm iterates through the array four times, so overall complexity is O(n+m)O(n+m)Author: arsijoDeveloper: stanislav.bezkorovainyi 1074A - The Tower is Going HomeObservation 1. If we remove all the horizontal spells, than the rook can move straightforward up to the upper side of the field. So the only purpose of removing the vertical spells is to reduce the number of horizontal spells to be removed.Observation 2. If we want to remove the ii-th vertical spell, then we should also remove all such vertical spells jj, that xj<xixj<xi. It is obvious, because when we delete a vertical spell, we suppose that the rook would be able to outflank some horizontal spells by getting at rows that have greater number than xixi. If there remains at least one vertical spell jj, such that xj<xixj<xi, than we will never be able to move to the rows with number greater than xjxj, including xixi.Let's find some observations about the horizontal spells:Let's assume that we deleted ii vertical spells. It means, that the rook can move freely left and right at columns between 11 and xi+1xi+1 inclusive. Let's say that our rook is on the row yy. If there is at least one cell which is located at row yy at any column between 11 and xi+1xi+1, that there is no blocking segment on the top of it, then the rook can move to this cell and move upwards into the row y+1y+1. It means that if there is at least one gap in the blocking segments in row yy and in columns between 11 and xi+1xi+1 incluse, then there is no need to remove any of horizontal spells in the row.Observation 3. We care only about such horizontal spells, in which x1=1x1=1. We have already proved, that we only care about such rows, that there are no gaps in blocking segments in them. If there is no such horizontal spell with x1=1x1=1, it means that there is a gap in the row at column 11. If there is such horizontal spell, then if there are more spells in that row, there would be a gap between any pair of neighbouring segments. Since we only care only about segments with x1=1x1=1 and it is guaranteed that no horizontal segments share a common point, it means that we might not care about the yy of any horizontal spell, because there is no such pair of segments that both x1x1 and yy of these are equal. So now while reading the descriptions of the horizontal spells, if the x1x1 of ii-th horizontal spell is not equal to 11, we can ignore it. Otherwise, we add x2x2 to some array.Now we can sort the array of x2x2-s, and solve the task using the two-pointer technique. Here is the final algorithm: Add fake vertical spell with x=109x=109.Sort all the vertical spells in ascending order.While reading the descriptions of the horizontal spells, we ignore ones with x1x1 not equal to 11. In other case, we add x2x2 to the array.Sort the array of x2x2-s in ascending order. Now we use the two pointer technique in the following way: we iterate ii from 0 to n — the number of vertical spells to be deleted and on each step we advance the pointer while the x2x2 at which the pointer points is less then xx of the (i+1)(i+1)-th vertical spell. Let's denote the position of the pointer as pp. The number of horizontal spells, that we need to remove with ii vertical spells removed is m−p+1m−p+1. Let's define the position of the pointer at ii-th step as pipi.The answer to the problem in minival value of i+m−pi+1i+m−pi+1 among all ii from 00 to nn.Overall complexity O(nlogn+mlogm)O(nlog⁡n+mlog⁡m)Author: stanislav.bezkorovainyiDeveloper: stanislav.bezkorovainyi 1074B - Intersecting SubtreesI'll split this into two parts, first is the solution, second is why it works.The intended solution only uses two questions. Choose an arbitrary yjyj, and ask \"B y_j\". Let the response be RR. Find a node xixi that is the closest to node RR. This can be done with a BFS or DFS. Ask \"A x_i\". Let the response be QQ. If QQ is one of y1,y2,…,yk2y1,y2,…,yk2, print \"C x_i\", otherwise, print \"C -1\". Here is why it works. Let's use the fact that if the two subtrees don't intersect, there is an edge in the tree such that if we cut the tree on this edge, it will split it into two components, each containing one of the subtrees.Suppose we did step 1 and we have RR. Let's root our tree at RR. There is a unique node xixi that has lowest depth in this tree which we can find (given that x1,x2,…,xk1x1,x2,…,xk1 form a subtree).Now, we claim that the two subtrees intersect if and only if Li Chen owns a node that lies in the subtree rooted by xixi (and in particular, we will show it is sufficient to only check node xixi).If none of Li Chen's nodes lie in the subtree rooted by xixi, then the edge xixi to its parent cuts the tree into two components with one subtree completely lying in one component and the other in the second, so the two subtrees are disjoint.Otherwise, there is a node WW that is in Li Chen's subtree that lies in the subtree rooted by xixi. All nodes in the path of RR to WW must also belong to Li Chen's subtree, and in particular this includes node xixi, so the two trees intersect. This also shows we can just check if xixi belongs in Li Chen's subtree by asking a question about it.Author: LewinDeveloper: Lewin 1074C - Optimal Polygon PerimeterI will show 2 solutions, both of which work in O(n)O(n) time. First, it is not hard to notice that we can only consider polygons that are convex.Observation: For a convex polygon, the given definition of \"polygon perimeter\" is equivalent to the perimeter of the bounding rectangle (aligned with the axis), of our polygon. If we look at some convex polygon, and 4 values maxx,minx,maxy,minymaxx,minx,maxy,miny representing the maximal xx coordinate of a point, minimal xx, maximal and minimal yy, then the perimeter of the bounding rectangle is simply 2∗(maxx−minx+maxy−miny)2∗(maxx−minx+maxy−miny).This simple rephrase gives us a bonus, and crucial observation: It is enough for us to take 4 points from the input, such that the perimeter of their polygon is the maximal possible (and is equal to the perimeter of the polygon formed from nn points). We will consider these the extreme points. Note that after taking the extreme points, it does not matter which other points we take. So, this solves all f(4),…,f(n)f(4),…,f(n).We are left with f(3)f(3) to compute (maximal triangle perimeter). Following are 2 solutions to do it:Solution 1: Let's show that the optimal triangle uses at least 2 of the extreme points. Imagine some optimal triangle, and its bounding rectangle. Notice that since each edge of the bounding rectangle must touch some vertex of the triangle (it is bounding after all), and we have 4 edges and 3 vertices, then there must be some vertex of the triangle that touches 2 edges of the rectangle (so it coincides with a rectangle vertex). If this is the case, we know that in comparison with the 2 other vertices, this vertex has \"extremal\" X and Y coordinates (minimal/maximal X, and minimal/maximal Y). Without loss of generality, assume this vertex has maximum X and Y. Then to optimize the perimeter, the other two vertices should have smallest possible X and smallest possible Y. We can pick these 2 vertices to be 2 of the extreme points (one with minimal X and one with minimal Y). So, this shows we just need to iterate over every adjacent pair of extreme vertices, and over all other points as the last vertex. This takes O(n)O(n).Solution 2: This solution is more general, and is an extension of the problem to find the 2 most distant points (manhattan distance). The triangle perimeter is an expression with 6 terms: |x1−x2|+|y1−y2|+…+|y3−y1||x1−x2|+|y1−y2|+…+|y3−y1|. We wish the maximize this expression, but the absolute value is troubling us. For each term, there are 2 cases: either it is positive, so the absolute value does nothing, or it is negative, so the absolute value negates it. In total, for the 6 terms we have 26=6426=64 options to place signs between them. We will call such option a setting.For any setting, the advantage now is that we can accumulate terms: For example the setting ++−−−+++−−−+, evaluates the expression to: (2x1+0y1)+(−2x2−2y2)+(0x3+2y3)(2x1+0y1)+(−2x2−2y2)+(0x3+2y3) We solve every setting by its own, and over all settings we take the maximal answer.Please note, that this strategy only works to find the maximal value of the expression, not minimal. The proof of this is left as an exercise to the reader :) (I promise it is not difficult).Given 6 constants c1,c2,...,c6c1,c2,...,c6, we want to find 3 indicies i<j<ki<j<k to maximize: c1∗xi+c2∗yi+...+c6∗ykc1∗xi+c2∗yi+...+c6∗yk. We define 3 arrays: Pi=c1⋅xi+c2⋅yiPi=c1⋅xi+c2⋅yi Qi=c3⋅xi+c4⋅yiQi=c3⋅xi+c4⋅yi Ri=c5⋅xi+c6⋅yiRi=c5⋅xi+c6⋅yi And so we want to maximize Pi+Qj+RkPi+Qj+Rk. This can be done in O(n)O(n) with simple dynamic programming.So this whole solution is O(n)O(n), with a constant of 64. In general, to compute f(k)f(k) this solution takes O(n⋅4k⋅k)O(n⋅4k⋅k) time, without any observations.Author: Noam527Developer: Noam527 1074D - Deduction QueriesFirst, let's learn how to handle information we have not recieved in updates. Let the function W(l,r)W(l,r) be equal to the xor of the subarray [l,r][l,r]. Also, we define W(l,r)=W(r,l)W(l,r)=W(r,l).Assume 3 indicies a≤b≤ca≤b≤c. There are 2 rules: W(a,b)⊕W(b+1,c)=W(a,c)W(a,b)⊕W(b+1,c)=W(a,c). W(a,c)⊕W(b,c)=W(a,b−1)W(a,c)⊕W(b,c)=W(a,b−1) (holds when a<ba<b). These rules require a lot of conditions (and also plenty of ±± 1). We can simplify them greatly: Let's index the borders between cells in our array (there are 230+1230+1 of them). Now, instead of defining a subarray [l,r][l,r] by its 2 endpoint cells, we will define a subarray by its 2 endpoint borders. Technically it just means, that we should increase rr by 1, and then we get the 2 end borders.From now I will assume that our input is given in such a way, that subarrays are defined by their borders (So I will not mention the addition of 1 to rr). Notice that the function W(l,r)W(l,r) is also affected by this.If we take a look at our rules again, they boil down to just 1 rule: W(a,b)⊕W(b,c)=W(a,c)W(a,b)⊕W(b,c)=W(a,c), for any 3 indicies a,b,ca,b,c (a≤b≤ca≤b≤c doesn't need to hold now, for instance W(3,5)⊕W(5,2)=W(3,2)W(3,5)⊕W(5,2)=W(3,2)). This transformation also shows an observation; Assume every border is a vertex in a graph, and every update W(l,r)=xW(l,r)=x describes an undirected edge between the vertices l,rl,r with weight xx. We let the distance between 2 nodes a,ba,b be the xor of edge weights on the path between them. Notice that this distance is equal to W(a,b)W(a,b). In other words, an update adds an edge and a query asks for some distance.Another observation is that, we do not care about all the 230+1230+1 nodes, but only about the ones we recieved in queries and updates. Moreover, their order is irrelevant, so we can do an online mapping of new nodes to the next free indicies. Thus, the number of nodes will be worstcase O(q)O(q).Claim: We can know the answer to some query [l,r][l,r], if and only if there exists a path between the nodes l,rl,r (they are in the same connected component).//start spoiler of proofThere will be some subset of edges we take, to form the xor between nodes ll and rr. Assume every vertex has 2 states, on/off. Initially all vertices are off, and our current answer is 00. When we take an edge we flip the state of its 2 ends, and xor our answer by its weight. Suppose at some moment of time the nodes with \"on\" state are {x0,x1,x2,...,xkx0,x1,x2,...,xk} (in sorted order). Observe that our current answer is equal to W(x0,x1)⊕W(x2,x3)⊕…⊕W(xk−1,xk)W(x0,x1)⊕W(x2,x3)⊕…⊕W(xk−1,xk). This implies we want our subset of edges to end up having only the nodes {l,rl,r} activated. We look at the connected components. Observe that in each connected component, the number of nodes activated at any time is even. If the nodes ll and rr are in different component, then in our final result we would want to have only 1 activated node in the component of ll, and same with rr, but this is impossible.//end spoiler of proofFirst, we need to know whether a query gives us 2 nodes that are in different components (to know whether the answer is −1−1 or not). For this we need to use the Union-Find structure. Also notice, that our Union-Find structure will only need to handle a forest of trees (if an update gives us an edge that creates a cycle, it means there is no contribution, so we ignore it).Provided that an answer does exist, we need to also handle finding a xor path between 2 nodes in a tree, and to support merging of trees. Generally to find a property over some path in a tree, it is common to use LCA or binary lifting. This turns out very difficult when we also need to merge trees (unless you insist on implementing Link-Cut/ETT). Fortunately, we can still abuse the xor operator. In some tree, mark xvxv as the xor of edges on the path from vv to some arbitrary root in the tree. The xor path between nodes (u,vu,v) turns out to be xu⊕xvxu⊕xv. So we would like to maintain for each tree some arbitrary root and all those values.Notice that we can augment our Union-Find structure to support this as well: For each node vv in the structure, we maintain pvpv as its parent in the structure, and xvxv as the xor on the path from vv to pvpv. Notice that xvxv can be easily updated together with pvpv during the find()find() operation in the structure.To summarize, when we are given W(l,r)=xW(l,r)=x in some update, we transform it to W(pl,pr)=x⊕xl⊕xrW(pl,pr)=x⊕xl⊕xr, and then we add the edge between the parents.Finally, the complexity is O(qlogq)O(qlog⁡q), but this is only due to the online mapping if we use a regular map; You can use a hash table and get a running time of O(q×α(q))O(q×α(q)), but I suggest being careful with a hash table (you may want to read this: https://codeforces.com/blog/entry/62393).Author: Noam527Developer: Noam527 1074E - Grid SortThe solution is more of a coding one than an algorithmic one. There are many different approaches, and it's important to be careful in how it is implemented. I'll explain one of the implementations.First, we can always move a particular block left, up, down, or right with an appropriate 2x2 square around it. Let's code some functions that let us do that for each direction.Next is to make sure that these moves don't mess up previous block spaces as we move blocks to the correct place. We can almost place blocks correctly in their spaces one by one in row major order, but there are some special cases.- We can do all blocks except the last two rows, which we'll handle separately (in paragraph below) - For each row, we can correctly place all blocks except the last one. The last one requires a bit more careful work, but is easy to handle if we have at least two free rows.For the last two rows, we can fill it in column by column from left to right. This is a similar startegy to fitting in the last column of the previous rows. We can almost do this except for the last 2x2 square.For the last 2x2 square, we can use the following sequence of moves to swap two blocks:123456413526421563213456Thus, we can shift the last block into the right position, then do at most three swaps (using the above sequence of moves) to fix the remaining blocks.The number of moves for this strategy can be computed and estimated to be about 50k in the worst case.Author: LewinDeveloper: Lewin 1074F - DFSLet's consider an arbitrary run of DFS producing some tree. Let's root the tree at the starting vertex. It can be shown that on a directed graph, there are only two types of edges. The first are the tree edges (those are the ones that are used to visit a new vertex). The second are edges which, upon being traversed, lead to a vertex that was already visited. It can be shown that, in the rooted tree, those edges always connect a vertex with one of its ancestors. In other words, all the edges that are dynamically added to the tree must connect a vertex with one of their ancestors. This means that the staring vertex must not lie on the path connecting the two endpoints of such edge, or any of the vertices in some of the subtrees. For instance, on the second sample, the edge {2,4}{2,4} disallows the vertex 11 from being the starting vertex, as it lies on the path from 22 to 44, and also vertex 66.Each edge thus forbids a certain set of vertices from being the starting point. This yields a straightforward O(n2)O(n2) solution. To optimize it further, we can root the tree arbitrarily and renumber the vertices using their DFS visit times. When we do this, we notice that the set of a forbidden vertices for each edge is a union of at most three intervals of vertices. This lets us build an O(nlogn)O(nlog⁡n) solution using a segment tree. The operation is add a constant on interval, and then find the minimum on interval and the number of occurrences of said minimum. We add 11 to forbid a vertex because of an edge, subtract 11 to revert that when the edge is subsequently removed. The answer is the number of minimums on the whole tree if that minimum is 00, and 00 otherwise.Author: _h_Developers: _h_ and majk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1075\\s*A"
          },
          "content_length": 20587
        }
      ],
      "code_examples": [
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 1",
          "code": "123456413526421563213456",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        },
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 2",
          "code": "2 3\n3\n5\n1 4 1\n2 100000 2\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        },
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 3",
          "code": "2 3\n3\n5\n1 4 1\n2 100000 2\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(2, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    long long x = inf.readLong(1, n, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(1, n, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(2, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    long long x = inf.readLong(1, n, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(1, n, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(2, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    long long x = inf.readLong(1, n, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(1, n, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]){\n    registerTestlibCmd(argc, argv);\n    long long n = inf.readLong();\n    long long x = inf.readLong();\n    long long y = inf.readLong();\n\n    long long w = max(abs(1LL - x), abs(1LL - y));\n    long long b = max(abs(n - x), abs(n - y));\n\n    long long time_w = 2 * w -1;\n    long long time_b = 2 * b;\n\n    string correct_ans = (time_w <= time_b) ? \"white\" : \"black\";\n\n    string participant_ans = ouf.readToken();\n\n    // Convert participant's answer to lowercase for case-insensitive comparison\n    transform(participant_ans.begin(), participant_ans.end(), participant_ans.begin(), ::tolower);\n\n    // Check that the participant's output is either \"white\" or \"black\"\n    if (participant_ans != \"white\" && participant_ans != \"black\") {\n        quitf(_wa, \"Participant's output is not 'White' or 'Black'\");\n    }\n\n    // Compare the participant's answer with the correct answer\n    if (participant_ans != correct_ans) {\n        quitf(_wa, \"Wrong answer: expected '%s', found '%s'\", correct_ans.c_str(), participant_ans.c_str());\n    }\n\n    // If everything is correct, report success\n    quitf(_ok, \"The answer is correct: %s\", correct_ans.c_str());\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    long long n = opt<long long>(\"n\");\n    string test_type = opt<string>(\"type\", \"random\");\n\n    // Validate n\n    ensure(n >= 2 && n <= 1000000000000000000LL); // 1e18\n\n    long long x, y;\n\n    if (test_type == \"random\") {\n        // Random position for the coin\n        x = rnd.next(1LL, n);\n        y = rnd.next(1LL, n);\n    } else if (test_type == \"white_immediate\") {\n        // Coin is at White King's starting position\n        x = 1;\n        y = 1;\n    } else if (test_type == \"black_immediate\") {\n        // Coin is at Black King's starting position\n        x = n;\n        y = n;\n    } else if (test_type == \"white_near\") {\n        // Coin is near White King\n        long long max_offset = min(10LL, n - 1);\n        x = 1 + rnd.next(0LL, max_offset);\n        y = 1 + rnd.next(0LL, max_offset);\n    } else if (test_type == \"black_near\") {\n        // Coin is near Black King\n        long long max_offset = min(10LL, n - 1);\n        x = n - rnd.next(0LL, max_offset);\n        y = n - rnd.next(0LL, max_offset);\n    } else if (test_type == \"equidistant\") {\n        // Coin is at a position equidistant from both kings\n        x = (n + 1) / 2;\n        y = (n + 1) / 2;\n    } else if (test_type == \"max_distance\") {\n        // Coin is at maximum distance from both kings\n        if (rnd.next(0, 1)) {\n            x = 1;\n            y = n;\n        } else {\n            x = n;\n            y = 1;\n        }\n    } else {\n        // Default to random if unknown type\n        x = rnd.next(1LL, n);\n        y = rnd.next(1LL, n);\n    }\n\n    // Ensure x and y are within valid range\n    x = max(1LL, min(x, n));\n    y = max(1LL, min(y, n));\n\n    // Output the test case\n    printf(\"%lld\\n\", n);\n    printf(\"%lld %lld\\n\", x, y);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    long long n = opt<long long>(\"n\");\n    string test_type = opt<string>(\"type\", \"random\");\n\n    // Validate n\n    ensure(n >= 2 && n <= 1000000000000000000LL); // 1e18\n\n    long long x, y;\n\n    if (test_type == \"random\") {\n        // Random position for the coin\n        x = rnd.next(1LL, n);\n        y = rnd.next(1LL, n);\n    } else if (test_type == \"white_immediate\") {\n        // Coin is at White King's starting position\n        x = 1;\n        y = 1;\n    } else if (test_type == \"black_immediate\") {\n        // Coin is at Black King's starting position\n        x = n;\n        y = n;\n    } else if (test_type == \"white_near\") {\n        // Coin is near White King\n        long long max_offset = min(10LL, n - 1);\n        x = 1 + rnd.next(0LL, max_offset);\n        y = 1 + rnd.next(0LL, max_offset);\n    } else if (test_type == \"black_near\") {\n        // Coin is near Black King\n        long long max_offset = min(10LL, n - 1);\n        x = n - rnd.next(0LL, max_offset);\n        y = n - rnd.next(0LL, max_offset);\n    } else if (test_type == \"equidistant\") {\n        // Coin is at a position equidistant from both kings\n        x = (n + 1) / 2;\n        y = (n + 1) / 2;\n    } else if (test_type == \"max_distance\") {\n        // Coin is at maximum distance from both kings\n        if (rnd.next(0, 1)) {\n            x = 1;\n            y = n;\n        } else {\n            x = n;\n            y = 1;\n        }\n    } else {\n        // Default to random if unknown type\n        x = rnd.next(1LL, n);\n        y = rnd.next(1LL, n);\n    }\n\n    // Ensure x and y are within valid range\n    x = max(1LL, min(x, n));\n    y = max(1LL, min(y, n));\n\n    // Output the test case\n    printf(\"%lld\\n\", n);\n    printf(\"%lld %lld\\n\", x, y);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random coin positions\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 10 -type random\n\n# Small n, coin at starting positions\n./gen -n 2 -type white_immediate\n./gen -n 2 -type black_immediate\n./gen -n 3 -type white_immediate\n./gen -n 3 -type black_immediate\n\n# Small n, coin near kings\n./gen -n 10 -type white_near\n./gen -n 10 -type black_near\n\n# Small n, coin equidistant\n./gen -n 2 -type equidistant\n./gen -n 3 -type equidistant\n./gen -n 10 -type equidistant\n\n# Medium n, random coin positions\n./gen -n 1000 -type random\n./gen -n 1000000 -type random\n\n# Medium n, coin near kings\n./gen -n 1000000 -type white_near\n./gen -n 1000000 -type black_near\n\n# Medium n, coin equidistant\n./gen -n 1000000 -type equidistant\n\n# Medium n, coin at maximum distance\n./gen -n 1000000 -type max_distance\n\n# Large n, random coin positions\n./gen -n 1000000000 -type random\n./gen -n 1000000000000 -type random\n\n# Large n, coin near kings\n./gen -n 1000000000000 -type white_near\n./gen -n 1000000000000 -type black_near\n\n# Large n, coin equidistant\n./gen -n 1000000000000 -type equidistant\n\n# Large n, coin at maximum distance\n./gen -n 1000000000000 -type max_distance\n\n# Maximum n, random coin positions\n./gen -n 1000000000000000000 -type random\n\n# Maximum n, coin at starting positions\n./gen -n 1000000000000000000 -type white_immediate\n./gen -n 1000000000000000000 -type black_immediate\n\n# Maximum n, coin near kings\n./gen -n 1000000000000000000 -type white_near\n./gen -n 1000000000000000000 -type black_near\n\n# Maximum n, coin equidistant\n./gen -n 1000000000000000000 -type equidistant\n\n# Maximum n, coin at maximum distance\n./gen -n 1000000000000000000 -type max_distance\n\n# Additional random test cases\n./gen -n 500000000000000000 -type random\n./gen -n 999999999999999999 -type random\n./gen -n 1000000000000000000 -type random\n./gen -n 2 -type max_distance\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:14:59.158971",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1075/B",
      "title": "B. Taxi drivers and Lyft",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and mm (1≤n,m≤1051≤n,m≤105) — number of riders and taxi drivers.The second line contains n+mn+m integers x1,x2,…,xn+mx1,x2,…,xn+m (1≤x1<x2<…<xn+m≤1091≤x1<x2<…<xn+m≤109), where xixi is the coordinate where the ii-th resident lives. The third line contains n+mn+m integers t1,t2,…,tn+mt1,t2,…,tn+m (0≤ti≤10≤ti≤1). If ti=1ti=1, then the ii-th resident is a taxi driver, otherwise ti=0ti=0.It is guaranteed that the number of ii such that ti=1ti=1 is equal to mm.",
      "output_spec": "OutputPrint mm integers a1,a2,…,ama1,a2,…,am, where aiai is the answer for the ii-th taxi driver. The taxi driver has the number ii if among all the taxi drivers he lives in the ii-th smallest coordinate (see examples for better understanding).",
      "sample_tests": "ExamplesInputCopy3 11 2 3 100 0 1 0OutputCopy3 InputCopy3 22 3 4 5 61 0 0 0 1OutputCopy2 1 InputCopy1 42 4 6 10 151 1 1 1 0OutputCopy0 0 0 1",
      "description": "B. Taxi drivers and Lyft\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and mm (1≤n,m≤1051≤n,m≤105) — number of riders and taxi drivers.The second line contains n+mn+m integers x1,x2,…,xn+mx1,x2,…,xn+m (1≤x1<x2<…<xn+m≤1091≤x1<x2<…<xn+m≤109), where xixi is the coordinate where the ii-th resident lives. The third line contains n+mn+m integers t1,t2,…,tn+mt1,t2,…,tn+m (0≤ti≤10≤ti≤1). If ti=1ti=1, then the ii-th resident is a taxi driver, otherwise ti=0ti=0.It is guaranteed that the number of ii such that ti=1ti=1 is equal to mm.\n\nOutputPrint mm integers a1,a2,…,ama1,a2,…,am, where aiai is the answer for the ii-th taxi driver. The taxi driver has the number ii if among all the taxi drivers he lives in the ii-th smallest coordinate (see examples for better understanding).\n\nInputCopy3 11 2 3 100 0 1 0OutputCopy3 InputCopy3 22 3 4 5 61 0 0 0 1OutputCopy2 1 InputCopy1 42 4 6 10 151 1 1 1 0OutputCopy0 0 0 1\n\nInputCopy3 11 2 3 100 0 1 0\n\nOutputCopy3\n\nInputCopy3 22 3 4 5 61 0 0 0 1\n\nOutputCopy2 1\n\nInputCopy1 42 4 6 10 151 1 1 1 0\n\nOutputCopy0 0 0 1\n\nNoteIn the first example, we have only one taxi driver, which means an order from any of nn riders will go to him.In the second example, the first taxi driver lives at the point with the coordinate 22, and the second one lives at the point with the coordinate 66. Obviously, the nearest taxi driver to the rider who lives on the 33 coordinate is the first one, and to the rider who lives on the coordinate 55 is the second one. The rider who lives on the 44 coordinate has the same distance to the first and the second taxi drivers, but since the first taxi driver has a smaller coordinate, the call from this rider will go to the first taxi driver.In the third example, we have one rider and the taxi driver nearest to him is the fourth one.",
      "solutions": [
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces",
          "content": "1075A - The King's RaceLet's find the minimum time needed for the white king to reach the coin.It is obvious that it is always optimal to move only towards the coin. In case of white king it means that we should move only up, right or up-right diagonally. During one move we can only add 11 or 00 to any of our coordinates (or to both of them), it means that the length of the optimal path can not be smaller than max(x−1,y−1)max(x−1,y−1).Let's show that we can reach the coin with max(x−1,y−1)max(x−1,y−1) moves.First step. Let zz be equal to min(x,y)min(x,y). The king does z−1z−1 up-right moves, so after that the king will be in the cell (z,z)(z,z). Second step. Let's assume that x≤yx≤y (the case when x>yx>y is proved in a similar way). So z=xz=x. It means that the king is in the cell (x,x)(x,x). Now the king can do y−xy−x up moves, after which he would be in the cell (x,y)(x,y). It took him (x−1)+(y−x)=y−1(x−1)+(y−x)=y−1 moves to reach the coin. If xx was greater than yy he would need x−1x−1 moves (could be proved the same way). So now we proved that it takes max(x−1,y−1)max(x−1,y−1) moves for the white king to reach the coin.In the same way we can prove that it takes max(n−x,n−y)max(n−x,n−y) steps for the black king to reach the coin.The king, which is closer to the coin, wins. If the distances is equal, than the white king wins, because he moves first.Final description of the algorithm:If max(n−x,n−y)<max(x−1,y−1)max(n−x,n−y)<max(x−1,y−1) then the answer is \"Black\", otherwise the answer is \"White\".It is also can be proven that instead of comparing minimal distances between the coin and the kings we can compare manhattan distances between them. I will leave the proof as homework task.Author: arsijoDeveloper: stanislav.bezkorovainyi 1075B - Taxi drivers and LyftLet's find for each rider the taxi driver that will get his call.To do this we can find for each rider the nearest taxi driver at right and the nearest taxi driver at left. Let's define the nearest taxi driver at left for ii-th citizen as lili and at the right as riri.The computations can be done with the following algorithm:Let's define l0=0l0=0 and rn+m+1=n+m+1rn+m+1=n+m+1. And x0=−2∗109x0=−2∗109, xn+m+1=2∗109xn+m+1=2∗109.In order to find lili for each ii we should iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a taxi driver, then he/she is obviously the nearest taxi driver to himself/herself. If the ii-th citizen is a rider, then li=li−1li=li−1In order to find riri for each ii we should iterate through the citizens from n+mn+m to 11. If the ii-th citizen is a taxi driver, then ri=iri=i, else ri=ri+1ri=ri+1.Now it's time to compute the answer.Let's denote bibi as the number of citizens, whose calls the ii-th citizen will get (if the ii-th citizen is a rider, then bi=0bi=0).In order to do compute the values of array bb we should iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a rider, then if the xri−xi<xi−xlixri−xi<xi−xli (distance between the nearest taxi driver at right and the ii-th citizen is smaller than distance between the nearest taxi driver at the left and the citizen), then taxi driver riri will get the call, otherwise the taxi driver lili will get the call. So if xri−xi<xi−xlixri−xi<xi−xli, then bri:=bri+1bri:=bri+1, else bli:=bli+1bli:=bli+1. In order to print out the answer we iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a taxi driver, than we should print bibi.The algorithm iterates through the array four times, so overall complexity is O(n+m)O(n+m)Author: arsijoDeveloper: stanislav.bezkorovainyi 1074A - The Tower is Going HomeObservation 1. If we remove all the horizontal spells, than the rook can move straightforward up to the upper side of the field. So the only purpose of removing the vertical spells is to reduce the number of horizontal spells to be removed.Observation 2. If we want to remove the ii-th vertical spell, then we should also remove all such vertical spells jj, that xj<xixj<xi. It is obvious, because when we delete a vertical spell, we suppose that the rook would be able to outflank some horizontal spells by getting at rows that have greater number than xixi. If there remains at least one vertical spell jj, such that xj<xixj<xi, than we will never be able to move to the rows with number greater than xjxj, including xixi.Let's find some observations about the horizontal spells:Let's assume that we deleted ii vertical spells. It means, that the rook can move freely left and right at columns between 11 and xi+1xi+1 inclusive. Let's say that our rook is on the row yy. If there is at least one cell which is located at row yy at any column between 11 and xi+1xi+1, that there is no blocking segment on the top of it, then the rook can move to this cell and move upwards into the row y+1y+1. It means that if there is at least one gap in the blocking segments in row yy and in columns between 11 and xi+1xi+1 incluse, then there is no need to remove any of horizontal spells in the row.Observation 3. We care only about such horizontal spells, in which x1=1x1=1. We have already proved, that we only care about such rows, that there are no gaps in blocking segments in them. If there is no such horizontal spell with x1=1x1=1, it means that there is a gap in the row at column 11. If there is such horizontal spell, then if there are more spells in that row, there would be a gap between any pair of neighbouring segments. Since we only care only about segments with x1=1x1=1 and it is guaranteed that no horizontal segments share a common point, it means that we might not care about the yy of any horizontal spell, because there is no such pair of segments that both x1x1 and yy of these are equal. So now while reading the descriptions of the horizontal spells, if the x1x1 of ii-th horizontal spell is not equal to 11, we can ignore it. Otherwise, we add x2x2 to some array.Now we can sort the array of x2x2-s, and solve the task using the two-pointer technique. Here is the final algorithm: Add fake vertical spell with x=109x=109.Sort all the vertical spells in ascending order.While reading the descriptions of the horizontal spells, we ignore ones with x1x1 not equal to 11. In other case, we add x2x2 to the array.Sort the array of x2x2-s in ascending order. Now we use the two pointer technique in the following way: we iterate ii from 0 to n — the number of vertical spells to be deleted and on each step we advance the pointer while the x2x2 at which the pointer points is less then xx of the (i+1)(i+1)-th vertical spell. Let's denote the position of the pointer as pp. The number of horizontal spells, that we need to remove with ii vertical spells removed is m−p+1m−p+1. Let's define the position of the pointer at ii-th step as pipi.The answer to the problem in minival value of i+m−pi+1i+m−pi+1 among all ii from 00 to nn.Overall complexity O(nlogn+mlogm)O(nlog⁡n+mlog⁡m)Author: stanislav.bezkorovainyiDeveloper: stanislav.bezkorovainyi 1074B - Intersecting SubtreesI'll split this into two parts, first is the solution, second is why it works.The intended solution only uses two questions. Choose an arbitrary yjyj, and ask \"B y_j\". Let the response be RR. Find a node xixi that is the closest to node RR. This can be done with a BFS or DFS. Ask \"A x_i\". Let the response be QQ. If QQ is one of y1,y2,…,yk2y1,y2,…,yk2, print \"C x_i\", otherwise, print \"C -1\". Here is why it works. Let's use the fact that if the two subtrees don't intersect, there is an edge in the tree such that if we cut the tree on this edge, it will split it into two components, each containing one of the subtrees.Suppose we did step 1 and we have RR. Let's root our tree at RR. There is a unique node xixi that has lowest depth in this tree which we can find (given that x1,x2,…,xk1x1,x2,…,xk1 form a subtree).Now, we claim that the two subtrees intersect if and only if Li Chen owns a node that lies in the subtree rooted by xixi (and in particular, we will show it is sufficient to only check node xixi).If none of Li Chen's nodes lie in the subtree rooted by xixi, then the edge xixi to its parent cuts the tree into two components with one subtree completely lying in one component and the other in the second, so the two subtrees are disjoint.Otherwise, there is a node WW that is in Li Chen's subtree that lies in the subtree rooted by xixi. All nodes in the path of RR to WW must also belong to Li Chen's subtree, and in particular this includes node xixi, so the two trees intersect. This also shows we can just check if xixi belongs in Li Chen's subtree by asking a question about it.Author: LewinDeveloper: Lewin 1074C - Optimal Polygon PerimeterI will show 2 solutions, both of which work in O(n)O(n) time. First, it is not hard to notice that we can only consider polygons that are convex.Observation: For a convex polygon, the given definition of \"polygon perimeter\" is equivalent to the perimeter of the bounding rectangle (aligned with the axis), of our polygon. If we look at some convex polygon, and 4 values maxx,minx,maxy,minymaxx,minx,maxy,miny representing the maximal xx coordinate of a point, minimal xx, maximal and minimal yy, then the perimeter of the bounding rectangle is simply 2∗(maxx−minx+maxy−miny)2∗(maxx−minx+maxy−miny).This simple rephrase gives us a bonus, and crucial observation: It is enough for us to take 4 points from the input, such that the perimeter of their polygon is the maximal possible (and is equal to the perimeter of the polygon formed from nn points). We will consider these the extreme points. Note that after taking the extreme points, it does not matter which other points we take. So, this solves all f(4),…,f(n)f(4),…,f(n).We are left with f(3)f(3) to compute (maximal triangle perimeter). Following are 2 solutions to do it:Solution 1: Let's show that the optimal triangle uses at least 2 of the extreme points. Imagine some optimal triangle, and its bounding rectangle. Notice that since each edge of the bounding rectangle must touch some vertex of the triangle (it is bounding after all), and we have 4 edges and 3 vertices, then there must be some vertex of the triangle that touches 2 edges of the rectangle (so it coincides with a rectangle vertex). If this is the case, we know that in comparison with the 2 other vertices, this vertex has \"extremal\" X and Y coordinates (minimal/maximal X, and minimal/maximal Y). Without loss of generality, assume this vertex has maximum X and Y. Then to optimize the perimeter, the other two vertices should have smallest possible X and smallest possible Y. We can pick these 2 vertices to be 2 of the extreme points (one with minimal X and one with minimal Y). So, this shows we just need to iterate over every adjacent pair of extreme vertices, and over all other points as the last vertex. This takes O(n)O(n).Solution 2: This solution is more general, and is an extension of the problem to find the 2 most distant points (manhattan distance). The triangle perimeter is an expression with 6 terms: |x1−x2|+|y1−y2|+…+|y3−y1||x1−x2|+|y1−y2|+…+|y3−y1|. We wish the maximize this expression, but the absolute value is troubling us. For each term, there are 2 cases: either it is positive, so the absolute value does nothing, or it is negative, so the absolute value negates it. In total, for the 6 terms we have 26=6426=64 options to place signs between them. We will call such option a setting.For any setting, the advantage now is that we can accumulate terms: For example the setting ++−−−+++−−−+, evaluates the expression to: (2x1+0y1)+(−2x2−2y2)+(0x3+2y3)(2x1+0y1)+(−2x2−2y2)+(0x3+2y3) We solve every setting by its own, and over all settings we take the maximal answer.Please note, that this strategy only works to find the maximal value of the expression, not minimal. The proof of this is left as an exercise to the reader :) (I promise it is not difficult).Given 6 constants c1,c2,...,c6c1,c2,...,c6, we want to find 3 indicies i<j<ki<j<k to maximize: c1∗xi+c2∗yi+...+c6∗ykc1∗xi+c2∗yi+...+c6∗yk. We define 3 arrays: Pi=c1⋅xi+c2⋅yiPi=c1⋅xi+c2⋅yi Qi=c3⋅xi+c4⋅yiQi=c3⋅xi+c4⋅yi Ri=c5⋅xi+c6⋅yiRi=c5⋅xi+c6⋅yi And so we want to maximize Pi+Qj+RkPi+Qj+Rk. This can be done in O(n)O(n) with simple dynamic programming.So this whole solution is O(n)O(n), with a constant of 64. In general, to compute f(k)f(k) this solution takes O(n⋅4k⋅k)O(n⋅4k⋅k) time, without any observations.Author: Noam527Developer: Noam527 1074D - Deduction QueriesFirst, let's learn how to handle information we have not recieved in updates. Let the function W(l,r)W(l,r) be equal to the xor of the subarray [l,r][l,r]. Also, we define W(l,r)=W(r,l)W(l,r)=W(r,l).Assume 3 indicies a≤b≤ca≤b≤c. There are 2 rules: W(a,b)⊕W(b+1,c)=W(a,c)W(a,b)⊕W(b+1,c)=W(a,c). W(a,c)⊕W(b,c)=W(a,b−1)W(a,c)⊕W(b,c)=W(a,b−1) (holds when a<ba<b). These rules require a lot of conditions (and also plenty of ±± 1). We can simplify them greatly: Let's index the borders between cells in our array (there are 230+1230+1 of them). Now, instead of defining a subarray [l,r][l,r] by its 2 endpoint cells, we will define a subarray by its 2 endpoint borders. Technically it just means, that we should increase rr by 1, and then we get the 2 end borders.From now I will assume that our input is given in such a way, that subarrays are defined by their borders (So I will not mention the addition of 1 to rr). Notice that the function W(l,r)W(l,r) is also affected by this.If we take a look at our rules again, they boil down to just 1 rule: W(a,b)⊕W(b,c)=W(a,c)W(a,b)⊕W(b,c)=W(a,c), for any 3 indicies a,b,ca,b,c (a≤b≤ca≤b≤c doesn't need to hold now, for instance W(3,5)⊕W(5,2)=W(3,2)W(3,5)⊕W(5,2)=W(3,2)). This transformation also shows an observation; Assume every border is a vertex in a graph, and every update W(l,r)=xW(l,r)=x describes an undirected edge between the vertices l,rl,r with weight xx. We let the distance between 2 nodes a,ba,b be the xor of edge weights on the path between them. Notice that this distance is equal to W(a,b)W(a,b). In other words, an update adds an edge and a query asks for some distance.Another observation is that, we do not care about all the 230+1230+1 nodes, but only about the ones we recieved in queries and updates. Moreover, their order is irrelevant, so we can do an online mapping of new nodes to the next free indicies. Thus, the number of nodes will be worstcase O(q)O(q).Claim: We can know the answer to some query [l,r][l,r], if and only if there exists a path between the nodes l,rl,r (they are in the same connected component).//start spoiler of proofThere will be some subset of edges we take, to form the xor between nodes ll and rr. Assume every vertex has 2 states, on/off. Initially all vertices are off, and our current answer is 00. When we take an edge we flip the state of its 2 ends, and xor our answer by its weight. Suppose at some moment of time the nodes with \"on\" state are {x0,x1,x2,...,xkx0,x1,x2,...,xk} (in sorted order). Observe that our current answer is equal to W(x0,x1)⊕W(x2,x3)⊕…⊕W(xk−1,xk)W(x0,x1)⊕W(x2,x3)⊕…⊕W(xk−1,xk). This implies we want our subset of edges to end up having only the nodes {l,rl,r} activated. We look at the connected components. Observe that in each connected component, the number of nodes activated at any time is even. If the nodes ll and rr are in different component, then in our final result we would want to have only 1 activated node in the component of ll, and same with rr, but this is impossible.//end spoiler of proofFirst, we need to know whether a query gives us 2 nodes that are in different components (to know whether the answer is −1−1 or not). For this we need to use the Union-Find structure. Also notice, that our Union-Find structure will only need to handle a forest of trees (if an update gives us an edge that creates a cycle, it means there is no contribution, so we ignore it).Provided that an answer does exist, we need to also handle finding a xor path between 2 nodes in a tree, and to support merging of trees. Generally to find a property over some path in a tree, it is common to use LCA or binary lifting. This turns out very difficult when we also need to merge trees (unless you insist on implementing Link-Cut/ETT). Fortunately, we can still abuse the xor operator. In some tree, mark xvxv as the xor of edges on the path from vv to some arbitrary root in the tree. The xor path between nodes (u,vu,v) turns out to be xu⊕xvxu⊕xv. So we would like to maintain for each tree some arbitrary root and all those values.Notice that we can augment our Union-Find structure to support this as well: For each node vv in the structure, we maintain pvpv as its parent in the structure, and xvxv as the xor on the path from vv to pvpv. Notice that xvxv can be easily updated together with pvpv during the find()find() operation in the structure.To summarize, when we are given W(l,r)=xW(l,r)=x in some update, we transform it to W(pl,pr)=x⊕xl⊕xrW(pl,pr)=x⊕xl⊕xr, and then we add the edge between the parents.Finally, the complexity is O(qlogq)O(qlog⁡q), but this is only due to the online mapping if we use a regular map; You can use a hash table and get a running time of O(q×α(q))O(q×α(q)), but I suggest being careful with a hash table (you may want to read this: https://codeforces.com/blog/entry/62393).Author: Noam527Developer: Noam527 1074E - Grid SortThe solution is more of a coding one than an algorithmic one. There are many different approaches, and it's important to be careful in how it is implemented. I'll explain one of the implementations.First, we can always move a particular block left, up, down, or right with an appropriate 2x2 square around it. Let's code some functions that let us do that for each direction.Next is to make sure that these moves don't mess up previous block spaces as we move blocks to the correct place. We can almost place blocks correctly in their spaces one by one in row major order, but there are some special cases.- We can do all blocks except the last two rows, which we'll handle separately (in paragraph below) - For each row, we can correctly place all blocks except the last one. The last one requires a bit more careful work, but is easy to handle if we have at least two free rows.For the last two rows, we can fill it in column by column from left to right. This is a similar startegy to fitting in the last column of the previous rows. We can almost do this except for the last 2x2 square.For the last 2x2 square, we can use the following sequence of moves to swap two blocks:123456413526421563213456Thus, we can shift the last block into the right position, then do at most three swaps (using the above sequence of moves) to fix the remaining blocks.The number of moves for this strategy can be computed and estimated to be about 50k in the worst case.Author: LewinDeveloper: Lewin 1074F - DFSLet's consider an arbitrary run of DFS producing some tree. Let's root the tree at the starting vertex. It can be shown that on a directed graph, there are only two types of edges. The first are the tree edges (those are the ones that are used to visit a new vertex). The second are edges which, upon being traversed, lead to a vertex that was already visited. It can be shown that, in the rooted tree, those edges always connect a vertex with one of its ancestors. In other words, all the edges that are dynamically added to the tree must connect a vertex with one of their ancestors. This means that the staring vertex must not lie on the path connecting the two endpoints of such edge, or any of the vertices in some of the subtrees. For instance, on the second sample, the edge {2,4}{2,4} disallows the vertex 11 from being the starting vertex, as it lies on the path from 22 to 44, and also vertex 66.Each edge thus forbids a certain set of vertices from being the starting point. This yields a straightforward O(n2)O(n2) solution. To optimize it further, we can root the tree arbitrarily and renumber the vertices using their DFS visit times. When we do this, we notice that the set of a forbidden vertices for each edge is a union of at most three intervals of vertices. This lets us build an O(nlogn)O(nlog⁡n) solution using a segment tree. The operation is add a constant on interval, and then find the minimum on interval and the number of occurrences of said minimum. We add 11 to forbid a vertex because of an edge, subtract 11 to revert that when the edge is subsequently removed. The answer is the number of minimums on the whole tree if that minimum is 00, and 00 otherwise.Author: _h_Developers: _h_ and majk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 1075\\s*B"
          },
          "content_length": 20587
        }
      ],
      "code_examples": [
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 1",
          "code": "123456413526421563213456",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        },
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 2",
          "code": "2 3\n3\n5\n1 4 1\n2 100000 2\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        },
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 3",
          "code": "2 3\n3\n5\n1 4 1\n2 100000 2\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int maxN = 100000;\n    const int maxX = 1000000000;\n    \n    int n = inf.readInt(1, maxN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, maxN, \"m\");\n    inf.readEoln();\n\n    int total = n + m;\n    vector<int> x = inf.readInts(total, 1, maxX, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < total; ++i) {\n        ensuref(x[i] < x[i+1], \"x[%d]=%d is not less than x[%d]=%d, coordinates must be strictly increasing\", i+1, x[i], i+2, x[i+1]);\n    }\n\n    vector<int> t = inf.readInts(total, 0, 1, \"t\");\n    inf.readEoln();\n\n    int sum_t = accumulate(t.begin(), t.end(), 0);\n    ensuref(sum_t == m, \"Sum of t_i equals %d, expected m=%d\", sum_t, m);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int maxN = 100000;\n    const int maxX = 1000000000;\n    \n    int n = inf.readInt(1, maxN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, maxN, \"m\");\n    inf.readEoln();\n\n    int total = n + m;\n    vector<int> x = inf.readInts(total, 1, maxX, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < total; ++i) {\n        ensuref(x[i] < x[i+1], \"x[%d]=%d is not less than x[%d]=%d, coordinates must be strictly increasing\", i+1, x[i], i+2, x[i+1]);\n    }\n\n    vector<int> t = inf.readInts(total, 0, 1, \"t\");\n    inf.readEoln();\n\n    int sum_t = accumulate(t.begin(), t.end(), 0);\n    ensuref(sum_t == m, \"Sum of t_i equals %d, expected m=%d\", sum_t, m);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int maxN = 100000;\n    const int maxX = 1000000000;\n    \n    int n = inf.readInt(1, maxN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, maxN, \"m\");\n    inf.readEoln();\n\n    int total = n + m;\n    vector<int> x = inf.readInts(total, 1, maxX, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < total; ++i) {\n        ensuref(x[i] < x[i+1], \"x[%d]=%d is not less than x[%d]=%d, coordinates must be strictly increasing\", i+1, x[i], i+2, x[i+1]);\n    }\n\n    vector<int> t = inf.readInts(total, 0, 1, \"t\");\n    inf.readEoln();\n\n    int sum_t = accumulate(t.begin(), t.end(), 0);\n    ensuref(sum_t == m, \"Sum of t_i equals %d, expected m=%d\", sum_t, m);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int total = n + m;\n\n    vector<int> positions;\n    vector<int> t;\n\n    if (type == \"random\") {\n        set<int> pos_set;\n        while (pos_set.size() < total) {\n            int pos = rnd.next(1, int(1e9));\n            pos_set.insert(pos);\n        }\n        positions.assign(pos_set.begin(), pos_set.end());\n        sort(positions.begin(), positions.end());\n\n        t.resize(total, 0);\n        vector<int> indices(total);\n        for(int i = 0; i < total; ++i) indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < m; ++i) {\n            t[indices[i]] = 1;\n        }\n\n    } else if (type == \"left\") {\n        int mid = rnd.next(int(1e8), int(9e8));\n        set<int> pos_set_riders;\n        set<int> pos_set_drivers;\n        while(pos_set_riders.size() < n) {\n            int pos = rnd.next(1, mid - 1);\n            pos_set_riders.insert(pos);\n        }\n        while(pos_set_drivers.size() < m) {\n            int pos = rnd.next(mid + 1, int(1e9));\n            pos_set_drivers.insert(pos);\n        }\n        positions.clear();\n        t.clear();\n        for(int pos : pos_set_riders) {\n            positions.push_back(pos);\n            t.push_back(0);\n        }\n        for(int pos : pos_set_drivers) {\n            positions.push_back(pos);\n            t.push_back(1);\n        }\n        vector<pair<int,int>> residents;\n        for(int i = 0; i < positions.size(); ++i) {\n            residents.push_back({positions[i], t[i]});\n        }\n        sort(residents.begin(), residents.end());\n        for(int i = 0; i < total; ++i) {\n            positions[i] = residents[i].first;\n            t[i] = residents[i].second;\n        }\n\n    } else if (type == \"right\") {\n        int mid = rnd.next(int(1e8), int(9e8));\n        set<int> pos_set_riders;\n        set<int> pos_set_drivers;\n        while(pos_set_drivers.size() < m) {\n            int pos = rnd.next(1, mid - 1);\n            pos_set_drivers.insert(pos);\n        }\n        while(pos_set_riders.size() < n) {\n            int pos = rnd.next(mid + 1, int(1e9));\n            pos_set_riders.insert(pos);\n        }\n        positions.clear();\n        t.clear();\n        for(int pos : pos_set_drivers) {\n            positions.push_back(pos);\n            t.push_back(1);\n        }\n        for(int pos : pos_set_riders) {\n            positions.push_back(pos);\n            t.push_back(0);\n        }\n        vector<pair<int,int>> residents;\n        for(int i = 0; i < positions.size(); ++i) {\n            residents.push_back({positions[i], t[i]});\n        }\n        sort(residents.begin(), residents.end());\n        for(int i = 0; i < total; ++i) {\n            positions[i] = residents[i].first;\n            t[i] = residents[i].second;\n        }\n\n    } else if (type == \"alternate\") {\n        set<int> pos_set;\n        while(pos_set.size() < total) {\n            int pos = rnd.next(1, int(1e9));\n            pos_set.insert(pos);\n        }\n        vector<int> pos_vec(pos_set.begin(), pos_set.end());\n        sort(pos_vec.begin(), pos_vec.end());\n\n        positions.clear();\n        t.clear();\n        int remaining_riders = n, remaining_drivers = m;\n        int i = 0;\n        while(remaining_riders > 0 || remaining_drivers > 0) {\n            if ((i % 2 == 0 && remaining_drivers > 0) || remaining_riders == 0) {\n                t.push_back(1);\n                remaining_drivers--;\n            } else {\n                t.push_back(0);\n                remaining_riders--;\n            }\n            positions.push_back(pos_vec[i]);\n            ++i;\n        }\n    } else if (type == \"cluster\") {\n        int center = rnd.next(int(1e8), int(9e8));\n        set<int> pos_set;\n        while(pos_set.size() < total) {\n            int pos = center + rnd.next(-int(1e5), int(1e5));\n            pos = max(1, min(pos, int(1e9)));\n            pos_set.insert(pos);\n        }\n        vector<int> pos_vec(pos_set.begin(), pos_set.end());\n        sort(pos_vec.begin(), pos_vec.end());\n        positions = pos_vec;\n\n        t.resize(total, 0);\n        vector<int> indices(total);\n        for(int i = 0; i < total; ++i) indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < m; ++i) {\n            t[indices[i]] = 1;\n        }\n\n    } else if (type == \"extreme_positions\") {\n        positions.push_back(1);\n        t.push_back(0); \n        positions.push_back(int(1e9));\n        t.push_back(1); \n        set<int> pos_set;\n        pos_set.insert(1);\n        pos_set.insert(int(1e9));\n        while(pos_set.size() < total) {\n            int pos = rnd.next(int(1e8), int(9e8));\n            pos_set.insert(pos);\n        }\n        vector<int> pos_vec(pos_set.begin(), pos_set.end());\n        sort(pos_vec.begin(), pos_vec.end());\n        pos_vec.erase(remove(pos_vec.begin(), pos_vec.end(), 1), pos_vec.end());\n        pos_vec.erase(remove(pos_vec.begin(), pos_vec.end(), int(1e9)), pos_vec.end());\n\n        positions.insert(positions.end(), pos_vec.begin(), pos_vec.end());\n        while(t.size() < positions.size()) {\n            t.push_back(rnd.next(0,1));\n        }\n        int taxis_so_far = count(t.begin(), t.end(), 1);\n        if (taxis_so_far < m) {\n            for(int i = 0; i < positions.size(); ++i) {\n                if (t[i] == 0 && taxis_so_far < m) {\n                    t[i] = 1;\n                    taxis_so_far++;\n                }\n            }\n        } else if(taxis_so_far > m) {\n            for(int i = 0; i < positions.size(); ++i) {\n                if (t[i] == 1 && taxis_so_far > m) {\n                    t[i] = 0;\n                    taxis_so_far--;\n                }\n            }\n        }\n\n    } else {\n        // Default to random\n        set<int> pos_set;\n        while (pos_set.size() < total) {\n            int pos = rnd.next(1, int(1e9));\n            pos_set.insert(pos);\n        }\n        positions.assign(pos_set.begin(), pos_set.end());\n        sort(positions.begin(), positions.end());\n\n        t.resize(total, 0);\n        vector<int> indices(total);\n        for(int i = 0; i < total; ++i) indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < m; ++i) {\n            t[indices[i]] = 1;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < total; ++i) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", positions[i]);\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < total; ++i) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", t[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int total = n + m;\n\n    vector<int> positions;\n    vector<int> t;\n\n    if (type == \"random\") {\n        set<int> pos_set;\n        while (pos_set.size() < total) {\n            int pos = rnd.next(1, int(1e9));\n            pos_set.insert(pos);\n        }\n        positions.assign(pos_set.begin(), pos_set.end());\n        sort(positions.begin(), positions.end());\n\n        t.resize(total, 0);\n        vector<int> indices(total);\n        for(int i = 0; i < total; ++i) indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < m; ++i) {\n            t[indices[i]] = 1;\n        }\n\n    } else if (type == \"left\") {\n        int mid = rnd.next(int(1e8), int(9e8));\n        set<int> pos_set_riders;\n        set<int> pos_set_drivers;\n        while(pos_set_riders.size() < n) {\n            int pos = rnd.next(1, mid - 1);\n            pos_set_riders.insert(pos);\n        }\n        while(pos_set_drivers.size() < m) {\n            int pos = rnd.next(mid + 1, int(1e9));\n            pos_set_drivers.insert(pos);\n        }\n        positions.clear();\n        t.clear();\n        for(int pos : pos_set_riders) {\n            positions.push_back(pos);\n            t.push_back(0);\n        }\n        for(int pos : pos_set_drivers) {\n            positions.push_back(pos);\n            t.push_back(1);\n        }\n        vector<pair<int,int>> residents;\n        for(int i = 0; i < positions.size(); ++i) {\n            residents.push_back({positions[i], t[i]});\n        }\n        sort(residents.begin(), residents.end());\n        for(int i = 0; i < total; ++i) {\n            positions[i] = residents[i].first;\n            t[i] = residents[i].second;\n        }\n\n    } else if (type == \"right\") {\n        int mid = rnd.next(int(1e8), int(9e8));\n        set<int> pos_set_riders;\n        set<int> pos_set_drivers;\n        while(pos_set_drivers.size() < m) {\n            int pos = rnd.next(1, mid - 1);\n            pos_set_drivers.insert(pos);\n        }\n        while(pos_set_riders.size() < n) {\n            int pos = rnd.next(mid + 1, int(1e9));\n            pos_set_riders.insert(pos);\n        }\n        positions.clear();\n        t.clear();\n        for(int pos : pos_set_drivers) {\n            positions.push_back(pos);\n            t.push_back(1);\n        }\n        for(int pos : pos_set_riders) {\n            positions.push_back(pos);\n            t.push_back(0);\n        }\n        vector<pair<int,int>> residents;\n        for(int i = 0; i < positions.size(); ++i) {\n            residents.push_back({positions[i], t[i]});\n        }\n        sort(residents.begin(), residents.end());\n        for(int i = 0; i < total; ++i) {\n            positions[i] = residents[i].first;\n            t[i] = residents[i].second;\n        }\n\n    } else if (type == \"alternate\") {\n        set<int> pos_set;\n        while(pos_set.size() < total) {\n            int pos = rnd.next(1, int(1e9));\n            pos_set.insert(pos);\n        }\n        vector<int> pos_vec(pos_set.begin(), pos_set.end());\n        sort(pos_vec.begin(), pos_vec.end());\n\n        positions.clear();\n        t.clear();\n        int remaining_riders = n, remaining_drivers = m;\n        int i = 0;\n        while(remaining_riders > 0 || remaining_drivers > 0) {\n            if ((i % 2 == 0 && remaining_drivers > 0) || remaining_riders == 0) {\n                t.push_back(1);\n                remaining_drivers--;\n            } else {\n                t.push_back(0);\n                remaining_riders--;\n            }\n            positions.push_back(pos_vec[i]);\n            ++i;\n        }\n    } else if (type == \"cluster\") {\n        int center = rnd.next(int(1e8), int(9e8));\n        set<int> pos_set;\n        while(pos_set.size() < total) {\n            int pos = center + rnd.next(-int(1e5), int(1e5));\n            pos = max(1, min(pos, int(1e9)));\n            pos_set.insert(pos);\n        }\n        vector<int> pos_vec(pos_set.begin(), pos_set.end());\n        sort(pos_vec.begin(), pos_vec.end());\n        positions = pos_vec;\n\n        t.resize(total, 0);\n        vector<int> indices(total);\n        for(int i = 0; i < total; ++i) indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < m; ++i) {\n            t[indices[i]] = 1;\n        }\n\n    } else if (type == \"extreme_positions\") {\n        positions.push_back(1);\n        t.push_back(0); \n        positions.push_back(int(1e9));\n        t.push_back(1); \n        set<int> pos_set;\n        pos_set.insert(1);\n        pos_set.insert(int(1e9));\n        while(pos_set.size() < total) {\n            int pos = rnd.next(int(1e8), int(9e8));\n            pos_set.insert(pos);\n        }\n        vector<int> pos_vec(pos_set.begin(), pos_set.end());\n        sort(pos_vec.begin(), pos_vec.end());\n        pos_vec.erase(remove(pos_vec.begin(), pos_vec.end(), 1), pos_vec.end());\n        pos_vec.erase(remove(pos_vec.begin(), pos_vec.end(), int(1e9)), pos_vec.end());\n\n        positions.insert(positions.end(), pos_vec.begin(), pos_vec.end());\n        while(t.size() < positions.size()) {\n            t.push_back(rnd.next(0,1));\n        }\n        int taxis_so_far = count(t.begin(), t.end(), 1);\n        if (taxis_so_far < m) {\n            for(int i = 0; i < positions.size(); ++i) {\n                if (t[i] == 0 && taxis_so_far < m) {\n                    t[i] = 1;\n                    taxis_so_far++;\n                }\n            }\n        } else if(taxis_so_far > m) {\n            for(int i = 0; i < positions.size(); ++i) {\n                if (t[i] == 1 && taxis_so_far > m) {\n                    t[i] = 0;\n                    taxis_so_far--;\n                }\n            }\n        }\n\n    } else {\n        // Default to random\n        set<int> pos_set;\n        while (pos_set.size() < total) {\n            int pos = rnd.next(1, int(1e9));\n            pos_set.insert(pos);\n        }\n        positions.assign(pos_set.begin(), pos_set.end());\n        sort(positions.begin(), positions.end());\n\n        t.resize(total, 0);\n        vector<int> indices(total);\n        for(int i = 0; i < total; ++i) indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < m; ++i) {\n            t[indices[i]] = 1;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < total; ++i) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", positions[i]);\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < total; ++i) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", t[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type left\n./gen -n 1 -m 1 -type right\n./gen -n 1 -m 1 -type alternate\n./gen -n 1 -m 1 -type cluster\n./gen -n 1 -m 1 -type extreme_positions\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type left\n./gen -n 10 -m 10 -type right\n./gen -n 10 -m 10 -type alternate\n./gen -n 10 -m 10 -type cluster\n./gen -n 10 -m 10 -type extreme_positions\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type left\n./gen -n 100 -m 100 -type right\n./gen -n 100 -m 100 -type alternate\n./gen -n 100 -m 100 -type cluster\n./gen -n 100 -m 100 -type extreme_positions\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type left\n./gen -n 1000 -m 1000 -type right\n./gen -n 1000 -m 1000 -type alternate\n./gen -n 1000 -m 1000 -type cluster\n./gen -n 1000 -m 1000 -type extreme_positions\n\n./gen -n 10000 -m 10000 -type random\n./gen -n 10000 -m 10000 -type left\n./gen -n 10000 -m 10000 -type right\n./gen -n 10000 -m 10000 -type alternate\n./gen -n 10000 -m 10000 -type cluster\n./gen -n 10000 -m 10000 -type extreme_positions\n\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type left\n./gen -n 100000 -m 100000 -type right\n./gen -n 100000 -m 100000 -type alternate\n./gen -n 100000 -m 100000 -type cluster\n./gen -n 100000 -m 100000 -type extreme_positions\n\n./gen -n 1 -m 100000 -type random\n./gen -n 100000 -m 1 -type random\n\n./gen -n 1000 -m 100 -type random\n./gen -n 100 -m 1000 -type random\n\n./gen -n 10 -m 100000 -type random\n./gen -n 100000 -m 10 -type random\n\n./gen -n 1000 -m 2 -type left\n./gen -n 1000 -m 2 -type right\n./gen -n 1000 -m 1 -type cluster\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:15:01.365130",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1075/C",
      "title": "C. The Tower is Going Home",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers nn and mm (0≤n,m≤1050≤n,m≤105) — the number of vertical and horizontal spells.Each of the following nn lines contains one integer xx (1≤x<1091≤x<109) — the description of the vertical spell. It will create a blocking line between the columns of xx and x+1x+1.Each of the following mm lines contains three integers x1x1, x2x2 and yy (1≤x1≤x2≤1091≤x1≤x2≤109, 1≤y<1091≤y<109) — the numbers that describe the horizontal spell. It will create a blocking segment that passes through the top sides of the cells that are in the row with the number yy, in columns from x1x1 to x2x2 inclusive.It is guaranteed that all spells are different, as well as the fact that for each pair of horizontal spells it is true that the segments that describe them do not have common points.",
      "output_spec": "OutputIn a single line print one integer — the minimum number of spells the rook needs to remove so it can get from the cell (1,1)(1,1) to at least one cell in the row with the number 109109",
      "sample_tests": "ExamplesInputCopy2 3681 5 61 9 42 4 2OutputCopy1InputCopy1 341 5 31 9 44 6 6OutputCopy1InputCopy0 21 1000000000 41 1000000000 2OutputCopy2InputCopy0 0OutputCopy0InputCopy2 3461 4 31 5 21 6 5OutputCopy2",
      "description": "C. The Tower is Going Home\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers nn and mm (0≤n,m≤1050≤n,m≤105) — the number of vertical and horizontal spells.Each of the following nn lines contains one integer xx (1≤x<1091≤x<109) — the description of the vertical spell. It will create a blocking line between the columns of xx and x+1x+1.Each of the following mm lines contains three integers x1x1, x2x2 and yy (1≤x1≤x2≤1091≤x1≤x2≤109, 1≤y<1091≤y<109) — the numbers that describe the horizontal spell. It will create a blocking segment that passes through the top sides of the cells that are in the row with the number yy, in columns from x1x1 to x2x2 inclusive.It is guaranteed that all spells are different, as well as the fact that for each pair of horizontal spells it is true that the segments that describe them do not have common points.\n\nOutputIn a single line print one integer — the minimum number of spells the rook needs to remove so it can get from the cell (1,1)(1,1) to at least one cell in the row with the number 109109\n\nInputCopy2 3681 5 61 9 42 4 2OutputCopy1InputCopy1 341 5 31 9 44 6 6OutputCopy1InputCopy0 21 1000000000 41 1000000000 2OutputCopy2InputCopy0 0OutputCopy0InputCopy2 3461 4 31 5 21 6 5OutputCopy2\n\nInputCopy2 3681 5 61 9 42 4 2\n\nOutputCopy1\n\nInputCopy1 341 5 31 9 44 6 6\n\nOutputCopy1\n\nInputCopy0 21 1000000000 41 1000000000 2\n\nOutputCopy2\n\nInputCopy0 0\n\nOutputCopy0\n\nInputCopy2 3461 4 31 5 21 6 5\n\nOutputCopy2\n\nNoteIn the first sample, in order for the rook return home, it is enough to remove the second horizontal spell.  Illustration for the first sample. On the left it shows how the field looked at the beginning. On the right it shows how the field looked after the deletion of the second horizontal spell. It also shows the path, on which the rook would be going home. In the second sample, in order for the rook to return home, it is enough to remove the only vertical spell. If we tried to remove just one of the horizontal spells, it would not allow the rook to get home, because it would be blocked from above by one of the remaining horizontal spells (either first one or second one), and to the right it would be blocked by a vertical spell.  Illustration for the second sample. On the left it shows how the field looked at the beginning. On the right it shows how it looked after the deletion of the vertical spell. It also shows the path, on which the rook would be going home. In the third sample, we have two horizontal spells that go through the whole field. These spells can not be bypassed, so we need to remove both of them.  Illustration for the third sample. On the left it shows how the field looked at the beginning. On the right it shows how the field looked after the deletion of the horizontal spells. It also shows the path, on which the rook would be going home. In the fourth sample, we have no spells, which means that we do not need to remove anything.In the fifth example, we can remove the first vertical and third horizontal spells.  Illustration for the fifth sample. On the left it shows how the field looked at the beginning. On the right it shows how it looked after the deletions. It also shows the path, on which the rook would be going home.",
      "solutions": [
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces",
          "content": "1075A - The King's RaceLet's find the minimum time needed for the white king to reach the coin.It is obvious that it is always optimal to move only towards the coin. In case of white king it means that we should move only up, right or up-right diagonally. During one move we can only add 11 or 00 to any of our coordinates (or to both of them), it means that the length of the optimal path can not be smaller than max(x−1,y−1)max(x−1,y−1).Let's show that we can reach the coin with max(x−1,y−1)max(x−1,y−1) moves.First step. Let zz be equal to min(x,y)min(x,y). The king does z−1z−1 up-right moves, so after that the king will be in the cell (z,z)(z,z). Second step. Let's assume that x≤yx≤y (the case when x>yx>y is proved in a similar way). So z=xz=x. It means that the king is in the cell (x,x)(x,x). Now the king can do y−xy−x up moves, after which he would be in the cell (x,y)(x,y). It took him (x−1)+(y−x)=y−1(x−1)+(y−x)=y−1 moves to reach the coin. If xx was greater than yy he would need x−1x−1 moves (could be proved the same way). So now we proved that it takes max(x−1,y−1)max(x−1,y−1) moves for the white king to reach the coin.In the same way we can prove that it takes max(n−x,n−y)max(n−x,n−y) steps for the black king to reach the coin.The king, which is closer to the coin, wins. If the distances is equal, than the white king wins, because he moves first.Final description of the algorithm:If max(n−x,n−y)<max(x−1,y−1)max(n−x,n−y)<max(x−1,y−1) then the answer is \"Black\", otherwise the answer is \"White\".It is also can be proven that instead of comparing minimal distances between the coin and the kings we can compare manhattan distances between them. I will leave the proof as homework task.Author: arsijoDeveloper: stanislav.bezkorovainyi 1075B - Taxi drivers and LyftLet's find for each rider the taxi driver that will get his call.To do this we can find for each rider the nearest taxi driver at right and the nearest taxi driver at left. Let's define the nearest taxi driver at left for ii-th citizen as lili and at the right as riri.The computations can be done with the following algorithm:Let's define l0=0l0=0 and rn+m+1=n+m+1rn+m+1=n+m+1. And x0=−2∗109x0=−2∗109, xn+m+1=2∗109xn+m+1=2∗109.In order to find lili for each ii we should iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a taxi driver, then he/she is obviously the nearest taxi driver to himself/herself. If the ii-th citizen is a rider, then li=li−1li=li−1In order to find riri for each ii we should iterate through the citizens from n+mn+m to 11. If the ii-th citizen is a taxi driver, then ri=iri=i, else ri=ri+1ri=ri+1.Now it's time to compute the answer.Let's denote bibi as the number of citizens, whose calls the ii-th citizen will get (if the ii-th citizen is a rider, then bi=0bi=0).In order to do compute the values of array bb we should iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a rider, then if the xri−xi<xi−xlixri−xi<xi−xli (distance between the nearest taxi driver at right and the ii-th citizen is smaller than distance between the nearest taxi driver at the left and the citizen), then taxi driver riri will get the call, otherwise the taxi driver lili will get the call. So if xri−xi<xi−xlixri−xi<xi−xli, then bri:=bri+1bri:=bri+1, else bli:=bli+1bli:=bli+1. In order to print out the answer we iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a taxi driver, than we should print bibi.The algorithm iterates through the array four times, so overall complexity is O(n+m)O(n+m)Author: arsijoDeveloper: stanislav.bezkorovainyi 1074A - The Tower is Going HomeObservation 1. If we remove all the horizontal spells, than the rook can move straightforward up to the upper side of the field. So the only purpose of removing the vertical spells is to reduce the number of horizontal spells to be removed.Observation 2. If we want to remove the ii-th vertical spell, then we should also remove all such vertical spells jj, that xj<xixj<xi. It is obvious, because when we delete a vertical spell, we suppose that the rook would be able to outflank some horizontal spells by getting at rows that have greater number than xixi. If there remains at least one vertical spell jj, such that xj<xixj<xi, than we will never be able to move to the rows with number greater than xjxj, including xixi.Let's find some observations about the horizontal spells:Let's assume that we deleted ii vertical spells. It means, that the rook can move freely left and right at columns between 11 and xi+1xi+1 inclusive. Let's say that our rook is on the row yy. If there is at least one cell which is located at row yy at any column between 11 and xi+1xi+1, that there is no blocking segment on the top of it, then the rook can move to this cell and move upwards into the row y+1y+1. It means that if there is at least one gap in the blocking segments in row yy and in columns between 11 and xi+1xi+1 incluse, then there is no need to remove any of horizontal spells in the row.Observation 3. We care only about such horizontal spells, in which x1=1x1=1. We have already proved, that we only care about such rows, that there are no gaps in blocking segments in them. If there is no such horizontal spell with x1=1x1=1, it means that there is a gap in the row at column 11. If there is such horizontal spell, then if there are more spells in that row, there would be a gap between any pair of neighbouring segments. Since we only care only about segments with x1=1x1=1 and it is guaranteed that no horizontal segments share a common point, it means that we might not care about the yy of any horizontal spell, because there is no such pair of segments that both x1x1 and yy of these are equal. So now while reading the descriptions of the horizontal spells, if the x1x1 of ii-th horizontal spell is not equal to 11, we can ignore it. Otherwise, we add x2x2 to some array.Now we can sort the array of x2x2-s, and solve the task using the two-pointer technique. Here is the final algorithm: Add fake vertical spell with x=109x=109.Sort all the vertical spells in ascending order.While reading the descriptions of the horizontal spells, we ignore ones with x1x1 not equal to 11. In other case, we add x2x2 to the array.Sort the array of x2x2-s in ascending order. Now we use the two pointer technique in the following way: we iterate ii from 0 to n — the number of vertical spells to be deleted and on each step we advance the pointer while the x2x2 at which the pointer points is less then xx of the (i+1)(i+1)-th vertical spell. Let's denote the position of the pointer as pp. The number of horizontal spells, that we need to remove with ii vertical spells removed is m−p+1m−p+1. Let's define the position of the pointer at ii-th step as pipi.The answer to the problem in minival value of i+m−pi+1i+m−pi+1 among all ii from 00 to nn.Overall complexity O(nlogn+mlogm)O(nlog⁡n+mlog⁡m)Author: stanislav.bezkorovainyiDeveloper: stanislav.bezkorovainyi 1074B - Intersecting SubtreesI'll split this into two parts, first is the solution, second is why it works.The intended solution only uses two questions. Choose an arbitrary yjyj, and ask \"B y_j\". Let the response be RR. Find a node xixi that is the closest to node RR. This can be done with a BFS or DFS. Ask \"A x_i\". Let the response be QQ. If QQ is one of y1,y2,…,yk2y1,y2,…,yk2, print \"C x_i\", otherwise, print \"C -1\". Here is why it works. Let's use the fact that if the two subtrees don't intersect, there is an edge in the tree such that if we cut the tree on this edge, it will split it into two components, each containing one of the subtrees.Suppose we did step 1 and we have RR. Let's root our tree at RR. There is a unique node xixi that has lowest depth in this tree which we can find (given that x1,x2,…,xk1x1,x2,…,xk1 form a subtree).Now, we claim that the two subtrees intersect if and only if Li Chen owns a node that lies in the subtree rooted by xixi (and in particular, we will show it is sufficient to only check node xixi).If none of Li Chen's nodes lie in the subtree rooted by xixi, then the edge xixi to its parent cuts the tree into two components with one subtree completely lying in one component and the other in the second, so the two subtrees are disjoint.Otherwise, there is a node WW that is in Li Chen's subtree that lies in the subtree rooted by xixi. All nodes in the path of RR to WW must also belong to Li Chen's subtree, and in particular this includes node xixi, so the two trees intersect. This also shows we can just check if xixi belongs in Li Chen's subtree by asking a question about it.Author: LewinDeveloper: Lewin 1074C - Optimal Polygon PerimeterI will show 2 solutions, both of which work in O(n)O(n) time. First, it is not hard to notice that we can only consider polygons that are convex.Observation: For a convex polygon, the given definition of \"polygon perimeter\" is equivalent to the perimeter of the bounding rectangle (aligned with the axis), of our polygon. If we look at some convex polygon, and 4 values maxx,minx,maxy,minymaxx,minx,maxy,miny representing the maximal xx coordinate of a point, minimal xx, maximal and minimal yy, then the perimeter of the bounding rectangle is simply 2∗(maxx−minx+maxy−miny)2∗(maxx−minx+maxy−miny).This simple rephrase gives us a bonus, and crucial observation: It is enough for us to take 4 points from the input, such that the perimeter of their polygon is the maximal possible (and is equal to the perimeter of the polygon formed from nn points). We will consider these the extreme points. Note that after taking the extreme points, it does not matter which other points we take. So, this solves all f(4),…,f(n)f(4),…,f(n).We are left with f(3)f(3) to compute (maximal triangle perimeter). Following are 2 solutions to do it:Solution 1: Let's show that the optimal triangle uses at least 2 of the extreme points. Imagine some optimal triangle, and its bounding rectangle. Notice that since each edge of the bounding rectangle must touch some vertex of the triangle (it is bounding after all), and we have 4 edges and 3 vertices, then there must be some vertex of the triangle that touches 2 edges of the rectangle (so it coincides with a rectangle vertex). If this is the case, we know that in comparison with the 2 other vertices, this vertex has \"extremal\" X and Y coordinates (minimal/maximal X, and minimal/maximal Y). Without loss of generality, assume this vertex has maximum X and Y. Then to optimize the perimeter, the other two vertices should have smallest possible X and smallest possible Y. We can pick these 2 vertices to be 2 of the extreme points (one with minimal X and one with minimal Y). So, this shows we just need to iterate over every adjacent pair of extreme vertices, and over all other points as the last vertex. This takes O(n)O(n).Solution 2: This solution is more general, and is an extension of the problem to find the 2 most distant points (manhattan distance). The triangle perimeter is an expression with 6 terms: |x1−x2|+|y1−y2|+…+|y3−y1||x1−x2|+|y1−y2|+…+|y3−y1|. We wish the maximize this expression, but the absolute value is troubling us. For each term, there are 2 cases: either it is positive, so the absolute value does nothing, or it is negative, so the absolute value negates it. In total, for the 6 terms we have 26=6426=64 options to place signs between them. We will call such option a setting.For any setting, the advantage now is that we can accumulate terms: For example the setting ++−−−+++−−−+, evaluates the expression to: (2x1+0y1)+(−2x2−2y2)+(0x3+2y3)(2x1+0y1)+(−2x2−2y2)+(0x3+2y3) We solve every setting by its own, and over all settings we take the maximal answer.Please note, that this strategy only works to find the maximal value of the expression, not minimal. The proof of this is left as an exercise to the reader :) (I promise it is not difficult).Given 6 constants c1,c2,...,c6c1,c2,...,c6, we want to find 3 indicies i<j<ki<j<k to maximize: c1∗xi+c2∗yi+...+c6∗ykc1∗xi+c2∗yi+...+c6∗yk. We define 3 arrays: Pi=c1⋅xi+c2⋅yiPi=c1⋅xi+c2⋅yi Qi=c3⋅xi+c4⋅yiQi=c3⋅xi+c4⋅yi Ri=c5⋅xi+c6⋅yiRi=c5⋅xi+c6⋅yi And so we want to maximize Pi+Qj+RkPi+Qj+Rk. This can be done in O(n)O(n) with simple dynamic programming.So this whole solution is O(n)O(n), with a constant of 64. In general, to compute f(k)f(k) this solution takes O(n⋅4k⋅k)O(n⋅4k⋅k) time, without any observations.Author: Noam527Developer: Noam527 1074D - Deduction QueriesFirst, let's learn how to handle information we have not recieved in updates. Let the function W(l,r)W(l,r) be equal to the xor of the subarray [l,r][l,r]. Also, we define W(l,r)=W(r,l)W(l,r)=W(r,l).Assume 3 indicies a≤b≤ca≤b≤c. There are 2 rules: W(a,b)⊕W(b+1,c)=W(a,c)W(a,b)⊕W(b+1,c)=W(a,c). W(a,c)⊕W(b,c)=W(a,b−1)W(a,c)⊕W(b,c)=W(a,b−1) (holds when a<ba<b). These rules require a lot of conditions (and also plenty of ±± 1). We can simplify them greatly: Let's index the borders between cells in our array (there are 230+1230+1 of them). Now, instead of defining a subarray [l,r][l,r] by its 2 endpoint cells, we will define a subarray by its 2 endpoint borders. Technically it just means, that we should increase rr by 1, and then we get the 2 end borders.From now I will assume that our input is given in such a way, that subarrays are defined by their borders (So I will not mention the addition of 1 to rr). Notice that the function W(l,r)W(l,r) is also affected by this.If we take a look at our rules again, they boil down to just 1 rule: W(a,b)⊕W(b,c)=W(a,c)W(a,b)⊕W(b,c)=W(a,c), for any 3 indicies a,b,ca,b,c (a≤b≤ca≤b≤c doesn't need to hold now, for instance W(3,5)⊕W(5,2)=W(3,2)W(3,5)⊕W(5,2)=W(3,2)). This transformation also shows an observation; Assume every border is a vertex in a graph, and every update W(l,r)=xW(l,r)=x describes an undirected edge between the vertices l,rl,r with weight xx. We let the distance between 2 nodes a,ba,b be the xor of edge weights on the path between them. Notice that this distance is equal to W(a,b)W(a,b). In other words, an update adds an edge and a query asks for some distance.Another observation is that, we do not care about all the 230+1230+1 nodes, but only about the ones we recieved in queries and updates. Moreover, their order is irrelevant, so we can do an online mapping of new nodes to the next free indicies. Thus, the number of nodes will be worstcase O(q)O(q).Claim: We can know the answer to some query [l,r][l,r], if and only if there exists a path between the nodes l,rl,r (they are in the same connected component).//start spoiler of proofThere will be some subset of edges we take, to form the xor between nodes ll and rr. Assume every vertex has 2 states, on/off. Initially all vertices are off, and our current answer is 00. When we take an edge we flip the state of its 2 ends, and xor our answer by its weight. Suppose at some moment of time the nodes with \"on\" state are {x0,x1,x2,...,xkx0,x1,x2,...,xk} (in sorted order). Observe that our current answer is equal to W(x0,x1)⊕W(x2,x3)⊕…⊕W(xk−1,xk)W(x0,x1)⊕W(x2,x3)⊕…⊕W(xk−1,xk). This implies we want our subset of edges to end up having only the nodes {l,rl,r} activated. We look at the connected components. Observe that in each connected component, the number of nodes activated at any time is even. If the nodes ll and rr are in different component, then in our final result we would want to have only 1 activated node in the component of ll, and same with rr, but this is impossible.//end spoiler of proofFirst, we need to know whether a query gives us 2 nodes that are in different components (to know whether the answer is −1−1 or not). For this we need to use the Union-Find structure. Also notice, that our Union-Find structure will only need to handle a forest of trees (if an update gives us an edge that creates a cycle, it means there is no contribution, so we ignore it).Provided that an answer does exist, we need to also handle finding a xor path between 2 nodes in a tree, and to support merging of trees. Generally to find a property over some path in a tree, it is common to use LCA or binary lifting. This turns out very difficult when we also need to merge trees (unless you insist on implementing Link-Cut/ETT). Fortunately, we can still abuse the xor operator. In some tree, mark xvxv as the xor of edges on the path from vv to some arbitrary root in the tree. The xor path between nodes (u,vu,v) turns out to be xu⊕xvxu⊕xv. So we would like to maintain for each tree some arbitrary root and all those values.Notice that we can augment our Union-Find structure to support this as well: For each node vv in the structure, we maintain pvpv as its parent in the structure, and xvxv as the xor on the path from vv to pvpv. Notice that xvxv can be easily updated together with pvpv during the find()find() operation in the structure.To summarize, when we are given W(l,r)=xW(l,r)=x in some update, we transform it to W(pl,pr)=x⊕xl⊕xrW(pl,pr)=x⊕xl⊕xr, and then we add the edge between the parents.Finally, the complexity is O(qlogq)O(qlog⁡q), but this is only due to the online mapping if we use a regular map; You can use a hash table and get a running time of O(q×α(q))O(q×α(q)), but I suggest being careful with a hash table (you may want to read this: https://codeforces.com/blog/entry/62393).Author: Noam527Developer: Noam527 1074E - Grid SortThe solution is more of a coding one than an algorithmic one. There are many different approaches, and it's important to be careful in how it is implemented. I'll explain one of the implementations.First, we can always move a particular block left, up, down, or right with an appropriate 2x2 square around it. Let's code some functions that let us do that for each direction.Next is to make sure that these moves don't mess up previous block spaces as we move blocks to the correct place. We can almost place blocks correctly in their spaces one by one in row major order, but there are some special cases.- We can do all blocks except the last two rows, which we'll handle separately (in paragraph below) - For each row, we can correctly place all blocks except the last one. The last one requires a bit more careful work, but is easy to handle if we have at least two free rows.For the last two rows, we can fill it in column by column from left to right. This is a similar startegy to fitting in the last column of the previous rows. We can almost do this except for the last 2x2 square.For the last 2x2 square, we can use the following sequence of moves to swap two blocks:123456413526421563213456Thus, we can shift the last block into the right position, then do at most three swaps (using the above sequence of moves) to fix the remaining blocks.The number of moves for this strategy can be computed and estimated to be about 50k in the worst case.Author: LewinDeveloper: Lewin 1074F - DFSLet's consider an arbitrary run of DFS producing some tree. Let's root the tree at the starting vertex. It can be shown that on a directed graph, there are only two types of edges. The first are the tree edges (those are the ones that are used to visit a new vertex). The second are edges which, upon being traversed, lead to a vertex that was already visited. It can be shown that, in the rooted tree, those edges always connect a vertex with one of its ancestors. In other words, all the edges that are dynamically added to the tree must connect a vertex with one of their ancestors. This means that the staring vertex must not lie on the path connecting the two endpoints of such edge, or any of the vertices in some of the subtrees. For instance, on the second sample, the edge {2,4}{2,4} disallows the vertex 11 from being the starting vertex, as it lies on the path from 22 to 44, and also vertex 66.Each edge thus forbids a certain set of vertices from being the starting point. This yields a straightforward O(n2)O(n2) solution. To optimize it further, we can root the tree arbitrarily and renumber the vertices using their DFS visit times. When we do this, we notice that the set of a forbidden vertices for each edge is a union of at most three intervals of vertices. This lets us build an O(nlogn)O(nlog⁡n) solution using a segment tree. The operation is add a constant on interval, and then find the minimum on interval and the number of occurrences of said minimum. We add 11 to forbid a vertex because of an edge, subtract 11 to revert that when the edge is subsequently removed. The answer is the number of minimums on the whole tree if that minimum is 00, and 00 otherwise.Author: _h_Developers: _h_ and majk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1075 和字母"
          },
          "content_length": 20587
        }
      ],
      "code_examples": [
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 1",
          "code": "123456413526421563213456",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        },
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 2",
          "code": "2 3\n3\n5\n1 4 1\n2 100000 2\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        },
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 3",
          "code": "2 3\n3\n5\n1 4 1\n2 100000 2\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<int> verticalSpells;\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(1, 1000000000 - 1, \"x\");\n        inf.readEoln();\n        ensuref(verticalSpells.insert(x).second, \"Vertical spell x=%d appears more than once\", x);\n    }\n\n    typedef tuple<int, int, int> Spell;\n    set<Spell> horizontalSpellsSet;\n    map<int, vector<pair<int, int>>> horizontalSpellsByY;\n    for (int i = 0; i < m; i++) {\n        int x1 = inf.readInt(1, 1000000000, \"x1\");\n        inf.readSpace();\n        int x2 = inf.readInt(x1, 1000000000, \"x2\");\n        inf.readSpace();\n        int y = inf.readInt(1, 1000000000 - 1, \"y\");\n        inf.readEoln();\n\n        Spell s = make_tuple(x1, x2, y);\n        ensuref(horizontalSpellsSet.insert(s).second, \"Horizontal spell at x1=%d, x2=%d, y=%d appears more than once\", x1, x2, y);\n        horizontalSpellsByY[y].push_back({x1, x2});\n    }\n\n    // For each y, check that the spells do not have common points\n    for (const auto& entry : horizontalSpellsByY) {\n        int y = entry.first;\n        vector<pair<int, int>> spells = entry.second;\n        sort(spells.begin(), spells.end());\n        for (size_t i = 0; i + 1 < spells.size(); i++) {\n            int x1_i = spells[i].first;\n            int x2_i = spells[i].second;\n            int x1_j = spells[i + 1].first;\n            int x2_j = spells[i + 1].second;\n            ensuref(x2_i < x1_j, \"Horizontal spells at y=%d overlap or touch: [%d, %d] and [%d, %d]\", y, x1_i, x2_i, x1_j, x2_j);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<int> verticalSpells;\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(1, 1000000000 - 1, \"x\");\n        inf.readEoln();\n        ensuref(verticalSpells.insert(x).second, \"Vertical spell x=%d appears more than once\", x);\n    }\n\n    typedef tuple<int, int, int> Spell;\n    set<Spell> horizontalSpellsSet;\n    map<int, vector<pair<int, int>>> horizontalSpellsByY;\n    for (int i = 0; i < m; i++) {\n        int x1 = inf.readInt(1, 1000000000, \"x1\");\n        inf.readSpace();\n        int x2 = inf.readInt(x1, 1000000000, \"x2\");\n        inf.readSpace();\n        int y = inf.readInt(1, 1000000000 - 1, \"y\");\n        inf.readEoln();\n\n        Spell s = make_tuple(x1, x2, y);\n        ensuref(horizontalSpellsSet.insert(s).second, \"Horizontal spell at x1=%d, x2=%d, y=%d appears more than once\", x1, x2, y);\n        horizontalSpellsByY[y].push_back({x1, x2});\n    }\n\n    // For each y, check that the spells do not have common points\n    for (const auto& entry : horizontalSpellsByY) {\n        int y = entry.first;\n        vector<pair<int, int>> spells = entry.second;\n        sort(spells.begin(), spells.end());\n        for (size_t i = 0; i + 1 < spells.size(); i++) {\n            int x1_i = spells[i].first;\n            int x2_i = spells[i].second;\n            int x1_j = spells[i + 1].first;\n            int x2_j = spells[i + 1].second;\n            ensuref(x2_i < x1_j, \"Horizontal spells at y=%d overlap or touch: [%d, %d] and [%d, %d]\", y, x1_i, x2_i, x1_j, x2_j);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<int> verticalSpells;\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(1, 1000000000 - 1, \"x\");\n        inf.readEoln();\n        ensuref(verticalSpells.insert(x).second, \"Vertical spell x=%d appears more than once\", x);\n    }\n\n    typedef tuple<int, int, int> Spell;\n    set<Spell> horizontalSpellsSet;\n    map<int, vector<pair<int, int>>> horizontalSpellsByY;\n    for (int i = 0; i < m; i++) {\n        int x1 = inf.readInt(1, 1000000000, \"x1\");\n        inf.readSpace();\n        int x2 = inf.readInt(x1, 1000000000, \"x2\");\n        inf.readSpace();\n        int y = inf.readInt(1, 1000000000 - 1, \"y\");\n        inf.readEoln();\n\n        Spell s = make_tuple(x1, x2, y);\n        ensuref(horizontalSpellsSet.insert(s).second, \"Horizontal spell at x1=%d, x2=%d, y=%d appears more than once\", x1, x2, y);\n        horizontalSpellsByY[y].push_back({x1, x2});\n    }\n\n    // For each y, check that the spells do not have common points\n    for (const auto& entry : horizontalSpellsByY) {\n        int y = entry.first;\n        vector<pair<int, int>> spells = entry.second;\n        sort(spells.begin(), spells.end());\n        for (size_t i = 0; i + 1 < spells.size(); i++) {\n            int x1_i = spells[i].first;\n            int x2_i = spells[i].second;\n            int x1_j = spells[i + 1].first;\n            int x2_j = spells[i + 1].second;\n            ensuref(x2_i < x1_j, \"Horizontal spells at y=%d overlap or touch: [%d, %d] and [%d, %d]\", y, x1_i, x2_i, x1_j, x2_j);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> verticalSpells;\n    vector<tuple<int, int, int>> horizontalSpells;\n    \n    if (type == \"no_spells\") {\n        n = 0;\n        m = 0;\n    }\n    else if (type == \"random\") {\n        // Generate random vertical spells\n        set<int> verticalSet;\n        while ((int)verticalSet.size() < n) {\n            int x = rnd.next(1, int(1e9) - 1);\n            verticalSet.insert(x);\n        }\n        verticalSpells.assign(verticalSet.begin(), verticalSet.end());\n        \n        // Generate random horizontal spells, ensuring no overlapping\n        set<int> usedY;\n        for (int i = 0; i < m; ++i) {\n            int y;\n            do {\n                y = rnd.next(1, int(1e9) - 1);\n            } while (usedY.count(y));\n            usedY.insert(y);\n            int x1 = rnd.next(1, int(1e9));\n            int x2 = rnd.next(x1, int(1e9));\n            horizontalSpells.emplace_back(x1, x2, y);\n        }\n    }\n    else if (type == \"block_row\") {\n        // Create horizontal spells that cover entire row\n        int y = rnd.next(1, int(1e9) - 1);\n        int segments = m;\n        long long totalWidth = 1e9;\n        long long segmentWidth = (totalWidth + segments - 1) / segments;\n        long long x = 1;\n        for (int i = 0; i < segments; ++i) {\n            long long x1 = x;\n            long long x2 = min(x1 + segmentWidth - 1, (long long)1e9);\n            x = x2 + 1;\n            horizontalSpells.emplace_back((int)x1, (int)x2, y);\n            if (x > 1e9) break;\n        }\n        n = 0;\n    }\n    else if (type == \"block_column\") {\n        // Create vertical spells blocking rook from moving right\n        int maxX = min(int(1e9) - 1, n + 1);\n        for (int x = 1; x <= maxX; ++x) {\n            verticalSpells.push_back(x);\n        }\n        m = 0;\n    }\n    else if (type == \"path_blocked\") {\n        // Block the rook's path unless specific spells are removed\n        // Place vertical spells at x = 1, 2, ..., n\n        for (int x = 1; x <= n; ++x) {\n            verticalSpells.push_back(x);\n        }\n        // Place horizontal spells at increasing y\n        int y = 2;\n        for (int i = 0; i < m; ++i) {\n            // Ensure horizontal spells do not overlap, so use different y\n            horizontalSpells.emplace_back(1, int(1e9), y);\n            y += 1;\n            if (y >= int(1e9)) break;\n        }\n    }\n    else {\n        // Default to random\n        // Generate random vertical spells\n        set<int> verticalSet;\n        while ((int)verticalSet.size() < n) {\n            int x = rnd.next(1, int(1e9) - 1);\n            verticalSet.insert(x);\n        }\n        verticalSpells.assign(verticalSet.begin(), verticalSet.end());\n        \n        // Generate random horizontal spells, ensuring no overlapping\n        set<int> usedY;\n        for (int i = 0; i < m; ++i) {\n            int y;\n            do {\n                y = rnd.next(1, int(1e9) - 1);\n            } while (usedY.count(y));\n            usedY.insert(y);\n            int x1 = rnd.next(1, int(1e9));\n            int x2 = rnd.next(x1, int(1e9));\n            horizontalSpells.emplace_back(x1, x2, y);\n        }\n    }\n    \n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int x : verticalSpells) {\n        printf(\"%d\\n\", x);\n    }\n    for (auto& spell : horizontalSpells) {\n        int x1, x2, y;\n        tie(x1, x2, y) = spell;\n        printf(\"%d %d %d\\n\", x1, x2, y);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> verticalSpells;\n    vector<tuple<int, int, int>> horizontalSpells;\n    \n    if (type == \"no_spells\") {\n        n = 0;\n        m = 0;\n    }\n    else if (type == \"random\") {\n        // Generate random vertical spells\n        set<int> verticalSet;\n        while ((int)verticalSet.size() < n) {\n            int x = rnd.next(1, int(1e9) - 1);\n            verticalSet.insert(x);\n        }\n        verticalSpells.assign(verticalSet.begin(), verticalSet.end());\n        \n        // Generate random horizontal spells, ensuring no overlapping\n        set<int> usedY;\n        for (int i = 0; i < m; ++i) {\n            int y;\n            do {\n                y = rnd.next(1, int(1e9) - 1);\n            } while (usedY.count(y));\n            usedY.insert(y);\n            int x1 = rnd.next(1, int(1e9));\n            int x2 = rnd.next(x1, int(1e9));\n            horizontalSpells.emplace_back(x1, x2, y);\n        }\n    }\n    else if (type == \"block_row\") {\n        // Create horizontal spells that cover entire row\n        int y = rnd.next(1, int(1e9) - 1);\n        int segments = m;\n        long long totalWidth = 1e9;\n        long long segmentWidth = (totalWidth + segments - 1) / segments;\n        long long x = 1;\n        for (int i = 0; i < segments; ++i) {\n            long long x1 = x;\n            long long x2 = min(x1 + segmentWidth - 1, (long long)1e9);\n            x = x2 + 1;\n            horizontalSpells.emplace_back((int)x1, (int)x2, y);\n            if (x > 1e9) break;\n        }\n        n = 0;\n    }\n    else if (type == \"block_column\") {\n        // Create vertical spells blocking rook from moving right\n        int maxX = min(int(1e9) - 1, n + 1);\n        for (int x = 1; x <= maxX; ++x) {\n            verticalSpells.push_back(x);\n        }\n        m = 0;\n    }\n    else if (type == \"path_blocked\") {\n        // Block the rook's path unless specific spells are removed\n        // Place vertical spells at x = 1, 2, ..., n\n        for (int x = 1; x <= n; ++x) {\n            verticalSpells.push_back(x);\n        }\n        // Place horizontal spells at increasing y\n        int y = 2;\n        for (int i = 0; i < m; ++i) {\n            // Ensure horizontal spells do not overlap, so use different y\n            horizontalSpells.emplace_back(1, int(1e9), y);\n            y += 1;\n            if (y >= int(1e9)) break;\n        }\n    }\n    else {\n        // Default to random\n        // Generate random vertical spells\n        set<int> verticalSet;\n        while ((int)verticalSet.size() < n) {\n            int x = rnd.next(1, int(1e9) - 1);\n            verticalSet.insert(x);\n        }\n        verticalSpells.assign(verticalSet.begin(), verticalSet.end());\n        \n        // Generate random horizontal spells, ensuring no overlapping\n        set<int> usedY;\n        for (int i = 0; i < m; ++i) {\n            int y;\n            do {\n                y = rnd.next(1, int(1e9) - 1);\n            } while (usedY.count(y));\n            usedY.insert(y);\n            int x1 = rnd.next(1, int(1e9));\n            int x2 = rnd.next(x1, int(1e9));\n            horizontalSpells.emplace_back(x1, x2, y);\n        }\n    }\n    \n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int x : verticalSpells) {\n        printf(\"%d\\n\", x);\n    }\n    for (auto& spell : horizontalSpells) {\n        int x1, x2, y;\n        tie(x1, x2, y) = spell;\n        printf(\"%d %d %d\\n\", x1, x2, y);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 0 -m 0 -type no_spells\n./gen -n 1 -m 1 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 10000 -m 10000 -type random\n./gen -n 50000 -m 50000 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 0 -m 1 -type block_row\n./gen -n 0 -m 2 -type block_row\n./gen -n 0 -m 10 -type block_row\n./gen -n 0 -m 100 -type block_row\n./gen -n 0 -m 1000 -type block_row\n./gen -n 0 -m 10000 -type block_row\n./gen -n 0 -m 50000 -type block_row\n./gen -n 0 -m 100000 -type block_row\n\n./gen -n 1 -m 0 -type block_column\n./gen -n 2 -m 0 -type block_column\n./gen -n 10 -m 0 -type block_column\n./gen -n 100 -m 0 -type block_column\n./gen -n 1000 -m 0 -type block_column\n./gen -n 10000 -m 0 -type block_column\n./gen -n 50000 -m 0 -type block_column\n./gen -n 100000 -m 0 -type block_column\n\n./gen -n 1000 -m 1000 -type path_blocked\n./gen -n 10000 -m 5000 -type path_blocked\n./gen -n 50000 -m 50000 -type path_blocked\n\n./gen -n 0 -m 0 -type random\n./gen -n 99999 -m 1 -type random\n./gen -n 1 -m 99999 -type random\n./gen -n 50000 -m 50001 -type random\n./gen -n 50001 -m 50000 -type random\n\n./gen -n 0 -m 1 -type path_blocked\n./gen -n 1 -m 0 -type path_blocked\n\n./gen -n 100000 -m 0 -type block_column\n./gen -n 0 -m 100000 -type block_row\n\n./gen -n 100000 -m 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:15:03.304470",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1075/E",
      "title": "E. Optimal Polygon Perimeter",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer nn (3≤n≤3⋅1053≤n≤3⋅105) — the number of points. Each of the next nn lines contains two integers xixi and yiyi (−108≤xi,yi≤108−108≤xi,yi≤108) — the coordinates of point pipi.The set of points is guaranteed to be convex, all points are distinct, the points are ordered in clockwise order, and there will be no three collinear points.",
      "output_spec": "OutputFor each ii (3≤i≤n3≤i≤n), output f(i)f(i).",
      "sample_tests": "ExamplesInputCopy42 44 33 01 3OutputCopy12 14 InputCopy30 00 22 0OutputCopy8",
      "description": "E. Optimal Polygon Perimeter\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nd(p1,p2)=|x1−x2|+|y1−y2|.d(p1,p2)=|x1−x2|+|y1−y2|.\n\nInputThe first line contains a single integer nn (3≤n≤3⋅1053≤n≤3⋅105) — the number of points. Each of the next nn lines contains two integers xixi and yiyi (−108≤xi,yi≤108−108≤xi,yi≤108) — the coordinates of point pipi.The set of points is guaranteed to be convex, all points are distinct, the points are ordered in clockwise order, and there will be no three collinear points.\n\nOutputFor each ii (3≤i≤n3≤i≤n), output f(i)f(i).\n\nInputCopy42 44 33 01 3OutputCopy12 14 InputCopy30 00 22 0OutputCopy8\n\nInputCopy42 44 33 01 3\n\nOutputCopy12 14\n\nInputCopy30 00 22 0\n\nOutputCopy8\n\nNoteIn the first example, for f(3)f(3), we consider four possible polygons:   (p1,p2,p3p1,p2,p3), with perimeter 1212.  (p1,p2,p4p1,p2,p4), with perimeter 88.  (p1,p3,p4p1,p3,p4), with perimeter 1212.  (p2,p3,p4p2,p3,p4), with perimeter 1212. For f(4)f(4), there is only one option, taking all the given points. Its perimeter 1414.In the second example, there is only one possible polygon. Its perimeter is 88.",
      "solutions": [
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces",
          "content": "1075A - The King's RaceLet's find the minimum time needed for the white king to reach the coin.It is obvious that it is always optimal to move only towards the coin. In case of white king it means that we should move only up, right or up-right diagonally. During one move we can only add 11 or 00 to any of our coordinates (or to both of them), it means that the length of the optimal path can not be smaller than max(x−1,y−1)max(x−1,y−1).Let's show that we can reach the coin with max(x−1,y−1)max(x−1,y−1) moves.First step. Let zz be equal to min(x,y)min(x,y). The king does z−1z−1 up-right moves, so after that the king will be in the cell (z,z)(z,z). Second step. Let's assume that x≤yx≤y (the case when x>yx>y is proved in a similar way). So z=xz=x. It means that the king is in the cell (x,x)(x,x). Now the king can do y−xy−x up moves, after which he would be in the cell (x,y)(x,y). It took him (x−1)+(y−x)=y−1(x−1)+(y−x)=y−1 moves to reach the coin. If xx was greater than yy he would need x−1x−1 moves (could be proved the same way). So now we proved that it takes max(x−1,y−1)max(x−1,y−1) moves for the white king to reach the coin.In the same way we can prove that it takes max(n−x,n−y)max(n−x,n−y) steps for the black king to reach the coin.The king, which is closer to the coin, wins. If the distances is equal, than the white king wins, because he moves first.Final description of the algorithm:If max(n−x,n−y)<max(x−1,y−1)max(n−x,n−y)<max(x−1,y−1) then the answer is \"Black\", otherwise the answer is \"White\".It is also can be proven that instead of comparing minimal distances between the coin and the kings we can compare manhattan distances between them. I will leave the proof as homework task.Author: arsijoDeveloper: stanislav.bezkorovainyi 1075B - Taxi drivers and LyftLet's find for each rider the taxi driver that will get his call.To do this we can find for each rider the nearest taxi driver at right and the nearest taxi driver at left. Let's define the nearest taxi driver at left for ii-th citizen as lili and at the right as riri.The computations can be done with the following algorithm:Let's define l0=0l0=0 and rn+m+1=n+m+1rn+m+1=n+m+1. And x0=−2∗109x0=−2∗109, xn+m+1=2∗109xn+m+1=2∗109.In order to find lili for each ii we should iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a taxi driver, then he/she is obviously the nearest taxi driver to himself/herself. If the ii-th citizen is a rider, then li=li−1li=li−1In order to find riri for each ii we should iterate through the citizens from n+mn+m to 11. If the ii-th citizen is a taxi driver, then ri=iri=i, else ri=ri+1ri=ri+1.Now it's time to compute the answer.Let's denote bibi as the number of citizens, whose calls the ii-th citizen will get (if the ii-th citizen is a rider, then bi=0bi=0).In order to do compute the values of array bb we should iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a rider, then if the xri−xi<xi−xlixri−xi<xi−xli (distance between the nearest taxi driver at right and the ii-th citizen is smaller than distance between the nearest taxi driver at the left and the citizen), then taxi driver riri will get the call, otherwise the taxi driver lili will get the call. So if xri−xi<xi−xlixri−xi<xi−xli, then bri:=bri+1bri:=bri+1, else bli:=bli+1bli:=bli+1. In order to print out the answer we iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a taxi driver, than we should print bibi.The algorithm iterates through the array four times, so overall complexity is O(n+m)O(n+m)Author: arsijoDeveloper: stanislav.bezkorovainyi 1074A - The Tower is Going HomeObservation 1. If we remove all the horizontal spells, than the rook can move straightforward up to the upper side of the field. So the only purpose of removing the vertical spells is to reduce the number of horizontal spells to be removed.Observation 2. If we want to remove the ii-th vertical spell, then we should also remove all such vertical spells jj, that xj<xixj<xi. It is obvious, because when we delete a vertical spell, we suppose that the rook would be able to outflank some horizontal spells by getting at rows that have greater number than xixi. If there remains at least one vertical spell jj, such that xj<xixj<xi, than we will never be able to move to the rows with number greater than xjxj, including xixi.Let's find some observations about the horizontal spells:Let's assume that we deleted ii vertical spells. It means, that the rook can move freely left and right at columns between 11 and xi+1xi+1 inclusive. Let's say that our rook is on the row yy. If there is at least one cell which is located at row yy at any column between 11 and xi+1xi+1, that there is no blocking segment on the top of it, then the rook can move to this cell and move upwards into the row y+1y+1. It means that if there is at least one gap in the blocking segments in row yy and in columns between 11 and xi+1xi+1 incluse, then there is no need to remove any of horizontal spells in the row.Observation 3. We care only about such horizontal spells, in which x1=1x1=1. We have already proved, that we only care about such rows, that there are no gaps in blocking segments in them. If there is no such horizontal spell with x1=1x1=1, it means that there is a gap in the row at column 11. If there is such horizontal spell, then if there are more spells in that row, there would be a gap between any pair of neighbouring segments. Since we only care only about segments with x1=1x1=1 and it is guaranteed that no horizontal segments share a common point, it means that we might not care about the yy of any horizontal spell, because there is no such pair of segments that both x1x1 and yy of these are equal. So now while reading the descriptions of the horizontal spells, if the x1x1 of ii-th horizontal spell is not equal to 11, we can ignore it. Otherwise, we add x2x2 to some array.Now we can sort the array of x2x2-s, and solve the task using the two-pointer technique. Here is the final algorithm: Add fake vertical spell with x=109x=109.Sort all the vertical spells in ascending order.While reading the descriptions of the horizontal spells, we ignore ones with x1x1 not equal to 11. In other case, we add x2x2 to the array.Sort the array of x2x2-s in ascending order. Now we use the two pointer technique in the following way: we iterate ii from 0 to n — the number of vertical spells to be deleted and on each step we advance the pointer while the x2x2 at which the pointer points is less then xx of the (i+1)(i+1)-th vertical spell. Let's denote the position of the pointer as pp. The number of horizontal spells, that we need to remove with ii vertical spells removed is m−p+1m−p+1. Let's define the position of the pointer at ii-th step as pipi.The answer to the problem in minival value of i+m−pi+1i+m−pi+1 among all ii from 00 to nn.Overall complexity O(nlogn+mlogm)O(nlog⁡n+mlog⁡m)Author: stanislav.bezkorovainyiDeveloper: stanislav.bezkorovainyi 1074B - Intersecting SubtreesI'll split this into two parts, first is the solution, second is why it works.The intended solution only uses two questions. Choose an arbitrary yjyj, and ask \"B y_j\". Let the response be RR. Find a node xixi that is the closest to node RR. This can be done with a BFS or DFS. Ask \"A x_i\". Let the response be QQ. If QQ is one of y1,y2,…,yk2y1,y2,…,yk2, print \"C x_i\", otherwise, print \"C -1\". Here is why it works. Let's use the fact that if the two subtrees don't intersect, there is an edge in the tree such that if we cut the tree on this edge, it will split it into two components, each containing one of the subtrees.Suppose we did step 1 and we have RR. Let's root our tree at RR. There is a unique node xixi that has lowest depth in this tree which we can find (given that x1,x2,…,xk1x1,x2,…,xk1 form a subtree).Now, we claim that the two subtrees intersect if and only if Li Chen owns a node that lies in the subtree rooted by xixi (and in particular, we will show it is sufficient to only check node xixi).If none of Li Chen's nodes lie in the subtree rooted by xixi, then the edge xixi to its parent cuts the tree into two components with one subtree completely lying in one component and the other in the second, so the two subtrees are disjoint.Otherwise, there is a node WW that is in Li Chen's subtree that lies in the subtree rooted by xixi. All nodes in the path of RR to WW must also belong to Li Chen's subtree, and in particular this includes node xixi, so the two trees intersect. This also shows we can just check if xixi belongs in Li Chen's subtree by asking a question about it.Author: LewinDeveloper: Lewin 1074C - Optimal Polygon PerimeterI will show 2 solutions, both of which work in O(n)O(n) time. First, it is not hard to notice that we can only consider polygons that are convex.Observation: For a convex polygon, the given definition of \"polygon perimeter\" is equivalent to the perimeter of the bounding rectangle (aligned with the axis), of our polygon. If we look at some convex polygon, and 4 values maxx,minx,maxy,minymaxx,minx,maxy,miny representing the maximal xx coordinate of a point, minimal xx, maximal and minimal yy, then the perimeter of the bounding rectangle is simply 2∗(maxx−minx+maxy−miny)2∗(maxx−minx+maxy−miny).This simple rephrase gives us a bonus, and crucial observation: It is enough for us to take 4 points from the input, such that the perimeter of their polygon is the maximal possible (and is equal to the perimeter of the polygon formed from nn points). We will consider these the extreme points. Note that after taking the extreme points, it does not matter which other points we take. So, this solves all f(4),…,f(n)f(4),…,f(n).We are left with f(3)f(3) to compute (maximal triangle perimeter). Following are 2 solutions to do it:Solution 1: Let's show that the optimal triangle uses at least 2 of the extreme points. Imagine some optimal triangle, and its bounding rectangle. Notice that since each edge of the bounding rectangle must touch some vertex of the triangle (it is bounding after all), and we have 4 edges and 3 vertices, then there must be some vertex of the triangle that touches 2 edges of the rectangle (so it coincides with a rectangle vertex). If this is the case, we know that in comparison with the 2 other vertices, this vertex has \"extremal\" X and Y coordinates (minimal/maximal X, and minimal/maximal Y). Without loss of generality, assume this vertex has maximum X and Y. Then to optimize the perimeter, the other two vertices should have smallest possible X and smallest possible Y. We can pick these 2 vertices to be 2 of the extreme points (one with minimal X and one with minimal Y). So, this shows we just need to iterate over every adjacent pair of extreme vertices, and over all other points as the last vertex. This takes O(n)O(n).Solution 2: This solution is more general, and is an extension of the problem to find the 2 most distant points (manhattan distance). The triangle perimeter is an expression with 6 terms: |x1−x2|+|y1−y2|+…+|y3−y1||x1−x2|+|y1−y2|+…+|y3−y1|. We wish the maximize this expression, but the absolute value is troubling us. For each term, there are 2 cases: either it is positive, so the absolute value does nothing, or it is negative, so the absolute value negates it. In total, for the 6 terms we have 26=6426=64 options to place signs between them. We will call such option a setting.For any setting, the advantage now is that we can accumulate terms: For example the setting ++−−−+++−−−+, evaluates the expression to: (2x1+0y1)+(−2x2−2y2)+(0x3+2y3)(2x1+0y1)+(−2x2−2y2)+(0x3+2y3) We solve every setting by its own, and over all settings we take the maximal answer.Please note, that this strategy only works to find the maximal value of the expression, not minimal. The proof of this is left as an exercise to the reader :) (I promise it is not difficult).Given 6 constants c1,c2,...,c6c1,c2,...,c6, we want to find 3 indicies i<j<ki<j<k to maximize: c1∗xi+c2∗yi+...+c6∗ykc1∗xi+c2∗yi+...+c6∗yk. We define 3 arrays: Pi=c1⋅xi+c2⋅yiPi=c1⋅xi+c2⋅yi Qi=c3⋅xi+c4⋅yiQi=c3⋅xi+c4⋅yi Ri=c5⋅xi+c6⋅yiRi=c5⋅xi+c6⋅yi And so we want to maximize Pi+Qj+RkPi+Qj+Rk. This can be done in O(n)O(n) with simple dynamic programming.So this whole solution is O(n)O(n), with a constant of 64. In general, to compute f(k)f(k) this solution takes O(n⋅4k⋅k)O(n⋅4k⋅k) time, without any observations.Author: Noam527Developer: Noam527 1074D - Deduction QueriesFirst, let's learn how to handle information we have not recieved in updates. Let the function W(l,r)W(l,r) be equal to the xor of the subarray [l,r][l,r]. Also, we define W(l,r)=W(r,l)W(l,r)=W(r,l).Assume 3 indicies a≤b≤ca≤b≤c. There are 2 rules: W(a,b)⊕W(b+1,c)=W(a,c)W(a,b)⊕W(b+1,c)=W(a,c). W(a,c)⊕W(b,c)=W(a,b−1)W(a,c)⊕W(b,c)=W(a,b−1) (holds when a<ba<b). These rules require a lot of conditions (and also plenty of ±± 1). We can simplify them greatly: Let's index the borders between cells in our array (there are 230+1230+1 of them). Now, instead of defining a subarray [l,r][l,r] by its 2 endpoint cells, we will define a subarray by its 2 endpoint borders. Technically it just means, that we should increase rr by 1, and then we get the 2 end borders.From now I will assume that our input is given in such a way, that subarrays are defined by their borders (So I will not mention the addition of 1 to rr). Notice that the function W(l,r)W(l,r) is also affected by this.If we take a look at our rules again, they boil down to just 1 rule: W(a,b)⊕W(b,c)=W(a,c)W(a,b)⊕W(b,c)=W(a,c), for any 3 indicies a,b,ca,b,c (a≤b≤ca≤b≤c doesn't need to hold now, for instance W(3,5)⊕W(5,2)=W(3,2)W(3,5)⊕W(5,2)=W(3,2)). This transformation also shows an observation; Assume every border is a vertex in a graph, and every update W(l,r)=xW(l,r)=x describes an undirected edge between the vertices l,rl,r with weight xx. We let the distance between 2 nodes a,ba,b be the xor of edge weights on the path between them. Notice that this distance is equal to W(a,b)W(a,b). In other words, an update adds an edge and a query asks for some distance.Another observation is that, we do not care about all the 230+1230+1 nodes, but only about the ones we recieved in queries and updates. Moreover, their order is irrelevant, so we can do an online mapping of new nodes to the next free indicies. Thus, the number of nodes will be worstcase O(q)O(q).Claim: We can know the answer to some query [l,r][l,r], if and only if there exists a path between the nodes l,rl,r (they are in the same connected component).//start spoiler of proofThere will be some subset of edges we take, to form the xor between nodes ll and rr. Assume every vertex has 2 states, on/off. Initially all vertices are off, and our current answer is 00. When we take an edge we flip the state of its 2 ends, and xor our answer by its weight. Suppose at some moment of time the nodes with \"on\" state are {x0,x1,x2,...,xkx0,x1,x2,...,xk} (in sorted order). Observe that our current answer is equal to W(x0,x1)⊕W(x2,x3)⊕…⊕W(xk−1,xk)W(x0,x1)⊕W(x2,x3)⊕…⊕W(xk−1,xk). This implies we want our subset of edges to end up having only the nodes {l,rl,r} activated. We look at the connected components. Observe that in each connected component, the number of nodes activated at any time is even. If the nodes ll and rr are in different component, then in our final result we would want to have only 1 activated node in the component of ll, and same with rr, but this is impossible.//end spoiler of proofFirst, we need to know whether a query gives us 2 nodes that are in different components (to know whether the answer is −1−1 or not). For this we need to use the Union-Find structure. Also notice, that our Union-Find structure will only need to handle a forest of trees (if an update gives us an edge that creates a cycle, it means there is no contribution, so we ignore it).Provided that an answer does exist, we need to also handle finding a xor path between 2 nodes in a tree, and to support merging of trees. Generally to find a property over some path in a tree, it is common to use LCA or binary lifting. This turns out very difficult when we also need to merge trees (unless you insist on implementing Link-Cut/ETT). Fortunately, we can still abuse the xor operator. In some tree, mark xvxv as the xor of edges on the path from vv to some arbitrary root in the tree. The xor path between nodes (u,vu,v) turns out to be xu⊕xvxu⊕xv. So we would like to maintain for each tree some arbitrary root and all those values.Notice that we can augment our Union-Find structure to support this as well: For each node vv in the structure, we maintain pvpv as its parent in the structure, and xvxv as the xor on the path from vv to pvpv. Notice that xvxv can be easily updated together with pvpv during the find()find() operation in the structure.To summarize, when we are given W(l,r)=xW(l,r)=x in some update, we transform it to W(pl,pr)=x⊕xl⊕xrW(pl,pr)=x⊕xl⊕xr, and then we add the edge between the parents.Finally, the complexity is O(qlogq)O(qlog⁡q), but this is only due to the online mapping if we use a regular map; You can use a hash table and get a running time of O(q×α(q))O(q×α(q)), but I suggest being careful with a hash table (you may want to read this: https://codeforces.com/blog/entry/62393).Author: Noam527Developer: Noam527 1074E - Grid SortThe solution is more of a coding one than an algorithmic one. There are many different approaches, and it's important to be careful in how it is implemented. I'll explain one of the implementations.First, we can always move a particular block left, up, down, or right with an appropriate 2x2 square around it. Let's code some functions that let us do that for each direction.Next is to make sure that these moves don't mess up previous block spaces as we move blocks to the correct place. We can almost place blocks correctly in their spaces one by one in row major order, but there are some special cases.- We can do all blocks except the last two rows, which we'll handle separately (in paragraph below) - For each row, we can correctly place all blocks except the last one. The last one requires a bit more careful work, but is easy to handle if we have at least two free rows.For the last two rows, we can fill it in column by column from left to right. This is a similar startegy to fitting in the last column of the previous rows. We can almost do this except for the last 2x2 square.For the last 2x2 square, we can use the following sequence of moves to swap two blocks:123456413526421563213456Thus, we can shift the last block into the right position, then do at most three swaps (using the above sequence of moves) to fix the remaining blocks.The number of moves for this strategy can be computed and estimated to be about 50k in the worst case.Author: LewinDeveloper: Lewin 1074F - DFSLet's consider an arbitrary run of DFS producing some tree. Let's root the tree at the starting vertex. It can be shown that on a directed graph, there are only two types of edges. The first are the tree edges (those are the ones that are used to visit a new vertex). The second are edges which, upon being traversed, lead to a vertex that was already visited. It can be shown that, in the rooted tree, those edges always connect a vertex with one of its ancestors. In other words, all the edges that are dynamically added to the tree must connect a vertex with one of their ancestors. This means that the staring vertex must not lie on the path connecting the two endpoints of such edge, or any of the vertices in some of the subtrees. For instance, on the second sample, the edge {2,4}{2,4} disallows the vertex 11 from being the starting vertex, as it lies on the path from 22 to 44, and also vertex 66.Each edge thus forbids a certain set of vertices from being the starting point. This yields a straightforward O(n2)O(n2) solution. To optimize it further, we can root the tree arbitrarily and renumber the vertices using their DFS visit times. When we do this, we notice that the set of a forbidden vertices for each edge is a union of at most three intervals of vertices. This lets us build an O(nlogn)O(nlog⁡n) solution using a segment tree. The operation is add a constant on interval, and then find the minimum on interval and the number of occurrences of said minimum. We add 11 to forbid a vertex because of an edge, subtract 11 to revert that when the edge is subsequently removed. The answer is the number of minimums on the whole tree if that minimum is 00, and 00 otherwise.Author: _h_Developers: _h_ and majk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1075 和字母"
          },
          "content_length": 20587
        }
      ],
      "code_examples": [
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 1",
          "code": "123456413526421563213456",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        },
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 2",
          "code": "2 3\n3\n5\n1 4 1\n2 100000 2\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        },
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 3",
          "code": "2 3\n3\n5\n1 4 1\n2 100000 2\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint64 cross(const pair<int,int>& a, const pair<int,int>& b, const pair<int,int>& c) {\n    int64 x1 = (int64)b.first - a.first;\n    int64 y1 = (int64)b.second - a.second;\n    int64 x2 = (int64)c.first - b.first;\n    int64 y2 = (int64)c.second - b.second;\n    return x1 * y2 - x2 * y1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300000, \"n\");\n    inf.readEoln();\n    vector<pair<int,int>> pts(n);\n    set<pair<int,int>> pointSet;\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-100000000, 100000000, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-100000000, 100000000, \"y_i\");\n        inf.readEoln();\n        pts[i] = {x, y};\n        ensuref(pointSet.insert(pts[i]).second, \"Point (%d,%d) is duplicated\", x, y);\n    }\n    int sign = 0; // 1 for positive, -1 for negative\n    for (int i = 0; i < n; ++i) {\n        int64 cp = cross(pts[i], pts[(i+1)%n], pts[(i+2)%n]);\n        ensuref(cp != 0, \"Points %d, %d, %d are colinear\", i+1, (i+1)%n+1, (i+2)%n+1);\n        int cp_sign = (cp > 0) ? 1 : -1;\n        if (sign == 0) {\n            sign = cp_sign;\n        } else {\n            ensuref(cp_sign == sign, \"Found non-convex angle at points %d, %d, %d\", i+1, (i+1)%n+1, (i+2)%n+1);\n        }\n    }\n\n    // Compute area\n    __int128 area = 0;\n    for (int i = 0; i < n; ++i) {\n        int64 x1 = pts[i].first;\n        int64 y1 = pts[i].second;\n        int64 x2 = pts[(i+1)%n].first;\n        int64 y2 = pts[(i+1)%n].second;\n        area += (__int128)x1 * y2 - (__int128)x2 * y1;\n    }\n\n    ensuref(area != 0, \"Polygon area is zero\");\n    ensuref(area < 0, \"Points are not in clockwise order\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint64 cross(const pair<int,int>& a, const pair<int,int>& b, const pair<int,int>& c) {\n    int64 x1 = (int64)b.first - a.first;\n    int64 y1 = (int64)b.second - a.second;\n    int64 x2 = (int64)c.first - b.first;\n    int64 y2 = (int64)c.second - b.second;\n    return x1 * y2 - x2 * y1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300000, \"n\");\n    inf.readEoln();\n    vector<pair<int,int>> pts(n);\n    set<pair<int,int>> pointSet;\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-100000000, 100000000, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-100000000, 100000000, \"y_i\");\n        inf.readEoln();\n        pts[i] = {x, y};\n        ensuref(pointSet.insert(pts[i]).second, \"Point (%d,%d) is duplicated\", x, y);\n    }\n    int sign = 0; // 1 for positive, -1 for negative\n    for (int i = 0; i < n; ++i) {\n        int64 cp = cross(pts[i], pts[(i+1)%n], pts[(i+2)%n]);\n        ensuref(cp != 0, \"Points %d, %d, %d are colinear\", i+1, (i+1)%n+1, (i+2)%n+1);\n        int cp_sign = (cp > 0) ? 1 : -1;\n        if (sign == 0) {\n            sign = cp_sign;\n        } else {\n            ensuref(cp_sign == sign, \"Found non-convex angle at points %d, %d, %d\", i+1, (i+1)%n+1, (i+2)%n+1);\n        }\n    }\n\n    // Compute area\n    __int128 area = 0;\n    for (int i = 0; i < n; ++i) {\n        int64 x1 = pts[i].first;\n        int64 y1 = pts[i].second;\n        int64 x2 = pts[(i+1)%n].first;\n        int64 y2 = pts[(i+1)%n].second;\n        area += (__int128)x1 * y2 - (__int128)x2 * y1;\n    }\n\n    ensuref(area != 0, \"Polygon area is zero\");\n    ensuref(area < 0, \"Points are not in clockwise order\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint64 cross(const pair<int,int>& a, const pair<int,int>& b, const pair<int,int>& c) {\n    int64 x1 = (int64)b.first - a.first;\n    int64 y1 = (int64)b.second - a.second;\n    int64 x2 = (int64)c.first - b.first;\n    int64 y2 = (int64)c.second - b.second;\n    return x1 * y2 - x2 * y1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300000, \"n\");\n    inf.readEoln();\n    vector<pair<int,int>> pts(n);\n    set<pair<int,int>> pointSet;\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-100000000, 100000000, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-100000000, 100000000, \"y_i\");\n        inf.readEoln();\n        pts[i] = {x, y};\n        ensuref(pointSet.insert(pts[i]).second, \"Point (%d,%d) is duplicated\", x, y);\n    }\n    int sign = 0; // 1 for positive, -1 for negative\n    for (int i = 0; i < n; ++i) {\n        int64 cp = cross(pts[i], pts[(i+1)%n], pts[(i+2)%n]);\n        ensuref(cp != 0, \"Points %d, %d, %d are colinear\", i+1, (i+1)%n+1, (i+2)%n+1);\n        int cp_sign = (cp > 0) ? 1 : -1;\n        if (sign == 0) {\n            sign = cp_sign;\n        } else {\n            ensuref(cp_sign == sign, \"Found non-convex angle at points %d, %d, %d\", i+1, (i+1)%n+1, (i+2)%n+1);\n        }\n    }\n\n    // Compute area\n    __int128 area = 0;\n    for (int i = 0; i < n; ++i) {\n        int64 x1 = pts[i].first;\n        int64 y1 = pts[i].second;\n        int64 x2 = pts[(i+1)%n].first;\n        int64 y2 = pts[(i+1)%n].second;\n        area += (__int128)x1 * y2 - (__int128)x2 * y1;\n    }\n\n    ensuref(area != 0, \"Polygon area is zero\");\n    ensuref(area < 0, \"Points are not in clockwise order\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_regular_polygon(int n, vector<pair<int, int>> &points, int radius) {\n    double angle_increment = 2 * M_PI / n;\n    for(int i = 0; i < n; ++i) {\n        double angle = 2 * M_PI - i * angle_increment; // To generate points in clockwise order\n        int x = (int)(radius * cos(angle));\n        int y = (int)(radius * sin(angle));\n        points.emplace_back(x, y);\n    }\n}\n\nvoid generate_random_convex_polygon(int n, vector<pair<int, int>> &points) {\n    vector<int> X, Y;\n\n    // Generate n unique random x and y coordinates\n    set<int> x_set, y_set;\n    while ((int)x_set.size() < n) {\n        x_set.insert(rnd.next(-100000000, 100000000));\n    }\n    while ((int)y_set.size() < n) {\n        y_set.insert(rnd.next(-100000000, 100000000));\n    }\n    X.assign(x_set.begin(), x_set.end());\n    Y.assign(y_set.begin(), y_set.end());\n\n    // Sort them\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n\n    // Generate vectors of delta x and delta y\n    vector<int> dx, dy;\n\n    int lastX = X[0];\n    for(int i = 1; i < n; i++) {\n        dx.push_back(X[i] - lastX);\n        lastX = X[i];\n    }\n\n    int lastY = Y[0];\n    for(int i = 1; i < n; i++) {\n        dy.push_back(Y[i] - lastY);\n        lastY = Y[i];\n    }\n\n    // Randomly assign signs to the differences\n    vector<int> vx, vy;\n\n    for(int i = 0; i < n - 1; i++) {\n        int sign = rnd.next(0, 1) ? 1 : -1;\n        vx.push_back(sign * dx[i]);\n    }\n    for(int i = 0; i < n - 1; i++) {\n        int sign = rnd.next(0, 1) ? 1 : -1;\n        vy.push_back(sign * dy[i]);\n    }\n\n    // Shuffle the differences\n    shuffle(vx.begin(), vx.end());\n    shuffle(vy.begin(), vy.end());\n\n    // Add last vectors to ensure sum to zero\n    int sumx = 0, sumy = 0;\n    for(int i = 0; i < n - 1; i++) {\n        sumx += vx[i];\n        sumy += vy[i];\n    }\n    vx.push_back(-sumx);\n    vy.push_back(-sumy);\n\n    // Now, create vectors\n    vector<pair<int, int>> vectors;\n    for(int i = 0; i < n; i++) {\n        vectors.emplace_back(vx[i], vy[i]);\n    }\n\n    // Sort vectors by angle in descending order to get clockwise order\n    sort(vectors.begin(), vectors.end(), [](pair<int, int> a, pair<int, int> b) {\n        return atan2(a.second, a.first) > atan2(b.second, b.first);\n    });\n\n    // Build the polygon points\n    int x = 0, y = 0;\n    for(int i = 0; i < n; i++) {\n        x += vectors[i].first;\n        y += vectors[i].second;\n        points.emplace_back(x, y);\n    }\n\n    // Find minimum coordinates to shift points into allowed range\n    int minx = INT_MAX, miny = INT_MAX, maxx = INT_MIN, maxy = INT_MIN;\n    for(const auto &p : points) {\n        minx = min(minx, p.first);\n        miny = min(miny, p.second);\n        maxx = max(maxx, p.first);\n        maxy = max(maxy, p.second);\n    }\n\n    int shiftx = rnd.next(-100000000 - minx, 100000000 - maxx);\n    int shifty = rnd.next(-100000000 - miny, 100000000 - maxy);\n\n    for(auto &p : points) {\n        p.first += shiftx;\n        p.second += shifty;\n    }\n}\n\nvoid generate_stretched_polygon(int n, vector<pair<int, int>> &points) {\n    int minX = -100000000 + 1000;\n    int maxX = 100000000 - 1000;\n    int width = 1000; // small width to make it stretched\n\n    for (int i = 0; i < n; ++i) {\n        int x = minX + i * ((maxX - minX) / (n - 1));\n        int y;\n        if (i % 2 == 0) {\n            y = -width / 2 + rnd.next(-10, 10);\n        } else {\n            y = width / 2 + rnd.next(-10, 10);\n        }\n        points.emplace_back(x, y);\n    }\n\n    // Build a convex polygon in clockwise order\n    vector<pair<int, int>> upper, lower;\n    for(int i = 0; i < n; ++i) {\n        if (points[i].second >= 0)\n            upper.push_back(points[i]);\n        else\n            lower.push_back(points[i]);\n    }\n    reverse(lower.begin(), lower.end());\n    points.clear();\n    // Points in clockwise order\n    points.insert(points.end(), upper.begin(), upper.end());\n    points.insert(points.end(), lower.begin(), lower.end());\n}\n\nvoid generate_large_coordinates_polygon(int n, vector<pair<int, int>> &points) {\n    int radius = 100000000 - 10; // Slightly less than 1e8 to avoid overflow\n    generate_regular_polygon(n, points, radius);\n}\n\nvoid generate_close_to_line_polygon(int n, vector<pair<int, int>> &points) {\n    int x0 = rnd.next(-50000000, 50000000);\n    int y0 = rnd.next(-50000000, 50000000);\n    int dx = rnd.next(1, 10);\n    for(int i = 0; i < n; ++i) {\n        int x = x0 + i * dx + rnd.next(-10, 10);\n        int y = y0 + rnd.next(-1000, 1000); // Small range to simulate close to line\n        points.emplace_back(x, y);\n    }\n\n    // Compute convex hull to get a convex polygon\n    // Graham scan\n    auto cross = [](pair<int, int> O, pair<int, int> A, pair<int, int> B) {\n        return (A.first - O.first) * (B.second - O.second) - (A.second - O.second) * (B.first - O.first);\n    };\n\n    sort(points.begin(), points.end());\n    vector<pair<int, int>> hull;\n    // Lower hull\n    for (auto p : points) {\n        while (hull.size() >= 2 && cross(hull[hull.size()-2], hull[hull.size()-1], p) <= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    // Upper hull\n    size_t t = hull.size() + 1;\n    for (int i = (int)points.size() - 2; i >= 0; i--) {\n        auto p = points[i];\n        while (hull.size() >= t && cross(hull[hull.size()-2], hull[hull.size()-1], p) <= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    hull.pop_back();\n    points = hull;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<int, int>> points;\n\n    if (type == \"regular\") {\n        int radius = opt<int>(\"radius\", 10000);\n        generate_regular_polygon(n, points, radius);\n    } else if (type == \"random\") {\n        generate_random_convex_polygon(n, points);\n    } else if (type == \"stretched\") {\n        generate_stretched_polygon(n, points);\n    } else if (type == \"large_coordinates\") {\n        generate_large_coordinates_polygon(n, points);\n    } else if (type == \"close_to_line\") {\n        generate_close_to_line_polygon(n, points);\n    } else {\n        // default or error\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", (int)points.size());\n    for (const auto &p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_regular_polygon(int n, vector<pair<int, int>> &points, int radius) {\n    double angle_increment = 2 * M_PI / n;\n    for(int i = 0; i < n; ++i) {\n        double angle = 2 * M_PI - i * angle_increment; // To generate points in clockwise order\n        int x = (int)(radius * cos(angle));\n        int y = (int)(radius * sin(angle));\n        points.emplace_back(x, y);\n    }\n}\n\nvoid generate_random_convex_polygon(int n, vector<pair<int, int>> &points) {\n    vector<int> X, Y;\n\n    // Generate n unique random x and y coordinates\n    set<int> x_set, y_set;\n    while ((int)x_set.size() < n) {\n        x_set.insert(rnd.next(-100000000, 100000000));\n    }\n    while ((int)y_set.size() < n) {\n        y_set.insert(rnd.next(-100000000, 100000000));\n    }\n    X.assign(x_set.begin(), x_set.end());\n    Y.assign(y_set.begin(), y_set.end());\n\n    // Sort them\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n\n    // Generate vectors of delta x and delta y\n    vector<int> dx, dy;\n\n    int lastX = X[0];\n    for(int i = 1; i < n; i++) {\n        dx.push_back(X[i] - lastX);\n        lastX = X[i];\n    }\n\n    int lastY = Y[0];\n    for(int i = 1; i < n; i++) {\n        dy.push_back(Y[i] - lastY);\n        lastY = Y[i];\n    }\n\n    // Randomly assign signs to the differences\n    vector<int> vx, vy;\n\n    for(int i = 0; i < n - 1; i++) {\n        int sign = rnd.next(0, 1) ? 1 : -1;\n        vx.push_back(sign * dx[i]);\n    }\n    for(int i = 0; i < n - 1; i++) {\n        int sign = rnd.next(0, 1) ? 1 : -1;\n        vy.push_back(sign * dy[i]);\n    }\n\n    // Shuffle the differences\n    shuffle(vx.begin(), vx.end());\n    shuffle(vy.begin(), vy.end());\n\n    // Add last vectors to ensure sum to zero\n    int sumx = 0, sumy = 0;\n    for(int i = 0; i < n - 1; i++) {\n        sumx += vx[i];\n        sumy += vy[i];\n    }\n    vx.push_back(-sumx);\n    vy.push_back(-sumy);\n\n    // Now, create vectors\n    vector<pair<int, int>> vectors;\n    for(int i = 0; i < n; i++) {\n        vectors.emplace_back(vx[i], vy[i]);\n    }\n\n    // Sort vectors by angle in descending order to get clockwise order\n    sort(vectors.begin(), vectors.end(), [](pair<int, int> a, pair<int, int> b) {\n        return atan2(a.second, a.first) > atan2(b.second, b.first);\n    });\n\n    // Build the polygon points\n    int x = 0, y = 0;\n    for(int i = 0; i < n; i++) {\n        x += vectors[i].first;\n        y += vectors[i].second;\n        points.emplace_back(x, y);\n    }\n\n    // Find minimum coordinates to shift points into allowed range\n    int minx = INT_MAX, miny = INT_MAX, maxx = INT_MIN, maxy = INT_MIN;\n    for(const auto &p : points) {\n        minx = min(minx, p.first);\n        miny = min(miny, p.second);\n        maxx = max(maxx, p.first);\n        maxy = max(maxy, p.second);\n    }\n\n    int shiftx = rnd.next(-100000000 - minx, 100000000 - maxx);\n    int shifty = rnd.next(-100000000 - miny, 100000000 - maxy);\n\n    for(auto &p : points) {\n        p.first += shiftx;\n        p.second += shifty;\n    }\n}\n\nvoid generate_stretched_polygon(int n, vector<pair<int, int>> &points) {\n    int minX = -100000000 + 1000;\n    int maxX = 100000000 - 1000;\n    int width = 1000; // small width to make it stretched\n\n    for (int i = 0; i < n; ++i) {\n        int x = minX + i * ((maxX - minX) / (n - 1));\n        int y;\n        if (i % 2 == 0) {\n            y = -width / 2 + rnd.next(-10, 10);\n        } else {\n            y = width / 2 + rnd.next(-10, 10);\n        }\n        points.emplace_back(x, y);\n    }\n\n    // Build a convex polygon in clockwise order\n    vector<pair<int, int>> upper, lower;\n    for(int i = 0; i < n; ++i) {\n        if (points[i].second >= 0)\n            upper.push_back(points[i]);\n        else\n            lower.push_back(points[i]);\n    }\n    reverse(lower.begin(), lower.end());\n    points.clear();\n    // Points in clockwise order\n    points.insert(points.end(), upper.begin(), upper.end());\n    points.insert(points.end(), lower.begin(), lower.end());\n}\n\nvoid generate_large_coordinates_polygon(int n, vector<pair<int, int>> &points) {\n    int radius = 100000000 - 10; // Slightly less than 1e8 to avoid overflow\n    generate_regular_polygon(n, points, radius);\n}\n\nvoid generate_close_to_line_polygon(int n, vector<pair<int, int>> &points) {\n    int x0 = rnd.next(-50000000, 50000000);\n    int y0 = rnd.next(-50000000, 50000000);\n    int dx = rnd.next(1, 10);\n    for(int i = 0; i < n; ++i) {\n        int x = x0 + i * dx + rnd.next(-10, 10);\n        int y = y0 + rnd.next(-1000, 1000); // Small range to simulate close to line\n        points.emplace_back(x, y);\n    }\n\n    // Compute convex hull to get a convex polygon\n    // Graham scan\n    auto cross = [](pair<int, int> O, pair<int, int> A, pair<int, int> B) {\n        return (A.first - O.first) * (B.second - O.second) - (A.second - O.second) * (B.first - O.first);\n    };\n\n    sort(points.begin(), points.end());\n    vector<pair<int, int>> hull;\n    // Lower hull\n    for (auto p : points) {\n        while (hull.size() >= 2 && cross(hull[hull.size()-2], hull[hull.size()-1], p) <= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    // Upper hull\n    size_t t = hull.size() + 1;\n    for (int i = (int)points.size() - 2; i >= 0; i--) {\n        auto p = points[i];\n        while (hull.size() >= t && cross(hull[hull.size()-2], hull[hull.size()-1], p) <= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    hull.pop_back();\n    points = hull;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<int, int>> points;\n\n    if (type == \"regular\") {\n        int radius = opt<int>(\"radius\", 10000);\n        generate_regular_polygon(n, points, radius);\n    } else if (type == \"random\") {\n        generate_random_convex_polygon(n, points);\n    } else if (type == \"stretched\") {\n        generate_stretched_polygon(n, points);\n    } else if (type == \"large_coordinates\") {\n        generate_large_coordinates_polygon(n, points);\n    } else if (type == \"close_to_line\") {\n        generate_close_to_line_polygon(n, points);\n    } else {\n        // default or error\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", (int)points.size());\n    for (const auto &p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n values\n./gen -n 3 -type regular\n./gen -n 3 -type random\n./gen -n 3 -type stretched\n./gen -n 4 -type regular\n./gen -n 4 -type random\n\n# Medium n values\n./gen -n 100 -type random\n./gen -n 100 -type stretched\n./gen -n 100 -type close_to_line\n./gen -n 1000 -type random\n./gen -n 1000 -type large_coordinates\n\n# Large n values\n./gen -n 300000 -type random\n./gen -n 300000 -type stretched\n./gen -n 300000 -type close_to_line\n./gen -n 300000 -type large_coordinates\n\n# Edge cases near minimal and maximal n\n./gen -n 3 -type large_coordinates\n./gen -n 299999 -type random\n\n# Varying types and sizes\n./gen -n 200000 -type regular\n./gen -n 200000 -type random\n./gen -n 150000 -type stretched\n./gen -n 150000 -type close_to_line\n./gen -n 100000 -type random\n./gen -n 100000 -type large_coordinates\n./gen -n 100000 -type stretched\n\n# Test with different radius for regular polygon\n./gen -n 6 -type regular -radius 100000\n./gen -n 8 -type regular -radius 50000\n./gen -n 123456 -type regular -radius 99999999\n\n# Mix of types\n./gen -n 250000 -type random\n./gen -n 250000 -type close_to_line\n./gen -n 250000 -type stretched\n\n# Random with maximum n\n./gen -n 300000 -type random\n\n# Stretched polygon with maximum n\n./gen -n 300000 -type stretched\n\n# Close to line polygon with maximum n\n./gen -n 300000 -type close_to_line\n\n# Large coordinates with maximum n\n./gen -n 300000 -type large_coordinates\n\n# Random polygons with n near maximum\n./gen -n 299998 -type random\n./gen -n 299999 -type random\n\n# Close to line polygon with small n\n./gen -n 10 -type close_to_line\n\n# Stretched polygon with small n\n./gen -n 10 -type stretched\n\n# Random polygon with small n\n./gen -n 10 -type random\n\n# Regular polygon with small custom radius\n./gen -n 5 -type regular -radius 50\n\n# Regular polygon with large custom radius\n./gen -n 5 -type regular -radius 10000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:15:05.335236",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "1075/F",
      "title": "F. Запросы на дедукцию",
      "difficulty": "Medium",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит одно целое число qq (1≤q≤2⋅1051≤q≤2⋅105) — количество запросов.Каждая из следующих qq строк описывает запрос. Она содержит одно целое число tt (1≤t≤21≤t≤2) — тип запроса.Запросы закодированы следующим образом: пусть lastlast будет ответом на последний запрос второго типа, на который вы ответили (сначала last=0last=0). Если ответ был −1−1, присвойте last=1last=1. Если t=1t=1, то далее следуют три целых числа l′l′, r′r′ и x′x′ (0≤l′,r′,x′<2300≤l′,r′,x′<230), которые значат, что вы получили обновление. Сначала сделайте следующие: l=l′⊕lastl=l′⊕last, r=r′⊕lastr=r′⊕last, x=x′⊕lastx=x′⊕last и, если l>rl>r, поменяйте местами ll и rr.Это значит, что исключающее ИЛИ подмассива [l,r][l,r] равно xx (обратите внимание, что вам нужно игнорировать запросы, которые противоречат предыдущим запросам). Если t=2t=2, то далее следуют два числа l′l′ и r′r′ (0≤l′,r′<2300≤l′,r′<230), которые значат, что вы получили запрос. Сначала сделайте следующие: l=l′⊕lastl=l′⊕last, r=r′⊕lastr=r′⊕last и, если l>rl>r, поменяйте местами ll и rr.Это значит, что нужно вывести исключающее ИЛИ подмассива [l,r][l,r]. Если невозможно ответить, то выведите −1−1. Не забудьте обновить значение lastlast.Гарантируется, что будет как минимум один запрос второго типа.",
      "output_spec": "Выходные данныеДля каждого запроса второго типа, выведите исключающее ИЛИ подмассива или −1−1, если на этот запрос невозможно ответить.",
      "sample_tests": "ПримерыВходные данныеСкопировать122 1 22 1 10737418221 0 3 42 0 02 3 32 0 31 6 7 32 4 41 0 2 12 0 02 4 42 0 0Выходные данныеСкопировать-1-1-1-15-1635Входные данныеСкопировать41 5 5 91 6 6 51 6 5 102 6 5Выходные данныеСкопировать12",
      "description": "F. Запросы на дедукцию\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит одно целое число qq (1≤q≤2⋅1051≤q≤2⋅105) — количество запросов.Каждая из следующих qq строк описывает запрос. Она содержит одно целое число tt (1≤t≤21≤t≤2) — тип запроса.Запросы закодированы следующим образом: пусть lastlast будет ответом на последний запрос второго типа, на который вы ответили (сначала last=0last=0). Если ответ был −1−1, присвойте last=1last=1. Если t=1t=1, то далее следуют три целых числа l′l′, r′r′ и x′x′ (0≤l′,r′,x′<2300≤l′,r′,x′<230), которые значат, что вы получили обновление. Сначала сделайте следующие: l=l′⊕lastl=l′⊕last, r=r′⊕lastr=r′⊕last, x=x′⊕lastx=x′⊕last и, если l>rl>r, поменяйте местами ll и rr.Это значит, что исключающее ИЛИ подмассива [l,r][l,r] равно xx (обратите внимание, что вам нужно игнорировать запросы, которые противоречат предыдущим запросам). Если t=2t=2, то далее следуют два числа l′l′ и r′r′ (0≤l′,r′<2300≤l′,r′<230), которые значат, что вы получили запрос. Сначала сделайте следующие: l=l′⊕lastl=l′⊕last, r=r′⊕lastr=r′⊕last и, если l>rl>r, поменяйте местами ll и rr.Это значит, что нужно вывести исключающее ИЛИ подмассива [l,r][l,r]. Если невозможно ответить, то выведите −1−1. Не забудьте обновить значение lastlast.Гарантируется, что будет как минимум один запрос второго типа.\n\nВходные данные\n\nВыходные данныеДля каждого запроса второго типа, выведите исключающее ИЛИ подмассива или −1−1, если на этот запрос невозможно ответить.\n\nВыходные данные\n\nВходные данныеСкопировать122 1 22 1 10737418221 0 3 42 0 02 3 32 0 31 6 7 32 4 41 0 2 12 0 02 4 42 0 0Выходные данныеСкопировать-1-1-1-15-1635Входные данныеСкопировать41 5 5 91 6 6 51 6 5 102 6 5Выходные данныеСкопировать12\n\nВходные данныеСкопировать122 1 22 1 10737418221 0 3 42 0 02 3 32 0 31 6 7 32 4 41 0 2 12 0 02 4 42 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1-1-1-15-1635\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать41 5 5 91 6 6 51 6 5 102 6 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере, реальными запросами (перед кодированием) являются: 12 2 1 2 2 0 1073741823 1 1 2 5 2 1 1 2 2 2 2 1 2 1 2 3 6 2 1 1 1 1 3 0 2 1 1 2 2 2 2 3 3  Ответы на первые два запроса равны −1−1 потому, что нет достаточно информации.  Первый запрос первого типа сообщает, что a1⊕a2=5a1⊕a2=5. Обратите внимание, что до сих пор невозможно узнать значения в a1a1 или a2a2 (например, может быть, что a1=1,a2=4a1=1,a2=4, или же a1=3,a2=6a1=3,a2=6).  После трех запросов первого типа есть достаточно информации, чтобы узнать значения в a1,a2,a3a1,a2,a3. Во втором примере обратите внимание, что после двух запросов первого типа, уже известно, что a5⊕a6=12a5⊕a6=12, значит третий запрос противоречит предыдущим двум, поэтому, ми его игнорируем.",
      "solutions": [
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces",
          "content": "1075A - The King's RaceLet's find the minimum time needed for the white king to reach the coin.It is obvious that it is always optimal to move only towards the coin. In case of white king it means that we should move only up, right or up-right diagonally. During one move we can only add 11 or 00 to any of our coordinates (or to both of them), it means that the length of the optimal path can not be smaller than max(x−1,y−1)max(x−1,y−1).Let's show that we can reach the coin with max(x−1,y−1)max(x−1,y−1) moves.First step. Let zz be equal to min(x,y)min(x,y). The king does z−1z−1 up-right moves, so after that the king will be in the cell (z,z)(z,z). Second step. Let's assume that x≤yx≤y (the case when x>yx>y is proved in a similar way). So z=xz=x. It means that the king is in the cell (x,x)(x,x). Now the king can do y−xy−x up moves, after which he would be in the cell (x,y)(x,y). It took him (x−1)+(y−x)=y−1(x−1)+(y−x)=y−1 moves to reach the coin. If xx was greater than yy he would need x−1x−1 moves (could be proved the same way). So now we proved that it takes max(x−1,y−1)max(x−1,y−1) moves for the white king to reach the coin.In the same way we can prove that it takes max(n−x,n−y)max(n−x,n−y) steps for the black king to reach the coin.The king, which is closer to the coin, wins. If the distances is equal, than the white king wins, because he moves first.Final description of the algorithm:If max(n−x,n−y)<max(x−1,y−1)max(n−x,n−y)<max(x−1,y−1) then the answer is \"Black\", otherwise the answer is \"White\".It is also can be proven that instead of comparing minimal distances between the coin and the kings we can compare manhattan distances between them. I will leave the proof as homework task.Author: arsijoDeveloper: stanislav.bezkorovainyi 1075B - Taxi drivers and LyftLet's find for each rider the taxi driver that will get his call.To do this we can find for each rider the nearest taxi driver at right and the nearest taxi driver at left. Let's define the nearest taxi driver at left for ii-th citizen as lili and at the right as riri.The computations can be done with the following algorithm:Let's define l0=0l0=0 and rn+m+1=n+m+1rn+m+1=n+m+1. And x0=−2∗109x0=−2∗109, xn+m+1=2∗109xn+m+1=2∗109.In order to find lili for each ii we should iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a taxi driver, then he/she is obviously the nearest taxi driver to himself/herself. If the ii-th citizen is a rider, then li=li−1li=li−1In order to find riri for each ii we should iterate through the citizens from n+mn+m to 11. If the ii-th citizen is a taxi driver, then ri=iri=i, else ri=ri+1ri=ri+1.Now it's time to compute the answer.Let's denote bibi as the number of citizens, whose calls the ii-th citizen will get (if the ii-th citizen is a rider, then bi=0bi=0).In order to do compute the values of array bb we should iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a rider, then if the xri−xi<xi−xlixri−xi<xi−xli (distance between the nearest taxi driver at right and the ii-th citizen is smaller than distance between the nearest taxi driver at the left and the citizen), then taxi driver riri will get the call, otherwise the taxi driver lili will get the call. So if xri−xi<xi−xlixri−xi<xi−xli, then bri:=bri+1bri:=bri+1, else bli:=bli+1bli:=bli+1. In order to print out the answer we iterate through the citizens from 11 to n+mn+m. If the ii-th citizen is a taxi driver, than we should print bibi.The algorithm iterates through the array four times, so overall complexity is O(n+m)O(n+m)Author: arsijoDeveloper: stanislav.bezkorovainyi 1074A - The Tower is Going HomeObservation 1. If we remove all the horizontal spells, than the rook can move straightforward up to the upper side of the field. So the only purpose of removing the vertical spells is to reduce the number of horizontal spells to be removed.Observation 2. If we want to remove the ii-th vertical spell, then we should also remove all such vertical spells jj, that xj<xixj<xi. It is obvious, because when we delete a vertical spell, we suppose that the rook would be able to outflank some horizontal spells by getting at rows that have greater number than xixi. If there remains at least one vertical spell jj, such that xj<xixj<xi, than we will never be able to move to the rows with number greater than xjxj, including xixi.Let's find some observations about the horizontal spells:Let's assume that we deleted ii vertical spells. It means, that the rook can move freely left and right at columns between 11 and xi+1xi+1 inclusive. Let's say that our rook is on the row yy. If there is at least one cell which is located at row yy at any column between 11 and xi+1xi+1, that there is no blocking segment on the top of it, then the rook can move to this cell and move upwards into the row y+1y+1. It means that if there is at least one gap in the blocking segments in row yy and in columns between 11 and xi+1xi+1 incluse, then there is no need to remove any of horizontal spells in the row.Observation 3. We care only about such horizontal spells, in which x1=1x1=1. We have already proved, that we only care about such rows, that there are no gaps in blocking segments in them. If there is no such horizontal spell with x1=1x1=1, it means that there is a gap in the row at column 11. If there is such horizontal spell, then if there are more spells in that row, there would be a gap between any pair of neighbouring segments. Since we only care only about segments with x1=1x1=1 and it is guaranteed that no horizontal segments share a common point, it means that we might not care about the yy of any horizontal spell, because there is no such pair of segments that both x1x1 and yy of these are equal. So now while reading the descriptions of the horizontal spells, if the x1x1 of ii-th horizontal spell is not equal to 11, we can ignore it. Otherwise, we add x2x2 to some array.Now we can sort the array of x2x2-s, and solve the task using the two-pointer technique. Here is the final algorithm: Add fake vertical spell with x=109x=109.Sort all the vertical spells in ascending order.While reading the descriptions of the horizontal spells, we ignore ones with x1x1 not equal to 11. In other case, we add x2x2 to the array.Sort the array of x2x2-s in ascending order. Now we use the two pointer technique in the following way: we iterate ii from 0 to n — the number of vertical spells to be deleted and on each step we advance the pointer while the x2x2 at which the pointer points is less then xx of the (i+1)(i+1)-th vertical spell. Let's denote the position of the pointer as pp. The number of horizontal spells, that we need to remove with ii vertical spells removed is m−p+1m−p+1. Let's define the position of the pointer at ii-th step as pipi.The answer to the problem in minival value of i+m−pi+1i+m−pi+1 among all ii from 00 to nn.Overall complexity O(nlogn+mlogm)O(nlog⁡n+mlog⁡m)Author: stanislav.bezkorovainyiDeveloper: stanislav.bezkorovainyi 1074B - Intersecting SubtreesI'll split this into two parts, first is the solution, second is why it works.The intended solution only uses two questions. Choose an arbitrary yjyj, and ask \"B y_j\". Let the response be RR. Find a node xixi that is the closest to node RR. This can be done with a BFS or DFS. Ask \"A x_i\". Let the response be QQ. If QQ is one of y1,y2,…,yk2y1,y2,…,yk2, print \"C x_i\", otherwise, print \"C -1\". Here is why it works. Let's use the fact that if the two subtrees don't intersect, there is an edge in the tree such that if we cut the tree on this edge, it will split it into two components, each containing one of the subtrees.Suppose we did step 1 and we have RR. Let's root our tree at RR. There is a unique node xixi that has lowest depth in this tree which we can find (given that x1,x2,…,xk1x1,x2,…,xk1 form a subtree).Now, we claim that the two subtrees intersect if and only if Li Chen owns a node that lies in the subtree rooted by xixi (and in particular, we will show it is sufficient to only check node xixi).If none of Li Chen's nodes lie in the subtree rooted by xixi, then the edge xixi to its parent cuts the tree into two components with one subtree completely lying in one component and the other in the second, so the two subtrees are disjoint.Otherwise, there is a node WW that is in Li Chen's subtree that lies in the subtree rooted by xixi. All nodes in the path of RR to WW must also belong to Li Chen's subtree, and in particular this includes node xixi, so the two trees intersect. This also shows we can just check if xixi belongs in Li Chen's subtree by asking a question about it.Author: LewinDeveloper: Lewin 1074C - Optimal Polygon PerimeterI will show 2 solutions, both of which work in O(n)O(n) time. First, it is not hard to notice that we can only consider polygons that are convex.Observation: For a convex polygon, the given definition of \"polygon perimeter\" is equivalent to the perimeter of the bounding rectangle (aligned with the axis), of our polygon. If we look at some convex polygon, and 4 values maxx,minx,maxy,minymaxx,minx,maxy,miny representing the maximal xx coordinate of a point, minimal xx, maximal and minimal yy, then the perimeter of the bounding rectangle is simply 2∗(maxx−minx+maxy−miny)2∗(maxx−minx+maxy−miny).This simple rephrase gives us a bonus, and crucial observation: It is enough for us to take 4 points from the input, such that the perimeter of their polygon is the maximal possible (and is equal to the perimeter of the polygon formed from nn points). We will consider these the extreme points. Note that after taking the extreme points, it does not matter which other points we take. So, this solves all f(4),…,f(n)f(4),…,f(n).We are left with f(3)f(3) to compute (maximal triangle perimeter). Following are 2 solutions to do it:Solution 1: Let's show that the optimal triangle uses at least 2 of the extreme points. Imagine some optimal triangle, and its bounding rectangle. Notice that since each edge of the bounding rectangle must touch some vertex of the triangle (it is bounding after all), and we have 4 edges and 3 vertices, then there must be some vertex of the triangle that touches 2 edges of the rectangle (so it coincides with a rectangle vertex). If this is the case, we know that in comparison with the 2 other vertices, this vertex has \"extremal\" X and Y coordinates (minimal/maximal X, and minimal/maximal Y). Without loss of generality, assume this vertex has maximum X and Y. Then to optimize the perimeter, the other two vertices should have smallest possible X and smallest possible Y. We can pick these 2 vertices to be 2 of the extreme points (one with minimal X and one with minimal Y). So, this shows we just need to iterate over every adjacent pair of extreme vertices, and over all other points as the last vertex. This takes O(n)O(n).Solution 2: This solution is more general, and is an extension of the problem to find the 2 most distant points (manhattan distance). The triangle perimeter is an expression with 6 terms: |x1−x2|+|y1−y2|+…+|y3−y1||x1−x2|+|y1−y2|+…+|y3−y1|. We wish the maximize this expression, but the absolute value is troubling us. For each term, there are 2 cases: either it is positive, so the absolute value does nothing, or it is negative, so the absolute value negates it. In total, for the 6 terms we have 26=6426=64 options to place signs between them. We will call such option a setting.For any setting, the advantage now is that we can accumulate terms: For example the setting ++−−−+++−−−+, evaluates the expression to: (2x1+0y1)+(−2x2−2y2)+(0x3+2y3)(2x1+0y1)+(−2x2−2y2)+(0x3+2y3) We solve every setting by its own, and over all settings we take the maximal answer.Please note, that this strategy only works to find the maximal value of the expression, not minimal. The proof of this is left as an exercise to the reader :) (I promise it is not difficult).Given 6 constants c1,c2,...,c6c1,c2,...,c6, we want to find 3 indicies i<j<ki<j<k to maximize: c1∗xi+c2∗yi+...+c6∗ykc1∗xi+c2∗yi+...+c6∗yk. We define 3 arrays: Pi=c1⋅xi+c2⋅yiPi=c1⋅xi+c2⋅yi Qi=c3⋅xi+c4⋅yiQi=c3⋅xi+c4⋅yi Ri=c5⋅xi+c6⋅yiRi=c5⋅xi+c6⋅yi And so we want to maximize Pi+Qj+RkPi+Qj+Rk. This can be done in O(n)O(n) with simple dynamic programming.So this whole solution is O(n)O(n), with a constant of 64. In general, to compute f(k)f(k) this solution takes O(n⋅4k⋅k)O(n⋅4k⋅k) time, without any observations.Author: Noam527Developer: Noam527 1074D - Deduction QueriesFirst, let's learn how to handle information we have not recieved in updates. Let the function W(l,r)W(l,r) be equal to the xor of the subarray [l,r][l,r]. Also, we define W(l,r)=W(r,l)W(l,r)=W(r,l).Assume 3 indicies a≤b≤ca≤b≤c. There are 2 rules: W(a,b)⊕W(b+1,c)=W(a,c)W(a,b)⊕W(b+1,c)=W(a,c). W(a,c)⊕W(b,c)=W(a,b−1)W(a,c)⊕W(b,c)=W(a,b−1) (holds when a<ba<b). These rules require a lot of conditions (and also plenty of ±± 1). We can simplify them greatly: Let's index the borders between cells in our array (there are 230+1230+1 of them). Now, instead of defining a subarray [l,r][l,r] by its 2 endpoint cells, we will define a subarray by its 2 endpoint borders. Technically it just means, that we should increase rr by 1, and then we get the 2 end borders.From now I will assume that our input is given in such a way, that subarrays are defined by their borders (So I will not mention the addition of 1 to rr). Notice that the function W(l,r)W(l,r) is also affected by this.If we take a look at our rules again, they boil down to just 1 rule: W(a,b)⊕W(b,c)=W(a,c)W(a,b)⊕W(b,c)=W(a,c), for any 3 indicies a,b,ca,b,c (a≤b≤ca≤b≤c doesn't need to hold now, for instance W(3,5)⊕W(5,2)=W(3,2)W(3,5)⊕W(5,2)=W(3,2)). This transformation also shows an observation; Assume every border is a vertex in a graph, and every update W(l,r)=xW(l,r)=x describes an undirected edge between the vertices l,rl,r with weight xx. We let the distance between 2 nodes a,ba,b be the xor of edge weights on the path between them. Notice that this distance is equal to W(a,b)W(a,b). In other words, an update adds an edge and a query asks for some distance.Another observation is that, we do not care about all the 230+1230+1 nodes, but only about the ones we recieved in queries and updates. Moreover, their order is irrelevant, so we can do an online mapping of new nodes to the next free indicies. Thus, the number of nodes will be worstcase O(q)O(q).Claim: We can know the answer to some query [l,r][l,r], if and only if there exists a path between the nodes l,rl,r (they are in the same connected component).//start spoiler of proofThere will be some subset of edges we take, to form the xor between nodes ll and rr. Assume every vertex has 2 states, on/off. Initially all vertices are off, and our current answer is 00. When we take an edge we flip the state of its 2 ends, and xor our answer by its weight. Suppose at some moment of time the nodes with \"on\" state are {x0,x1,x2,...,xkx0,x1,x2,...,xk} (in sorted order). Observe that our current answer is equal to W(x0,x1)⊕W(x2,x3)⊕…⊕W(xk−1,xk)W(x0,x1)⊕W(x2,x3)⊕…⊕W(xk−1,xk). This implies we want our subset of edges to end up having only the nodes {l,rl,r} activated. We look at the connected components. Observe that in each connected component, the number of nodes activated at any time is even. If the nodes ll and rr are in different component, then in our final result we would want to have only 1 activated node in the component of ll, and same with rr, but this is impossible.//end spoiler of proofFirst, we need to know whether a query gives us 2 nodes that are in different components (to know whether the answer is −1−1 or not). For this we need to use the Union-Find structure. Also notice, that our Union-Find structure will only need to handle a forest of trees (if an update gives us an edge that creates a cycle, it means there is no contribution, so we ignore it).Provided that an answer does exist, we need to also handle finding a xor path between 2 nodes in a tree, and to support merging of trees. Generally to find a property over some path in a tree, it is common to use LCA or binary lifting. This turns out very difficult when we also need to merge trees (unless you insist on implementing Link-Cut/ETT). Fortunately, we can still abuse the xor operator. In some tree, mark xvxv as the xor of edges on the path from vv to some arbitrary root in the tree. The xor path between nodes (u,vu,v) turns out to be xu⊕xvxu⊕xv. So we would like to maintain for each tree some arbitrary root and all those values.Notice that we can augment our Union-Find structure to support this as well: For each node vv in the structure, we maintain pvpv as its parent in the structure, and xvxv as the xor on the path from vv to pvpv. Notice that xvxv can be easily updated together with pvpv during the find()find() operation in the structure.To summarize, when we are given W(l,r)=xW(l,r)=x in some update, we transform it to W(pl,pr)=x⊕xl⊕xrW(pl,pr)=x⊕xl⊕xr, and then we add the edge between the parents.Finally, the complexity is O(qlogq)O(qlog⁡q), but this is only due to the online mapping if we use a regular map; You can use a hash table and get a running time of O(q×α(q))O(q×α(q)), but I suggest being careful with a hash table (you may want to read this: https://codeforces.com/blog/entry/62393).Author: Noam527Developer: Noam527 1074E - Grid SortThe solution is more of a coding one than an algorithmic one. There are many different approaches, and it's important to be careful in how it is implemented. I'll explain one of the implementations.First, we can always move a particular block left, up, down, or right with an appropriate 2x2 square around it. Let's code some functions that let us do that for each direction.Next is to make sure that these moves don't mess up previous block spaces as we move blocks to the correct place. We can almost place blocks correctly in their spaces one by one in row major order, but there are some special cases.- We can do all blocks except the last two rows, which we'll handle separately (in paragraph below) - For each row, we can correctly place all blocks except the last one. The last one requires a bit more careful work, but is easy to handle if we have at least two free rows.For the last two rows, we can fill it in column by column from left to right. This is a similar startegy to fitting in the last column of the previous rows. We can almost do this except for the last 2x2 square.For the last 2x2 square, we can use the following sequence of moves to swap two blocks:123456413526421563213456Thus, we can shift the last block into the right position, then do at most three swaps (using the above sequence of moves) to fix the remaining blocks.The number of moves for this strategy can be computed and estimated to be about 50k in the worst case.Author: LewinDeveloper: Lewin 1074F - DFSLet's consider an arbitrary run of DFS producing some tree. Let's root the tree at the starting vertex. It can be shown that on a directed graph, there are only two types of edges. The first are the tree edges (those are the ones that are used to visit a new vertex). The second are edges which, upon being traversed, lead to a vertex that was already visited. It can be shown that, in the rooted tree, those edges always connect a vertex with one of its ancestors. In other words, all the edges that are dynamically added to the tree must connect a vertex with one of their ancestors. This means that the staring vertex must not lie on the path connecting the two endpoints of such edge, or any of the vertices in some of the subtrees. For instance, on the second sample, the edge {2,4}{2,4} disallows the vertex 11 from being the starting vertex, as it lies on the path from 22 to 44, and also vertex 66.Each edge thus forbids a certain set of vertices from being the starting point. This yields a straightforward O(n2)O(n2) solution. To optimize it further, we can root the tree arbitrarily and renumber the vertices using their DFS visit times. When we do this, we notice that the set of a forbidden vertices for each edge is a union of at most three intervals of vertices. This lets us build an O(nlogn)O(nlog⁡n) solution using a segment tree. The operation is add a constant on interval, and then find the minimum on interval and the number of occurrences of said minimum. We add 11 to forbid a vertex because of an edge, subtract 11 to revert that when the edge is subsequently removed. The answer is the number of minimums on the whole tree if that minimum is 00, and 00 otherwise.Author: _h_Developers: _h_ and majk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/62985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 1075 和字母"
          },
          "content_length": 20587
        }
      ],
      "code_examples": [
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 1",
          "code": "123456413526421563213456",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        },
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 2",
          "code": "2 3\n3\n5\n1 4 1\n2 100000 2\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        },
        {
          "title": "Lyft Level 5 Challenge 2018 — Final Round — Editorial - Codeforces - Code 3",
          "code": "2 3\n3\n5\n1 4 1\n2 100000 2\n1 4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/62985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_Q = 200000;\n    const int MAX_VAL = (1 << 30) - 1;\n\n    int q = inf.readInt(1, MAX_Q, \"q\");\n    inf.readEoln();\n\n    int count_type_2 = 0;\n\n    for (int i = 0; i < q; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int l = inf.readInt(0, MAX_VAL, \"l'\");\n            inf.readSpace();\n            int r = inf.readInt(0, MAX_VAL, \"r'\");\n            inf.readSpace();\n            int x = inf.readInt(0, MAX_VAL, \"x'\");\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int l = inf.readInt(0, MAX_VAL, \"l'\");\n            inf.readSpace();\n            int r = inf.readInt(0, MAX_VAL, \"r'\");\n            inf.readEoln();\n\n            count_type_2++;\n        }\n    }\n\n    ensuref(count_type_2 >= 1, \"There must be at least one query of type 2\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_Q = 200000;\n    const int MAX_VAL = (1 << 30) - 1;\n\n    int q = inf.readInt(1, MAX_Q, \"q\");\n    inf.readEoln();\n\n    int count_type_2 = 0;\n\n    for (int i = 0; i < q; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int l = inf.readInt(0, MAX_VAL, \"l'\");\n            inf.readSpace();\n            int r = inf.readInt(0, MAX_VAL, \"r'\");\n            inf.readSpace();\n            int x = inf.readInt(0, MAX_VAL, \"x'\");\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int l = inf.readInt(0, MAX_VAL, \"l'\");\n            inf.readSpace();\n            int r = inf.readInt(0, MAX_VAL, \"r'\");\n            inf.readEoln();\n\n            count_type_2++;\n        }\n    }\n\n    ensuref(count_type_2 >= 1, \"There must be at least one query of type 2\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_Q = 200000;\n    const int MAX_VAL = (1 << 30) - 1;\n\n    int q = inf.readInt(1, MAX_Q, \"q\");\n    inf.readEoln();\n\n    int count_type_2 = 0;\n\n    for (int i = 0; i < q; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int l = inf.readInt(0, MAX_VAL, \"l'\");\n            inf.readSpace();\n            int r = inf.readInt(0, MAX_VAL, \"r'\");\n            inf.readSpace();\n            int x = inf.readInt(0, MAX_VAL, \"x'\");\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int l = inf.readInt(0, MAX_VAL, \"l'\");\n            inf.readSpace();\n            int r = inf.readInt(0, MAX_VAL, \"r'\");\n            inf.readEoln();\n\n            count_type_2++;\n        }\n    }\n\n    ensuref(count_type_2 >= 1, \"There must be at least one query of type 2\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nunordered_map<int, int> parent, val;\n\nint find(int x) {\n    if (parent.find(x) == parent.end()) {\n        parent[x] = x;\n        val[x] = 0;\n        return x;\n    }\n    if (parent[x] == x)\n        return x;\n    int p = parent[x];\n    parent[x] = find(p);\n    val[x] ^= val[p];\n    return parent[x];\n}\n\nbool union_sets(int x, int y, int w) { // x and y are indices, w is the xor between x and y\n    int rx = find(x);\n    int ry = find(y);\n    int w0 = val[x] ^ val[y] ^ w;\n    if (rx != ry) {\n        parent[rx] = ry;\n        val[rx] = w0;\n        return true;\n    } else {\n        if (w0 != 0) {\n            // Contradiction\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n\nint query(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx != ry)\n        return -1;\n    else\n        return val[x] ^ val[y];\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int last = 0; // last answer to type 2 query\n    int type2_count = 0; // count of type 2 queries\n\n    printf(\"%d\\n\", q);\n\n    for (int i = 0; i < q; ++i) {\n        int t;\n        if (type == \"random\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"only_type1\") {\n            t = 1;\n        } else if (type == \"only_type2\") {\n            t = 2;\n        } else if (type == \"mostly_type1\") {\n            t = (rnd.next(1, 10) <= 9) ? 1 : 2; // 90% type 1\n        } else if (type == \"mostly_type2\") {\n            t = (rnd.next(1, 10) <= 9) ? 2 : 1; // 90% type 2\n        } else if (type == \"max_ranges\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"single_element\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"contradictory\") {\n            t = 1; // only generate type 1\n        } else if (type == \"repeated_queries\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"large_indices\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"l_equals_r\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"full_range\") {\n            t = rnd.next(1, 2);\n        } else {\n            t = 1; // default to type 1\n        }\n\n        if (t == 1) {\n            // Generate update\n            int l, r, x;\n            if (type == \"max_ranges\") {\n                l = 0;\n                r = (1 << 30) - 1;\n            } else if (type == \"single_element\") {\n                l = r = rnd.next(0, (1 << 30) - 1);\n            } else if (type == \"contradictory\") {\n                // Generate contradictory updates\n                l = r = rnd.next(0, (1 << 30) - 1);\n                x = rnd.next(0, (1 << 30) - 1);\n                // First time, insert correct info\n                // Next time, insert contradictory info\n                bool res = union_sets(l, r, x);\n                if (!res) continue;\n                // Now, generate a contradictory update\n                x ^= 1; // Flip one bit to make it contradictory\n                // Apply last encoding\n            } else if (type == \"large_indices\") {\n                l = rnd.next((1 << 30) - (1 << 20), (1 << 30) -1);\n                r = rnd.next((1 << 30) - (1 << 20), (1 << 30) -1);\n            } else if (type == \"l_equals_r\") {\n                l = r = rnd.next(0, (1 << 30) - 1);\n            } else if (type == \"full_range\") {\n                l = 0;\n                r = (1 << 30) - 1;\n            } else {\n                l = rnd.next(0, (1 << 30) - 1);\n                r = rnd.next(0, (1 << 30) - 1);\n            }\n            if (l > r) swap(l, r);\n            if (type != \"contradictory\") {\n                x = rnd.next(0, (1 << 30) - 1);\n            }\n\n            // Apply last encoding\n            int l_prime = l ^ last;\n            int r_prime = r ^ last;\n            int x_prime = x ^ last;\n\n            if (l_prime > r_prime) swap(l_prime, r_prime);\n\n            // Process the update\n            bool res = union_sets(l, r, x);\n\n            // If contradictory, ignore the update\n            if (!res) continue;\n\n            printf(\"1 %d %d %d\\n\", l_prime, r_prime, x_prime);\n\n        } else { // t == 2\n            // Generate query\n            int l, r;\n            if (type == \"max_ranges\") {\n                l = 0;\n                r = (1 << 30) - 1;\n            } else if (type == \"single_element\") {\n                l = r = rnd.next(0, (1 << 30) - 1);\n            } else if (type == \"large_indices\") {\n                l = rnd.next((1 << 30) - (1 << 20), (1 << 30) -1);\n                r = rnd.next((1 << 30) - (1 << 20), (1 << 30) -1);\n            } else if (type == \"l_equals_r\") {\n                l = r = rnd.next(0, (1 << 30) - 1);\n            } else if (type == \"full_range\") {\n                l = 0;\n                r = (1 << 30) - 1;\n            } else {\n                l = rnd.next(0, (1 << 30) - 1);\n                r = rnd.next(0, (1 << 30) - 1);\n            }\n            if (l > r) swap(l, r);\n\n            // Apply last encoding\n            int l_prime = l ^ last;\n            int r_prime = r ^ last;\n            if (l_prime > r_prime) swap(l_prime, r_prime);\n\n            // Get answer\n            int ans = query(l, r);\n\n            printf(\"2 %d %d\\n\", l_prime, r_prime);\n\n            // Update last\n            if (ans == -1) last = 1;\n            else last = ans;\n\n            type2_count++;\n        }\n    }\n\n    // Ensure at least one query of type 2\n    if (type2_count == 0) {\n        int l = rnd.next(0, (1 << 30) - 1);\n        int r = rnd.next(0, (1 << 30) - 1);\n        if (l > r) swap(l, r);\n        int l_prime = l ^ last;\n        int r_prime = r ^ last;\n        if (l_prime > r_prime) swap(l_prime, r_prime);\n        int ans = query(l, r);\n        printf(\"2 %d %d\\n\", l_prime, r_prime);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nunordered_map<int, int> parent, val;\n\nint find(int x) {\n    if (parent.find(x) == parent.end()) {\n        parent[x] = x;\n        val[x] = 0;\n        return x;\n    }\n    if (parent[x] == x)\n        return x;\n    int p = parent[x];\n    parent[x] = find(p);\n    val[x] ^= val[p];\n    return parent[x];\n}\n\nbool union_sets(int x, int y, int w) { // x and y are indices, w is the xor between x and y\n    int rx = find(x);\n    int ry = find(y);\n    int w0 = val[x] ^ val[y] ^ w;\n    if (rx != ry) {\n        parent[rx] = ry;\n        val[rx] = w0;\n        return true;\n    } else {\n        if (w0 != 0) {\n            // Contradiction\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n\nint query(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx != ry)\n        return -1;\n    else\n        return val[x] ^ val[y];\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int last = 0; // last answer to type 2 query\n    int type2_count = 0; // count of type 2 queries\n\n    printf(\"%d\\n\", q);\n\n    for (int i = 0; i < q; ++i) {\n        int t;\n        if (type == \"random\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"only_type1\") {\n            t = 1;\n        } else if (type == \"only_type2\") {\n            t = 2;\n        } else if (type == \"mostly_type1\") {\n            t = (rnd.next(1, 10) <= 9) ? 1 : 2; // 90% type 1\n        } else if (type == \"mostly_type2\") {\n            t = (rnd.next(1, 10) <= 9) ? 2 : 1; // 90% type 2\n        } else if (type == \"max_ranges\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"single_element\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"contradictory\") {\n            t = 1; // only generate type 1\n        } else if (type == \"repeated_queries\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"large_indices\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"l_equals_r\") {\n            t = rnd.next(1, 2);\n        } else if (type == \"full_range\") {\n            t = rnd.next(1, 2);\n        } else {\n            t = 1; // default to type 1\n        }\n\n        if (t == 1) {\n            // Generate update\n            int l, r, x;\n            if (type == \"max_ranges\") {\n                l = 0;\n                r = (1 << 30) - 1;\n            } else if (type == \"single_element\") {\n                l = r = rnd.next(0, (1 << 30) - 1);\n            } else if (type == \"contradictory\") {\n                // Generate contradictory updates\n                l = r = rnd.next(0, (1 << 30) - 1);\n                x = rnd.next(0, (1 << 30) - 1);\n                // First time, insert correct info\n                // Next time, insert contradictory info\n                bool res = union_sets(l, r, x);\n                if (!res) continue;\n                // Now, generate a contradictory update\n                x ^= 1; // Flip one bit to make it contradictory\n                // Apply last encoding\n            } else if (type == \"large_indices\") {\n                l = rnd.next((1 << 30) - (1 << 20), (1 << 30) -1);\n                r = rnd.next((1 << 30) - (1 << 20), (1 << 30) -1);\n            } else if (type == \"l_equals_r\") {\n                l = r = rnd.next(0, (1 << 30) - 1);\n            } else if (type == \"full_range\") {\n                l = 0;\n                r = (1 << 30) - 1;\n            } else {\n                l = rnd.next(0, (1 << 30) - 1);\n                r = rnd.next(0, (1 << 30) - 1);\n            }\n            if (l > r) swap(l, r);\n            if (type != \"contradictory\") {\n                x = rnd.next(0, (1 << 30) - 1);\n            }\n\n            // Apply last encoding\n            int l_prime = l ^ last;\n            int r_prime = r ^ last;\n            int x_prime = x ^ last;\n\n            if (l_prime > r_prime) swap(l_prime, r_prime);\n\n            // Process the update\n            bool res = union_sets(l, r, x);\n\n            // If contradictory, ignore the update\n            if (!res) continue;\n\n            printf(\"1 %d %d %d\\n\", l_prime, r_prime, x_prime);\n\n        } else { // t == 2\n            // Generate query\n            int l, r;\n            if (type == \"max_ranges\") {\n                l = 0;\n                r = (1 << 30) - 1;\n            } else if (type == \"single_element\") {\n                l = r = rnd.next(0, (1 << 30) - 1);\n            } else if (type == \"large_indices\") {\n                l = rnd.next((1 << 30) - (1 << 20), (1 << 30) -1);\n                r = rnd.next((1 << 30) - (1 << 20), (1 << 30) -1);\n            } else if (type == \"l_equals_r\") {\n                l = r = rnd.next(0, (1 << 30) - 1);\n            } else if (type == \"full_range\") {\n                l = 0;\n                r = (1 << 30) - 1;\n            } else {\n                l = rnd.next(0, (1 << 30) - 1);\n                r = rnd.next(0, (1 << 30) - 1);\n            }\n            if (l > r) swap(l, r);\n\n            // Apply last encoding\n            int l_prime = l ^ last;\n            int r_prime = r ^ last;\n            if (l_prime > r_prime) swap(l_prime, r_prime);\n\n            // Get answer\n            int ans = query(l, r);\n\n            printf(\"2 %d %d\\n\", l_prime, r_prime);\n\n            // Update last\n            if (ans == -1) last = 1;\n            else last = ans;\n\n            type2_count++;\n        }\n    }\n\n    // Ensure at least one query of type 2\n    if (type2_count == 0) {\n        int l = rnd.next(0, (1 << 30) - 1);\n        int r = rnd.next(0, (1 << 30) - 1);\n        if (l > r) swap(l, r);\n        int l_prime = l ^ last;\n        int r_prime = r ^ last;\n        if (l_prime > r_prime) swap(l_prime, r_prime);\n        int ans = query(l, r);\n        printf(\"2 %d %d\\n\", l_prime, r_prime);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -q 1 -type random\n./gen -q 2 -type random\n./gen -q 5 -type random\n./gen -q 10 -type random\n\n# Test cases with only type 1 queries (except for the required one type 2)\n./gen -q 10 -type only_type1\n./gen -q 10 -type only_type2\n\n# Test cases with mostly type 1 queries\n./gen -q 100 -type mostly_type1\n./gen -q 1000 -type mostly_type1\n\n# Test cases with mostly type 2 queries\n./gen -q 100 -type mostly_type2\n./gen -q 1000 -type mostly_type2\n\n# Large test cases with random queries\n./gen -q 10000 -type random\n./gen -q 50000 -type random\n./gen -q 100000 -type random\n./gen -q 200000 -type random\n\n# Test cases with maximum ranges\n./gen -q 1000 -type max_ranges\n./gen -q 10000 -type max_ranges\n./gen -q 100000 -type max_ranges\n\n# Test cases with single element ranges\n./gen -q 1000 -type single_element\n./gen -q 10000 -type single_element\n./gen -q 100000 -type single_element\n\n# Test cases designed to generate contradictions\n./gen -q 1000 -type contradictory\n./gen -q 5000 -type contradictory\n./gen -q 10000 -type contradictory\n\n# Test cases designed to check for efficiency with repeated queries\n./gen -q 1000 -type repeated_queries\n./gen -q 10000 -type repeated_queries\n./gen -q 100000 -type repeated_queries\n\n# Test cases with large indices\n./gen -q 1000 -type large_indices\n./gen -q 10000 -type large_indices\n./gen -q 100000 -type large_indices\n\n# Edge cases with l = r\n./gen -q 1000 -type l_equals_r\n./gen -q 10000 -type l_equals_r\n./gen -q 100000 -type l_equals_r\n\n# Test cases covering the full range of the array\n./gen -q 1000 -type full_range\n./gen -q 5000 -type full_range\n./gen -q 10000 -type full_range\n\n# Mixing different types in one test case\n./gen -q 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T18:15:07.304169",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}