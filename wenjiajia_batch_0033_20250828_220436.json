{
  "metadata": {
    "batch_number": 33,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:41.204358",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "220/D",
      "title": "D. Little Elephant and Triangle",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains two integers w and h (1 ≤ w, h ≤ 4000).",
      "output_spec": "OutputIn a single output line print an integer — the remainder of dividing the answer to the problem by 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy2 1OutputCopy36InputCopy2 2OutputCopy240",
      "description": "D. Little Elephant and Triangle\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains two integers w and h (1 ≤ w, h ≤ 4000).\n\nOutputIn a single output line print an integer — the remainder of dividing the answer to the problem by 1000000007 (109 + 7).\n\nInputCopy2 1OutputCopy36InputCopy2 2OutputCopy240\n\nInputCopy2 1\n\nOutputCopy36\n\nInputCopy2 2\n\nOutputCopy240",
      "solutions": [
        {
          "title": "Codeforces Round #136 - Codeforces",
          "content": "Tomorrow, in 4 and half hours before the end of the summer (check your zone), Codeforces Round #136 will take place. I am the author of this round, it's my 6th contest on CF.Gerlad Agapov (Gerald) is helping me in preparing the problems. Translations will be done by Maria Belova (Delinur). Thanks to them.I hope you will like this round. The points distribution will be standart.Thanks!7 user in the first division solved all 5 problems, here they are: peter50216 yeputons winger rng_58 RAD al13n KADR Meanwhile, in second division, Top-4 looks like this: blue.boy de_troit lxyxynt ilona You can find the editorial of the contest here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5167",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 636
        },
        {
          "title": "Codeforces Round #136 — Editorial - Codeforces",
          "content": "221A - Little Elephant and FunctionIn this problems you should notice that the answer for the problem is always of the following form: n, 1, 2, 3, ..., n-1. In such case array will be always sorted after the end of the algorithm.221B - Little Elephant and NumbersHere you just need to find all divisors of n. This can be done using standart algorithm with iterating from 1 to sqrt(n). After that you need to write some function that checks whether two numbers has same digits. This also can be done using simple loops.220A - Little Elephant and ProblemThere are multiple possible solutions for this problem. For example, the following. Find the last index x such that there exists some y (y < x) (minimal possible) that Ax < Ay. Then you just need to try two possibilities — either swap Ax and Ay, or don't change anything.220B - Little Elephant and ArrayThis problem can be solve in simpler O(NsqrtN) solution, but I will describe O(NlogN) one.We will solve this problem in offline. For each x (0 ≤ x < n) we should keep all the queries that end in x. Iterate that x from 0 to n - 1. Also we need to keep some array D such that for current x Dl + Dl + 1 + ... + Dx will be the answer for query [l;x]. To keep D correct, before the processing all queries that end in x, we need to update D. Let t be the current integer in A, i. e. Ax, and vector P be the list of indices of previous occurences of t (0-based numeration of vector). Then, if |P| ≥ t, you need to add 1 to DP[|P| - t], because this position is now the first (from right) that contains exactly t occurences of t. After that, if |P| > t, you need to subtract 2 from DP[|P| - t - 1], in order to close current interval and cancel previous. Finally, if |P| > t + 1, then you need additionally add 1 to DP[|P| - t - 2] to cancel previous close of the interval.220C - Little Elephant and ShiftsEach of the shifts can be divided into two parts — the right (the one that starts from occurrence 1) and the left (the rest of the elements). If we could keep minimal distance for each part, the minimal of these numbers will be the answers for the corresponding shift. Lets solve the problems of the right part, the left will be almost the same.Let we have some shift, for example 34567[12] and the permutation A is 4312765 and B is 2145673, then shifted B is 4567321. Let we keep two sets (S1 and S2). The first will keep all the distances from integers in current left part to the corresponding positions in A (for the example above, it is \\texttt{2, 4}). When you come to the next shift, all integers in S1 should be decreased by 1 (that is because all distances are also decreased by 1). But now some integers in set may be negative, when any negative integer occures (it always will be -1) you need to delete it from S1 and put 1 to the S2. Also after shifting to the next shifts, all integers in S2 must be increase by 1. After that, for any shift, the answer will be minimum from the smallest numbers in S1 and S2.It was very useful to use standart \"set\" in C++.220D - Little Elephant and TriangleLet iterate all possible points that, as we consider, must be the first point. Let it be (x;y). Let the second and the third points be (x1;y1) and (x2;y2). Then the doubled area is |(x1 - x)(y2 - y) - (x2 - x)(y1 - y)|. We need this number to be even and nonzero. For first we will find the number of groups of points that are even, after that just subtract the number of groups with area equal to zero.For the first subproblem, we need to rewrite our formula. It is equal to |x(y1 - y2) + y(x2 - x1)|. Since we know x and y and we just need to check parity, we can try all possible 24 values of parity of x1, y1, x2 and y2 (let it be d0, d1, d2 and d3, respectively). And check whether they will form a 0 after multiplications and taking modulo 2. If it froms a 0, then add to the answer value cxd0cyd1cxd2cyd3, where cxd is equal to the number of integers between 0 and n, inclusve, that modulo 2 are equal d. cyd is the same but in range [0..m].Now we need to subtract bad groups — the ones that has the area equal to zero. This means that they will either form a dot or a segment. If it is segment, we can just iterate dx = |x1 - x2| and dy = |y1 - y2| instead of all 4 coordinates. Then the number of such segments on the plane will be (n - dx + 1)(m - dy + 1). Also for counting the number of triples of points on the segment you need to find the number of integer coordinates on the segment. It is well-know problem, and the answer is gcd(dx, dy) + 1.This gives us, with some simple optimizations, and O(nm) solution.220E - Little Elephant and InversionsIn this problems you can use a method of two pointers. Also some RMQ are required. If you do not know about RMQ, please, read about it in the Internet before solving this problem.Firstly, map all the elements in the input array. After that all of them will be in range [0..n - 1]. We need to keep two RMQs, both of size n. Let the first RMQ be Q1 and the second Q2. Q1i will contain the number of numbers i in current left subarray. Q2i will contain the number of numbers i in the left subarray. Firstly, add all n number to the Q2. After that iterate some pointer r from n - 1 downto 1, by the way keeping point l (which, at the beggining, is equal to n - 1) Using RMQs, you can keep the number of inversions when you decrease r or l (using \"sum on the range\" operation). While the current number of inversions is more then k and l ≥ 0, decrease l. Then for each r the answer of correct l will be l + 1 (considering 0-based numeration).This makes the algorithm working in O(NlogN) time with correct realisation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 220\\s*D"
          },
          "content_length": 5630
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(1, 4000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 4000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(1, 4000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 4000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(1, 4000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 4000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\", -1);\n    int h = opt<int>(\"h\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_WH = 4000;\n    const int MIN_WH = 1;\n\n    if (w == -1 || h == -1) {\n        if (type == \"small\") {\n            w = rnd.next(MIN_WH, 5);\n            h = rnd.next(MIN_WH, 5);\n        } else if (type == \"large\") {\n            w = rnd.next(MAX_WH - 5, MAX_WH);\n            h = rnd.next(MAX_WH - 5, MAX_WH);\n        } else if (type == \"thin_w\") {\n            w = MIN_WH;\n            h = rnd.next(MIN_WH, MAX_WH);\n        } else if (type == \"thin_h\") {\n            w = rnd.next(MIN_WH, MAX_WH);\n            h = MIN_WH;\n        } else if (type == \"square\") {\n            int val = rnd.next(MIN_WH, MAX_WH);\n            w = h = val;\n        } else if (type == \"rectangle\") {\n            w = rnd.next(MIN_WH, MAX_WH);\n            h = rnd.next(MIN_WH, MAX_WH);\n            while (w == h) {\n                h = rnd.next(MIN_WH, MAX_WH);\n            }\n        } else if (type == \"max\") {\n            w = MAX_WH;\n            h = MAX_WH;\n        } else if (type == \"min\") {\n            w = MIN_WH;\n            h = MIN_WH;\n        } else if (type == \"random_small\") {\n            w = rnd.next(MIN_WH, 100);\n            h = rnd.next(MIN_WH, 100);\n        } else if (type == \"random_large\") {\n            w = rnd.next(1000, MAX_WH);\n            h = rnd.next(1000, MAX_WH);\n        } else { // random\n            w = rnd.next(MIN_WH, MAX_WH);\n            h = rnd.next(MIN_WH, MAX_WH);\n        }\n    }\n\n    if (w < MIN_WH || w > MAX_WH || h < MIN_WH || h > MAX_WH) {\n        fprintf(stderr, \"Invalid w or h: w=%d, h=%d\\n\", w, h);\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", w, h);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\", -1);\n    int h = opt<int>(\"h\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_WH = 4000;\n    const int MIN_WH = 1;\n\n    if (w == -1 || h == -1) {\n        if (type == \"small\") {\n            w = rnd.next(MIN_WH, 5);\n            h = rnd.next(MIN_WH, 5);\n        } else if (type == \"large\") {\n            w = rnd.next(MAX_WH - 5, MAX_WH);\n            h = rnd.next(MAX_WH - 5, MAX_WH);\n        } else if (type == \"thin_w\") {\n            w = MIN_WH;\n            h = rnd.next(MIN_WH, MAX_WH);\n        } else if (type == \"thin_h\") {\n            w = rnd.next(MIN_WH, MAX_WH);\n            h = MIN_WH;\n        } else if (type == \"square\") {\n            int val = rnd.next(MIN_WH, MAX_WH);\n            w = h = val;\n        } else if (type == \"rectangle\") {\n            w = rnd.next(MIN_WH, MAX_WH);\n            h = rnd.next(MIN_WH, MAX_WH);\n            while (w == h) {\n                h = rnd.next(MIN_WH, MAX_WH);\n            }\n        } else if (type == \"max\") {\n            w = MAX_WH;\n            h = MAX_WH;\n        } else if (type == \"min\") {\n            w = MIN_WH;\n            h = MIN_WH;\n        } else if (type == \"random_small\") {\n            w = rnd.next(MIN_WH, 100);\n            h = rnd.next(MIN_WH, 100);\n        } else if (type == \"random_large\") {\n            w = rnd.next(1000, MAX_WH);\n            h = rnd.next(1000, MAX_WH);\n        } else { // random\n            w = rnd.next(MIN_WH, MAX_WH);\n            h = rnd.next(MIN_WH, MAX_WH);\n        }\n    }\n\n    if (w < MIN_WH || w > MAX_WH || h < MIN_WH || h > MAX_WH) {\n        fprintf(stderr, \"Invalid w or h: w=%d, h=%d\\n\", w, h);\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", w, h);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -type min\n./gen -type small\n./gen -type small\n\n# Edge cases with w or h = 1\n./gen -w 1 -h 1\n./gen -w 1 -h 10\n./gen -w 10 -h 1\n\n# Random small test cases\n./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n\n# Random test cases\n./gen -type random\n./gen -type random\n\n# Random large test cases\n./gen -type random_large\n./gen -type random_large\n\n# Maximum size test case\n./gen -type max\n\n# Thin rectangle test cases\n./gen -type thin_w\n./gen -type thin_h\n\n# Square test cases\n./gen -type square\n./gen -type square\n\n# Rectangle test cases\n./gen -type rectangle\n./gen -type rectangle\n\n# Mix of specified w and h\n./gen -w 1 -h 4000\n./gen -w 4000 -h 1\n./gen -w 2000 -h 2000\n./gen -w 4000 -h 3999\n\n# Additional test cases\n./gen -w 1 -h 2\n./gen -w 2 -h 1\n./gen -w 4000 -h 2\n./gen -w 2 -h 4000\n./gen -w 1000 -h 3000\n./gen -w 3000 -h 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:56.871842",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "220/E",
      "title": "E. Little Elephant and Inversions",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (2 ≤ n ≤ 105, 0 ≤ k ≤ 1018) — the size of array a and the maximum allowed number of inversions respectively. The next line contains n positive integers, separated by single spaces, a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of array a.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputIn a single line print a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy3 11 3 2OutputCopy3InputCopy5 21 3 2 1 7OutputCopy6",
      "description": "E. Little Elephant and Inversions\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (2 ≤ n ≤ 105, 0 ≤ k ≤ 1018) — the size of array a and the maximum allowed number of inversions respectively. The next line contains n positive integers, separated by single spaces, a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of array a.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nOutputIn a single line print a single number — the answer to the problem.\n\nInputCopy3 11 3 2OutputCopy3InputCopy5 21 3 2 1 7OutputCopy6\n\nInputCopy3 11 3 2\n\nOutputCopy3\n\nInputCopy5 21 3 2 1 7\n\nOutputCopy6",
      "solutions": [
        {
          "title": "Codeforces Round #136 - Codeforces",
          "content": "Tomorrow, in 4 and half hours before the end of the summer (check your zone), Codeforces Round #136 will take place. I am the author of this round, it's my 6th contest on CF.Gerlad Agapov (Gerald) is helping me in preparing the problems. Translations will be done by Maria Belova (Delinur). Thanks to them.I hope you will like this round. The points distribution will be standart.Thanks!7 user in the first division solved all 5 problems, here they are: peter50216 yeputons winger rng_58 RAD al13n KADR Meanwhile, in second division, Top-4 looks like this: blue.boy de_troit lxyxynt ilona You can find the editorial of the contest here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5167",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 636
        },
        {
          "title": "Codeforces Round #136 — Editorial - Codeforces",
          "content": "221A - Little Elephant and FunctionIn this problems you should notice that the answer for the problem is always of the following form: n, 1, 2, 3, ..., n-1. In such case array will be always sorted after the end of the algorithm.221B - Little Elephant and NumbersHere you just need to find all divisors of n. This can be done using standart algorithm with iterating from 1 to sqrt(n). After that you need to write some function that checks whether two numbers has same digits. This also can be done using simple loops.220A - Little Elephant and ProblemThere are multiple possible solutions for this problem. For example, the following. Find the last index x such that there exists some y (y < x) (minimal possible) that Ax < Ay. Then you just need to try two possibilities — either swap Ax and Ay, or don't change anything.220B - Little Elephant and ArrayThis problem can be solve in simpler O(NsqrtN) solution, but I will describe O(NlogN) one.We will solve this problem in offline. For each x (0 ≤ x < n) we should keep all the queries that end in x. Iterate that x from 0 to n - 1. Also we need to keep some array D such that for current x Dl + Dl + 1 + ... + Dx will be the answer for query [l;x]. To keep D correct, before the processing all queries that end in x, we need to update D. Let t be the current integer in A, i. e. Ax, and vector P be the list of indices of previous occurences of t (0-based numeration of vector). Then, if |P| ≥ t, you need to add 1 to DP[|P| - t], because this position is now the first (from right) that contains exactly t occurences of t. After that, if |P| > t, you need to subtract 2 from DP[|P| - t - 1], in order to close current interval and cancel previous. Finally, if |P| > t + 1, then you need additionally add 1 to DP[|P| - t - 2] to cancel previous close of the interval.220C - Little Elephant and ShiftsEach of the shifts can be divided into two parts — the right (the one that starts from occurrence 1) and the left (the rest of the elements). If we could keep minimal distance for each part, the minimal of these numbers will be the answers for the corresponding shift. Lets solve the problems of the right part, the left will be almost the same.Let we have some shift, for example 34567[12] and the permutation A is 4312765 and B is 2145673, then shifted B is 4567321. Let we keep two sets (S1 and S2). The first will keep all the distances from integers in current left part to the corresponding positions in A (for the example above, it is \\texttt{2, 4}). When you come to the next shift, all integers in S1 should be decreased by 1 (that is because all distances are also decreased by 1). But now some integers in set may be negative, when any negative integer occures (it always will be -1) you need to delete it from S1 and put 1 to the S2. Also after shifting to the next shifts, all integers in S2 must be increase by 1. After that, for any shift, the answer will be minimum from the smallest numbers in S1 and S2.It was very useful to use standart \"set\" in C++.220D - Little Elephant and TriangleLet iterate all possible points that, as we consider, must be the first point. Let it be (x;y). Let the second and the third points be (x1;y1) and (x2;y2). Then the doubled area is |(x1 - x)(y2 - y) - (x2 - x)(y1 - y)|. We need this number to be even and nonzero. For first we will find the number of groups of points that are even, after that just subtract the number of groups with area equal to zero.For the first subproblem, we need to rewrite our formula. It is equal to |x(y1 - y2) + y(x2 - x1)|. Since we know x and y and we just need to check parity, we can try all possible 24 values of parity of x1, y1, x2 and y2 (let it be d0, d1, d2 and d3, respectively). And check whether they will form a 0 after multiplications and taking modulo 2. If it froms a 0, then add to the answer value cxd0cyd1cxd2cyd3, where cxd is equal to the number of integers between 0 and n, inclusve, that modulo 2 are equal d. cyd is the same but in range [0..m].Now we need to subtract bad groups — the ones that has the area equal to zero. This means that they will either form a dot or a segment. If it is segment, we can just iterate dx = |x1 - x2| and dy = |y1 - y2| instead of all 4 coordinates. Then the number of such segments on the plane will be (n - dx + 1)(m - dy + 1). Also for counting the number of triples of points on the segment you need to find the number of integer coordinates on the segment. It is well-know problem, and the answer is gcd(dx, dy) + 1.This gives us, with some simple optimizations, and O(nm) solution.220E - Little Elephant and InversionsIn this problems you can use a method of two pointers. Also some RMQ are required. If you do not know about RMQ, please, read about it in the Internet before solving this problem.Firstly, map all the elements in the input array. After that all of them will be in range [0..n - 1]. We need to keep two RMQs, both of size n. Let the first RMQ be Q1 and the second Q2. Q1i will contain the number of numbers i in current left subarray. Q2i will contain the number of numbers i in the left subarray. Firstly, add all n number to the Q2. After that iterate some pointer r from n - 1 downto 1, by the way keeping point l (which, at the beggining, is equal to n - 1) Using RMQs, you can keep the number of inversions when you decrease r or l (using \"sum on the range\" operation). While the current number of inversions is more then k and l ≥ 0, decrease l. Then for each r the answer of correct l will be l + 1 (considering 0-based numeration).This makes the algorithm working in O(NlogN) time with correct realisation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 220\\s*E"
          },
          "content_length": 5630
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read parameters\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\", 0LL);\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n    \n    if (type == \"random\") {\n        // Generate random numbers between 1 and 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"sorted\") {\n        // Generate an increasing sequence\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + rnd.next(0, 10);\n        }\n    } else if (type == \"reversesorted\") {\n        // Generate a decreasing sequence\n        a[0] = 1000000000;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i-1] - rnd.next(0, 10);\n            if (a[i] < 1) a[i] = 1;  // Ensure a[i] >= 1\n        }\n    } else if (type == \"equal\") {\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"smallrange\") {\n        int minVal = rnd.next(1, 1000);\n        int maxVal = minVal + rnd.next(0, 10);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(minVal, maxVal);\n        }\n    } else if (type == \"alternating\") {\n        int high = rnd.next(1e9 - 100, 1e9);\n        int low = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? high : low;\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n    \n    // Output\n    printf(\"%d %lld\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read parameters\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\", 0LL);\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n    \n    if (type == \"random\") {\n        // Generate random numbers between 1 and 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"sorted\") {\n        // Generate an increasing sequence\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + rnd.next(0, 10);\n        }\n    } else if (type == \"reversesorted\") {\n        // Generate a decreasing sequence\n        a[0] = 1000000000;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i-1] - rnd.next(0, 10);\n            if (a[i] < 1) a[i] = 1;  // Ensure a[i] >= 1\n        }\n    } else if (type == \"equal\") {\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"smallrange\") {\n        int minVal = rnd.next(1, 1000);\n        int maxVal = minVal + rnd.next(0, 10);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(minVal, maxVal);\n        }\n    } else if (type == \"alternating\") {\n        int high = rnd.next(1e9 - 100, 1e9);\n        int low = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? high : low;\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n    \n    // Output\n    printf(\"%d %lld\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -k 0 -type equal\n./gen -n 2 -k 1 -type equal\n./gen -n 5 -k 2 -type sorted\n./gen -n 5 -k 2 -type reversesorted\n./gen -n 5 -k 2 -type random\n\n./gen -n 100 -k 0 -type equal\n./gen -n 100 -k 0 -type sorted\n./gen -n 100 -k 0 -type reversesorted\n./gen -n 100 -k 0 -type random\n\n./gen -n 1000 -k 1000000000000 -type equal\n./gen -n 1000 -k 1000000000000 -type sorted\n./gen -n 1000 -k 1000000000000 -type reversesorted\n./gen -n 1000 -k 1000000000000 -type random\n\n./gen -n 100000 -k 1000000000000000000 -type equal\n./gen -n 100000 -k 1000000000000000000 -type sorted\n./gen -n 100000 -k 1000000000000000000 -type reversesorted\n./gen -n 100000 -k 1000000000000000000 -type random\n\n./gen -n 100000 -k 1000000000000000000 -type smallrange\n./gen -n 100000 -k 1000000000000000000 -type alternating\n./gen -n 100000 -k 0 -type alternating\n./gen -n 100000 -k 0 -type max\n\n./gen -n 2 -k 0 -type random\n./gen -n 2 -k 1000000000000000000 -type random\n\n./gen -n 100000 -k 0 -type random\n./gen -n 100000 -k 1000000000000000000 -type random\n\n./gen -n 100000 -k 1000000000000000000 -type random\n./gen -n 50000 -k 50000000000 -type equal\n./gen -n 50000 -k 50000000000 -type smallrange\n./gen -n 50000 -k 50000000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:59.164835",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "221/A",
      "title": "A. Маленький Слоник и функция",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано целое число n (1 ≤ n ≤ 103) — размер перестановки.",
      "output_spec": "Выходные данныеВ единственную строку выведите n различных чисел от 1 до n — искомая перестановка. Числа в строке разделяйте пробелами.Гарантируется, что ответ существует.",
      "sample_tests": "ПримерыВходные данныеСкопировать1Выходные данныеСкопировать1 Входные данныеСкопировать2Выходные данныеСкопировать2 1",
      "description": "A. Маленький Слоник и функция\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записано целое число n (1 ≤ n ≤ 103) — размер перестановки.\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите n различных чисел от 1 до n — искомая перестановка. Числа в строке разделяйте пробелами.Гарантируется, что ответ существует.\n\nВыходные данные\n\nВходные данныеСкопировать1Выходные данныеСкопировать1 Входные данныеСкопировать2Выходные данныеСкопировать2 1\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #136 - Codeforces",
          "content": "Завтра, 31-го августа, за 4 с половиной часа до конца лета (по Москве) будет проходить Codeforces Round #136. Автором этого контеста буду я, это уже мой 6-й контест на CF.Помогает строить раунд мне Геральд Агапов (Gerald), задачи переведет, как я предполагаю, Мария Белова (Delinur). Спасибо всем.Надеюсь, вам понравится раунд. Разбалловка стандартная.Спасибо за участие. К сожалению, большинство моих контестов не пользуются особым интересом, судя по системе \"Вклад\", но надеюсь все-таки нашлись те, кому он понравился :)В первом дивизионе ровно 7 участников решили все задачи, они и попадут на главную: peter50216 yeputons winger rng_58 RAD al13n KADR В то время Топ-4 во втором дивизионе выглядит следующим образом: blue.boy de_troit lxyxynt ilona На данный момент есть только разбор на английском.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5167",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 801
        },
        {
          "title": "Codeforces Round #136 — Разбор - Codeforces",
          "content": "221A - Маленький Слоник и функцияВ этой задаче все что нужно заметить это то, что ответ всегда имеет следующею форму: n, 1, 2, 3, ..., n-1. При такой перестановке не трудно заметить, что после полого выполнения алгоритма перестановка будет отсортирована.221B - Маленький Слоник и числаНужно найти все делители числа n. Это можно сделать простым перебором от 1 до sqrt(n). После этого нужно написать функцию, которая умеет определять, существуют ли две одинаковые цифры в паре чисел. Это тоже можно сделать простым перебором по цифрам.220A - Маленький Слоник и проблемаСуществует несколько решений этой задачи. Например, можно найти максимальное x такое, что существует y (минимальное возможное) такое, что (y < x) и Ax < Ay. После этого остается проверить ровно два варианты — либо менять местами x-е и y-е числа, либо не делать ничего.220B - Маленький Слоник и массивЗадачу можно решить за O(NsqrtN), но я опишу решение за O(NlogN).Будем решать задачу в оффлайне, тоесть сначала считаем все запросы, а потом будем давать ответы. Для каждого x (0 ≤ x n) мы должны держать все запросы, концами которых есть x. Будем перебирать x от 0 до n - 1. Также нам нужно поддерживать массив чисел D такой, что для текущего x ответом на запрос [l;x] будет число Dl + Dl + 1 + ... + Dr. Для правильной поддержки массива, перед тем как обрабатывать запросы для текущего x, нудно обновить D. Пусть t — текущее число, тоесть Ax, а вектор P — список индексов всех вхождений числа t (до позиции x), нумерация с 0. Тогда, если |P| ≥ t, нам нужно добавить 1 до DP[|P| - t], так как эта позиция теперь переломной — после нее будет не меньше чем t вхождений числа t. Потом, если |P| > t, нужно отнять 2 от DP[|P| - t - 1], для того что-бы закрыть текущий интервал (после этой позиции количество вхождений t будет превосходить t), а также отменить предыдущий. И наконец, если |P| > t + 1, нужно еще добавить 1 к DP[|P| - t - 2] для того что-бы отменить закрытие предыдущего интервала.220C - Маленький Слоник и сдвигиEach of the shifts can be divided into two parts — the right (the one that starts from occurrence 1) and the left (the rest of the elements). If we could keep minimal distance for each part, the minimal of these numbers will be the answers for the corresponding shift. Lets solve the problems of the right part, the left will be almost the same.Let we have some shift, for example 34567[12] and the permutation A is 4312765 and B is 2145673, then shifted B is 4567321. Let we keep two sets (S1 and S2). The first will keep all the distances from integers in current left part to the corresponding positions in A (for the example above, it is [2, 4]). When you come to the next shift, all integers in S1 should be decreased by 1 (that is because all distances are also decreased by 1). But now some integers in set may be negative, when any negative integer occures (it always will be -1) you need to delete it from S1 and put 1 to the S2. Also after shifting to the next shifts, all integers in S2 must be increase by 1. After that, for any shift, the answer will be minimum from the smallest numbers in S1 and S2.It was very useful to use standart \"set\" in C++.220D - Маленький Слоник и треугольникДавайте переберем все возможные точки нашей плоскости и предположим что это первая точка тройки. Пусть это будет точка (x;y). Пусть вторая и третья точки это (x1;y1) и (x2;y2). Тогда удвоенная площадь равна |(x1 - x)(y2 - y) - (x2 - x)(y1 - y)|. Нам нужно что-бы это число было четным, а также ненулевым. Для начала найдем количество троек, которые образуют четную площадь, а потом отнимем количество точек с нулевой площадью. Первая подзадача. Так как мы знаем x и y и нам нужно проверить четность, давайте еще переберем все возможные 24 варианты четности x1, y1, x2 и y2 (пусть это d0, d1, d2 и d3, соответственно). Потом проверим будет ли такая тройка чисел формировать 0 после подстановки в формулу площади и взятии по модулю 2. Если это так, тогда нужно добавит к ответу число cxd0cyd1cxd2cyd3, где cxd равно количеству целых чисел в промежутке [0..n] таких, что они по модулю 2 равны d. Аналогично для cyd, только в промежутке [0..m].Теперь нужно отнять плохие тройки — такие, что треугольник, который они создают, имеет нулевую площадь. Это значит, что тройка точек формирует отрезок (или точку). Так как это отрезок, давайте переберем dx = |x1 - x2| и dy = |y1 - y2|, вместо перебора всех 4 координат. Количество таких отрезков на плоскости равно (n - dx + 1)(m - dy + 1). Также для подсчета количества троек, что формируют такой отрезок, нужно искать количество точек с целыми координатами на плоскости, которые лежат на этом отрезке. Это известная задача — это количество равно gcd(dx, dy) + 1.Это дает нам, с еще некоторыми оптимизациями, решение за O(nm).220E - Маленький Слоник, а также инверсииВ этой задачи нужно использовать метод двух указателей. Также нужно использовать RMQ. Если вы не знакомы со структурой данных RMQ, почитать о нем можно здесь.Для начала, уменьшим все числа, не меняя их относительное значения, тогда все числа будут в переделе от 0 до n - 1. Нужно поддерживать два RMQ, каждое размером n. Пусть первое RMQ это Q1, а второе — Q2. Q1i будет содержать количество чисел i в текущему левом подмассиве, а Q2i — в правом. Для начала нужно добавить все n чисел в левое RMQ. После этого будем идти указателем r от n - 1 до 1, при этом поддерживая l — максимальный индекс такой, что пара (l;r) содержит не более чем k инверсий (в начале l равно n - 1). Количество инверсий, очевидно, нужно поддерживать, используя RMQ (используя операцию \"сумма на отрезке\"). В такой реализации время выполнения алгоритма равно O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 221\\s*A"
          },
          "content_length": 5641
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #136 - Codeforces - Code 1",
          "code": "1)how to solve C help me please",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 2",
          "code": "2)it won't do harm for your rating. just + for me....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 3",
          "code": "1)it won't be your really rating.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 4",
          "code": "2)it will affect to others rating.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 5",
          "code": "3)do you really want to practice ComputerProgramming?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 6",
          "code": "100000 100000\n413 212 432 39 177 169 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 7",
          "code": "100000 100000\n362 328 428 153 323 415 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 8",
          "code": "362 328 428 153 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 9",
          "code": "250 302 154 91 381 407 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid simulate_f(vector<int>& a) {\n    int n = a.size();\n    function<void(int)> f = [&](int x) {\n        if (x == 1) return;\n        f(x - 1);\n        swap(a[x - 2], a[x - 1]);\n    };\n    f(n);\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n\n    // Read contestant's output\n    vector<int> a;\n    for (int i = 0; i < n; i++) {\n        int x = ouf.readInt(1, n, format(\"a[%d]\", i + 1).c_str());\n        a.push_back(x);\n    }\n\n    // Check that all numbers are distinct\n    set<int> s(a.begin(), a.end());\n    if (s.size() != n) {\n        quitf(_wa, \"The permutation contains duplicate elements\");\n    }\n\n    // Simulate the function f(n)\n    simulate_f(a);\n\n    // Check if the resulting permutation is sorted in ascending order\n    for (int i = 0; i < n; i++) {\n        if (a[i] != i + 1) {\n            quitf(_wa, \"After applying f(n), the permutation is not sorted\");\n        }\n    }\n\n    quitf(_ok, \"The permutation is valid\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 10\n./gen -n 50\n./gen -n 100\n./gen -n 256\n./gen -n 500\n./gen -n 512\n./gen -n 750\n./gen -n 997\n./gen -n 998\n./gen -n 999\n./gen -n 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:01.227966",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "221/B",
      "title": "B. Little Elephant and Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains a single integer x (1 ≤ x ≤ 109).",
      "output_spec": "OutputIn a single line print an integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy1OutputCopy1InputCopy10OutputCopy2",
      "description": "B. Little Elephant and Numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains a single integer x (1 ≤ x ≤ 109).\n\nOutputIn a single line print an integer — the answer to the problem.\n\nInputCopy1OutputCopy1InputCopy10OutputCopy2\n\nOutputCopy1\n\nInputCopy10\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #136 - Codeforces",
          "content": "Tomorrow, in 4 and half hours before the end of the summer (check your zone), Codeforces Round #136 will take place. I am the author of this round, it's my 6th contest on CF.Gerlad Agapov (Gerald) is helping me in preparing the problems. Translations will be done by Maria Belova (Delinur). Thanks to them.I hope you will like this round. The points distribution will be standart.Thanks!7 user in the first division solved all 5 problems, here they are: peter50216 yeputons winger rng_58 RAD al13n KADR Meanwhile, in second division, Top-4 looks like this: blue.boy de_troit lxyxynt ilona You can find the editorial of the contest here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5167",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 636
        },
        {
          "title": "Codeforces Round #136 — Editorial - Codeforces",
          "content": "221A - Little Elephant and FunctionIn this problems you should notice that the answer for the problem is always of the following form: n, 1, 2, 3, ..., n-1. In such case array will be always sorted after the end of the algorithm.221B - Little Elephant and NumbersHere you just need to find all divisors of n. This can be done using standart algorithm with iterating from 1 to sqrt(n). After that you need to write some function that checks whether two numbers has same digits. This also can be done using simple loops.220A - Little Elephant and ProblemThere are multiple possible solutions for this problem. For example, the following. Find the last index x such that there exists some y (y < x) (minimal possible) that Ax < Ay. Then you just need to try two possibilities — either swap Ax and Ay, or don't change anything.220B - Little Elephant and ArrayThis problem can be solve in simpler O(NsqrtN) solution, but I will describe O(NlogN) one.We will solve this problem in offline. For each x (0 ≤ x < n) we should keep all the queries that end in x. Iterate that x from 0 to n - 1. Also we need to keep some array D such that for current x Dl + Dl + 1 + ... + Dx will be the answer for query [l;x]. To keep D correct, before the processing all queries that end in x, we need to update D. Let t be the current integer in A, i. e. Ax, and vector P be the list of indices of previous occurences of t (0-based numeration of vector). Then, if |P| ≥ t, you need to add 1 to DP[|P| - t], because this position is now the first (from right) that contains exactly t occurences of t. After that, if |P| > t, you need to subtract 2 from DP[|P| - t - 1], in order to close current interval and cancel previous. Finally, if |P| > t + 1, then you need additionally add 1 to DP[|P| - t - 2] to cancel previous close of the interval.220C - Little Elephant and ShiftsEach of the shifts can be divided into two parts — the right (the one that starts from occurrence 1) and the left (the rest of the elements). If we could keep minimal distance for each part, the minimal of these numbers will be the answers for the corresponding shift. Lets solve the problems of the right part, the left will be almost the same.Let we have some shift, for example 34567[12] and the permutation A is 4312765 and B is 2145673, then shifted B is 4567321. Let we keep two sets (S1 and S2). The first will keep all the distances from integers in current left part to the corresponding positions in A (for the example above, it is \\texttt{2, 4}). When you come to the next shift, all integers in S1 should be decreased by 1 (that is because all distances are also decreased by 1). But now some integers in set may be negative, when any negative integer occures (it always will be -1) you need to delete it from S1 and put 1 to the S2. Also after shifting to the next shifts, all integers in S2 must be increase by 1. After that, for any shift, the answer will be minimum from the smallest numbers in S1 and S2.It was very useful to use standart \"set\" in C++.220D - Little Elephant and TriangleLet iterate all possible points that, as we consider, must be the first point. Let it be (x;y). Let the second and the third points be (x1;y1) and (x2;y2). Then the doubled area is |(x1 - x)(y2 - y) - (x2 - x)(y1 - y)|. We need this number to be even and nonzero. For first we will find the number of groups of points that are even, after that just subtract the number of groups with area equal to zero.For the first subproblem, we need to rewrite our formula. It is equal to |x(y1 - y2) + y(x2 - x1)|. Since we know x and y and we just need to check parity, we can try all possible 24 values of parity of x1, y1, x2 and y2 (let it be d0, d1, d2 and d3, respectively). And check whether they will form a 0 after multiplications and taking modulo 2. If it froms a 0, then add to the answer value cxd0cyd1cxd2cyd3, where cxd is equal to the number of integers between 0 and n, inclusve, that modulo 2 are equal d. cyd is the same but in range [0..m].Now we need to subtract bad groups — the ones that has the area equal to zero. This means that they will either form a dot or a segment. If it is segment, we can just iterate dx = |x1 - x2| and dy = |y1 - y2| instead of all 4 coordinates. Then the number of such segments on the plane will be (n - dx + 1)(m - dy + 1). Also for counting the number of triples of points on the segment you need to find the number of integer coordinates on the segment. It is well-know problem, and the answer is gcd(dx, dy) + 1.This gives us, with some simple optimizations, and O(nm) solution.220E - Little Elephant and InversionsIn this problems you can use a method of two pointers. Also some RMQ are required. If you do not know about RMQ, please, read about it in the Internet before solving this problem.Firstly, map all the elements in the input array. After that all of them will be in range [0..n - 1]. We need to keep two RMQs, both of size n. Let the first RMQ be Q1 and the second Q2. Q1i will contain the number of numbers i in current left subarray. Q2i will contain the number of numbers i in the left subarray. Firstly, add all n number to the Q2. After that iterate some pointer r from n - 1 downto 1, by the way keeping point l (which, at the beggining, is equal to n - 1) Using RMQs, you can keep the number of inversions when you decrease r or l (using \"sum on the range\" operation). While the current number of inversions is more then k and l ≥ 0, decrease l. Then for each r the answer of correct l will be l + 1 (considering 0-based numeration).This makes the algorithm working in O(NlogN) time with correct realisation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 221\\s*B"
          },
          "content_length": 5630
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long max_x = opt<long long>(\"max_x\", 1000000000LL);\n    max_x = min(max_x, 1000000000LL);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x;\n\n    if (type == \"min\") {\n        x = 1LL;\n    } else if (type == \"max\") {\n        x = max_x;\n    } else if (type == \"random\") {\n        x = rnd.next(1LL, max_x);\n    } else if (type == \"small\") {\n        x = rnd.next(1LL, min(10LL, max_x));\n    } else if (type == \"power10\") {\n        vector<long long> powers;\n        long long val = 1;\n        while (val <= max_x) {\n            powers.push_back(val);\n            if (val > max_x / 10)\n                break;\n            val *= 10;\n        }\n        x = powers[rnd.next(0, (int)powers.size() - 1)];\n    } else if (type == \"unique_digits\") {\n        vector<char> digits = {'1','2','3','4','5','6','7','8','9'};\n        shuffle(digits.begin(), digits.end());\n        string s(digits.begin(), digits.end());\n        while (stoll(s) > max_x && !s.empty()) {\n            s.pop_back();\n        }\n        if (s.empty()) s = \"1\";\n        x = stoll(s);\n    } else if (type == \"same_digit\") {\n        char digit = '1' + rnd.next(0, 8); // Digit from '1' to '9'\n        int max_len = to_string(max_x).size();\n        int len = rnd.next(1, max_len);\n        string s(len, digit);\n        while (stoll(s) > max_x && len > 1) {\n            len--;\n            s = string(len, digit);\n        }\n        x = stoll(s);\n    } else if (type == \"palindrome\") {\n        int max_len = to_string(max_x).size();\n        int len = rnd.next(1, max_len);\n        string s;\n        while (true) {\n            string half;\n            int half_len = len / 2;\n            for (int i = 0; i < half_len; ++i) {\n                char digit = '1' + rnd.next(0, 8);\n                half.push_back(digit);\n            }\n            string mid = \"\";\n            if (len % 2 == 1) {\n                mid += ('1' + rnd.next(0, 8));\n            }\n            s = half + mid + string(half.rbegin(), half.rend());\n            if (stoll(s) <= max_x) break;\n            if (len > 1) len--;\n            else {\n                s = \"1\";\n                break;\n            }\n        }\n        x = stoll(s);\n    } else if (type == \"composite\") {\n        vector<long long> hcn = {1, 2, 4, 6, 12, 24, 36, 48,60, 120, 180, 240, 360, 720, 840,1260,1680, 2520, 5040, 7560, 10080, 15120, 20160, 25200, 27720, 45360, 50400, 55440,83160, 110880, 166320, 221760,277200,332640,498960,554400,665280};\n        vector<long long> available_hcn;\n        for (long long val : hcn) {\n            if (val <= max_x) {\n                available_hcn.push_back(val);\n            }\n        }\n        if (available_hcn.empty()) {\n            x = 1LL;\n        } else {\n            x = available_hcn[rnd.next(0, (int)available_hcn.size() - 1)];\n        }\n    } else if (type == \"prime\") {\n        vector<long long> primes = {\n            2LL, 3LL, 5LL, 7LL, 11LL, 13LL,17LL,19LL,23LL,29LL,\n            31LL,37LL,41LL,43LL,47LL,53LL,59LL,61LL,67LL,71LL,73LL,79LL,83LL,89LL,97LL,\n            999999937LL, 999999929LL,999999893LL,999999883LL, 999999863LL,999999797LL,\n            1000000007LL, 1000000009LL\n        };\n        vector<long long> available_primes;\n        for (long long val : primes) {\n            if (val <= max_x)\n                available_primes.push_back(val);\n        }\n        if (available_primes.empty()) {\n            x = 2LL;\n        } else {\n            x = available_primes[rnd.next(0, (int)available_primes.size() - 1)];\n        }\n    } else if (type == \"square\") {\n        long long max_k = sqrt((double)max_x);\n        long long k = rnd.next(1LL, max_k);\n        x = k * k;\n    } else {\n        // Default to random\n        x = rnd.next(1LL, max_x);\n    }\n\n    printf(\"%lld\\n\", x);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long max_x = opt<long long>(\"max_x\", 1000000000LL);\n    max_x = min(max_x, 1000000000LL);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x;\n\n    if (type == \"min\") {\n        x = 1LL;\n    } else if (type == \"max\") {\n        x = max_x;\n    } else if (type == \"random\") {\n        x = rnd.next(1LL, max_x);\n    } else if (type == \"small\") {\n        x = rnd.next(1LL, min(10LL, max_x));\n    } else if (type == \"power10\") {\n        vector<long long> powers;\n        long long val = 1;\n        while (val <= max_x) {\n            powers.push_back(val);\n            if (val > max_x / 10)\n                break;\n            val *= 10;\n        }\n        x = powers[rnd.next(0, (int)powers.size() - 1)];\n    } else if (type == \"unique_digits\") {\n        vector<char> digits = {'1','2','3','4','5','6','7','8','9'};\n        shuffle(digits.begin(), digits.end());\n        string s(digits.begin(), digits.end());\n        while (stoll(s) > max_x && !s.empty()) {\n            s.pop_back();\n        }\n        if (s.empty()) s = \"1\";\n        x = stoll(s);\n    } else if (type == \"same_digit\") {\n        char digit = '1' + rnd.next(0, 8); // Digit from '1' to '9'\n        int max_len = to_string(max_x).size();\n        int len = rnd.next(1, max_len);\n        string s(len, digit);\n        while (stoll(s) > max_x && len > 1) {\n            len--;\n            s = string(len, digit);\n        }\n        x = stoll(s);\n    } else if (type == \"palindrome\") {\n        int max_len = to_string(max_x).size();\n        int len = rnd.next(1, max_len);\n        string s;\n        while (true) {\n            string half;\n            int half_len = len / 2;\n            for (int i = 0; i < half_len; ++i) {\n                char digit = '1' + rnd.next(0, 8);\n                half.push_back(digit);\n            }\n            string mid = \"\";\n            if (len % 2 == 1) {\n                mid += ('1' + rnd.next(0, 8));\n            }\n            s = half + mid + string(half.rbegin(), half.rend());\n            if (stoll(s) <= max_x) break;\n            if (len > 1) len--;\n            else {\n                s = \"1\";\n                break;\n            }\n        }\n        x = stoll(s);\n    } else if (type == \"composite\") {\n        vector<long long> hcn = {1, 2, 4, 6, 12, 24, 36, 48,60, 120, 180, 240, 360, 720, 840,1260,1680, 2520, 5040, 7560, 10080, 15120, 20160, 25200, 27720, 45360, 50400, 55440,83160, 110880, 166320, 221760,277200,332640,498960,554400,665280};\n        vector<long long> available_hcn;\n        for (long long val : hcn) {\n            if (val <= max_x) {\n                available_hcn.push_back(val);\n            }\n        }\n        if (available_hcn.empty()) {\n            x = 1LL;\n        } else {\n            x = available_hcn[rnd.next(0, (int)available_hcn.size() - 1)];\n        }\n    } else if (type == \"prime\") {\n        vector<long long> primes = {\n            2LL, 3LL, 5LL, 7LL, 11LL, 13LL,17LL,19LL,23LL,29LL,\n            31LL,37LL,41LL,43LL,47LL,53LL,59LL,61LL,67LL,71LL,73LL,79LL,83LL,89LL,97LL,\n            999999937LL, 999999929LL,999999893LL,999999883LL, 999999863LL,999999797LL,\n            1000000007LL, 1000000009LL\n        };\n        vector<long long> available_primes;\n        for (long long val : primes) {\n            if (val <= max_x)\n                available_primes.push_back(val);\n        }\n        if (available_primes.empty()) {\n            x = 2LL;\n        } else {\n            x = available_primes[rnd.next(0, (int)available_primes.size() - 1)];\n        }\n    } else if (type == \"square\") {\n        long long max_k = sqrt((double)max_x);\n        long long k = rnd.next(1LL, max_k);\n        x = k * k;\n    } else {\n        // Default to random\n        x = rnd.next(1LL, max_x);\n    }\n\n    printf(\"%lld\\n\", x);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type small\n./gen -type random -max_x 10\n./gen -type random -max_x 100\n./gen -type random -max_x 1000\n./gen -type random -max_x 1000000\n./gen -type random -max_x 1000000000\n./gen -type power10\n./gen -type power10 -max_x 1000000000\n./gen -type unique_digits\n./gen -type same_digit\n./gen -type palindrome\n./gen -type composite\n./gen -type prime\n./gen -type square\n./gen -type random -max_x 1\n./gen -type random -max_x 2\n./gen -type random -max_x 3\n./gen -type random -max_x 9973\n./gen -type random -max_x 1000000\n./gen -type composite -max_x 5040\n./gen -type composite -max_x 2520\n./gen -type prime -max_x 97\n./gen -type prime -max_x 1000000000\n./gen -type square -max_x 1000000\n./gen -type unique_digits -max_x 123456789\n./gen -type same_digit -max_x 444444444\n./gen -type palindrome -max_x 1000000\n./gen -type min -max_x 100\n./gen -type max -max_x 1000\n./gen -type palindrome -max_x 10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:03.183511",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "221/C",
      "title": "C. Little Elephant and Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.Note that the elements of the array are not necessarily distinct numbers.",
      "output_spec": "OutputIn a single line print \"YES\" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and \"NO\" (without the quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy21 2OutputCopyYESInputCopy33 2 1OutputCopyYESInputCopy44 3 2 1OutputCopyNO",
      "description": "C. Little Elephant and Problem\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 105) — the size of array a. The next line contains n positive integers, separated by single spaces and not exceeding 109, — array a.Note that the elements of the array are not necessarily distinct numbers.\n\nOutputIn a single line print \"YES\" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and \"NO\" (without the quotes) otherwise.\n\nInputCopy21 2OutputCopyYESInputCopy33 2 1OutputCopyYESInputCopy44 3 2 1OutputCopyNO\n\nInputCopy21 2\n\nOutputCopyYES\n\nInputCopy33 2 1\n\nOutputCopyYES\n\nInputCopy44 3 2 1\n\nOutputCopyNO\n\nNoteIn the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is \"YES\".In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is \"YES\".In the third sample we can't sort the array in more than one swap operation, so the answer is \"NO\".",
      "solutions": [
        {
          "title": "Codeforces Round #136 - Codeforces",
          "content": "Tomorrow, in 4 and half hours before the end of the summer (check your zone), Codeforces Round #136 will take place. I am the author of this round, it's my 6th contest on CF.Gerlad Agapov (Gerald) is helping me in preparing the problems. Translations will be done by Maria Belova (Delinur). Thanks to them.I hope you will like this round. The points distribution will be standart.Thanks!7 user in the first division solved all 5 problems, here they are: peter50216 yeputons winger rng_58 RAD al13n KADR Meanwhile, in second division, Top-4 looks like this: blue.boy de_troit lxyxynt ilona You can find the editorial of the contest here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5167",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 636
        },
        {
          "title": "Codeforces Round #136 — Editorial - Codeforces",
          "content": "221A - Little Elephant and FunctionIn this problems you should notice that the answer for the problem is always of the following form: n, 1, 2, 3, ..., n-1. In such case array will be always sorted after the end of the algorithm.221B - Little Elephant and NumbersHere you just need to find all divisors of n. This can be done using standart algorithm with iterating from 1 to sqrt(n). After that you need to write some function that checks whether two numbers has same digits. This also can be done using simple loops.220A - Little Elephant and ProblemThere are multiple possible solutions for this problem. For example, the following. Find the last index x such that there exists some y (y < x) (minimal possible) that Ax < Ay. Then you just need to try two possibilities — either swap Ax and Ay, or don't change anything.220B - Little Elephant and ArrayThis problem can be solve in simpler O(NsqrtN) solution, but I will describe O(NlogN) one.We will solve this problem in offline. For each x (0 ≤ x < n) we should keep all the queries that end in x. Iterate that x from 0 to n - 1. Also we need to keep some array D such that for current x Dl + Dl + 1 + ... + Dx will be the answer for query [l;x]. To keep D correct, before the processing all queries that end in x, we need to update D. Let t be the current integer in A, i. e. Ax, and vector P be the list of indices of previous occurences of t (0-based numeration of vector). Then, if |P| ≥ t, you need to add 1 to DP[|P| - t], because this position is now the first (from right) that contains exactly t occurences of t. After that, if |P| > t, you need to subtract 2 from DP[|P| - t - 1], in order to close current interval and cancel previous. Finally, if |P| > t + 1, then you need additionally add 1 to DP[|P| - t - 2] to cancel previous close of the interval.220C - Little Elephant and ShiftsEach of the shifts can be divided into two parts — the right (the one that starts from occurrence 1) and the left (the rest of the elements). If we could keep minimal distance for each part, the minimal of these numbers will be the answers for the corresponding shift. Lets solve the problems of the right part, the left will be almost the same.Let we have some shift, for example 34567[12] and the permutation A is 4312765 and B is 2145673, then shifted B is 4567321. Let we keep two sets (S1 and S2). The first will keep all the distances from integers in current left part to the corresponding positions in A (for the example above, it is \\texttt{2, 4}). When you come to the next shift, all integers in S1 should be decreased by 1 (that is because all distances are also decreased by 1). But now some integers in set may be negative, when any negative integer occures (it always will be -1) you need to delete it from S1 and put 1 to the S2. Also after shifting to the next shifts, all integers in S2 must be increase by 1. After that, for any shift, the answer will be minimum from the smallest numbers in S1 and S2.It was very useful to use standart \"set\" in C++.220D - Little Elephant and TriangleLet iterate all possible points that, as we consider, must be the first point. Let it be (x;y). Let the second and the third points be (x1;y1) and (x2;y2). Then the doubled area is |(x1 - x)(y2 - y) - (x2 - x)(y1 - y)|. We need this number to be even and nonzero. For first we will find the number of groups of points that are even, after that just subtract the number of groups with area equal to zero.For the first subproblem, we need to rewrite our formula. It is equal to |x(y1 - y2) + y(x2 - x1)|. Since we know x and y and we just need to check parity, we can try all possible 24 values of parity of x1, y1, x2 and y2 (let it be d0, d1, d2 and d3, respectively). And check whether they will form a 0 after multiplications and taking modulo 2. If it froms a 0, then add to the answer value cxd0cyd1cxd2cyd3, where cxd is equal to the number of integers between 0 and n, inclusve, that modulo 2 are equal d. cyd is the same but in range [0..m].Now we need to subtract bad groups — the ones that has the area equal to zero. This means that they will either form a dot or a segment. If it is segment, we can just iterate dx = |x1 - x2| and dy = |y1 - y2| instead of all 4 coordinates. Then the number of such segments on the plane will be (n - dx + 1)(m - dy + 1). Also for counting the number of triples of points on the segment you need to find the number of integer coordinates on the segment. It is well-know problem, and the answer is gcd(dx, dy) + 1.This gives us, with some simple optimizations, and O(nm) solution.220E - Little Elephant and InversionsIn this problems you can use a method of two pointers. Also some RMQ are required. If you do not know about RMQ, please, read about it in the Internet before solving this problem.Firstly, map all the elements in the input array. After that all of them will be in range [0..n - 1]. We need to keep two RMQs, both of size n. Let the first RMQ be Q1 and the second Q2. Q1i will contain the number of numbers i in current left subarray. Q2i will contain the number of numbers i in the left subarray. Firstly, add all n number to the Q2. After that iterate some pointer r from n - 1 downto 1, by the way keeping point l (which, at the beggining, is equal to n - 1) Using RMQs, you can keep the number of inversions when you decrease r or l (using \"sum on the range\" operation). While the current number of inversions is more then k and l ≥ 0, decrease l. Then for each r the answer of correct l will be l + 1 (considering 0-based numeration).This makes the algorithm working in O(NlogN) time with correct realisation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 221 和字母"
          },
          "content_length": 5630
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_VAL = (int)1e9;\n\n    vector<int> a(n);\n\n    if (type == \"sorted\") {\n        /* Generate a sorted array */\n        int current = rnd.next(1, MAX_VAL - 10 * n);\n        for(int i = 0; i < n; ++i){\n            a[i] = current;\n            current += rnd.next(0, 10);  // Increase by 0 to 10\n            if (current > MAX_VAL) current = MAX_VAL; // Clamp to MAX_VAL\n        }\n\n    } else if (type == \"one_swap\") {\n        /* Generate a sorted array and swap two elements */\n        int current = rnd.next(1, MAX_VAL - 10 * n);\n        for(int i = 0; i < n; ++i){\n            a[i] = current;\n            current += rnd.next(0, 10);  // Increase by 0 to 10\n        }\n        // Swap two random positions\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, n - 1);\n        while(i == j) j = rnd.next(0, n - 1); // Ensure i != j\n        swap(a[i], a[j]);\n\n    } else if (type == \"reverse\") {\n        /* Generate a reverse sorted array */\n        int current = rnd.next(MAX_VAL - 10 * n, MAX_VAL);\n        for(int i = 0; i < n; ++i){\n            a[i] = current;\n            current -= rnd.next(0, 10);  // Decrease by 0 to 10\n            if (current < 1) current = 1; // Clamp to 1\n        }\n\n    } else if (type == \"random\") {\n        /* Generate a random array */\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(1, MAX_VAL);\n        }\n\n    } else if (type == \"duplicates\") {\n        /* Generate a sorted array with duplicates */\n        int current = rnd.next(1, MAX_VAL / 2);\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)){\n                current += rnd.next(0, 10);  // Increase\n            }\n            a[i] = current;\n        }\n\n    } else if (type == \"all_equal\") {\n        /* Generate an array where all elements are the same */\n        int val = rnd.next(1, MAX_VAL);\n        for(int i = 0; i < n; ++i){\n            a[i] = val;\n        }\n\n    } else if (type == \"cannot_sort_in_one_swap\") {\n        /* Generate an array that cannot be sorted with one swap */\n        int current = rnd.next(1, MAX_VAL - 10 * n);\n        for(int i = 0; i < n; ++i){\n            a[i] = current;\n            current += rnd.next(0, 10);  // Increase by 0 to 10\n        }\n        // Introduce multiple inversions\n        int swaps = 3;\n        set<int> indices;\n        while (indices.size() < swaps * 2){\n            indices.insert(rnd.next(0, n - 1));\n        }\n        vector<int> idx(indices.begin(), indices.end());\n        for (int k = 0; k < swaps; ++k){\n            swap(a[idx[2 * k]], a[idx[2 * k + 1]]);\n        }\n\n    } else if (type == \"max_values\") {\n        /* Generate an array with maximum possible values */\n        for(int i = 0; i < n; ++i){\n            a[i] = MAX_VAL;\n        }\n\n    } else if (type == \"min_values\") {\n        /* Generate an array with minimum possible values */\n        for(int i = 0; i < n; ++i){\n            a[i] = 1;\n        }\n\n    } else {\n        /* Default to random */\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(1, MAX_VAL);\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output array */\n    for (int i = 0; i < n; ++i){\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_VAL = (int)1e9;\n\n    vector<int> a(n);\n\n    if (type == \"sorted\") {\n        /* Generate a sorted array */\n        int current = rnd.next(1, MAX_VAL - 10 * n);\n        for(int i = 0; i < n; ++i){\n            a[i] = current;\n            current += rnd.next(0, 10);  // Increase by 0 to 10\n            if (current > MAX_VAL) current = MAX_VAL; // Clamp to MAX_VAL\n        }\n\n    } else if (type == \"one_swap\") {\n        /* Generate a sorted array and swap two elements */\n        int current = rnd.next(1, MAX_VAL - 10 * n);\n        for(int i = 0; i < n; ++i){\n            a[i] = current;\n            current += rnd.next(0, 10);  // Increase by 0 to 10\n        }\n        // Swap two random positions\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, n - 1);\n        while(i == j) j = rnd.next(0, n - 1); // Ensure i != j\n        swap(a[i], a[j]);\n\n    } else if (type == \"reverse\") {\n        /* Generate a reverse sorted array */\n        int current = rnd.next(MAX_VAL - 10 * n, MAX_VAL);\n        for(int i = 0; i < n; ++i){\n            a[i] = current;\n            current -= rnd.next(0, 10);  // Decrease by 0 to 10\n            if (current < 1) current = 1; // Clamp to 1\n        }\n\n    } else if (type == \"random\") {\n        /* Generate a random array */\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(1, MAX_VAL);\n        }\n\n    } else if (type == \"duplicates\") {\n        /* Generate a sorted array with duplicates */\n        int current = rnd.next(1, MAX_VAL / 2);\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)){\n                current += rnd.next(0, 10);  // Increase\n            }\n            a[i] = current;\n        }\n\n    } else if (type == \"all_equal\") {\n        /* Generate an array where all elements are the same */\n        int val = rnd.next(1, MAX_VAL);\n        for(int i = 0; i < n; ++i){\n            a[i] = val;\n        }\n\n    } else if (type == \"cannot_sort_in_one_swap\") {\n        /* Generate an array that cannot be sorted with one swap */\n        int current = rnd.next(1, MAX_VAL - 10 * n);\n        for(int i = 0; i < n; ++i){\n            a[i] = current;\n            current += rnd.next(0, 10);  // Increase by 0 to 10\n        }\n        // Introduce multiple inversions\n        int swaps = 3;\n        set<int> indices;\n        while (indices.size() < swaps * 2){\n            indices.insert(rnd.next(0, n - 1));\n        }\n        vector<int> idx(indices.begin(), indices.end());\n        for (int k = 0; k < swaps; ++k){\n            swap(a[idx[2 * k]], a[idx[2 * k + 1]]);\n        }\n\n    } else if (type == \"max_values\") {\n        /* Generate an array with maximum possible values */\n        for(int i = 0; i < n; ++i){\n            a[i] = MAX_VAL;\n        }\n\n    } else if (type == \"min_values\") {\n        /* Generate an array with minimum possible values */\n        for(int i = 0; i < n; ++i){\n            a[i] = 1;\n        }\n\n    } else {\n        /* Default to random */\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(1, MAX_VAL);\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output array */\n    for (int i = 0; i < n; ++i){\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type sorted\n./gen -n 2 -type one_swap\n./gen -n 2 -type reverse\n./gen -n 2 -type random\n./gen -n 2 -type duplicates\n\n./gen -n 5 -type sorted\n./gen -n 5 -type one_swap\n./gen -n 5 -type reverse\n./gen -n 5 -type duplicates\n./gen -n 5 -type all_equal\n\n./gen -n 10 -type sorted\n./gen -n 10 -type one_swap\n./gen -n 10 -type reverse\n./gen -n 10 -type cannot_sort_in_one_swap\n./gen -n 10 -type duplicates\n./gen -n 10 -type random\n\n./gen -n 1000 -type all_equal\n./gen -n 1000 -type duplicates\n./gen -n 1000 -type sorted\n./gen -n 1000 -type cannot_sort_in_one_swap\n./gen -n 1000 -type random\n\n./gen -n 99999 -type sorted\n./gen -n 99999 -type one_swap\n./gen -n 100000 -type reverse\n./gen -n 100000 -type cannot_sort_in_one_swap\n\n./gen -n 100000 -type max_values\n./gen -n 100000 -type min_values\n./gen -n 100000 -type all_equal\n./gen -n 100000 -type duplicates\n./gen -n 100000 -type random\n\n./gen -n 1000 -type max_values\n./gen -n 1000 -type min_values\n\n./gen -n 99999 -type cannot_sort_in_one_swap\n./gen -n 100000 -type one_swap\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:05.319086",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "221/D",
      "title": "D. Little Elephant and Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 105) — the size of array a and the number of queries to it. The next line contains n space-separated positive integers a1, a2, ..., an (1 ≤ ai ≤ 109). Next m lines contain descriptions of queries, one per line. The j-th of these lines contains the description of the j-th query as two space-separated integers lj and rj (1 ≤ lj ≤ rj ≤ n).",
      "output_spec": "OutputIn m lines print m integers — the answers to the queries. The j-th line should contain the answer to the j-th query.",
      "sample_tests": "ExamplesInputCopy7 23 1 2 2 3 3 71 73 4OutputCopy31",
      "description": "D. Little Elephant and Array\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 105) — the size of array a and the number of queries to it. The next line contains n space-separated positive integers a1, a2, ..., an (1 ≤ ai ≤ 109). Next m lines contain descriptions of queries, one per line. The j-th of these lines contains the description of the j-th query as two space-separated integers lj and rj (1 ≤ lj ≤ rj ≤ n).\n\nOutputIn m lines print m integers — the answers to the queries. The j-th line should contain the answer to the j-th query.\n\nInputCopy7 23 1 2 2 3 3 71 73 4OutputCopy31\n\nInputCopy7 23 1 2 2 3 3 71 73 4\n\nOutputCopy31",
      "solutions": [
        {
          "title": "Codeforces Round #136 - Codeforces",
          "content": "Tomorrow, in 4 and half hours before the end of the summer (check your zone), Codeforces Round #136 will take place. I am the author of this round, it's my 6th contest on CF.Gerlad Agapov (Gerald) is helping me in preparing the problems. Translations will be done by Maria Belova (Delinur). Thanks to them.I hope you will like this round. The points distribution will be standart.Thanks!7 user in the first division solved all 5 problems, here they are: peter50216 yeputons winger rng_58 RAD al13n KADR Meanwhile, in second division, Top-4 looks like this: blue.boy de_troit lxyxynt ilona You can find the editorial of the contest here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5167",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 636
        },
        {
          "title": "Codeforces Round #136 — Editorial - Codeforces",
          "content": "221A - Little Elephant and FunctionIn this problems you should notice that the answer for the problem is always of the following form: n, 1, 2, 3, ..., n-1. In such case array will be always sorted after the end of the algorithm.221B - Little Elephant and NumbersHere you just need to find all divisors of n. This can be done using standart algorithm with iterating from 1 to sqrt(n). After that you need to write some function that checks whether two numbers has same digits. This also can be done using simple loops.220A - Little Elephant and ProblemThere are multiple possible solutions for this problem. For example, the following. Find the last index x such that there exists some y (y < x) (minimal possible) that Ax < Ay. Then you just need to try two possibilities — either swap Ax and Ay, or don't change anything.220B - Little Elephant and ArrayThis problem can be solve in simpler O(NsqrtN) solution, but I will describe O(NlogN) one.We will solve this problem in offline. For each x (0 ≤ x < n) we should keep all the queries that end in x. Iterate that x from 0 to n - 1. Also we need to keep some array D such that for current x Dl + Dl + 1 + ... + Dx will be the answer for query [l;x]. To keep D correct, before the processing all queries that end in x, we need to update D. Let t be the current integer in A, i. e. Ax, and vector P be the list of indices of previous occurences of t (0-based numeration of vector). Then, if |P| ≥ t, you need to add 1 to DP[|P| - t], because this position is now the first (from right) that contains exactly t occurences of t. After that, if |P| > t, you need to subtract 2 from DP[|P| - t - 1], in order to close current interval and cancel previous. Finally, if |P| > t + 1, then you need additionally add 1 to DP[|P| - t - 2] to cancel previous close of the interval.220C - Little Elephant and ShiftsEach of the shifts can be divided into two parts — the right (the one that starts from occurrence 1) and the left (the rest of the elements). If we could keep minimal distance for each part, the minimal of these numbers will be the answers for the corresponding shift. Lets solve the problems of the right part, the left will be almost the same.Let we have some shift, for example 34567[12] and the permutation A is 4312765 and B is 2145673, then shifted B is 4567321. Let we keep two sets (S1 and S2). The first will keep all the distances from integers in current left part to the corresponding positions in A (for the example above, it is \\texttt{2, 4}). When you come to the next shift, all integers in S1 should be decreased by 1 (that is because all distances are also decreased by 1). But now some integers in set may be negative, when any negative integer occures (it always will be -1) you need to delete it from S1 and put 1 to the S2. Also after shifting to the next shifts, all integers in S2 must be increase by 1. After that, for any shift, the answer will be minimum from the smallest numbers in S1 and S2.It was very useful to use standart \"set\" in C++.220D - Little Elephant and TriangleLet iterate all possible points that, as we consider, must be the first point. Let it be (x;y). Let the second and the third points be (x1;y1) and (x2;y2). Then the doubled area is |(x1 - x)(y2 - y) - (x2 - x)(y1 - y)|. We need this number to be even and nonzero. For first we will find the number of groups of points that are even, after that just subtract the number of groups with area equal to zero.For the first subproblem, we need to rewrite our formula. It is equal to |x(y1 - y2) + y(x2 - x1)|. Since we know x and y and we just need to check parity, we can try all possible 24 values of parity of x1, y1, x2 and y2 (let it be d0, d1, d2 and d3, respectively). And check whether they will form a 0 after multiplications and taking modulo 2. If it froms a 0, then add to the answer value cxd0cyd1cxd2cyd3, where cxd is equal to the number of integers between 0 and n, inclusve, that modulo 2 are equal d. cyd is the same but in range [0..m].Now we need to subtract bad groups — the ones that has the area equal to zero. This means that they will either form a dot or a segment. If it is segment, we can just iterate dx = |x1 - x2| and dy = |y1 - y2| instead of all 4 coordinates. Then the number of such segments on the plane will be (n - dx + 1)(m - dy + 1). Also for counting the number of triples of points on the segment you need to find the number of integer coordinates on the segment. It is well-know problem, and the answer is gcd(dx, dy) + 1.This gives us, with some simple optimizations, and O(nm) solution.220E - Little Elephant and InversionsIn this problems you can use a method of two pointers. Also some RMQ are required. If you do not know about RMQ, please, read about it in the Internet before solving this problem.Firstly, map all the elements in the input array. After that all of them will be in range [0..n - 1]. We need to keep two RMQs, both of size n. Let the first RMQ be Q1 and the second Q2. Q1i will contain the number of numbers i in current left subarray. Q2i will contain the number of numbers i in the left subarray. Firstly, add all n number to the Q2. After that iterate some pointer r from n - 1 downto 1, by the way keeping point l (which, at the beggining, is equal to n - 1) Using RMQs, you can keep the number of inversions when you decrease r or l (using \"sum on the range\" operation). While the current number of inversions is more then k and l ≥ 0, decrease l. Then for each r the answer of correct l will be l + 1 (considering 0-based numeration).This makes the algorithm working in O(NlogN) time with correct realisation.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 221 和字母"
          },
          "content_length": 5630
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\"); // 1 ≤ n ≤ 1e5\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\"); // 1 ≤ m ≤ 1e5\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\"); // 1 ≤ a_i ≤ 1e9\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n);\n        inf.readSpace();\n        int r = inf.readInt(l, n);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\"); // 1 ≤ n ≤ 1e5\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\"); // 1 ≤ m ≤ 1e5\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\"); // 1 ≤ a_i ≤ 1e9\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n);\n        inf.readSpace();\n        int r = inf.readInt(l, n);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\"); // 1 ≤ n ≤ 1e5\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\"); // 1 ≤ m ≤ 1e5\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\"); // 1 ≤ a_i ≤ 1e9\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n);\n        inf.readSpace();\n        int r = inf.readInt(l, n);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random numbers between 1 and 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    } else if (type == \"same\") {\n        // All numbers are the same\n        int val = rnd.next(1, (int)1e9);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increase\") {\n        // Numbers increase from 1 to n\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"decrease\") {\n        // Numbers decrease from n to 1\n        for(int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"max_ai\") {\n        // All numbers are 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = 1e9;\n    } else if (type == \"min_ai\") {\n        // All numbers are 1\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"special\") {\n        // Arrange numbers such that number x occurs exactly x times\n        int k = 1;\n        while(k*(k+1)/2 <= n)\n            ++k;\n        --k;\n\n        int idx = 0;\n        for(int x = 1; x <= k; ++x) {\n            for(int i = 0; i < x; ++i) {\n                if(idx < n)\n                    a[idx++] = x;\n            }\n        }\n\n        while(idx < n) {\n            a[idx++] = rnd.next(1, (int)1e9);\n        }\n\n        shuffle(a.begin(), a.end());\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if(i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    vector<pair<int, int>> queries(m);\n\n    if (qtype == \"full\") {\n        for(int i = 0; i < m; ++i)\n            queries[i] = make_pair(1, n);\n    } else if (qtype == \"single\") {\n        for(int i = 0; i < m; ++i) {\n            int pos = rnd.next(1, n);\n            queries[i] = make_pair(pos, pos);\n        }\n    } else if (qtype == \"prefix\") {\n        for(int i = 0; i < m; ++i) {\n            int r = rnd.next(1, n);\n            queries[i] = make_pair(1, r);\n        }\n    } else {\n        for(int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    }\n\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random numbers between 1 and 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    } else if (type == \"same\") {\n        // All numbers are the same\n        int val = rnd.next(1, (int)1e9);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increase\") {\n        // Numbers increase from 1 to n\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"decrease\") {\n        // Numbers decrease from n to 1\n        for(int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"max_ai\") {\n        // All numbers are 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = 1e9;\n    } else if (type == \"min_ai\") {\n        // All numbers are 1\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"special\") {\n        // Arrange numbers such that number x occurs exactly x times\n        int k = 1;\n        while(k*(k+1)/2 <= n)\n            ++k;\n        --k;\n\n        int idx = 0;\n        for(int x = 1; x <= k; ++x) {\n            for(int i = 0; i < x; ++i) {\n                if(idx < n)\n                    a[idx++] = x;\n            }\n        }\n\n        while(idx < n) {\n            a[idx++] = rnd.next(1, (int)1e9);\n        }\n\n        shuffle(a.begin(), a.end());\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if(i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    vector<pair<int, int>> queries(m);\n\n    if (qtype == \"full\") {\n        for(int i = 0; i < m; ++i)\n            queries[i] = make_pair(1, n);\n    } else if (qtype == \"single\") {\n        for(int i = 0; i < m; ++i) {\n            int pos = rnd.next(1, n);\n            queries[i] = make_pair(pos, pos);\n        }\n    } else if (qtype == \"prefix\") {\n        for(int i = 0; i < m; ++i) {\n            int r = rnd.next(1, n);\n            queries[i] = make_pair(1, r);\n        }\n    } else {\n        for(int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    }\n\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -type random -qtype random\n./gen -n 10 -m 5 -type same -qtype random\n./gen -n 10 -m 5 -type increase -qtype random\n./gen -n 10 -m 5 -type decrease -qtype random\n./gen -n 10 -m 5 -type max_ai -qtype random\n./gen -n 10 -m 5 -type min_ai -qtype random\n./gen -n 10 -m 5 -type special -qtype random\n\n./gen -n 100000 -m 100000 -type random -qtype random\n./gen -n 100000 -m 100000 -type same -qtype random\n./gen -n 100000 -m 100000 -type increase -qtype random\n./gen -n 100000 -m 100000 -type decrease -qtype random\n./gen -n 100000 -m 100000 -type max_ai -qtype random\n./gen -n 100000 -m 100000 -type min_ai -qtype random\n./gen -n 100000 -m 100000 -type special -qtype random\n\n./gen -n 100000 -m 100000 -type random -qtype full\n./gen -n 100000 -m 100000 -type same -qtype full\n./gen -n 100000 -m 100000 -type random -qtype single\n./gen -n 100000 -m 100000 -type random -qtype prefix\n\n./gen -n 1 -m 1 -type same -qtype single\n./gen -n 2 -m 1 -type same -qtype full\n./gen -n 2 -m 1 -type random -qtype random\n\n./gen -n 100000 -m 1 -type special -qtype random\n./gen -n 100000 -m 100000 -type special -qtype single\n./gen -n 100000 -m 100000 -type special -qtype prefix\n\n./gen -n 99999 -m 99999 -type increase -qtype random\n\n./gen -n 88888 -m 88888 -type decrease -qtype random\n\n./gen -n 100000 -m 100000 -type random -qtype full\n./gen -n 100000 -m 50000 -type random -qtype random\n./gen -n 100000 -m 50000 -type random -qtype single\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:07.686252",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "221/E",
      "title": "E. Little Elephant and Shifts",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105) — the size of the permutations. The second line contains permutation a as n distinct numbers from 1 to n, inclusive. The numbers are separated with single spaces. The third line contains permutation b in the same format.",
      "output_spec": "OutputIn n lines print n integers — the answers for cyclic shifts. Print the answers to the shifts in the order of the shifts' numeration in permutation b, that is, first for the 1-st cyclic shift, then for the 2-nd, and so on.",
      "sample_tests": "ExamplesInputCopy21 22 1OutputCopy10InputCopy42 1 3 43 4 2 1OutputCopy2101",
      "description": "E. Little Elephant and Shifts\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105) — the size of the permutations. The second line contains permutation a as n distinct numbers from 1 to n, inclusive. The numbers are separated with single spaces. The third line contains permutation b in the same format.\n\nOutputIn n lines print n integers — the answers for cyclic shifts. Print the answers to the shifts in the order of the shifts' numeration in permutation b, that is, first for the 1-st cyclic shift, then for the 2-nd, and so on.\n\nInputCopy21 22 1OutputCopy10InputCopy42 1 3 43 4 2 1OutputCopy2101\n\nInputCopy21 22 1\n\nOutputCopy10\n\nInputCopy42 1 3 43 4 2 1\n\nOutputCopy2101",
      "solutions": [
        {
          "title": "Codeforces Round #136 - Codeforces",
          "content": "Tomorrow, in 4 and half hours before the end of the summer (check your zone), Codeforces Round #136 will take place. I am the author of this round, it's my 6th contest on CF.Gerlad Agapov (Gerald) is helping me in preparing the problems. Translations will be done by Maria Belova (Delinur). Thanks to them.I hope you will like this round. The points distribution will be standart.Thanks!7 user in the first division solved all 5 problems, here they are: peter50216 yeputons winger rng_58 RAD al13n KADR Meanwhile, in second division, Top-4 looks like this: blue.boy de_troit lxyxynt ilona You can find the editorial of the contest here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5167",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 636
        },
        {
          "title": "Codeforces Round #136 — Editorial - Codeforces",
          "content": "221A - Little Elephant and FunctionIn this problems you should notice that the answer for the problem is always of the following form: n, 1, 2, 3, ..., n-1. In such case array will be always sorted after the end of the algorithm.221B - Little Elephant and NumbersHere you just need to find all divisors of n. This can be done using standart algorithm with iterating from 1 to sqrt(n). After that you need to write some function that checks whether two numbers has same digits. This also can be done using simple loops.220A - Little Elephant and ProblemThere are multiple possible solutions for this problem. For example, the following. Find the last index x such that there exists some y (y < x) (minimal possible) that Ax < Ay. Then you just need to try two possibilities — either swap Ax and Ay, or don't change anything.220B - Little Elephant and ArrayThis problem can be solve in simpler O(NsqrtN) solution, but I will describe O(NlogN) one.We will solve this problem in offline. For each x (0 ≤ x < n) we should keep all the queries that end in x. Iterate that x from 0 to n - 1. Also we need to keep some array D such that for current x Dl + Dl + 1 + ... + Dx will be the answer for query [l;x]. To keep D correct, before the processing all queries that end in x, we need to update D. Let t be the current integer in A, i. e. Ax, and vector P be the list of indices of previous occurences of t (0-based numeration of vector). Then, if |P| ≥ t, you need to add 1 to DP[|P| - t], because this position is now the first (from right) that contains exactly t occurences of t. After that, if |P| > t, you need to subtract 2 from DP[|P| - t - 1], in order to close current interval and cancel previous. Finally, if |P| > t + 1, then you need additionally add 1 to DP[|P| - t - 2] to cancel previous close of the interval.220C - Little Elephant and ShiftsEach of the shifts can be divided into two parts — the right (the one that starts from occurrence 1) and the left (the rest of the elements). If we could keep minimal distance for each part, the minimal of these numbers will be the answers for the corresponding shift. Lets solve the problems of the right part, the left will be almost the same.Let we have some shift, for example 34567[12] and the permutation A is 4312765 and B is 2145673, then shifted B is 4567321. Let we keep two sets (S1 and S2). The first will keep all the distances from integers in current left part to the corresponding positions in A (for the example above, it is \\texttt{2, 4}). When you come to the next shift, all integers in S1 should be decreased by 1 (that is because all distances are also decreased by 1). But now some integers in set may be negative, when any negative integer occures (it always will be -1) you need to delete it from S1 and put 1 to the S2. Also after shifting to the next shifts, all integers in S2 must be increase by 1. After that, for any shift, the answer will be minimum from the smallest numbers in S1 and S2.It was very useful to use standart \"set\" in C++.220D - Little Elephant and TriangleLet iterate all possible points that, as we consider, must be the first point. Let it be (x;y). Let the second and the third points be (x1;y1) and (x2;y2). Then the doubled area is |(x1 - x)(y2 - y) - (x2 - x)(y1 - y)|. We need this number to be even and nonzero. For first we will find the number of groups of points that are even, after that just subtract the number of groups with area equal to zero.For the first subproblem, we need to rewrite our formula. It is equal to |x(y1 - y2) + y(x2 - x1)|. Since we know x and y and we just need to check parity, we can try all possible 24 values of parity of x1, y1, x2 and y2 (let it be d0, d1, d2 and d3, respectively). And check whether they will form a 0 after multiplications and taking modulo 2. If it froms a 0, then add to the answer value cxd0cyd1cxd2cyd3, where cxd is equal to the number of integers between 0 and n, inclusve, that modulo 2 are equal d. cyd is the same but in range [0..m].Now we need to subtract bad groups — the ones that has the area equal to zero. This means that they will either form a dot or a segment. If it is segment, we can just iterate dx = |x1 - x2| and dy = |y1 - y2| instead of all 4 coordinates. Then the number of such segments on the plane will be (n - dx + 1)(m - dy + 1). Also for counting the number of triples of points on the segment you need to find the number of integer coordinates on the segment. It is well-know problem, and the answer is gcd(dx, dy) + 1.This gives us, with some simple optimizations, and O(nm) solution.220E - Little Elephant and InversionsIn this problems you can use a method of two pointers. Also some RMQ are required. If you do not know about RMQ, please, read about it in the Internet before solving this problem.Firstly, map all the elements in the input array. After that all of them will be in range [0..n - 1]. We need to keep two RMQs, both of size n. Let the first RMQ be Q1 and the second Q2. Q1i will contain the number of numbers i in current left subarray. Q2i will contain the number of numbers i in the left subarray. Firstly, add all n number to the Q2. After that iterate some pointer r from n - 1 downto 1, by the way keeping point l (which, at the beggining, is equal to n - 1) Using RMQs, you can keep the number of inversions when you decrease r or l (using \"sum on the range\" operation). While the current number of inversions is more then k and l ≥ 0, decrease l. Then for each r the answer of correct l will be l + 1 (considering 0-based numeration).This makes the algorithm working in O(NlogN) time with correct realisation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 221 和字母"
          },
          "content_length": 5630
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a(n);\n    vector<bool> used(n+1, false);\n\n    for(int i = 0; i < n; ++i) {\n        a[i] = inf.readInt(1, n);\n        ensuref(!used[a[i]], \"Duplicate number %d in permutation 'a'\", a[i]);\n        used[a[i]] = true;\n\n        if(i < n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    // Reset used array\n    fill(used.begin(), used.end(), false);\n\n    for(int i = 0; i < n; ++i) {\n        int bi = inf.readInt(1, n);\n        ensuref(!used[bi], \"Duplicate number %d in permutation 'b'\", bi);\n        used[bi] = true;\n\n        if(i < n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a(n);\n    vector<bool> used(n+1, false);\n\n    for(int i = 0; i < n; ++i) {\n        a[i] = inf.readInt(1, n);\n        ensuref(!used[a[i]], \"Duplicate number %d in permutation 'a'\", a[i]);\n        used[a[i]] = true;\n\n        if(i < n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    // Reset used array\n    fill(used.begin(), used.end(), false);\n\n    for(int i = 0; i < n; ++i) {\n        int bi = inf.readInt(1, n);\n        ensuref(!used[bi], \"Duplicate number %d in permutation 'b'\", bi);\n        used[bi] = true;\n\n        if(i < n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a(n);\n    vector<bool> used(n+1, false);\n\n    for(int i = 0; i < n; ++i) {\n        a[i] = inf.readInt(1, n);\n        ensuref(!used[a[i]], \"Duplicate number %d in permutation 'a'\", a[i]);\n        used[a[i]] = true;\n\n        if(i < n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    // Reset used array\n    fill(used.begin(), used.end(), false);\n\n    for(int i = 0; i < n; ++i) {\n        int bi = inf.readInt(1, n);\n        ensuref(!used[bi], \"Duplicate number %d in permutation 'b'\", bi);\n        used[bi] = true;\n\n        if(i < n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n);\n\n    if (type == \"identical\") {\n        // a and b are identical permutations\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        b = a;\n    } else if (type == \"reverse\") {\n        // a is [1..n], b is [n..1]\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n            b[i] = n - i;\n        }\n    } else if (type == \"shift\") {\n        // b is cyclic shift of a by 'shift' positions\n        int shift = opt<int>(\"shift\", 1);\n        shift = shift % n;\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            b[(i + shift) % n] = a[i];\n        }\n    } else if (type == \"alternate\") {\n        // a is [1..n], b alternates elements\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        b = a;\n        for (int i = 0; i + 1 < n; i += 2) {\n            swap(b[i], b[i + 1]);\n        }\n    } else if (type == \"max_distance\") {\n        // Positions of matching elements are as far apart as possible\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n            b[n - i - 1] = i + 1;\n        }\n    } else if (type == \"b_random\") {\n        // a is sorted, b is random permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n            b[i] = i + 1;\n        }\n        shuffle(b.begin(), b.end());\n    } else if (type == \"a_random\") {\n        // b is sorted, a is random permutation\n        for (int i = 0; i < n; ++i) {\n            b[i] = i + 1;\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"random\") {\n        // Both a and b are random permutations\n        for (int i = 0; i < n; ++i) {\n            a[i] = b[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n        shuffle(b.begin(), b.end());\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i) {\n            a[i] = b[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n        shuffle(b.begin(), b.end());\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", b[i], i + 1 == n ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n);\n\n    if (type == \"identical\") {\n        // a and b are identical permutations\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        b = a;\n    } else if (type == \"reverse\") {\n        // a is [1..n], b is [n..1]\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n            b[i] = n - i;\n        }\n    } else if (type == \"shift\") {\n        // b is cyclic shift of a by 'shift' positions\n        int shift = opt<int>(\"shift\", 1);\n        shift = shift % n;\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            b[(i + shift) % n] = a[i];\n        }\n    } else if (type == \"alternate\") {\n        // a is [1..n], b alternates elements\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n        b = a;\n        for (int i = 0; i + 1 < n; i += 2) {\n            swap(b[i], b[i + 1]);\n        }\n    } else if (type == \"max_distance\") {\n        // Positions of matching elements are as far apart as possible\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n            b[n - i - 1] = i + 1;\n        }\n    } else if (type == \"b_random\") {\n        // a is sorted, b is random permutation\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n            b[i] = i + 1;\n        }\n        shuffle(b.begin(), b.end());\n    } else if (type == \"a_random\") {\n        // b is sorted, a is random permutation\n        for (int i = 0; i < n; ++i) {\n            b[i] = i + 1;\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"random\") {\n        // Both a and b are random permutations\n        for (int i = 0; i < n; ++i) {\n            a[i] = b[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n        shuffle(b.begin(), b.end());\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i) {\n            a[i] = b[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n        shuffle(b.begin(), b.end());\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", b[i], i + 1 == n ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type identical\n./gen -n 1 -type random\n\n./gen -n 2 -type identical\n./gen -n 2 -type reverse\n./gen -n 2 -type shift -shift 1\n./gen -n 2 -type random\n\n./gen -n 5 -type identical\n./gen -n 5 -type reverse\n./gen -n 5 -type shift -shift 2\n./gen -n 5 -type alternate\n./gen -n 5 -type max_distance\n./gen -n 5 -type random\n\n./gen -n 10 -type identical\n./gen -n 10 -type reverse\n./gen -n 10 -type shift -shift 3\n./gen -n 10 -type alternate\n./gen -n 10 -type max_distance\n./gen -n 10 -type random\n\n./gen -n 100 -type identical\n./gen -n 100 -type reverse\n./gen -n 100 -type shift -shift 50\n./gen -n 100 -type alternate\n./gen -n 100 -type max_distance\n./gen -n 100 -type random\n\n./gen -n 1000 -type identical\n./gen -n 1000 -type reverse\n./gen -n 1000 -type shift -shift 500\n./gen -n 1000 -type alternate\n./gen -n 1000 -type max_distance\n./gen -n 1000 -type random\n\n./gen -n 10000 -type identical\n./gen -n 10000 -type reverse\n./gen -n 10000 -type shift -shift 1234\n./gen -n 10000 -type alternate\n./gen -n 10000 -type max_distance\n./gen -n 10000 -type random\n\n./gen -n 100000 -type identical\n./gen -n 100000 -type reverse\n./gen -n 100000 -type shift -shift 99999\n./gen -n 100000 -type alternate\n./gen -n 100000 -type max_distance\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:09.646694",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "222/A",
      "title": "A. Shooshuns and Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and k (1 ≤ k ≤ n ≤ 105).The second line contains n space-separated integers: a1, a2, ..., an (1 ≤ ai ≤ 105) — the sequence that the shooshuns found.",
      "output_spec": "OutputPrint the minimum number of operations, required for all numbers on the blackboard to become the same. If it is impossible to achieve, print -1.",
      "sample_tests": "ExamplesInputCopy3 23 1 1OutputCopy1InputCopy3 13 1 1OutputCopy-1",
      "description": "A. Shooshuns and Sequence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and k (1 ≤ k ≤ n ≤ 105).The second line contains n space-separated integers: a1, a2, ..., an (1 ≤ ai ≤ 105) — the sequence that the shooshuns found.\n\nOutputPrint the minimum number of operations, required for all numbers on the blackboard to become the same. If it is impossible to achieve, print -1.\n\nInputCopy3 23 1 1OutputCopy1InputCopy3 13 1 1OutputCopy-1\n\nInputCopy3 23 1 1\n\nOutputCopy1\n\nInputCopy3 13 1 1\n\nOutputCopy-1\n\nNoteIn the first test case after the first operation the blackboard will have sequence [1, 1, 1]. So, one operation is enough to make all numbers the same. Thus, the answer equals one.In the second test case the sequence will never consist of the same numbers. It will always contain at least two distinct numbers 3 and 1. Thus, the answer equals -1.",
      "solutions": [
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces",
          "content": "Hello everybody!Today, Codeforces Round #137 for the Second Division Participants will take place. As usual, all other interested persons can take part in it. The problems have been developed by a group of authors from Vladivostok: Ilya Zban (izban), Alexey Evsyukov (aevsyukov), Zakhar Voit (zakharvoit).Gerald Agapov (Gerald) has greatly contributed as well and we thank him for it. The translation of the problems has been done by Maria Belova (Delinur) — thanks to her! We are also grateful to Pavel Kunyavskiy (PavelKunyavskiy), who has help us in the preparation of the contest.We hope you will have fun and like this round. The points distribution will be standard (500 — 1000 — 1500 — 2000 — 2500).Good luck to everybody!UPD: The start will be 15 minutes later due to technical reasons, we apologize.UPD2: Congratulation to winners!In second division:1: zxl07142: resodo3: mugurelionut4: hmspmy0775: CCC6: white_rich_beautiful7: loveSakura8: gcwtft8279: yuxingdubai10: b821213In first division:1: navi2: Shik3: SteamTurbineUPD3: The editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5248",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1064
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces",
          "content": "Problem A:Note that the k-th element is copied to the end. Then the (k+1)-th element from the initial sequence is copied, then (k+2)-th, … , n-th, k-th, (k+1)-th, etc. So all the numbers on the blackboard will become equal if and only if all the numbers from the k-th to the n-th in the initial sequence were equal. It's now also obvious that the number of operations needed for it is equal to the index of the last number that is not equal to the n-th element of the initial sequence, because it's exactly the number of deletions needed to eliminate the elements that are not equal to the last one. If this number is greater than k, than answer is -1. Complexity — O(n).Problem B:Let’s store the order of the rows and columns of table. Thus, row[x] is the number of the row x in the initial table and column[x] is the number of column x in the initial table. Then, the value of an element in the row x and column y in the current table is equal to t[row[x], column[y]], where t — initial table. When we get the update request, we need to swap the x-th element and the y-th element in the corresponding array. Complexity — O(n * m + k).Problem C:Let's factorize the numerator and denominator. Now for each prime integer x we know the extent of x in the factorization of the numerator(a[x]) and the denominator(b[x]). For each prime number x we can calculate the extent of x in the factorization of the numerator and the denominator after reduction : newa[x]=a[x]-min(a[x], b[x]), newb[x]=b[x]-min(a[x],b[x]). We have the numerator and the denominator of the answer in factorized form. Now we have to bring them into the form which is required in the condition. One of the ways to do it is to note that the fraction from the statement satisfies the conditions. We can factorize it again and in the answer we will have the same fraction for which there will not be such a prime x so that the degree of x in answer would be greater than newa[x] or newb[x]. (This operation can be called reduction) The result will satisfy the condition and the fraction will be equal to the required number. If you try to build answer greedily (put factors in the answer till their product <= 10^7), the count of numbers in the answer (n_out or m_out) will be bigger than 10^5. Factorization by O(sqrt(max)) received TL. You should have found a faster way. For example you could have used linear sieve of Eratosthenes. Complexity — O(max + n * log(max)). log(max) is size of factorization.Problem D:First of all, note that in any case the best place which Vasya can take is the first place for he can earn maximum points. Now we must find the worst place which Vasya can take. We need to find maximal matching in bipartite graph, where the edge between vertice i from the first part and vertice j from the second part exists if a[i] + b[j] >= x. To solve this task, it is enough just to sort the vertices in both parts of the graph by their weights and use two pointers method. Suppose that we have sorted all the vertices by non-increasing points (a1 >= a2 >= ... >= an). Let's take two pointers — L = 1 in the first part and R = N in the second part. While a[L] + b[R] < x we must decrease R to find the first vertice such a[L] + b[R] >= x. When we found such R, we must add this edge to the answer, i.e. increase the answer, increase L by 1, decrease R by 1. It is easy to show why this algo is correct and it finds the optimal solution. I have discovered a truly marvelous proof of this, but the margins of this analysis are too narrow to for him. Complexity — O(N log N) for sorting and O(N) for two pointers.Problem E:1) Solution with complexity O(n*m*m), using the dynamic programming: State — d[n][m] — the number of allowed chains of length n that ends in symbol m. Transition — sort out all possible characters, and check if you can put the symbol k after symbol m.2) Solution with complexity O(m*m*m*log n): Note that the transition in the first solution is always the same. So we can make the transition matrix A of size MxM. If j-th symbol can follow i-th then A[i][j]=1 else A[i][j]=0. Define a vector of size 1хМ b={1,1,…,1}. We can see that b * a^(n-1) = answer. Now we can use fast exponentiation for computing a^(n-1). We should consider the case with n=1 separately. The answer is the sum of numbers in the vector ans. Complexity — O(m^3) from matrix multiplication and O(log n) from fast exponentiation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5251",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4403
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 1",
          "code": "if (a >= 'A' && a <= 'Z') a -= 'A' + 26;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 2",
          "code": "if (a >= 'A' && a <= 'Z') a -= 'A' + 26;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 1",
          "code": "1 2 3\n1 2\nc 1 2\ng 1 1\ng 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 2",
          "code": "1 2 3\n1 2\nc 1 2\ng 1 1\ng 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    if(k < 1 || k > n) {\n        fprintf(stderr, \"Invalid k: %d (should be 1 ≤ k ≤ n = %d)\\n\", k, n);\n        return 1;\n    }\n    if(n < 1 || n > 100000) {\n        fprintf(stderr, \"Invalid n: %d (should be 1 ≤ n ≤ 1e5)\\n\", n);\n        return 1;\n    }\n\n    vector<int> a(n);\n\n    if (type == \"equal\") {\n        // All elements are the same\n        int value = rnd.next(1, 100000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"almost_equal\") {\n        // All but one element are the same\n        int value = rnd.next(1, 100000);\n        int diff_value = rnd.next(1, 100000);\n        while(diff_value == value) {\n            diff_value = rnd.next(1, 100000);\n        }\n        int diff_idx = rnd.next(0, n-1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n        a[diff_idx] = diff_value;\n    } else if (type == \"impossible\") {\n        // Generate a sequence where it's impossible for numbers to become the same\n        // When k = 1 and first element is different\n        int value1 = rnd.next(1, 100000);\n        int value2 = rnd.next(1, 100000);\n        while(value2 == value1) {\n            value2 = rnd.next(1, 100000);\n        }\n        a[0] = value1;\n        for(int i = 1; i < n; ++i) {\n            a[i] = value2;\n        }\n    } else if (type == \"possible\") {\n        // Generate a sequence where it's possible for all numbers to become the same\n        int value = rnd.next(1, 100000);\n        int diff_idx = rnd.next(0, n-1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n        a[diff_idx] = value; // All same, guaranteed possible\n    } else if (type == \"random\") {\n        // Generate random elements\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"max_values\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 100000;\n        }\n    } else if (type == \"min_values\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        return 1;\n    }\n    \n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the sequence\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if(i+1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    if(k < 1 || k > n) {\n        fprintf(stderr, \"Invalid k: %d (should be 1 ≤ k ≤ n = %d)\\n\", k, n);\n        return 1;\n    }\n    if(n < 1 || n > 100000) {\n        fprintf(stderr, \"Invalid n: %d (should be 1 ≤ n ≤ 1e5)\\n\", n);\n        return 1;\n    }\n\n    vector<int> a(n);\n\n    if (type == \"equal\") {\n        // All elements are the same\n        int value = rnd.next(1, 100000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"almost_equal\") {\n        // All but one element are the same\n        int value = rnd.next(1, 100000);\n        int diff_value = rnd.next(1, 100000);\n        while(diff_value == value) {\n            diff_value = rnd.next(1, 100000);\n        }\n        int diff_idx = rnd.next(0, n-1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n        a[diff_idx] = diff_value;\n    } else if (type == \"impossible\") {\n        // Generate a sequence where it's impossible for numbers to become the same\n        // When k = 1 and first element is different\n        int value1 = rnd.next(1, 100000);\n        int value2 = rnd.next(1, 100000);\n        while(value2 == value1) {\n            value2 = rnd.next(1, 100000);\n        }\n        a[0] = value1;\n        for(int i = 1; i < n; ++i) {\n            a[i] = value2;\n        }\n    } else if (type == \"possible\") {\n        // Generate a sequence where it's possible for all numbers to become the same\n        int value = rnd.next(1, 100000);\n        int diff_idx = rnd.next(0, n-1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n        a[diff_idx] = value; // All same, guaranteed possible\n    } else if (type == \"random\") {\n        // Generate random elements\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"max_values\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 100000;\n        }\n    } else if (type == \"min_values\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        return 1;\n    }\n    \n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the sequence\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if(i+1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type equal\n./gen -n 1 -k 1 -type random\n./gen -n 2 -k 1 -type equal\n./gen -n 2 -k 2 -type equal\n./gen -n 2 -k 1 -type almost_equal\n./gen -n 2 -k 2 -type almost_equal\n./gen -n 3 -k 1 -type impossible\n./gen -n 3 -k 1 -type possible\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 5 -type max_values\n./gen -n 10 -k 5 -type min_values\n./gen -n 100 -k 50 -type random\n./gen -n 100 -k 1 -type impossible\n./gen -n 100 -k 100 -type impossible\n./gen -n 1000 -k 500 -type random\n./gen -n 1000 -k 1 -type possible\n./gen -n 10000 -k 1 -type impossible\n./gen -n 10000 -k 5000 -type random\n./gen -n 100000 -k 1 -type impossible\n./gen -n 100000 -k 50000 -type random\n./gen -n 100000 -k 100000 -type impossible\n./gen -n 100000 -k 100000 -type possible\n./gen -n 100000 -k 1 -type equal\n./gen -n 100000 -k 100000 -type equal\n./gen -n 100000 -k 1 -type almost_equal\n./gen -n 100000 -k 100000 -type almost_equal\n./gen -n 100000 -k 99999 -type impossible\n./gen -n 50000 -k 25000 -type random\n./gen -n 99999 -k 99999 -type impossible\n./gen -n 99999 -k 1 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:11.740196",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "222/B",
      "title": "B. Космические таблицы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел записаны три целых числа n, m и k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 500000) — количество строк, столбцов таблицы и количество запросов соответственно.В следующих n строках записаны по m чисел через пробел — изначальное состояние таблицы. Каждое число p в таблице целое и удовлетворяет неравенству 0 ≤ p ≤ 106.В следующих k строках записаны запросы в формате «si xi yi», где si — один из символов «с», «r» или «g», а xi, yi — два целых числа.  Если si = «c», то текущий запрос — запрос на обмен столбцов с номерами xi и yi местами (1 ≤ x, y ≤ m, x ≠ y);  Если si = «r», то текущий запрос — запрос на обмен строк с номерами xi и yi местами (1 ≤ x, y ≤ n, x ≠ y);  Если si = «g», то текущий запрос — запрос на получение числа, стоящего в xi-ой строке в yi-ом столбце (1 ≤ x ≤ n, 1 ≤ y ≤ m). Считайте, что строки таблицы нумеруются сверху вниз от 1 до n, а столбцы слева направо от 1 до m.",
      "output_spec": "Выходные данныеДля каждого запроса на получение числа (si = «g») выведите требуемое число. Ответы на запросы выводите в том порядке, в котором запросы заданы во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 3 51 2 34 5 67 8 9g 3 2r 3 2c 2 3g 2 2g 3 2Выходные данныеСкопировать896Входные данныеСкопировать2 3 31 2 43 1 5c 2 1r 1 2g 1 3Выходные данныеСкопировать5",
      "description": "B. Космические таблицы\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел записаны три целых числа n, m и k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 500000) — количество строк, столбцов таблицы и количество запросов соответственно.В следующих n строках записаны по m чисел через пробел — изначальное состояние таблицы. Каждое число p в таблице целое и удовлетворяет неравенству 0 ≤ p ≤ 106.В следующих k строках записаны запросы в формате «si xi yi», где si — один из символов «с», «r» или «g», а xi, yi — два целых числа.  Если si = «c», то текущий запрос — запрос на обмен столбцов с номерами xi и yi местами (1 ≤ x, y ≤ m, x ≠ y);  Если si = «r», то текущий запрос — запрос на обмен строк с номерами xi и yi местами (1 ≤ x, y ≤ n, x ≠ y);  Если si = «g», то текущий запрос — запрос на получение числа, стоящего в xi-ой строке в yi-ом столбце (1 ≤ x ≤ n, 1 ≤ y ≤ m). Считайте, что строки таблицы нумеруются сверху вниз от 1 до n, а столбцы слева направо от 1 до m.\n\nВходные данные\n\nВыходные данныеДля каждого запроса на получение числа (si = «g») выведите требуемое число. Ответы на запросы выводите в том порядке, в котором запросы заданы во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать3 3 51 2 34 5 67 8 9g 3 2r 3 2c 2 3g 2 2g 3 2Выходные данныеСкопировать896Входные данныеСкопировать2 3 31 2 43 1 5c 2 1r 1 2g 1 3Выходные данныеСкопировать5\n\nВходные данныеСкопировать3 3 51 2 34 5 67 8 9g 3 2r 3 2c 2 3g 2 2g 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать896\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 3 31 2 43 1 5c 2 1r 1 2g 1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеДавайте посмотрим, как изменяется таблица во втором тестовом примере.После выполнения первой операции таблица примет следующий вид:2 1 41 3 5После выполнения второй операции она примет такой вид:1 3 52 1 4На третий запрос (какое число стоит в первом ряду в третьем столбце) ответом будет 5.",
      "solutions": [
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces",
          "content": "Всем привет!Сегодня пройдет Codeforces Round #137 для участников второго дивизиона. Как обычно, остальные могут принять участие вне конкурса.Задачи подготовила группа авторов из Владивостока — Илья Збань (izban), Алексей Евсюков (aevsyukov), Захар Войт (zakharvoit). Огромный вклад в подготовку раунда внес Геральд Агапов (Gerald), большое ему спасибо. Перевела задачи Мария Белова (Delinur). Также выражаем благодарность Павлу Кунявскому (PavelKunyavskiy), который тоже предложил свою помощь в подготовку контеста.Разбалловка сегодня стандартная (500 — 1000 — 1500 — 2000 — 2500).Всем удачи!UPD: Начало контеста передвинуто на 15 минут по техническим причинам, приносим свои извинения.UPD2: Опубликован разбор. Пока только на русском.UPD3: Поздравляем победителей!Во втором дивизионе первые 10 участников:1: zxl07142: resodo3: mugurelionut4: hmspmy0775: CCC6: white_rich_beautiful7: loveSakura8: gcwtft8279: yuxingdubai10: b821213В первом дивизионе, оторвавшись на взломах по задаче С, первые места заняли1: navi2: Shik3: SteamTurbineНадеюсь, вам понравилось!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5248",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1060
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces",
          "content": "Задача А:Заметим, что в конец копируется элемент, который был k-тым. Затем копируется элемент, который был (k+1)-м в исходном массиве, затем (k+2)-й, ... , n-й, k-тый, (k+1)-й etc. Значит, все числа станут одинаковыми тогда и только тогда, когда в исходной последовательности все числа с k-го по n-й были одинаковы. Теперь очевидно и то, что количество операций, требуемое для этого, равно номеру последнего не равного n-му элемента последовательности, так как ровно столько удалений понадобится для того, чтобы убрать не равные ему элементы. Если этот номер больше, чем k, то ответа нет. Асимтотика — O(N).Задача B:Давайте на каждом шаге будем хранить текущий порядок строк и порядок столбцов в таблице, относительно начального. То есть, row[x] — номер строки x в начальной таблице, а column[x] — номер столбца x в начальной таблице. Тогда значение элемента в строке x и столбце y текущей таблицы будет равно t[row[x], column[y]], где t — начальная таблица. В запросах обновления нужно просто поменять местами ячейки соответствующего массива с номерами x и y. Асимптотика O(n * m + k).Задача C:Для начала факторизуем числитель и знаменатель. Теперь для каждого простого числа x мы знаем степень этого числа в факторизации числителя(a[x]) и в факторизации знаменателя(b[x]). Для любого простого числа x мы можем вычислить его степень в факторизации числителя числа после сокращения(newa[x]) и в факторизации знаменателя этого числа(newb[x]): newa[x] = a[x] — min(a[x], b[x]), newb[x] = b[x] — min(a[x], b[x]). У нас есть числитель и знаменатель ответа(в факторизованном виде), осталось только привести их в вид, требуемый в условии. Один из способов — заметить, что дробь из условия подходила под все требования. Поэтому можно факторизовать ее еще раз и вывести такую же дробь, но так, чтобы ни одно простое число не имело большую степень, чем в посчитанных нами newa и newb. Получившиеся числа будут подходить под ограничения и их частное будет равно искомому числу. Если пробовать строить ответ жадно (набирать множители, пока их произведение <= 10^7), то количество чисел в ответе выходит за рамки 10^5. Асимптотика решения O(max + n * log max). Факторизация за O(sqrt(max)) получала TL, поэтому нужно было воспользоваться более быстрыми способами. Например — посчитать для каждого числа его наименьший простой делитель с помощью линейного решета эратосфена.Задача D:Во-первых, заметим, что наилучшее место, которое мог занять Вася — это первое, ведь ограничений сверху на его балл нет. Теперь нужно найти самое худшее место из тех, что он мог занять. Переформулируем. Нужно максимизировать количество таких участников, что если участник в первом туре набрал a[i] баллов, во втором — b[j], то a[i]+b[j] >= x. То есть, нам нужно найти максимальное паросочетание в двудольном графе, в котором ребро между вершинами i первой доли, j второй доли есть тогда, когда a[i] + b[j] >= x. Для решения этой подзадачи достаточно было отсортировать вершины в обоих долях по весу, и пройтись двумя указателями. Допустим, мы отсортировали по убыванию веса. Возьмем два указателя L = 1 в левой доле и R = N в правой доле. Пока a[L] + b[R] < x (то есть нет ребра L->R) нам стоит уменьшить R — взять вершину во второй доле с большим весом. Как только мы нашли R такое, что a[L] + b[R] >= x, мы берем ребро L->R и добавляем в ответ. Все — переходим к следующим L и R. Несложно показать, почему этот алгоритм найдет оптимальное решение. Я нашел поистине удивительное доказательство этому, но поля этого разбора слишком узки для него. Асимптотика — O(N log N) на сортировку и O(N) на два указателя.Задача Е:1) Решение за O(n*m*m): Простая динамика. Состояние — d[n][m] — сколько возможных цепочек длины n могут заканчиваться на символ m. Переход — перебираем все возможные символы, и смотрим, можно ли поставить символ k после символа m. 2) Решение за O(m*m*m*log n): Заметим, что в нашей динамике переход всегда одинаковый. Можно составить матрицу перехода A размером MxM. Если jый символ может идти за iым, то A[i][j]=1, иначе A[i][j]=0. Пусть есть вектор размером 1хМ b={1,1,...,1}. Тогда можно заметить, что b * a^(n-1) = ans. Воспользуемся бинарным возведением в степень для того, чтобы посчитать a^(n-1). Отдельно следует рассмотреть случай n==1. Ответом будет сумма элементов в векторе ans. Асимптотика — m^3 на перемножение матриц и log n на бинарное возведение в степень.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5251",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4361
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 1",
          "code": "Can't compile Solution.java:\nSolution.java:54: error: unmappable character for encoding Cp1252  \n                //Р§РёС?Р»Рѕ РїСЂРѕС?С‚РѕРµ \n                       ^ \nSolution.java:54: error: unmappable character for encoding Cp1252 \n                //Р§РёС?Р»Рѕ РїСЂРѕС?С‚РѕРµ \n                                    ^ \n2 errors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 2",
          "code": "Can't compile Solution.java:\nSolution.java:54: error: unmappable character for encoding Cp1252  \n                //Р§РёС?Р»Рѕ РїСЂРѕС?С‚РѕРµ \n                       ^ \nSolution.java:54: error: unmappable character for encoding Cp1252 \n                //Р§РёС?Р»Рѕ РїСЂРѕС?С‚РѕРµ \n                                    ^ \n2 errors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 3",
          "code": "(A^k)[x][y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 5",
          "code": "if (a >= 'A' && a <= 'Z') a -= 'A' + 26;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 6",
          "code": "if (a >= 'A' && a <= 'Z') a -= 'A' + 26;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 1",
          "code": "inc(cnt[a[r+1]]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 2",
          "code": "if (cnt[a[r+1]]=1) then inc(allcnt);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 3",
          "code": "Может, кто-нибудь из знатоков объяснит, почему одна и та же посылка",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 4",
          "code": "1 2 3\n1 2\nc 1 2\ng 1 1\ng 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 5",
          "code": "1 2 3\n1 2\nc 1 2\ng 1 1\ng 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 500000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        inf.readInts(m, 0, 1000000);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < k; i++) {\n        string si = inf.readToken(\"[crg]\", \"si\");\n        inf.readSpace();\n        int xi;\n        if (si == \"c\") {\n            xi = inf.readInt(1, m, \"xi\");\n        } else if (si == \"r\") {\n            xi = inf.readInt(1, n, \"xi\");\n        } else { // si == \"g\"\n            xi = inf.readInt(1, n, \"xi\");\n        }\n        inf.readSpace();\n        int yi;\n        if (si == \"c\") {\n            yi = inf.readInt(1, m, \"yi\");\n        } else if (si == \"r\") {\n            yi = inf.readInt(1, n, \"yi\");\n        } else { // si == \"g\"\n            yi = inf.readInt(1, m, \"yi\");\n        }\n        inf.readEoln();\n        if ((si == \"c\" || si == \"r\") && xi == yi) {\n            quitf(_fail, \"In '%s' query at line %d, xi (%d) should not be equal to yi (%d)\", si.c_str(), i+1, xi, yi);\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 500000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        inf.readInts(m, 0, 1000000);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < k; i++) {\n        string si = inf.readToken(\"[crg]\", \"si\");\n        inf.readSpace();\n        int xi;\n        if (si == \"c\") {\n            xi = inf.readInt(1, m, \"xi\");\n        } else if (si == \"r\") {\n            xi = inf.readInt(1, n, \"xi\");\n        } else { // si == \"g\"\n            xi = inf.readInt(1, n, \"xi\");\n        }\n        inf.readSpace();\n        int yi;\n        if (si == \"c\") {\n            yi = inf.readInt(1, m, \"yi\");\n        } else if (si == \"r\") {\n            yi = inf.readInt(1, n, \"yi\");\n        } else { // si == \"g\"\n            yi = inf.readInt(1, m, \"yi\");\n        }\n        inf.readEoln();\n        if ((si == \"c\" || si == \"r\") && xi == yi) {\n            quitf(_fail, \"In '%s' query at line %d, xi (%d) should not be equal to yi (%d)\", si.c_str(), i+1, xi, yi);\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 500000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        inf.readInts(m, 0, 1000000);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < k; i++) {\n        string si = inf.readToken(\"[crg]\", \"si\");\n        inf.readSpace();\n        int xi;\n        if (si == \"c\") {\n            xi = inf.readInt(1, m, \"xi\");\n        } else if (si == \"r\") {\n            xi = inf.readInt(1, n, \"xi\");\n        } else { // si == \"g\"\n            xi = inf.readInt(1, n, \"xi\");\n        }\n        inf.readSpace();\n        int yi;\n        if (si == \"c\") {\n            yi = inf.readInt(1, m, \"yi\");\n        } else if (si == \"r\") {\n            yi = inf.readInt(1, n, \"yi\");\n        } else { // si == \"g\"\n            yi = inf.readInt(1, m, \"yi\");\n        }\n        inf.readEoln();\n        if ((si == \"c\" || si == \"r\") && xi == yi) {\n            quitf(_fail, \"In '%s' query at line %d, xi (%d) should not be equal to yi (%d)\", si.c_str(), i+1, xi, yi);\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    Generator for the \"Swap Rows and Columns\" problem.\n\n    Usage:\n        ./gen -n <int> -m <int> -k <int> -type <string>\n\n    The parameter 'type' controls how the table is initialized and how queries are distributed.\n    Possible 'type' values and their behavior (feel free to add/modify if desired):\n      1) \"random\":    Random table, random mix of row-swap, col-swap, and get queries.\n      2) \"allzero\":   All table cells = 0, random queries.\n      3) \"allmax\":    All table cells = 10^6, random queries.\n      4) \"smallfix\":  Very small table with a fixed pattern, queries systematically cover edges.\n      5) \"inc\":       Incremental pattern in the table (e.g., a[i][j] = i * m + j), random queries.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");        // number of rows\n    int m = opt<int>(\"m\");        // number of columns\n    int k = opt<int>(\"k\");        // number of queries\n    string type = opt<string>(\"type\", \"random\");\n\n    // 1) Generate the table\n    //    Depending on 'type', fill the table differently.\n    vector<vector<int>> table(n, vector<int>(m));\n\n    if (type == \"allzero\") {\n        // All zeros\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                table[i][j] = 0;\n            }\n        }\n    }\n    else if (type == \"allmax\") {\n        // All 10^6\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                table[i][j] = 1000000;\n            }\n        }\n    }\n    else if (type == \"smallfix\") {\n        // If n and m are small, fill with a simple pattern.\n        // If n, m are large, we just do a random fallback.\n        if (n <= 5 && m <= 5) {\n            // Fill a small pattern\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    table[i][j] = cnt++;\n                }\n            }\n        } else {\n            // fallback to random\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    table[i][j] = rnd.next(0, 1000000);\n                }\n            }\n        }\n    }\n    else if (type == \"inc\") {\n        // a[i][j] = i*m + j\n        // Cap if it exceeds 10^6 to be safe, though typically i*m+j won't exceed 10^6 unless n*m is large.\n        // We'll still just do min(i*m + j, 10^6).\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                long long val = 1LL * i * m + j;\n                if (val > 1000000) val = 1000000;\n                table[i][j] = (int)val;\n            }\n        }\n    }\n    else {\n        // default = \"random\"\n        // random in [0..10^6]\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                table[i][j] = rnd.next(0, 1000000);\n            }\n        }\n    }\n\n    // 2) Print n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // 3) Output the table\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            printf(\"%d%c\", table[i][j], (j+1==m ? '\\n' : ' '));\n        }\n    }\n\n    // 4) Generate queries.\n    //    We'll create a random mix of 'r', 'c', 'g' queries unless 'smallfix' suggests a pattern.\n    //    In all cases, we ensure indices are valid and respect constraints (distinct x,y for r/c).\n\n    auto genDistinct = [&](int lim) {\n        // Generate a distinct pair (x,y), both in [1..lim], x != y.\n        // x and y in different order is relevant to 'r' or 'c'.\n        int x = rnd.next(1, lim);\n        int y = rnd.next(1, lim);\n        while (y == x) {\n            y = rnd.next(1, lim);\n        }\n        return make_pair(x, y);\n    };\n\n    if (type == \"smallfix\" && n <= 5 && m <= 5) {\n        // In \"smallfix\" with tiny table, let's systematically produce queries:\n        //   - a few row swaps, a few col swaps, then get from corners\n        // Ensuring k doesn't exceed 20 if user gave something small.\n        // If k is large, we'll fill the rest with random queries.\n\n        int baseOps = min(k, 10); // number of systematic ops\n        // 2 row-swaps, 2 col-swaps\n        int opsUsed = 0;\n        // Row-swap #1\n        if (n >= 2 && opsUsed < baseOps) {\n            printf(\"r 1 2\\n\");\n            opsUsed++;\n        }\n        // Col-swap #1\n        if (m >= 2 && opsUsed < baseOps) {\n            printf(\"c 1 2\\n\");\n            opsUsed++;\n        }\n        // Row-swap #2\n        if (n >= 2 && opsUsed < baseOps) {\n            printf(\"r %d %d\\n\", n, max(1, n-1)); // swirl last two\n            opsUsed++;\n        }\n        // Col-swap #2\n        if (m >= 2 && opsUsed < baseOps) {\n            printf(\"c %d %d\\n\", m, max(1, m-1));\n            opsUsed++;\n        }\n        // Some get queries from corners if possible\n        if (opsUsed < baseOps) { // top-left\n            printf(\"g 1 1\\n\");\n            opsUsed++;\n        }\n        if (opsUsed < baseOps && n>=2 && m>=2) { // bottom-right\n            printf(\"g %d %d\\n\", n, m);\n            opsUsed++;\n        }\n\n        // Fill the rest (if any) with random\n        for (int i = opsUsed; i < k; i++) {\n            int t = rnd.next(3); // 0->r, 1->c, 2->g\n            if (t == 0 && n > 1) {\n                // row swap\n                auto [x, y] = genDistinct(n);\n                printf(\"r %d %d\\n\", x, y);\n            } else if (t == 1 && m > 1) {\n                // col swap\n                auto [x, y] = genDistinct(m);\n                printf(\"c %d %d\\n\", x, y);\n            } else {\n                // get\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                printf(\"g %d %d\\n\", x, y);\n            }\n        }\n    }\n    else {\n        // For other types, produce a random mixture:\n        // Let's do 30% row swap, 30% col swap, 40% get\n        // (If n=1 or m=1, row-swap or col-swap might be impossible, so we adapt.)\n\n        for (int i = 0; i < k; i++) {\n            int choice = rnd.next(100); // 0..99\n            // If we can't do a row swap or col swap (e.g. n=1 or m=1), skip to \"get\".\n            bool canRowSwap = (n >= 2);\n            bool canColSwap = (m >= 2);\n\n            if (choice < 30 && canRowSwap) {\n                // row swap\n                auto [x, y] = genDistinct(n);\n                printf(\"r %d %d\\n\", x, y);\n            }\n            else if (choice < 60 && canColSwap) {\n                // col swap\n                auto [x, y] = genDistinct(m);\n                printf(\"c %d %d\\n\", x, y);\n            }\n            else {\n                // get\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                printf(\"g %d %d\\n\", x, y);\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    Generator for the \"Swap Rows and Columns\" problem.\n\n    Usage:\n        ./gen -n <int> -m <int> -k <int> -type <string>\n\n    The parameter 'type' controls how the table is initialized and how queries are distributed.\n    Possible 'type' values and their behavior (feel free to add/modify if desired):\n      1) \"random\":    Random table, random mix of row-swap, col-swap, and get queries.\n      2) \"allzero\":   All table cells = 0, random queries.\n      3) \"allmax\":    All table cells = 10^6, random queries.\n      4) \"smallfix\":  Very small table with a fixed pattern, queries systematically cover edges.\n      5) \"inc\":       Incremental pattern in the table (e.g., a[i][j] = i * m + j), random queries.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");        // number of rows\n    int m = opt<int>(\"m\");        // number of columns\n    int k = opt<int>(\"k\");        // number of queries\n    string type = opt<string>(\"type\", \"random\");\n\n    // 1) Generate the table\n    //    Depending on 'type', fill the table differently.\n    vector<vector<int>> table(n, vector<int>(m));\n\n    if (type == \"allzero\") {\n        // All zeros\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                table[i][j] = 0;\n            }\n        }\n    }\n    else if (type == \"allmax\") {\n        // All 10^6\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                table[i][j] = 1000000;\n            }\n        }\n    }\n    else if (type == \"smallfix\") {\n        // If n and m are small, fill with a simple pattern.\n        // If n, m are large, we just do a random fallback.\n        if (n <= 5 && m <= 5) {\n            // Fill a small pattern\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    table[i][j] = cnt++;\n                }\n            }\n        } else {\n            // fallback to random\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    table[i][j] = rnd.next(0, 1000000);\n                }\n            }\n        }\n    }\n    else if (type == \"inc\") {\n        // a[i][j] = i*m + j\n        // Cap if it exceeds 10^6 to be safe, though typically i*m+j won't exceed 10^6 unless n*m is large.\n        // We'll still just do min(i*m + j, 10^6).\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                long long val = 1LL * i * m + j;\n                if (val > 1000000) val = 1000000;\n                table[i][j] = (int)val;\n            }\n        }\n    }\n    else {\n        // default = \"random\"\n        // random in [0..10^6]\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                table[i][j] = rnd.next(0, 1000000);\n            }\n        }\n    }\n\n    // 2) Print n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // 3) Output the table\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            printf(\"%d%c\", table[i][j], (j+1==m ? '\\n' : ' '));\n        }\n    }\n\n    // 4) Generate queries.\n    //    We'll create a random mix of 'r', 'c', 'g' queries unless 'smallfix' suggests a pattern.\n    //    In all cases, we ensure indices are valid and respect constraints (distinct x,y for r/c).\n\n    auto genDistinct = [&](int lim) {\n        // Generate a distinct pair (x,y), both in [1..lim], x != y.\n        // x and y in different order is relevant to 'r' or 'c'.\n        int x = rnd.next(1, lim);\n        int y = rnd.next(1, lim);\n        while (y == x) {\n            y = rnd.next(1, lim);\n        }\n        return make_pair(x, y);\n    };\n\n    if (type == \"smallfix\" && n <= 5 && m <= 5) {\n        // In \"smallfix\" with tiny table, let's systematically produce queries:\n        //   - a few row swaps, a few col swaps, then get from corners\n        // Ensuring k doesn't exceed 20 if user gave something small.\n        // If k is large, we'll fill the rest with random queries.\n\n        int baseOps = min(k, 10); // number of systematic ops\n        // 2 row-swaps, 2 col-swaps\n        int opsUsed = 0;\n        // Row-swap #1\n        if (n >= 2 && opsUsed < baseOps) {\n            printf(\"r 1 2\\n\");\n            opsUsed++;\n        }\n        // Col-swap #1\n        if (m >= 2 && opsUsed < baseOps) {\n            printf(\"c 1 2\\n\");\n            opsUsed++;\n        }\n        // Row-swap #2\n        if (n >= 2 && opsUsed < baseOps) {\n            printf(\"r %d %d\\n\", n, max(1, n-1)); // swirl last two\n            opsUsed++;\n        }\n        // Col-swap #2\n        if (m >= 2 && opsUsed < baseOps) {\n            printf(\"c %d %d\\n\", m, max(1, m-1));\n            opsUsed++;\n        }\n        // Some get queries from corners if possible\n        if (opsUsed < baseOps) { // top-left\n            printf(\"g 1 1\\n\");\n            opsUsed++;\n        }\n        if (opsUsed < baseOps && n>=2 && m>=2) { // bottom-right\n            printf(\"g %d %d\\n\", n, m);\n            opsUsed++;\n        }\n\n        // Fill the rest (if any) with random\n        for (int i = opsUsed; i < k; i++) {\n            int t = rnd.next(3); // 0->r, 1->c, 2->g\n            if (t == 0 && n > 1) {\n                // row swap\n                auto [x, y] = genDistinct(n);\n                printf(\"r %d %d\\n\", x, y);\n            } else if (t == 1 && m > 1) {\n                // col swap\n                auto [x, y] = genDistinct(m);\n                printf(\"c %d %d\\n\", x, y);\n            } else {\n                // get\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                printf(\"g %d %d\\n\", x, y);\n            }\n        }\n    }\n    else {\n        // For other types, produce a random mixture:\n        // Let's do 30% row swap, 30% col swap, 40% get\n        // (If n=1 or m=1, row-swap or col-swap might be impossible, so we adapt.)\n\n        for (int i = 0; i < k; i++) {\n            int choice = rnd.next(100); // 0..99\n            // If we can't do a row swap or col swap (e.g. n=1 or m=1), skip to \"get\".\n            bool canRowSwap = (n >= 2);\n            bool canColSwap = (m >= 2);\n\n            if (choice < 30 && canRowSwap) {\n                // row swap\n                auto [x, y] = genDistinct(n);\n                printf(\"r %d %d\\n\", x, y);\n            }\n            else if (choice < 60 && canColSwap) {\n                // col swap\n                auto [x, y] = genDistinct(m);\n                printf(\"c %d %d\\n\", x, y);\n            }\n            else {\n                // get\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                printf(\"g %d %d\\n\", x, y);\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are ~20 DISTINCT example commands to produce a variety of test cases.\n# Each command prints exactly one test, according to the specified parameters.\n# You do NOT need to redirect outputs to files here.\n\n# Small sizes, test pattern-based generation\n./gen -n 1 -m 1 -k 1 -type random\n./gen -n 2 -m 2 -k 5 -type smallfix\n./gen -n 5 -m 5 -k 10 -type smallfix\n./gen -n 5 -m 5 -k 10 -type random\n\n# Tests with \"allzero\" or \"allmax\" tables\n./gen -n 3 -m 4 -k 5 -type allzero\n./gen -n 4 -m 5 -k 5 -type allmax\n\n# Medium sizes\n./gen -n 10 -m 10 -k 30 -type random\n./gen -n 10 -m 10 -k 30 -type inc\n./gen -n 37 -m 41 -k 100 -type random\n./gen -n 50 -m 50 -k 200 -type random\n\n# Larger sizes\n./gen -n 100 -m 100 -k 1000 -type inc\n./gen -n 200 -m 200 -k 2000 -type random\n./gen -n 300 -m 300 -k 2000 -type allzero\n./gen -n 500 -m 500 -k 5000 -type allmax\n\n# Stressing row swaps more (but still random distribution in code)\n./gen -n 999 -m 10 -k 2000 -type random\n./gen -n 10 -m 999 -k 2000 -type random\n\n# Very large n, m, moderate k\n./gen -n 1000 -m 1000 -k 1000 -type inc\n\n# Very large n, m, and large k\n./gen -n 1000 -m 1000 -k 500000 -type random\n\n# Additional diverse shapes\n./gen -n 1 -m 1000 -k 500 -type random\n./gen -n 1000 -m 1 -k 500 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:13.941541",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "222/C",
      "title": "C. Reducing Fractions",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains two space-separated integers n, m (1 ≤ n, m ≤ 105) that show how many numbers the first set (the numerator) and the second set (the denominator) contain, correspondingly.The second line contains n space-separated integers: a1, a2, ..., an (1 ≤ ai ≤ 107) — the numbers that are multiplied to produce the numerator.The third line contains m space-separated integers: b1, b2, ..., bm (1 ≤ bi ≤ 107) — the numbers that are multiplied to produce the denominator.",
      "output_spec": "OutputPrint the answer to the problem in the form, similar to the form of the input data. The number of values in the sets you print nout, mout must satisfy the inequality 1 ≤ nout, mout ≤ 105, and the actual values in the sets aout, i and bout, i must satisfy the inequality 1 ≤ aout, i, bout, i ≤ 107. Separate the values in the lines by spaces. The printed fraction must be reduced, that is, there mustn't be such integer x (x > 1), that the numerator and the denominator of the printed fraction are divisible by x. If there are several matching answers, print any of them.",
      "sample_tests": "ExamplesInputCopy3 2100 5 250 10OutputCopy2 32 11 1 1InputCopy4 32 5 10 20100 1 3OutputCopy1 1203",
      "description": "C. Reducing Fractions\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains two space-separated integers n, m (1 ≤ n, m ≤ 105) that show how many numbers the first set (the numerator) and the second set (the denominator) contain, correspondingly.The second line contains n space-separated integers: a1, a2, ..., an (1 ≤ ai ≤ 107) — the numbers that are multiplied to produce the numerator.The third line contains m space-separated integers: b1, b2, ..., bm (1 ≤ bi ≤ 107) — the numbers that are multiplied to produce the denominator.\n\nOutputPrint the answer to the problem in the form, similar to the form of the input data. The number of values in the sets you print nout, mout must satisfy the inequality 1 ≤ nout, mout ≤ 105, and the actual values in the sets aout, i and bout, i must satisfy the inequality 1 ≤ aout, i, bout, i ≤ 107. Separate the values in the lines by spaces. The printed fraction must be reduced, that is, there mustn't be such integer x (x > 1), that the numerator and the denominator of the printed fraction are divisible by x. If there are several matching answers, print any of them.\n\nInputCopy3 2100 5 250 10OutputCopy2 32 11 1 1InputCopy4 32 5 10 20100 1 3OutputCopy1 1203\n\nInputCopy3 2100 5 250 10\n\nOutputCopy2 32 11 1 1\n\nInputCopy4 32 5 10 20100 1 3\n\nOutputCopy1 1203\n\nNoteIn the first test sample the numerator equals 1000, the denominator equals 500. If we reduce fraction 1000/500 by the greatest common divisor of the numerator and the denominator (by 500), we obtain fraction 2/1.In the second test sample the numerator equals 2000, the denominator equals 300. If we reduce fraction 2000/300 by the greatest common divisor of the numerator and the denominator (by 100), we obtain fraction 20/3.",
      "solutions": [
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces",
          "content": "Hello everybody!Today, Codeforces Round #137 for the Second Division Participants will take place. As usual, all other interested persons can take part in it. The problems have been developed by a group of authors from Vladivostok: Ilya Zban (izban), Alexey Evsyukov (aevsyukov), Zakhar Voit (zakharvoit).Gerald Agapov (Gerald) has greatly contributed as well and we thank him for it. The translation of the problems has been done by Maria Belova (Delinur) — thanks to her! We are also grateful to Pavel Kunyavskiy (PavelKunyavskiy), who has help us in the preparation of the contest.We hope you will have fun and like this round. The points distribution will be standard (500 — 1000 — 1500 — 2000 — 2500).Good luck to everybody!UPD: The start will be 15 minutes later due to technical reasons, we apologize.UPD2: Congratulation to winners!In second division:1: zxl07142: resodo3: mugurelionut4: hmspmy0775: CCC6: white_rich_beautiful7: loveSakura8: gcwtft8279: yuxingdubai10: b821213In first division:1: navi2: Shik3: SteamTurbineUPD3: The editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5248",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1064
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces",
          "content": "Problem A:Note that the k-th element is copied to the end. Then the (k+1)-th element from the initial sequence is copied, then (k+2)-th, … , n-th, k-th, (k+1)-th, etc. So all the numbers on the blackboard will become equal if and only if all the numbers from the k-th to the n-th in the initial sequence were equal. It's now also obvious that the number of operations needed for it is equal to the index of the last number that is not equal to the n-th element of the initial sequence, because it's exactly the number of deletions needed to eliminate the elements that are not equal to the last one. If this number is greater than k, than answer is -1. Complexity — O(n).Problem B:Let’s store the order of the rows and columns of table. Thus, row[x] is the number of the row x in the initial table and column[x] is the number of column x in the initial table. Then, the value of an element in the row x and column y in the current table is equal to t[row[x], column[y]], where t — initial table. When we get the update request, we need to swap the x-th element and the y-th element in the corresponding array. Complexity — O(n * m + k).Problem C:Let's factorize the numerator and denominator. Now for each prime integer x we know the extent of x in the factorization of the numerator(a[x]) and the denominator(b[x]). For each prime number x we can calculate the extent of x in the factorization of the numerator and the denominator after reduction : newa[x]=a[x]-min(a[x], b[x]), newb[x]=b[x]-min(a[x],b[x]). We have the numerator and the denominator of the answer in factorized form. Now we have to bring them into the form which is required in the condition. One of the ways to do it is to note that the fraction from the statement satisfies the conditions. We can factorize it again and in the answer we will have the same fraction for which there will not be such a prime x so that the degree of x in answer would be greater than newa[x] or newb[x]. (This operation can be called reduction) The result will satisfy the condition and the fraction will be equal to the required number. If you try to build answer greedily (put factors in the answer till their product <= 10^7), the count of numbers in the answer (n_out or m_out) will be bigger than 10^5. Factorization by O(sqrt(max)) received TL. You should have found a faster way. For example you could have used linear sieve of Eratosthenes. Complexity — O(max + n * log(max)). log(max) is size of factorization.Problem D:First of all, note that in any case the best place which Vasya can take is the first place for he can earn maximum points. Now we must find the worst place which Vasya can take. We need to find maximal matching in bipartite graph, where the edge between vertice i from the first part and vertice j from the second part exists if a[i] + b[j] >= x. To solve this task, it is enough just to sort the vertices in both parts of the graph by their weights and use two pointers method. Suppose that we have sorted all the vertices by non-increasing points (a1 >= a2 >= ... >= an). Let's take two pointers — L = 1 in the first part and R = N in the second part. While a[L] + b[R] < x we must decrease R to find the first vertice such a[L] + b[R] >= x. When we found such R, we must add this edge to the answer, i.e. increase the answer, increase L by 1, decrease R by 1. It is easy to show why this algo is correct and it finds the optimal solution. I have discovered a truly marvelous proof of this, but the margins of this analysis are too narrow to for him. Complexity — O(N log N) for sorting and O(N) for two pointers.Problem E:1) Solution with complexity O(n*m*m), using the dynamic programming: State — d[n][m] — the number of allowed chains of length n that ends in symbol m. Transition — sort out all possible characters, and check if you can put the symbol k after symbol m.2) Solution with complexity O(m*m*m*log n): Note that the transition in the first solution is always the same. So we can make the transition matrix A of size MxM. If j-th symbol can follow i-th then A[i][j]=1 else A[i][j]=0. Define a vector of size 1хМ b={1,1,…,1}. We can see that b * a^(n-1) = answer. Now we can use fast exponentiation for computing a^(n-1). We should consider the case with n=1 separately. The answer is the sum of numbers in the vector ans. Complexity — O(m^3) from matrix multiplication and O(log n) from fast exponentiation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5251",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4403
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 1",
          "code": "if (a >= 'A' && a <= 'Z') a -= 'A' + 26;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 2",
          "code": "if (a >= 'A' && a <= 'Z') a -= 'A' + 26;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 1",
          "code": "1 2 3\n1 2\nc 1 2\ng 1 1\ng 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 2",
          "code": "1 2 3\n1 2\nc 1 2\ng 1 1\ng 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 10000000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 10000000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 10000000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 10000000 + 1;\nvector<int> spf(MAXN); // Smallest prime factor\n\nvoid computeSPF() {\n    for (int i = 2; i < MAXN; ++i) {\n        if (spf[i] == 0) {\n            for (int j = i; j < MAXN; j += i) {\n                if (spf[j] == 0)\n                    spf[j] = i;\n            }\n        }\n    }\n}\n\nmap<int, long long> factorize(int num) {\n    map<int, long long> factors;\n    while (num > 1) {\n        int p = spf[num];\n        factors[p]++;\n        num /= p;\n    }\n    return factors;\n}\n\nvoid addFactors(map<int, long long>& totalFactors, const map<int, long long>& factors, int sign) {\n    for (auto& f : factors) {\n        totalFactors[f.first] += sign * f.second;\n    }\n}\n\nvoid processNumbers(InStream& stream, int count, map<int, long long>& totalFactors, int sign) {\n    for (int i = 0; i < count; ++i) {\n        int num = stream.readInt(1, 10000000, \"number\");\n        map<int, long long> factors = factorize(num);\n        addFactors(totalFactors, factors, sign);\n    }\n}\n\nmap<int, long long> readAndProcessFraction(InStream& stream) {\n    int n = stream.readInt(1, 100000, \"n\");\n    int m = stream.readInt(1, 100000, \"m\");\n    map<int, long long> totalFactors;\n    processNumbers(stream, n, totalFactors, +1); // Numerator\n    processNumbers(stream, m, totalFactors, -1); // Denominator\n\n    // Cancel out common factors\n    map<int, long long> reducedFactors;\n    for (auto& f : totalFactors) {\n        if (f.second != 0) {\n            reducedFactors[f.first] = f.second;\n        }\n    }\n    return reducedFactors;\n}\n\nbool isReduced(const map<int, long long>& factors) {\n    // If any prime factor appears in both numerator and denominator,\n    // after cancellation, it should not be present.\n    for (auto& f : factors) {\n        if (f.second != 0) {\n            return true; // Fraction is reduced\n        }\n    }\n    return false; // Fraction is 1/1\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    computeSPF();\n\n    // Read input fraction and compute reduced factors\n    int n = inf.readInt(1, 100000, \"n\");\n    int m = inf.readInt(1, 100000, \"m\");\n    map<int, long long> inputFactors;\n    processNumbers(inf, n, inputFactors, +1); // Numerator\n    processNumbers(inf, m, inputFactors, -1); // Denominator\n\n    // Cancel out common factors in input fraction\n    map<int, long long> inputReducedFactors;\n    for (auto& f : inputFactors) {\n        if (f.second != 0) {\n            inputReducedFactors[f.first] = f.second;\n        }\n    }\n\n    // Read participant's output fraction and compute reduced factors\n    map<int, long long> outputFactors = readAndProcessFraction(ouf);\n\n    // Ensure the participant's fraction is reduced\n    for (auto& f : outputFactors) {\n        if (f.second > 0) {\n            // Prime appears in numerator\n            if (outputFactors.count(f.first) && outputFactors[f.first] < 0) {\n                quitf(_wa, \"Fraction is not reduced, prime factor %d appears in both numerator and denominator\", f.first);\n            }\n        } else if (f.second < 0) {\n            // Prime appears in denominator\n            if (outputFactors.count(f.first) && outputFactors[f.first] > 0) {\n                quitf(_wa, \"Fraction is not reduced, prime factor %d appears in both numerator and denominator\", f.first);\n            }\n        }\n    }\n\n    // Compare inputReducedFactors and outputFactors\n    if (inputReducedFactors != outputFactors) {\n        quitf(_wa, \"Your fraction does not match the reduced fraction of the input\");\n    }\n\n    quitf(_ok, \"Correct solution\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_ai = opt<int>(\"max_ai\", 10000000);  // default 1e7\n    int max_bi = opt<int>(\"max_bi\", 10000000);  // default 1e7\n\n    vector<int> a(n), b(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, max_bi);\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_ai;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, max_bi);\n        }\n    } else if (type == \"max_bi\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = max_bi;\n        }\n    } else if (type == \"large_gcd\") {\n        // Generate numbers such that numerator and denominator share a large GCD\n        int gcd_value = rnd.next(1000000, 10000000); // GCD in range [1e6,1e7]\n        for (int i = 0; i < n; ++i) {\n            a[i] = gcd_value * rnd.next(1, max_ai / gcd_value);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = gcd_value * rnd.next(1, max_bi / gcd_value);\n        }\n    } else if (type == \"coprime\") {\n        // Generate numbers such that numerator and denominator are coprime\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2, max_ai/2) * 2; // Even numbers\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(2, max_bi/2) * 2 + 1; // Odd numbers\n        }\n    } else if (type == \"equal\") {\n        // Numerator and denominator products are equal\n        int total = n + m;\n        vector<int> values(total);\n        for (int i = 0; i < total; ++i) {\n            values[i] = rnd.next(1, max_ai);\n        }\n        // Shuffle and divide into a and b\n        shuffle(values.begin(), values.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = values[i];\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = values[n + i];\n        }\n    } else if (type == \"min_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, max_bi);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], (i == m - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_ai = opt<int>(\"max_ai\", 10000000);  // default 1e7\n    int max_bi = opt<int>(\"max_bi\", 10000000);  // default 1e7\n\n    vector<int> a(n), b(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, max_bi);\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_ai;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, max_bi);\n        }\n    } else if (type == \"max_bi\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = max_bi;\n        }\n    } else if (type == \"large_gcd\") {\n        // Generate numbers such that numerator and denominator share a large GCD\n        int gcd_value = rnd.next(1000000, 10000000); // GCD in range [1e6,1e7]\n        for (int i = 0; i < n; ++i) {\n            a[i] = gcd_value * rnd.next(1, max_ai / gcd_value);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = gcd_value * rnd.next(1, max_bi / gcd_value);\n        }\n    } else if (type == \"coprime\") {\n        // Generate numbers such that numerator and denominator are coprime\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2, max_ai/2) * 2; // Even numbers\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(2, max_bi/2) * 2 + 1; // Odd numbers\n        }\n    } else if (type == \"equal\") {\n        // Numerator and denominator products are equal\n        int total = n + m;\n        vector<int> values(total);\n        for (int i = 0; i < total; ++i) {\n            values[i] = rnd.next(1, max_ai);\n        }\n        // Shuffle and divide into a and b\n        shuffle(values.begin(), values.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = values[i];\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = values[n + i];\n        }\n    } else if (type == \"min_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, max_bi);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], (i == m - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random data\n./gen -n 1 -m 1 -type random\n./gen -n 10 -m 10 -type random\n\n# Maximum size random data\n./gen -n 100000 -m 100000 -type random\n\n# Maximum ai, random bi\n./gen -n 100000 -m 100000 -type max_ai\n\n# Random ai, maximum bi\n./gen -n 100000 -m 100000 -type max_bi\n\n# All ai and bi are minimum values (1)\n./gen -n 100000 -m 100000 -type min_values\n\n# Large GCD between numerator and denominator\n./gen -n 100000 -m 100000 -type large_gcd\n\n# Numerator and denominator are coprime\n./gen -n 100000 -m 100000 -type coprime\n\n# Numerator and denominator are equal\n./gen -n 50000 -m 50000 -type equal\n\n# n = 1, m = 1\n./gen -n 1 -m 1 -type random\n\n# n = maximum, m = 1\n./gen -n 100000 -m 1 -type random\n\n# n = 1, m = maximum\n./gen -n 1 -m 100000 -type random\n\n# Max ai and bi\n./gen -n 100000 -m 100000 -type random -max_ai 10000000 -max_bi 10000000\n\n# Min ai and bi\n./gen -n 100000 -m 100000 -type random -max_ai 1 -max_bi 1\n\n# Small values of ai and bi\n./gen -n 100000 -m 100000 -type random -max_ai 10 -max_bi 10\n\n# All ai = max_ai\n./gen -n 100000 -m 100000 -type max_ai -max_ai 10000000\n\n# All bi = max_bi\n./gen -n 100000 -m 100000 -type max_bi -max_bi 10000000\n\n# Large GCD with specific gcd_value\n./gen -n 100000 -m 100000 -type large_gcd\n\n# Coprime with small values\n./gen -n 100000 -m 100000 -type coprime -max_ai 1000 -max_bi 1000\n\n# Equal numerator and denominator with small n and m\n./gen -n 5 -m 5 -type equal\n\n# Equal numerator and denominator with large n and m\n./gen -n 50000 -m 50000 -type equal\n\n# Random data with n = 1\n./gen -n 1 -m 1000 -type random\n\n# Random data with m = 1\n./gen -n 1000 -m 1 -type random\n\n# Random data with maximum ai and bi values\n./gen -n 100000 -m 100000 -type random -max_ai 10000000 -max_bi 10000000\n\n# Varying n and m\n./gen -n 12345 -m 54321 -type random\n\n# Large values but small counts\n./gen -n 100 -m 100 -type random -max_ai 10000000 -max_bi 10000000\n\n# Large counts but small values\n./gen -n 100000 -m 100000 -type random -max_ai 100 -max_bi 100\n\n# Edge case: n and m are different\n./gen -n 99999 -m 100000 -type random\n\n# Edge case: ai's and bi's are all ones except one large number\n./gen -n 99999 -m 99999 -type random -max_ai 1 -max_bi 1\n\n# Edge case: ai's are ones, bi's are maximum\n./gen -n 100000 -m 100000 -type random -max_ai 1 -max_bi 10000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:15.841077",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "222/D",
      "title": "D. Olympiad",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.",
      "output_spec": "OutputPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.",
      "sample_tests": "ExamplesInputCopy5 21 1 1 1 11 1 1 1 1OutputCopy1 5InputCopy6 74 3 5 6 4 48 6 0 4 3 4OutputCopy1 5",
      "description": "D. Olympiad\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\nOutputPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\nInputCopy5 21 1 1 1 11 1 1 1 1OutputCopy1 5InputCopy6 74 3 5 6 4 48 6 0 4 3 4OutputCopy1 5\n\nInputCopy5 21 1 1 1 11 1 1 1 1\n\nOutputCopy1 5\n\nInputCopy6 74 3 5 6 4 48 6 0 4 3 4\n\nOutputCopy1 5\n\nNoteIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.",
      "solutions": [
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces",
          "content": "Hello everybody!Today, Codeforces Round #137 for the Second Division Participants will take place. As usual, all other interested persons can take part in it. The problems have been developed by a group of authors from Vladivostok: Ilya Zban (izban), Alexey Evsyukov (aevsyukov), Zakhar Voit (zakharvoit).Gerald Agapov (Gerald) has greatly contributed as well and we thank him for it. The translation of the problems has been done by Maria Belova (Delinur) — thanks to her! We are also grateful to Pavel Kunyavskiy (PavelKunyavskiy), who has help us in the preparation of the contest.We hope you will have fun and like this round. The points distribution will be standard (500 — 1000 — 1500 — 2000 — 2500).Good luck to everybody!UPD: The start will be 15 minutes later due to technical reasons, we apologize.UPD2: Congratulation to winners!In second division:1: zxl07142: resodo3: mugurelionut4: hmspmy0775: CCC6: white_rich_beautiful7: loveSakura8: gcwtft8279: yuxingdubai10: b821213In first division:1: navi2: Shik3: SteamTurbineUPD3: The editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5248",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1064
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces",
          "content": "Problem A:Note that the k-th element is copied to the end. Then the (k+1)-th element from the initial sequence is copied, then (k+2)-th, … , n-th, k-th, (k+1)-th, etc. So all the numbers on the blackboard will become equal if and only if all the numbers from the k-th to the n-th in the initial sequence were equal. It's now also obvious that the number of operations needed for it is equal to the index of the last number that is not equal to the n-th element of the initial sequence, because it's exactly the number of deletions needed to eliminate the elements that are not equal to the last one. If this number is greater than k, than answer is -1. Complexity — O(n).Problem B:Let’s store the order of the rows and columns of table. Thus, row[x] is the number of the row x in the initial table and column[x] is the number of column x in the initial table. Then, the value of an element in the row x and column y in the current table is equal to t[row[x], column[y]], where t — initial table. When we get the update request, we need to swap the x-th element and the y-th element in the corresponding array. Complexity — O(n * m + k).Problem C:Let's factorize the numerator and denominator. Now for each prime integer x we know the extent of x in the factorization of the numerator(a[x]) and the denominator(b[x]). For each prime number x we can calculate the extent of x in the factorization of the numerator and the denominator after reduction : newa[x]=a[x]-min(a[x], b[x]), newb[x]=b[x]-min(a[x],b[x]). We have the numerator and the denominator of the answer in factorized form. Now we have to bring them into the form which is required in the condition. One of the ways to do it is to note that the fraction from the statement satisfies the conditions. We can factorize it again and in the answer we will have the same fraction for which there will not be such a prime x so that the degree of x in answer would be greater than newa[x] or newb[x]. (This operation can be called reduction) The result will satisfy the condition and the fraction will be equal to the required number. If you try to build answer greedily (put factors in the answer till their product <= 10^7), the count of numbers in the answer (n_out or m_out) will be bigger than 10^5. Factorization by O(sqrt(max)) received TL. You should have found a faster way. For example you could have used linear sieve of Eratosthenes. Complexity — O(max + n * log(max)). log(max) is size of factorization.Problem D:First of all, note that in any case the best place which Vasya can take is the first place for he can earn maximum points. Now we must find the worst place which Vasya can take. We need to find maximal matching in bipartite graph, where the edge between vertice i from the first part and vertice j from the second part exists if a[i] + b[j] >= x. To solve this task, it is enough just to sort the vertices in both parts of the graph by their weights and use two pointers method. Suppose that we have sorted all the vertices by non-increasing points (a1 >= a2 >= ... >= an). Let's take two pointers — L = 1 in the first part and R = N in the second part. While a[L] + b[R] < x we must decrease R to find the first vertice such a[L] + b[R] >= x. When we found such R, we must add this edge to the answer, i.e. increase the answer, increase L by 1, decrease R by 1. It is easy to show why this algo is correct and it finds the optimal solution. I have discovered a truly marvelous proof of this, but the margins of this analysis are too narrow to for him. Complexity — O(N log N) for sorting and O(N) for two pointers.Problem E:1) Solution with complexity O(n*m*m), using the dynamic programming: State — d[n][m] — the number of allowed chains of length n that ends in symbol m. Transition — sort out all possible characters, and check if you can put the symbol k after symbol m.2) Solution with complexity O(m*m*m*log n): Note that the transition in the first solution is always the same. So we can make the transition matrix A of size MxM. If j-th symbol can follow i-th then A[i][j]=1 else A[i][j]=0. Define a vector of size 1хМ b={1,1,…,1}. We can see that b * a^(n-1) = answer. Now we can use fast exponentiation for computing a^(n-1). We should consider the case with n=1 separately. The answer is the sum of numbers in the vector ans. Complexity — O(m^3) from matrix multiplication and O(log n) from fast exponentiation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5251",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4403
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 1",
          "code": "if (a >= 'A' && a <= 'Z') a -= 'A' + 26;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 2",
          "code": "if (a >= 'A' && a <= 'Z') a -= 'A' + 26;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 1",
          "code": "1 2 3\n1 2\nc 1 2\ng 1 1\ng 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 2",
          "code": "1 2 3\n1 2\nc 1 2\ng 1 1\ng 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 200000, \"x\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 0, 100000, \"a\");\n    inf.readEoln();\n    \n    vector<int> b = inf.readInts(n, 0, 100000, \"b\");\n    inf.readEoln();\n    \n    int max_a = *max_element(a.begin(), a.end());\n    int max_b = *max_element(b.begin(), b.end());\n    \n    ensuref(max_a + max_b >= x, \"No pair (a_i, b_j) such that a_i (%d) + b_j (%d) >= x (%d)\", max_a, max_b, x);\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 200000, \"x\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 0, 100000, \"a\");\n    inf.readEoln();\n    \n    vector<int> b = inf.readInts(n, 0, 100000, \"b\");\n    inf.readEoln();\n    \n    int max_a = *max_element(a.begin(), a.end());\n    int max_b = *max_element(b.begin(), b.end());\n    \n    ensuref(max_a + max_b >= x, \"No pair (a_i, b_j) such that a_i (%d) + b_j (%d) >= x (%d)\", max_a, max_b, x);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 200000, \"x\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 0, 100000, \"a\");\n    inf.readEoln();\n    \n    vector<int> b = inf.readInts(n, 0, 100000, \"b\");\n    inf.readEoln();\n    \n    int max_a = *max_element(a.begin(), a.end());\n    int max_b = *max_element(b.begin(), b.end());\n    \n    ensuref(max_a + max_b >= x, \"No pair (a_i, b_j) such that a_i (%d) + b_j (%d) >= x (%d)\", max_a, max_b, x);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator.\n    // Do NOT set any manual seed. This is done behind the scenes by testlib. \n    registerGen(argc, argv, 1);\n\n    // Read parameters from the command line.\n    // \"n\" : number of participants\n    // \"x\" : the minimum number of points Vasya earned\n    // \"type\" : the pattern to generate, default is \"random\"\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    /*\n      We need to output:\n      1) One line containing n and x\n      2) One line containing n integers a_1..a_n (the first-tour scores)\n      3) One line containing n integers b_1..b_n (the second-tour scores)\n\n      Constraints:\n      1 <= n <= 100000\n      0 <= x <= 200000\n      0 <= a_i, b_i <= 100000\n      It is guaranteed (by how we construct the data) that there exists\n      at least one pair (i, j) with a_i + b_j >= x.\n    */\n\n    // Prepare arrays for the first and second tour scores.\n    vector<int> A(n), B(n);\n\n    // A small helper function to ensure we have at least one pair with sum >= x\n    // We'll specifically set A[0] and B[0] so that A[0] + B[0] >= x if possible.\n    // Then for the rest, we'll fill according to the \"type\".\n\n    auto ensureVasya = [&](int xVal){\n        // We only need to fix A[0] and B[0].\n        // If xVal <= 100000, we can set A[0] = xVal, B[0] = 0.\n        // Else if xVal <= 200000, we can set A[0] = 100000, B[0] = xVal - 100000.\n        // We know xVal won't exceed 200k by problem constraints.\n        // Then clamp to <= 100000 just in case.\n        if(xVal <= 100000) {\n            A[0] = xVal;\n            B[0] = 0;\n        } else {\n            int leftover = xVal - 100000;\n            // leftover at most 100000\n            B[0] = min(leftover, 100000);\n            A[0] = 100000;\n        }\n    };\n\n    // Strategy per type:\n    //   \"allzero\": all scores are zero if x=0. Otherwise, handle with caution.\n    //   \"maxscores\": fill all with 100000, guaranteeing sums up to 200000.\n    //   \"randomsmall\": fill with random from [0..10], forcing duplicates and small range.\n    //   \"randomlarge\": fill with random from [0..100000].\n    //   \"onesidebig\": make all A small, all B big (or vice versa).\n    //   \"halfsplit\": half participants have large A, half have large B, etc.\n    // By default, \"random\" means random from [0..100000].\n\n    if(type == \"allzero\"){\n        // If x>0, it's impossible to have a pair with sum >= x if everything is zero.\n        // We can forcibly fix A[0] + B[0] >= x, but that would break \"allzero.\"\n        // So \"allzero\" logically only works with x=0.\n        // We'll proceed to produce  all zeros if x=0.\n        // If x>0, let's just revert to a random generator that meets x. \n        if(x == 0){\n            for(int i = 0; i < n; i++){\n                A[i] = 0;\n                B[i] = 0;\n            }\n        } else {\n            // revert to random if x>0\n            ensureVasya(x);\n            for(int i = 1; i < n; i++){\n                A[i] = rnd.next(101000) % 100001; \n                B[i] = rnd.next(101000) % 100001; \n            }\n        }\n    }\n    else if(type == \"maxscores\"){\n        // Everyone has A[i] = 100000, B[i] = 100000\n        // Then sum is 200000 for everyone, definitely >= x up to 200000\n        for(int i = 0; i < n; i++){\n            A[i] = 100000;\n            B[i] = 100000;\n        }\n    }\n    else if(type == \"randomsmall\"){\n        // Let’s ensure A[0]+B[0] >= x, then fill the rest random in [0..10]\n        ensureVasya(x);\n        for(int i = 1; i < n; i++){\n            A[i] = rnd.next(11); // 0..10\n            B[i] = rnd.next(11); // 0..10\n        }\n    }\n    else if(type == \"onesidebig\"){\n        // For instance, let A be very small, B be large\n        // Ensure A[0]+B[0] >= x\n        // Then for i>0, A[i] in [0..10], B[i] in [90000..100000]\n        ensureVasya(x);\n        for(int i = 1; i < n; i++){\n            A[i] = rnd.next(11); // 0..10\n            B[i] = rnd.next(100001 - 90000) + 90000; // 90000..100000\n        }\n    }\n    else if(type == \"halfsplit\"){\n        // half participants have large A, small B\n        // half participants have small A, large B\n        // ensure Vasya\n        ensureVasya(x);\n        for(int i = 1; i < n; i++){\n            if(i < n/2){\n                // large A, small B\n                A[i] = rnd.next(100001 - 90000) + 90000; \n                B[i] = rnd.next(11);\n            } else {\n                // small A, large B\n                A[i] = rnd.next(11);\n                B[i] = rnd.next(100001 - 90000) + 90000;\n            }\n        }\n    }\n    else {\n        // default \"random\" or other unknown type -> full random in [0..100000]\n        ensureVasya(x);\n        for(int i = 1; i < n; i++){\n            A[i] = rnd.next(100001);\n            B[i] = rnd.next(100001);\n        }\n    }\n\n    // Make sure A[0] and B[0] do not exceed 100000 or go below 0.\n    A[0] = max(0, min(A[0], 100000));\n    B[0] = max(0, min(B[0], 100000));\n\n    // Finally, we must print:\n    // 1) n x\n    // 2) n integers: A array\n    // 3) n integers: B array\n\n    cout << n << \" \" << x << \"\\n\";\n    for(int i = 0; i < n; i++){\n        cout << A[i] << (i+1 < n ? ' ' : '\\n');\n    }\n    for(int i = 0; i < n; i++){\n        cout << B[i] << (i+1 < n ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator.\n    // Do NOT set any manual seed. This is done behind the scenes by testlib. \n    registerGen(argc, argv, 1);\n\n    // Read parameters from the command line.\n    // \"n\" : number of participants\n    // \"x\" : the minimum number of points Vasya earned\n    // \"type\" : the pattern to generate, default is \"random\"\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    /*\n      We need to output:\n      1) One line containing n and x\n      2) One line containing n integers a_1..a_n (the first-tour scores)\n      3) One line containing n integers b_1..b_n (the second-tour scores)\n\n      Constraints:\n      1 <= n <= 100000\n      0 <= x <= 200000\n      0 <= a_i, b_i <= 100000\n      It is guaranteed (by how we construct the data) that there exists\n      at least one pair (i, j) with a_i + b_j >= x.\n    */\n\n    // Prepare arrays for the first and second tour scores.\n    vector<int> A(n), B(n);\n\n    // A small helper function to ensure we have at least one pair with sum >= x\n    // We'll specifically set A[0] and B[0] so that A[0] + B[0] >= x if possible.\n    // Then for the rest, we'll fill according to the \"type\".\n\n    auto ensureVasya = [&](int xVal){\n        // We only need to fix A[0] and B[0].\n        // If xVal <= 100000, we can set A[0] = xVal, B[0] = 0.\n        // Else if xVal <= 200000, we can set A[0] = 100000, B[0] = xVal - 100000.\n        // We know xVal won't exceed 200k by problem constraints.\n        // Then clamp to <= 100000 just in case.\n        if(xVal <= 100000) {\n            A[0] = xVal;\n            B[0] = 0;\n        } else {\n            int leftover = xVal - 100000;\n            // leftover at most 100000\n            B[0] = min(leftover, 100000);\n            A[0] = 100000;\n        }\n    };\n\n    // Strategy per type:\n    //   \"allzero\": all scores are zero if x=0. Otherwise, handle with caution.\n    //   \"maxscores\": fill all with 100000, guaranteeing sums up to 200000.\n    //   \"randomsmall\": fill with random from [0..10], forcing duplicates and small range.\n    //   \"randomlarge\": fill with random from [0..100000].\n    //   \"onesidebig\": make all A small, all B big (or vice versa).\n    //   \"halfsplit\": half participants have large A, half have large B, etc.\n    // By default, \"random\" means random from [0..100000].\n\n    if(type == \"allzero\"){\n        // If x>0, it's impossible to have a pair with sum >= x if everything is zero.\n        // We can forcibly fix A[0] + B[0] >= x, but that would break \"allzero.\"\n        // So \"allzero\" logically only works with x=0.\n        // We'll proceed to produce  all zeros if x=0.\n        // If x>0, let's just revert to a random generator that meets x. \n        if(x == 0){\n            for(int i = 0; i < n; i++){\n                A[i] = 0;\n                B[i] = 0;\n            }\n        } else {\n            // revert to random if x>0\n            ensureVasya(x);\n            for(int i = 1; i < n; i++){\n                A[i] = rnd.next(101000) % 100001; \n                B[i] = rnd.next(101000) % 100001; \n            }\n        }\n    }\n    else if(type == \"maxscores\"){\n        // Everyone has A[i] = 100000, B[i] = 100000\n        // Then sum is 200000 for everyone, definitely >= x up to 200000\n        for(int i = 0; i < n; i++){\n            A[i] = 100000;\n            B[i] = 100000;\n        }\n    }\n    else if(type == \"randomsmall\"){\n        // Let’s ensure A[0]+B[0] >= x, then fill the rest random in [0..10]\n        ensureVasya(x);\n        for(int i = 1; i < n; i++){\n            A[i] = rnd.next(11); // 0..10\n            B[i] = rnd.next(11); // 0..10\n        }\n    }\n    else if(type == \"onesidebig\"){\n        // For instance, let A be very small, B be large\n        // Ensure A[0]+B[0] >= x\n        // Then for i>0, A[i] in [0..10], B[i] in [90000..100000]\n        ensureVasya(x);\n        for(int i = 1; i < n; i++){\n            A[i] = rnd.next(11); // 0..10\n            B[i] = rnd.next(100001 - 90000) + 90000; // 90000..100000\n        }\n    }\n    else if(type == \"halfsplit\"){\n        // half participants have large A, small B\n        // half participants have small A, large B\n        // ensure Vasya\n        ensureVasya(x);\n        for(int i = 1; i < n; i++){\n            if(i < n/2){\n                // large A, small B\n                A[i] = rnd.next(100001 - 90000) + 90000; \n                B[i] = rnd.next(11);\n            } else {\n                // small A, large B\n                A[i] = rnd.next(11);\n                B[i] = rnd.next(100001 - 90000) + 90000;\n            }\n        }\n    }\n    else {\n        // default \"random\" or other unknown type -> full random in [0..100000]\n        ensureVasya(x);\n        for(int i = 1; i < n; i++){\n            A[i] = rnd.next(100001);\n            B[i] = rnd.next(100001);\n        }\n    }\n\n    // Make sure A[0] and B[0] do not exceed 100000 or go below 0.\n    A[0] = max(0, min(A[0], 100000));\n    B[0] = max(0, min(B[0], 100000));\n\n    // Finally, we must print:\n    // 1) n x\n    // 2) n integers: A array\n    // 3) n integers: B array\n\n    cout << n << \" \" << x << \"\\n\";\n    for(int i = 0; i < n; i++){\n        cout << A[i] << (i+1 < n ? ' ' : '\\n');\n    }\n    for(int i = 0; i < n; i++){\n        cout << B[i] << (i+1 < n ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# 1) Minimal n and x=0 (all zeros valid)\n./gen -n 1 -x 0 -type allzero\n\n# 2) Minimal n but x>0 (type allzero reverts to random-like)\n./gen -n 1 -x 5 -type allzero\n\n# 3) Very small n, randomsmall\n./gen -n 2 -x 1 -type randomsmall\n\n# 4) Another small random\n./gen -n 5 -x 2 -type random\n\n# 5) Small with halfsplit\n./gen -n 6 -x 5 -type halfsplit\n\n# 6) Moderate n with randomsmall\n./gen -n 10 -x 7 -type randomsmall\n\n# 7) Moderate n with onesidebig\n./gen -n 10 -x 50 -type onesidebig\n\n# 8) n=10, allzero (x=0)\n./gen -n 10 -x 0 -type allzero\n\n# 9) n=10, allzero but x=10 => reverts internally\n./gen -n 10 -x 10 -type allzero\n\n# 10) n=10, maxscores => All participants have 100000 each\n./gen -n 10 -x 150000 -type maxscores\n\n# 11) Medium n=50, random\n./gen -n 50 -x 100 -type random\n\n# 12) Medium n=50, randomsmall\n./gen -n 50 -x 3 -type randomsmall\n\n# 13) Medium n=50, onesidebig\n./gen -n 50 -x 99999 -type onesidebig\n\n# 14) n=100, x near 0\n./gen -n 100 -x 0 -type random\n\n# 15) n=100, x around 50000 (random)\n./gen -n 100 -x 50000 -type random\n\n# 16) n=100, halfsplit\n./gen -n 100 -x 150000 -type halfsplit\n\n# 17) Larger n=1000, random\n./gen -n 1000 -x 100000 -type random\n\n# 18) Larger n=1000, randomsmall\n./gen -n 1000 -x 50 -type randomsmall\n\n# 19) Larger n=1000, onesidebig\n./gen -n 1000 -x 200000 -type onesidebig\n\n# 20) Larger n=5000, maxscores\n./gen -n 5000 -x 200000 -type maxscores\n\n# 21) n=10000, random\n./gen -n 10000 -x 123456 -type random\n\n# 22) n=10000, halfsplit\n./gen -n 10000 -x 200000 -type halfsplit\n\n# 23) n=99999, randomsmall\n./gen -n 99999 -x 0 -type randomsmall\n\n# 24) n=100000, x=200000, max boundary\n./gen -n 100000 -x 200000 -type maxscores\n\n# 25) n=100000, random\n./gen -n 100000 -x 100000 -type random\n\n# 26) n=100000, halfsplit\n./gen -n 100000 -x 150000 -type halfsplit\n\n# 27) n=100000, onesidebig\n./gen -n 100000 -x 200000 -type onesidebig\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:17.936252",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "222/E",
      "title": "E. Decoding Genome",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, m, k (1 ≤ n ≤ 1015, 1 ≤ m ≤ 52, 0 ≤ k ≤ m2).Next k lines contain two characters each, without a space between them, representing a forbidden nucleotide pair. The first character represents the first nucleotide in the forbidden pair, the second character represents the second nucleotide.The nucleotides with assigned numbers from 1 to 26 are represented by English alphabet letters from \"a\" to \"z\" (1 is an \"a\", 2 is a \"b\", ..., 26 is a \"z\"). Nucleotides with assigned numbers from 27 to 52 are represented by English alphabet letters from \"A\" to \"Z\" (27 is an \"A\", 28 is a \"B\", ..., 52 is a \"Z\").It is guaranteed that each forbidden pair occurs at most once in the input. It is guaranteed that nucleotide's numbers in all forbidden pairs cannot be more than m. Note that order is important in nucleotide pairs.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint a single integer — the sought number modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy3 3 2abbaOutputCopy17InputCopy3 3 0OutputCopy27InputCopy2 1 1aaOutputCopy0",
      "description": "E. Decoding Genome\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, m, k (1 ≤ n ≤ 1015, 1 ≤ m ≤ 52, 0 ≤ k ≤ m2).Next k lines contain two characters each, without a space between them, representing a forbidden nucleotide pair. The first character represents the first nucleotide in the forbidden pair, the second character represents the second nucleotide.The nucleotides with assigned numbers from 1 to 26 are represented by English alphabet letters from \"a\" to \"z\" (1 is an \"a\", 2 is a \"b\", ..., 26 is a \"z\"). Nucleotides with assigned numbers from 27 to 52 are represented by English alphabet letters from \"A\" to \"Z\" (27 is an \"A\", 28 is a \"B\", ..., 52 is a \"Z\").It is guaranteed that each forbidden pair occurs at most once in the input. It is guaranteed that nucleotide's numbers in all forbidden pairs cannot be more than m. Note that order is important in nucleotide pairs.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nOutputPrint a single integer — the sought number modulo 1000000007 (109 + 7).\n\nInputCopy3 3 2abbaOutputCopy17InputCopy3 3 0OutputCopy27InputCopy2 1 1aaOutputCopy0\n\nInputCopy3 3 2abba\n\nOutputCopy17\n\nInputCopy3 3 0\n\nOutputCopy27\n\nInputCopy2 1 1aa\n\nOutputCopy0\n\nNoteIn the second test case all possible three-nucleotide DNAs are permitted. Each nucleotide can take one of three values, thus in total there are 27 distinct three nucleotide DNAs.In the third test sample we cannot make any DNA of two nucleotides — the only possible nucleotide \"a\" cannot occur two times consecutively.",
      "solutions": [
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces",
          "content": "Hello everybody!Today, Codeforces Round #137 for the Second Division Participants will take place. As usual, all other interested persons can take part in it. The problems have been developed by a group of authors from Vladivostok: Ilya Zban (izban), Alexey Evsyukov (aevsyukov), Zakhar Voit (zakharvoit).Gerald Agapov (Gerald) has greatly contributed as well and we thank him for it. The translation of the problems has been done by Maria Belova (Delinur) — thanks to her! We are also grateful to Pavel Kunyavskiy (PavelKunyavskiy), who has help us in the preparation of the contest.We hope you will have fun and like this round. The points distribution will be standard (500 — 1000 — 1500 — 2000 — 2500).Good luck to everybody!UPD: The start will be 15 minutes later due to technical reasons, we apologize.UPD2: Congratulation to winners!In second division:1: zxl07142: resodo3: mugurelionut4: hmspmy0775: CCC6: white_rich_beautiful7: loveSakura8: gcwtft8279: yuxingdubai10: b821213In first division:1: navi2: Shik3: SteamTurbineUPD3: The editorial is published.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5248",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1064
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces",
          "content": "Problem A:Note that the k-th element is copied to the end. Then the (k+1)-th element from the initial sequence is copied, then (k+2)-th, … , n-th, k-th, (k+1)-th, etc. So all the numbers on the blackboard will become equal if and only if all the numbers from the k-th to the n-th in the initial sequence were equal. It's now also obvious that the number of operations needed for it is equal to the index of the last number that is not equal to the n-th element of the initial sequence, because it's exactly the number of deletions needed to eliminate the elements that are not equal to the last one. If this number is greater than k, than answer is -1. Complexity — O(n).Problem B:Let’s store the order of the rows and columns of table. Thus, row[x] is the number of the row x in the initial table and column[x] is the number of column x in the initial table. Then, the value of an element in the row x and column y in the current table is equal to t[row[x], column[y]], where t — initial table. When we get the update request, we need to swap the x-th element and the y-th element in the corresponding array. Complexity — O(n * m + k).Problem C:Let's factorize the numerator and denominator. Now for each prime integer x we know the extent of x in the factorization of the numerator(a[x]) and the denominator(b[x]). For each prime number x we can calculate the extent of x in the factorization of the numerator and the denominator after reduction : newa[x]=a[x]-min(a[x], b[x]), newb[x]=b[x]-min(a[x],b[x]). We have the numerator and the denominator of the answer in factorized form. Now we have to bring them into the form which is required in the condition. One of the ways to do it is to note that the fraction from the statement satisfies the conditions. We can factorize it again and in the answer we will have the same fraction for which there will not be such a prime x so that the degree of x in answer would be greater than newa[x] or newb[x]. (This operation can be called reduction) The result will satisfy the condition and the fraction will be equal to the required number. If you try to build answer greedily (put factors in the answer till their product <= 10^7), the count of numbers in the answer (n_out or m_out) will be bigger than 10^5. Factorization by O(sqrt(max)) received TL. You should have found a faster way. For example you could have used linear sieve of Eratosthenes. Complexity — O(max + n * log(max)). log(max) is size of factorization.Problem D:First of all, note that in any case the best place which Vasya can take is the first place for he can earn maximum points. Now we must find the worst place which Vasya can take. We need to find maximal matching in bipartite graph, where the edge between vertice i from the first part and vertice j from the second part exists if a[i] + b[j] >= x. To solve this task, it is enough just to sort the vertices in both parts of the graph by their weights and use two pointers method. Suppose that we have sorted all the vertices by non-increasing points (a1 >= a2 >= ... >= an). Let's take two pointers — L = 1 in the first part and R = N in the second part. While a[L] + b[R] < x we must decrease R to find the first vertice such a[L] + b[R] >= x. When we found such R, we must add this edge to the answer, i.e. increase the answer, increase L by 1, decrease R by 1. It is easy to show why this algo is correct and it finds the optimal solution. I have discovered a truly marvelous proof of this, but the margins of this analysis are too narrow to for him. Complexity — O(N log N) for sorting and O(N) for two pointers.Problem E:1) Solution with complexity O(n*m*m), using the dynamic programming: State — d[n][m] — the number of allowed chains of length n that ends in symbol m. Transition — sort out all possible characters, and check if you can put the symbol k after symbol m.2) Solution with complexity O(m*m*m*log n): Note that the transition in the first solution is always the same. So we can make the transition matrix A of size MxM. If j-th symbol can follow i-th then A[i][j]=1 else A[i][j]=0. Define a vector of size 1хМ b={1,1,…,1}. We can see that b * a^(n-1) = answer. Now we can use fast exponentiation for computing a^(n-1). We should consider the case with n=1 separately. The answer is the sum of numbers in the vector ans. Complexity — O(m^3) from matrix multiplication and O(log n) from fast exponentiation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5251",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4403
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 1",
          "code": "if (a >= 'A' && a <= 'Z') a -= 'A' + 26;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #137 (Div. 2) - Codeforces - Code 2",
          "code": "if (a >= 'A' && a <= 'Z') a -= 'A' + 26;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5248",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 1",
          "code": "1 2 3\n1 2\nc 1 2\ng 1 1\ng 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #137 (Div. 2) - Codeforces - Code 2",
          "code": "1 2 3\n1 2\nc 1 2\ng 1 1\ng 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5251",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint nucleotideNumber(char c) {\n    if('a' <= c && c <= 'z') return c - 'a' + 1;\n    else if('A' <= c && c <= 'Z') return c - 'A' + 27;\n    else return -1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    long long n = inf.readLong(1LL, 1000000000000000LL, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1,52,\"m\");\n    inf.readSpace();\n    int k_max = m * m;\n    int k = inf.readInt(0,k_max,\"k\");\n    inf.readEoln();\n\n    set<pair<int, int> > forbiddenPairs;\n\n    for (int i = 0; i < k; i++) {\n        string s = inf.readLine(\"[a-zA-Z]{2}\", \"forbidden pair\");\n        \n        char c1 = s[0];\n        char c2 = s[1];\n\n        int num1 = nucleotideNumber(c1);\n        int num2 = nucleotideNumber(c2);\n\n        ensuref(num1 != -1, \"Invalid nucleotide '%c' at position 1 in forbidden pair at line %d\", c1, i+2);\n        ensuref(num2 != -1, \"Invalid nucleotide '%c' at position 2 in forbidden pair at line %d\", c2, i+2);\n\n        ensuref(num1 >=1 && num1 <= m, \"First nucleotide in forbidden pair at line %d has number %d which exceeds m %d\", i+2, num1, m);\n        ensuref(num2 >=1 && num2 <= m, \"Second nucleotide in forbidden pair at line %d has number %d which exceeds m %d\", i+2, num2, m);\n\n        pair<int,int> p = make_pair(num1, num2);\n        ensuref(forbiddenPairs.find(p) == forbiddenPairs.end(), \"Forbidden pair occurs more than once at line %d\", i+2);\n        \n        forbiddenPairs.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint nucleotideNumber(char c) {\n    if('a' <= c && c <= 'z') return c - 'a' + 1;\n    else if('A' <= c && c <= 'Z') return c - 'A' + 27;\n    else return -1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    long long n = inf.readLong(1LL, 1000000000000000LL, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1,52,\"m\");\n    inf.readSpace();\n    int k_max = m * m;\n    int k = inf.readInt(0,k_max,\"k\");\n    inf.readEoln();\n\n    set<pair<int, int> > forbiddenPairs;\n\n    for (int i = 0; i < k; i++) {\n        string s = inf.readLine(\"[a-zA-Z]{2}\", \"forbidden pair\");\n        \n        char c1 = s[0];\n        char c2 = s[1];\n\n        int num1 = nucleotideNumber(c1);\n        int num2 = nucleotideNumber(c2);\n\n        ensuref(num1 != -1, \"Invalid nucleotide '%c' at position 1 in forbidden pair at line %d\", c1, i+2);\n        ensuref(num2 != -1, \"Invalid nucleotide '%c' at position 2 in forbidden pair at line %d\", c2, i+2);\n\n        ensuref(num1 >=1 && num1 <= m, \"First nucleotide in forbidden pair at line %d has number %d which exceeds m %d\", i+2, num1, m);\n        ensuref(num2 >=1 && num2 <= m, \"Second nucleotide in forbidden pair at line %d has number %d which exceeds m %d\", i+2, num2, m);\n\n        pair<int,int> p = make_pair(num1, num2);\n        ensuref(forbiddenPairs.find(p) == forbiddenPairs.end(), \"Forbidden pair occurs more than once at line %d\", i+2);\n        \n        forbiddenPairs.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint nucleotideNumber(char c) {\n    if('a' <= c && c <= 'z') return c - 'a' + 1;\n    else if('A' <= c && c <= 'Z') return c - 'A' + 27;\n    else return -1;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    long long n = inf.readLong(1LL, 1000000000000000LL, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1,52,\"m\");\n    inf.readSpace();\n    int k_max = m * m;\n    int k = inf.readInt(0,k_max,\"k\");\n    inf.readEoln();\n\n    set<pair<int, int> > forbiddenPairs;\n\n    for (int i = 0; i < k; i++) {\n        string s = inf.readLine(\"[a-zA-Z]{2}\", \"forbidden pair\");\n        \n        char c1 = s[0];\n        char c2 = s[1];\n\n        int num1 = nucleotideNumber(c1);\n        int num2 = nucleotideNumber(c2);\n\n        ensuref(num1 != -1, \"Invalid nucleotide '%c' at position 1 in forbidden pair at line %d\", c1, i+2);\n        ensuref(num2 != -1, \"Invalid nucleotide '%c' at position 2 in forbidden pair at line %d\", c2, i+2);\n\n        ensuref(num1 >=1 && num1 <= m, \"First nucleotide in forbidden pair at line %d has number %d which exceeds m %d\", i+2, num1, m);\n        ensuref(num2 >=1 && num2 <= m, \"Second nucleotide in forbidden pair at line %d has number %d which exceeds m %d\", i+2, num2, m);\n\n        pair<int,int> p = make_pair(num1, num2);\n        ensuref(forbiddenPairs.find(p) == forbiddenPairs.end(), \"Forbidden pair occurs more than once at line %d\", i+2);\n        \n        forbiddenPairs.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\"); // n can be up to 1e15\n    int m = opt<int>(\"m\"); // m up to 52\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> forbiddenPairs;\n    int k;\n\n    if (type == \"none\") {\n        k = 0;\n    } else if (type == \"maxk\") {\n        k = m * m;\n        // All pairs are forbidden\n        forbiddenPairs.reserve(k);\n        for (int i = 0; i < m; ++i) {\n            char c1;\n            if (i < 26)\n                c1 = 'a' + i;\n            else\n                c1 = 'A' + i - 26;\n            for (int j = 0; j < m; ++j) {\n                char c2;\n                if (j < 26)\n                    c2 = 'a' + j;\n                else\n                    c2 = 'A' + j - 26;\n                string s = \"\";\n                s += c1;\n                s += c2;\n                forbiddenPairs.push_back(s);\n            }\n        }\n    } else if (type == \"self\") {\n        k = m;\n        forbiddenPairs.reserve(k);\n        for (int i = 0; i < m; ++i) {\n            char c;\n            if (i < 26)\n                c = 'a' + i;\n            else\n                c = 'A' + i - 26;\n            string s = \"\";\n            s += c;\n            s += c;\n            forbiddenPairs.push_back(s);\n        }\n    } else if (type == \"onepair\") {\n        k = 1;\n        int i = rnd.next(0, m - 1);\n        int j = rnd.next(0, m - 1);\n        char c1 = (i < 26) ? ('a' + i) : ('A' + i - 26);\n        char c2 = (j < 26) ? ('a' + j) : ('A' + j - 26);\n        string s = \"\";\n        s += c1;\n        s += c2;\n        forbiddenPairs.push_back(s);\n    } else if (type == \"allbutone\") {\n        k = m * m - 1;\n        forbiddenPairs.reserve(k);\n        int except_i = rnd.next(0, m - 1);\n        int except_j = rnd.next(0, m - 1);\n        for (int i = 0; i < m; ++i) {\n            char c1;\n            if (i < 26)\n                c1 = 'a' + i;\n            else\n                c1 = 'A' + i - 26;\n            for (int j = 0; j < m; ++j) {\n                if (i == except_i && j == except_j) continue;\n                char c2;\n                if (j < 26)\n                    c2 = 'a' + j;\n                else\n                    c2 = 'A' + j - 26;\n                string s = \"\";\n                s += c1;\n                s += c2;\n                forbiddenPairs.push_back(s);\n            }\n        }\n    } else if (type == \"random\") {\n        // Random k between 0 and m*m\n        k = rnd.next(0, m * m);\n        forbiddenPairs.reserve(k);\n        set<pair<int, int>> forbiddenSet;\n        while ((int)forbiddenSet.size() < k) {\n            int i = rnd.next(0, m - 1);\n            int j = rnd.next(0, m -1);\n            forbiddenSet.insert(make_pair(i, j));\n        }\n        for (auto& p : forbiddenSet) {\n            int i = p.first;\n            int j = p.second;\n            char c1 = (i < 26) ? ('a' + i) : ('A' + i - 26);\n            char c2 = (j < 26) ? ('a' + j) : ('A' + j - 26);\n            string s = \"\";\n            s += c1;\n            s += c2;\n            forbiddenPairs.push_back(s);\n        }\n    } else if (type == \"chain\") {\n        // Build a chain: forbidden only from i to (i+1)%m\n        k = m;\n        forbiddenPairs.reserve(k);\n        for (int i = 0; i < m; ++i) {\n            int j = (i + 1) % m;\n            char c1 = (i < 26) ? ('a' + i) : ('A' + i - 26);\n            char c2 = (j < 26) ? ('a' + j) : ('A' + j - 26);\n            string s = \"\";\n            s += c1;\n            s += c2;\n            forbiddenPairs.push_back(s);\n        }\n    } else {\n        // Default to 'none'\n        k = 0;\n    }\n\n    // Output\n    printf(\"%lld %d %d\\n\", n, m, k);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%s\\n\", forbiddenPairs[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\"); // n can be up to 1e15\n    int m = opt<int>(\"m\"); // m up to 52\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> forbiddenPairs;\n    int k;\n\n    if (type == \"none\") {\n        k = 0;\n    } else if (type == \"maxk\") {\n        k = m * m;\n        // All pairs are forbidden\n        forbiddenPairs.reserve(k);\n        for (int i = 0; i < m; ++i) {\n            char c1;\n            if (i < 26)\n                c1 = 'a' + i;\n            else\n                c1 = 'A' + i - 26;\n            for (int j = 0; j < m; ++j) {\n                char c2;\n                if (j < 26)\n                    c2 = 'a' + j;\n                else\n                    c2 = 'A' + j - 26;\n                string s = \"\";\n                s += c1;\n                s += c2;\n                forbiddenPairs.push_back(s);\n            }\n        }\n    } else if (type == \"self\") {\n        k = m;\n        forbiddenPairs.reserve(k);\n        for (int i = 0; i < m; ++i) {\n            char c;\n            if (i < 26)\n                c = 'a' + i;\n            else\n                c = 'A' + i - 26;\n            string s = \"\";\n            s += c;\n            s += c;\n            forbiddenPairs.push_back(s);\n        }\n    } else if (type == \"onepair\") {\n        k = 1;\n        int i = rnd.next(0, m - 1);\n        int j = rnd.next(0, m - 1);\n        char c1 = (i < 26) ? ('a' + i) : ('A' + i - 26);\n        char c2 = (j < 26) ? ('a' + j) : ('A' + j - 26);\n        string s = \"\";\n        s += c1;\n        s += c2;\n        forbiddenPairs.push_back(s);\n    } else if (type == \"allbutone\") {\n        k = m * m - 1;\n        forbiddenPairs.reserve(k);\n        int except_i = rnd.next(0, m - 1);\n        int except_j = rnd.next(0, m - 1);\n        for (int i = 0; i < m; ++i) {\n            char c1;\n            if (i < 26)\n                c1 = 'a' + i;\n            else\n                c1 = 'A' + i - 26;\n            for (int j = 0; j < m; ++j) {\n                if (i == except_i && j == except_j) continue;\n                char c2;\n                if (j < 26)\n                    c2 = 'a' + j;\n                else\n                    c2 = 'A' + j - 26;\n                string s = \"\";\n                s += c1;\n                s += c2;\n                forbiddenPairs.push_back(s);\n            }\n        }\n    } else if (type == \"random\") {\n        // Random k between 0 and m*m\n        k = rnd.next(0, m * m);\n        forbiddenPairs.reserve(k);\n        set<pair<int, int>> forbiddenSet;\n        while ((int)forbiddenSet.size() < k) {\n            int i = rnd.next(0, m - 1);\n            int j = rnd.next(0, m -1);\n            forbiddenSet.insert(make_pair(i, j));\n        }\n        for (auto& p : forbiddenSet) {\n            int i = p.first;\n            int j = p.second;\n            char c1 = (i < 26) ? ('a' + i) : ('A' + i - 26);\n            char c2 = (j < 26) ? ('a' + j) : ('A' + j - 26);\n            string s = \"\";\n            s += c1;\n            s += c2;\n            forbiddenPairs.push_back(s);\n        }\n    } else if (type == \"chain\") {\n        // Build a chain: forbidden only from i to (i+1)%m\n        k = m;\n        forbiddenPairs.reserve(k);\n        for (int i = 0; i < m; ++i) {\n            int j = (i + 1) % m;\n            char c1 = (i < 26) ? ('a' + i) : ('A' + i - 26);\n            char c2 = (j < 26) ? ('a' + j) : ('A' + j - 26);\n            string s = \"\";\n            s += c1;\n            s += c2;\n            forbiddenPairs.push_back(s);\n        }\n    } else {\n        // Default to 'none'\n        k = 0;\n    }\n\n    // Output\n    printf(\"%lld %d %d\\n\", n, m, k);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%s\\n\", forbiddenPairs[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type none\n./gen -n 1 -m 52 -type none\n./gen -n 1 -m 52 -type random\n\n./gen -n 2 -m 1 -type none\n./gen -n 2 -m 1 -type self\n\n./gen -n 2 -m 2 -type onepair\n\n./gen -n 1000 -m 5 -type random\n\n./gen -n 1000000 -m 26 -type random\n\n./gen -n 10000000000 -m 50 -type random\n\n./gen -n 1000000000000000 -m 52 -type none\n\n./gen -n 1000000000000000 -m 1 -type self\n\n./gen -n 1000000000000000 -m 52 -type self\n\n./gen -n 1000000000000000 -m 26 -type maxk\n\n./gen -n 1 -m 1 -type maxk\n\n./gen -n 1 -m 52 -type maxk\n\n./gen -n 100 -m 52 -type chain\n\n./gen -n 1000 -m 52 -type chain\n\n./gen -n 1000000000000 -m 40 -type chain\n\n./gen -n 999999999999999999 -m 52 -type chain\n\n./gen -n 1000000000000000 -m 20 -type allbutone\n\n./gen -n 500 -m 20 -type allbutone\n\n./gen -n 1000000000000000 -m 52 -type random\n\n./gen -n 100000 -m 30 -type random\n\n./gen -n 1 -m 52 -type self\n\n./gen -n 2 -m 52 -type random\n\n./gen -n 15 -m 15 -type random\n\n./gen -n 1000000000000000 -m 52 -type onepair\n\n./gen -n 1000000000000000 -m 50 -type chain\n\n./gen -n 1000000000000000 -m 2 -type self\n\n./gen -n 1 -m 1 -type self\n\n./gen -n 1000000000000000 -m 52 -type maxk\n\n./gen -n 2 -m 2 -type maxk\n\n./gen -n 2 -m 2 -type none\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:19.595434",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "223/A",
      "title": "A. Скобочная последовательность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой и единственной строке записана скобочная последовательность — строка, состоящая только из символов «(», «)», «[» и «]». Гарантируется, что строка непустая и ее длина не превышает 105 символов.",
      "output_spec": "Выходные данныеВ первой строке выведите единственное целое число — количество скобок «[» в оптимальной подстроке. Во второй строке выведите саму подстроку. Если существует несколько оптимальных подстрок выведите любую.",
      "sample_tests": "ПримерыВходные данныеСкопировать([])Выходные данныеСкопировать1([])Входные данныеСкопировать(((Выходные данныеСкопировать0",
      "description": "A. Скобочная последовательность\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой и единственной строке записана скобочная последовательность — строка, состоящая только из символов «(», «)», «[» и «]». Гарантируется, что строка непустая и ее длина не превышает 105 символов.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите единственное целое число — количество скобок «[» в оптимальной подстроке. Во второй строке выведите саму подстроку. Если существует несколько оптимальных подстрок выведите любую.\n\nВыходные данные\n\nВходные данныеСкопировать([])Выходные данныеСкопировать1([])Входные данныеСкопировать(((Выходные данныеСкопировать0\n\nВходные данныеСкопировать([])\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1([])\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать(((\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #138 - Codeforces",
          "content": "Всем привет!Я рад объявить о том, что сегодня в 19:30 MSKсостоится Codeforces Round #138. Автором этого раунда являюсь я (Василий Вадимов). Это мой первый раунд на Codeforces, до этого я лишь помогал другим авторам в подготовке их раундов.Раунд мне помогал готовить Геральд Gerald Агапов, а условия задач перевела Мария Delinur Белова, за что им большое спасибо. Также я благодарен создателю Codeforces Михаилу MikeMirzayanov Мирзаянову за отличную платформу для проведения соревнований.Успехов на раунде! Надеюсь, задачи будут для вас интересными.Разбалловка в обоих дивизионах стандартная (500-1000-1500-2000-2500).UPD. Внимание! Язык D, который находится на этапе внедрения на Codeforces, на этом контесте не будет доступен.UPD2. Раунд завершен, топ-5 по в каждом из дивизионов:Div1: Petr tourist peter50216 Shik Egor Div2: ecnerwala ordcoder scipianus jonathanpaulson void_rank Поздравляем победителей! Также приношу извинения за неточность в условии в задаче div1 A/div2 C. Разбор будет опубликован завтра.UPD3. Доступен разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1039
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces",
          "content": "Div2 A. ПараллелепипедВ этой задаче были даны площади трех граней прямоугольного параллелепипеда, нужно было найти сумму длин всех его сторон.Пусть длины трех сторон, имеющих одну общую вершину, равны a, b и c. Тогда нетрудно видеть, что нам даны числа s1 = ab, s2 = bc и s3 = ca. Из площадей легко можно выразить длины сторон: , , . Ответом является число 4(a + b + c), поскольку в параллелепипеде есть по 4 стороны с длинами a, b и c. Сложность решения — O(1).Div2 B. МассивВ задаче был дан массив a из n элементов, ai являлись положительными целыми и не превышали 105 для всех 1 ≤ i ≤ n. Также было дано число k. Нужно было найти минимальный по включению отрезок [l, r] такой, что среди чисел al, ... ar ровно k различных. Определение минимальности по включению дано в условии.Заведем массив cnt, изначально элемент cnti будет равен количеству вхождений числа i в массив a. Это можно сделать, поскольку элементы массива a небольшие. Число ненулевых элементов в массиве cnt равно числу различных элементов в массиве a. Если их меньше, чем k, то искомый отрезок найти невозможно. Допустим что это не так, тогда будем строить отрезок ответа [l, r]. Пусть изначально [l, r] = [1, n]. Будем уменьшать на 1 правую границу отрезка r, пока количество различных чисел не станет меньше, чем k. Поддерживать количество различных элементов на отрезке [l, r] можно следующим образом: при удалении элемента номер r из отрезка, уменьшим cntar на единицу. Если после этого cntar стал равным нулю, то уменьшим число различных элементов на 1. После этого вернем обратно последний выкинутый из отрезка элемент, чтобы количество различных стало ровно k. Затем сделаем точно так же с левой границей l, только будем не уменьшать, а увеличивать l на 1 каждый шаг. В результате мы получим отрезок [l, r], на котором есть ровно k различных элементов, а на отрезках [l + 1, r] и [l, r - 1] — меньше, чем k, следовательно это и есть искомый отрезок. Сложность решения — O(n).Div2 C/Div1 A. Скобочная последовательностьВ задаче была дана скобочная последовательность s из двух типов скобок. Нужно было найти правильную скобочную последовательность, являющуюся подстрокой строки s, содержащую наибольшее количество скобок <<>>.Для каждой открывающейся скобки попытаемся определить ей соответствующую закрывающуюся. Более формально, пусть открывающаяся скобка находится на позиции i, тогда скобка на позиции j называется ей соответствующей, если подстрока si... sj является кратчайшей правильной скобочной последовательностью, начинающейся с индекса i. Очевидно, если s не является правильной скобочной последовательностью, то не для каждой скобки найдется ей соответствующая.Будем идти по строке s и складывать позиции, на которых находятся открывающиеся скобки, в стек. Пусть мы находимся на позиции i, если si — открывающаяся скобка, то просто положим ее номер на вершину стека. Если нет, то посмотрим на вершину стека: если стек пустой или последняя открывающаяся скобка не соответствует текущей, то очистим стек. В противном случае запомним, что для скобки, лежащей на вершине, соответствующая есть скобка на позиции j и снимем вершину со стека. Нетрудно понять, что таким образом мы найдем все соответствующие для всех скобок, если они есть.Тогда строку s можно разбить на блоки. Блок — отрезок [l, r] такой, что скобка на позиции r — соответствующая для скобки на позиции l, и нет пары соответствующих скобок на позициях x и y таких, что и [l, r] ≠ [x, y]. Легко понять, что блоки не пересекаются и разбиение на блоки единственно. Мы можем склеивать подряд идущие блоки в правильные скобочные последовательности. При этом выгодно склеить как можно больше блоков, чтобы набрать как можно больше скобок нужного типа. Склеим все подряд идущие блоки, получим несколько подстрок, являющихся правильными скобочными последовательностями. Выберем из получившихся подстрок ту, в которой наибольшее количество скобок <<>>. Сложность решения — O(|s|).Div2 D/Div1 B. Две строкиВ задаче были даны две строки: s и t. Нужно было рассмотреть все вхождения строки t в строку s как подпоследовательность и сказать, верно ли, что для каждой позиции строки s найдется такое вхождение, которое содержит эту позицию.Для каждой позиции i строки s посчитаем две величины li и ri, li — максимально возможное число такое, что строка t1... tli входит как подпоследовательность в строку s1... si, ri — максимально возможное число такое, что строка t|t| - ri + 1... t|t| входит как подпоследовательность в строку si... s|s|. Пусть мы нашли все l для позиций 1... i - 1 и хотим найти li. Если символ tli - 1 + 1 существует и совпадает с символом si, то li = li - 1 + 1, в противном случае li = li - 1. Аналогично можно найти ri, если двигаться с конца строки.Теперь научимся проверять для позиции i в строке s, что она принадлежит хотя бы одному вхождению. Допустим, это так, и символ si соответствует символу tj в строке t. Тогда li - 1 ≥ j - 1 и ri + 1 ≥ |t| - j, по определению l и r. Тогда если существует j, такое что si = tj и li - 1 + 1 ≥ j ≥ |t| - ri + 1, то позиция i строки s принадлежит хотя бы одному вхождению t, в противном случае нет. Это легко проверить, если мы заведем для каждой буквы массив cnta, i — количество букв a в строке t на позициях 1... i. Алфавит небольшой, поэтому никаких проблем с памятью не будет. Сложность решения — O(|s| + |t|)Div2 E/Div1 C. Частичные суммыВ задаче был дан массив a. За одну операцию массив a заменяется массивом из его частичных сумм s. Нужно было найти массив после выполнения k таких операций. Все вычисления производятся по модулю P = 109 + 7.Запишем s в следующем виде: где Bi, j = 1, если i ≥ j и Bi, j = 0, если i < j, для всех 1 ≤ i, j ≤ n. Если a и s представить в виде векторов-столбцов, то применение одной операции соответствует умножению матрицы B на вектор столбец a. Тогда массив, получающийся после выполнения k операций результирующий массив будет равен Bka. Возводить матрицу в степень можно за , что уже неплохо, но недостаточно быстро.Заметим, что = , то есть элементы матрицы Bk на диагоналях, параллельным главным, одинаковы. Это можно легко доказать, используя метод математической индукции, предоставляю это читателю. Тогда можно задавать матрицу набором чисел , равным элементам первого столбца. Элементы первого столбца для произведения BkBl равны . Это следует прямо из формулы умножения двух матриц. Вычисление одного элемента работает за O(n) времени, всего элементов n, поэтому умножение можно производить за O(n2). Таким образом, мы научились решать задачу за времени, что уже укладывается в ограничения.Можно решать эту задачу быстрее, если убедиться, что . Допустим, что эта формула верна для какого-то k, докажем, что из этого следует, что формула верна и для k + 1. Используем формулу умножения для коэффициентов b: Используя формулу Cnk = n! / k!(n - k)!, можно получить, что , поэтому мы можем построить все коэффициенты b, если умеем делить по модулю P, поэтому в этом решении существенна простота P. Обратный для числа x по простому модулю равен в силу малой теоремы Ферма. Таким образом, мы получаем решение за O(n2).Div1 D. ПаукВ этой задаче был дан многоугольник из n вершин, нужно было найти кратчайший путь от одной его вершины до другой, если можно двигаться по границе, а также спускаться вертикально вниз, не выходя наружу.Все стороны многоугольника можно разбить на три группы: верхние, нижние и вертикальные. Вертикальная сторона это сторона, у которой совпадают координаты x ее концов. Нижняя сторона это такая сторона, что внутренность многоугольника лежит сверху от нее. Верхняя сторона это такая сторона, что внутренность многоугольника лежит снизу от нее. Понятно, что мы можем спускаться только с точек верхних сторон в точки нижних сторон. Вертикальные стороны на спуски никак не влияют, поскольку спуск проходящий через вертикальную сторону может быть разбит на два спуска и переход. Докажем, что нужно спускаться либо из вершины либо в вершину. Допустим, что какой-то спуск в оптимальном решении начинается с внутренней точки и заканчивается внутренней точкой. Попробуем немного изменить координату x этого спуска. Поскольку длина пути монотонно (возможно нестрого монотонно) зависит от x, то можно немного сдвинуть x так, что ответ не увеличится, а может быть даже и уменьшится. Нестрогая монотонность ломается только если спуск проходит через какую-то вершину, поэтому нужно рассматривать спуски из вершин и в вершины.Решаем задачу методом сканирующей прямой, будем двигать вертикальную прямую с абсциссой X слева направо и поддерживать множество S пересекающихся с ней сторон. Элементы этого множества будем хранить в отсортированном по y порядке. Поскольку стороны имеют общие точки только в вершинах, порядок всегда можно определить. При движении происходят разные события: какие-то отрезки добавляются в множество S, какие-то удаляются из него. Заведем массив событий, каждое событие описывается координатой x, равное координате X прямой, при котором происходит событие, а также типом события: номером отрезка и удаляется он или добавляется в S. Понятно, что для каждой стороны есть по два события, их координаты x соответствуют абсциссам концов сторон. Вертикальные стороны при этом можно игнорировать.Будем обрабатывать события в порядке неубывания координат x этих событий. Если пришло событие добавления стороны, то добавим сторону в S, после добавления посмотрим на ближайших соседей этой стороны в текущем множестве S. Если только что добавленный отрезок верхний, то проводим спуск из его левой вершины вниз, до пересечения с нижним соседом, а именно находим точку пересечения, запоминаем на каком отрезке она находится и запоминаем, что есть спуск из вершины в эту новую точку. Если добавленная сторона нижняя, то проводим спуск с верхнего соседа в левый конец добавленного отрезка, точно так же запоминая точку пересечения, на какой стороне она лежит и то, что есть спуск из этой точки в вершину. Если же событие соответствует удалению отрезка, то мы точно так же анализируем его соседей, только спуски будут начинаться или заканчиваться в правом конце отрезка, который мы собираемся удалять. Важный момент, если у нас происходит несколько событий одного типа одновременно, мы должны их обработать также одновременно, то есть если есть несколько добавлений в одной и той же координате x, нужно добавить их всех, а только потом рассматривать соседей. Аналогично, если нужно сделать несколько удалений, нужно рассмотреть соседей и только потом удалить отрезки. Также при равенстве координат x события добавления должны идти раньше событий удаления, иначе решение не будет работать в случае двух углов, лежащих по разные стороны от вертикальной прямой, но с вершинами, лежащими на этой вертикальной прямой.Множество S удобно хранить в контейнере типа set, при этом для него нужно аккуратно написать компаратор. Можно делать это следующим образом: Два отрезка могут одновременно находиться в S, если есть вертикальная прямая, которая пересекает каждый из них. В общем случае такая вертикальная прямая не единственная, возможные положения X, при котором это так, лежат на отрезке [l, r], который легко находится по координатам концов отрезков. Тогда можно взять произвольное X внутри [l, r] и сравнить ординаты точек пересечения. Удобно брать именно внутреннюю точку, поскольку не придется рассматривать частные случаи, связанные с тем, что сравниваемые отрезки могут иметь общий конец.После этого строим граф, вершинами которого являются вершины многоугольника и концы возможных спусков, а ребра — отрезки сторон и спуски. Кратчайший путь на таком графе ищется алгоритмом Дейкстры. Сложность решения — .Div1 E. Планарный графВ задаче был дан связный неориентированный планарный граф, без мостов, точек сочленения, кратных ребер и петель, уложенный на плоскость. Также были даны запросы следующего типа: для заданного цикла посчитать количество вершин внутри этого цикла, либо на нем самом.Возьмем произвольную вершину на границе, например вершину с самой маленькой абсциссой. Подвесим к ней новую вершину, причем ребро между вершиной на границе и новой вершиной должно быть снаружи от внешней грани графа. Назовем эту вершину стоком. Из каждой вершины графа, кроме стока, пустим поток величиной 1, текущий в сток. Поток можно пустить по дереву поиска в ширину или глубину, время, затрачиваемое на такую операцию есть O(E).Рассмотрим какой-нибудь запрос. Считаем, что цикл ориентирован против часовой стрелки, если это не так, то перевернем его. Сделаем разрез в графе: в первой доле разреза будут все вершины, которые лежат внутри цикла или на нем самом, во второй доле --- все оставшиеся вершины, в том числе и сток. Докажем, что величина потока через разрез равна количеству вершин в первой доле. Очевидно, что вклад в общий поток от каждой вершины графа можно рассматривать независимо. Пусть вершина находится в первой доле. Единичный поток от нее течет к стоку по какому-то пути. Так как эта вершина и сток находятся в разных долях, то этот путь нечетное число раз проходит по ребрам разреза, поэтому вклад в поток через разрез от этой вершины равен 1. Рассмотрим вершину, находящуюся во второй доле. Так как она в той же доле, что и сток, то поток от нее до стока проходит по ребрам разреза четное число раз, поэтому вклад от нее нулевой. Чтобы найти величину потока через разрез, нужно просуммировать потоки, текущие по ребрам разреза. Заметим, что каждое ребро разреза инцидентно ровно одной вершине, лежащей на цикле, поэтому можно для каждой вершины цикла просуммировать потоки, по ребрам, ведущим из этой вершины наружу цикла. Чтобы найти все ребра, ведущие наружу, отсортируем по углу все ребра, исходящие из вершины, в порядке против часовой стрелки. Тогда все ребра, ведущие наружу из вершины цикла, будут расположены после предыдущей вершины цикла и перед следующей вершиной цикла. Поэтому сумма потоков по ребрам наружу сводится к сумме на отрезке, что успешно решается частичными суммами. Сложность решения на сортировку графа плюс на запрос, где l — длина цикла. Логарифм числа ребер возникает из-за необходимости узнавать номер вершины в списке смежности для другой вершины.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5301",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 14065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #138 - Codeforces - Code 1",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 2",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 3",
          "code": "> ошибки в определении сложности задач случаются регулярно\n\n> совместить с сортировкой по предлагаемому уровню сложности.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 4",
          "code": "> ошибки в определении сложности задач случаются регулярно\n\n> совместить с сортировкой по предлагаемому уровню сложности.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 5",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 6",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 7",
          "code": "5 3\n1 2 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 8",
          "code": "4\n[[]]()[][][()]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 9",
          "code": "100000\n[][][][]...[][][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 10",
          "code": "4 3\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 1",
          "code": "([[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 2",
          "code": "([[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 3",
          "code": "5\n[[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 4",
          "code": "5\n[[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 5",
          "code": "4 * (a + b + c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    int n = s.size();\n\n    ensuref(1 <= n && n <= 100000, \"Length of input string must be between 1 and 1e5 inclusive, found %d\", n);\n\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        ensuref(c == '(' || c == ')' || c == '[' || c == ']', \"Invalid character '%c' at position %d\", c, i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    int n = s.size();\n\n    ensuref(1 <= n && n <= 100000, \"Length of input string must be between 1 and 1e5 inclusive, found %d\", n);\n\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        ensuref(c == '(' || c == ')' || c == '[' || c == ']', \"Invalid character '%c' at position %d\", c, i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    int n = s.size();\n\n    ensuref(1 <= n && n <= 100000, \"Length of input string must be between 1 and 1e5 inclusive, found %d\", n);\n\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        ensuref(c == '(' || c == ')' || c == '[' || c == ']', \"Invalid character '%c' at position %d\", c, i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to check if a bracket sequence is correct\nbool isCorrect(const string& seq) {\n    stack<char> st;\n    for (char c : seq) {\n        if (c == '(' || c == '[') {\n            st.push(c);\n        } else if (c == ')') {\n            if (st.empty() || st.top() != '(')\n                return false;\n            st.pop();\n        } else if (c == ']') {\n            if (st.empty() || st.top() != '[')\n                return false;\n            st.pop();\n        } else {\n            // Invalid character\n            return false;\n        }\n    }\n    return st.empty();\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the input sequence from 'inf'\n    string s = inf.readLine();\n\n    // Read jury's answer\n    int max_jury = ans.readInt(0, (int)s.length(), \"max_jury\");\n    ans.readEoln();\n    string jury_seq = ans.readLine();\n\n    // Read participant's answer\n    int max_participant = ouf.readInt(0, (int)s.length(), \"max_participant\");\n    ouf.readEoln();\n    string participant_seq = ouf.readLine();\n\n    // Check that participant's max_participant equals number of '[' in participant_seq\n    int num_open_brackets = 0;\n    for (char c : participant_seq) {\n        if (c == '[')\n            num_open_brackets++;\n    }\n    if (num_open_brackets != max_participant) {\n        quitf(_wa, \"Number of '[' in the sequence (%d) does not match the reported number (%d)\", num_open_brackets, max_participant);\n    }\n\n    // Check that participant_seq is a correct bracket sequence\n    if (!isCorrect(participant_seq)) {\n        quitf(_wa, \"The sequence is not a correct bracket sequence\");\n    }\n\n    // Check that participant_seq is a substring of s\n    if (s.find(participant_seq) == string::npos) {\n        quitf(_wa, \"The sequence is not a substring of the input\");\n    }\n\n    // Compare participant's max_participant with jury's max_jury\n    if (max_participant > max_jury) {\n        quitf(_fail, \"Participant's answer is better than jury's: participant has %d '[' while jury has %d '['\", max_participant, max_jury);\n    } else if (max_participant < max_jury) {\n        quitf(_wa, \"Participant's answer is worse than jury's: participant has %d '[' while jury has %d '['\", max_participant, max_jury);\n    } else {\n        // Participant's answer is acceptable\n        quitf(_ok, \"Correct answer with %d '['\", max_participant);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random bracket sequence of length n\nstring generate_random(int n) {\n    string s;\n    string brackets = \"()\" \"[]\";\n    for (int i = 0; i < n; ++i) {\n        s += brackets[rnd.next(0, 3)];  // Randomly pick one of the four characters\n    }\n    return s;\n}\n\n// Function to generate a bracket sequence with only '(' and ')' of length n\nstring generate_only_parens(int n) {\n    string s;\n    string brackets = \"()\";\n    for (int i = 0; i < n; ++i) {\n        s += brackets[rnd.next(0, 1)];\n    }\n    return s;\n}\n\n// Function to generate a bracket sequence with only '[' and ']' of length n\nstring generate_only_brackets(int n) {\n    string s;\n    string brackets = \"[]\";\n    for (int i = 0; i < n; ++i) {\n        s += brackets[rnd.next(0, 1)];\n    }\n    return s;\n}\n\n// Function to generate a correct nested bracket sequence of length n\nstring generate_nested_correct(int n) {\n    string s;\n    stack<char> st;\n    while ((int)s.length() < n) {\n        if (st.empty() || rnd.next(0, 1) == 0) {\n            if ((int)s.length() + 2 > n) {\n                // Can't open new brackets, so close existing ones\n                while (!st.empty() && (int)s.length() < n) {\n                    s += st.top();\n                    st.pop();\n                }\n                break;\n            } else {\n                // Open a bracket\n                char open_b;\n                char close_b;\n                if (rnd.next(0, 1) == 0) {\n                    open_b = '(';\n                    close_b = ')';\n                } else {\n                    open_b = '[';\n                    close_b = ']';\n                }\n                s += open_b;\n                st.push(close_b);\n            }\n        } else {\n            // Close a bracket\n            s += st.top();\n            st.pop();\n        }\n    }\n    // Close remaining brackets if any\n    while (!st.empty() && (int)s.length() < n) {\n        s += st.top();\n        st.pop();\n    }\n    // Truncate if over length\n    if ((int)s.length() > n)\n        s = s.substr(0, n);\n    return s;\n}\n\n// Function to generate an incorrect nested bracket sequence of length n\nstring generate_nested_incorrect(int n) {\n    // Generate a correct nested sequence and introduce an error\n    string s = generate_nested_correct(n);\n    if (n > 0) {\n        int pos = rnd.next(0, n - 1);\n        // Change one bracket to the wrong type to make it incorrect\n        if (s[pos] == '(') s[pos] = '[';\n        else if (s[pos] == '[') s[pos] = '(';\n        else if (s[pos] == ')') s[pos] = ']';\n        else if (s[pos] == ']') s[pos] = ')';\n    }\n    return s;\n}\n\n// Function to generate a correct bracket sequence maximizing the number of '['\nstring generate_max_brackets(int n) {\n    string s;\n    stack<char> st;\n    while ((int)s.length() < n) {\n        if (st.empty() || rnd.next(0, 1) == 0) {\n            if ((int)s.length() + 2 > n) {\n                // Can't open new brackets, so close existing ones\n                while (!st.empty() && (int)s.length() < n) {\n                    s += st.top();\n                    st.pop();\n                }\n                break;\n            } else {\n                // Open a '[' bracket\n                s += '[';\n                st.push(']');\n            }\n        } else {\n            // Close a bracket\n            s += st.top();\n            st.pop();\n        }\n    }\n    // Close remaining brackets if any\n    while (!st.empty() && (int)s.length() < n) {\n        s += st.top();\n        st.pop();\n    }\n    // Truncate if over length\n    if ((int)s.length() > n)\n        s = s.substr(0, n);\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n    if (type == \"random\") {\n        s = generate_random(n);\n    } else if (type == \"only_parens\") {\n        s = generate_only_parens(n);\n    } else if (type == \"only_brackets\") {\n        s = generate_only_brackets(n);\n    } else if (type == \"nested_correct\") {\n        s = generate_nested_correct(n);\n    } else if (type == \"nested_incorrect\") {\n        s = generate_nested_incorrect(n);\n    } else if (type == \"max_brackets\") {\n        s = generate_max_brackets(n);\n    } else {\n        // Default to random if type is unrecognized\n        s = generate_random(n);\n    }\n\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random bracket sequence of length n\nstring generate_random(int n) {\n    string s;\n    string brackets = \"()\" \"[]\";\n    for (int i = 0; i < n; ++i) {\n        s += brackets[rnd.next(0, 3)];  // Randomly pick one of the four characters\n    }\n    return s;\n}\n\n// Function to generate a bracket sequence with only '(' and ')' of length n\nstring generate_only_parens(int n) {\n    string s;\n    string brackets = \"()\";\n    for (int i = 0; i < n; ++i) {\n        s += brackets[rnd.next(0, 1)];\n    }\n    return s;\n}\n\n// Function to generate a bracket sequence with only '[' and ']' of length n\nstring generate_only_brackets(int n) {\n    string s;\n    string brackets = \"[]\";\n    for (int i = 0; i < n; ++i) {\n        s += brackets[rnd.next(0, 1)];\n    }\n    return s;\n}\n\n// Function to generate a correct nested bracket sequence of length n\nstring generate_nested_correct(int n) {\n    string s;\n    stack<char> st;\n    while ((int)s.length() < n) {\n        if (st.empty() || rnd.next(0, 1) == 0) {\n            if ((int)s.length() + 2 > n) {\n                // Can't open new brackets, so close existing ones\n                while (!st.empty() && (int)s.length() < n) {\n                    s += st.top();\n                    st.pop();\n                }\n                break;\n            } else {\n                // Open a bracket\n                char open_b;\n                char close_b;\n                if (rnd.next(0, 1) == 0) {\n                    open_b = '(';\n                    close_b = ')';\n                } else {\n                    open_b = '[';\n                    close_b = ']';\n                }\n                s += open_b;\n                st.push(close_b);\n            }\n        } else {\n            // Close a bracket\n            s += st.top();\n            st.pop();\n        }\n    }\n    // Close remaining brackets if any\n    while (!st.empty() && (int)s.length() < n) {\n        s += st.top();\n        st.pop();\n    }\n    // Truncate if over length\n    if ((int)s.length() > n)\n        s = s.substr(0, n);\n    return s;\n}\n\n// Function to generate an incorrect nested bracket sequence of length n\nstring generate_nested_incorrect(int n) {\n    // Generate a correct nested sequence and introduce an error\n    string s = generate_nested_correct(n);\n    if (n > 0) {\n        int pos = rnd.next(0, n - 1);\n        // Change one bracket to the wrong type to make it incorrect\n        if (s[pos] == '(') s[pos] = '[';\n        else if (s[pos] == '[') s[pos] = '(';\n        else if (s[pos] == ')') s[pos] = ']';\n        else if (s[pos] == ']') s[pos] = ')';\n    }\n    return s;\n}\n\n// Function to generate a correct bracket sequence maximizing the number of '['\nstring generate_max_brackets(int n) {\n    string s;\n    stack<char> st;\n    while ((int)s.length() < n) {\n        if (st.empty() || rnd.next(0, 1) == 0) {\n            if ((int)s.length() + 2 > n) {\n                // Can't open new brackets, so close existing ones\n                while (!st.empty() && (int)s.length() < n) {\n                    s += st.top();\n                    st.pop();\n                }\n                break;\n            } else {\n                // Open a '[' bracket\n                s += '[';\n                st.push(']');\n            }\n        } else {\n            // Close a bracket\n            s += st.top();\n            st.pop();\n        }\n    }\n    // Close remaining brackets if any\n    while (!st.empty() && (int)s.length() < n) {\n        s += st.top();\n        st.pop();\n    }\n    // Truncate if over length\n    if ((int)s.length() > n)\n        s = s.substr(0, n);\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n    if (type == \"random\") {\n        s = generate_random(n);\n    } else if (type == \"only_parens\") {\n        s = generate_only_parens(n);\n    } else if (type == \"only_brackets\") {\n        s = generate_only_brackets(n);\n    } else if (type == \"nested_correct\") {\n        s = generate_nested_correct(n);\n    } else if (type == \"nested_incorrect\") {\n        s = generate_nested_incorrect(n);\n    } else if (type == \"max_brackets\") {\n        s = generate_max_brackets(n);\n    } else {\n        // Default to random if type is unrecognized\n        s = generate_random(n);\n    }\n\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 10 -type only_parens\n./gen -n 10 -type only_brackets\n./gen -n 10 -type nested_correct\n./gen -n 10 -type nested_incorrect\n./gen -n 10 -type max_brackets\n\n./gen -n 100 -type random\n./gen -n 100 -type only_parens\n./gen -n 100 -type only_brackets\n./gen -n 100 -type nested_correct\n./gen -n 100 -type nested_incorrect\n./gen -n 100 -type max_brackets\n\n./gen -n 1000 -type random\n./gen -n 1000 -type only_parens\n./gen -n 1000 -type only_brackets\n./gen -n 1000 -type nested_correct\n./gen -n 1000 -type nested_incorrect\n./gen -n 1000 -type max_brackets\n\n./gen -n 10000 -type random\n./gen -n 10000 -type only_parens\n./gen -n 10000 -type only_brackets\n./gen -n 10000 -type nested_correct\n./gen -n 10000 -type nested_incorrect\n./gen -n 10000 -type max_brackets\n\n./gen -n 100000 -type random\n./gen -n 100000 -type only_parens\n./gen -n 100000 -type only_brackets\n./gen -n 100000 -type nested_correct\n./gen -n 100000 -type nested_incorrect\n./gen -n 100000 -type max_brackets\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:21.587530",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "223/B",
      "title": "B. Две строки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записана строка s, во второй — t. Каждая строка состоит только из строчных латинских букв. Заданные строки непустые, длина каждой строки не превышает 2·105.",
      "output_spec": "Выходные данныеВыведите «Yes» (без кавычек), если каждый символ строки s находится хотя бы в одной из описанных подпоследовательностей, или «No» (без кавычек) в противном случае.",
      "sample_tests": "ПримерыВходные данныеСкопироватьabababВыходные данныеСкопироватьYesВходные данныеСкопироватьabacabaabaВыходные данныеСкопироватьNoВходные данныеСкопироватьabcbaВыходные данныеСкопироватьNo",
      "description": "B. Две строки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записана строка s, во второй — t. Каждая строка состоит только из строчных латинских букв. Заданные строки непустые, длина каждой строки не превышает 2·105.\n\nВходные данные\n\nВыходные данныеВыведите «Yes» (без кавычек), если каждый символ строки s находится хотя бы в одной из описанных подпоследовательностей, или «No» (без кавычек) в противном случае.\n\nВыходные данные\n\nВходные данныеСкопироватьabababВыходные данныеСкопироватьYesВходные данныеСкопироватьabacabaabaВыходные данныеСкопироватьNoВходные данныеСкопироватьabcbaВыходные данныеСкопироватьNo\n\nВходные данныеСкопироватьababab\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYes\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьabacabaaba\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNo\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьabcba\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNo\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере строка t может входить в строку s как подпоследовательность тремя способами: abab, abab и abab. При этом каждый символ строки s попадает хотя бы в одно вхождение.Во втором примере 4-й символ строки s не попадает ни в одно вхождение строки t.В третьем примере нет ни одного вхождения строки t в строку s.",
      "solutions": [
        {
          "title": "Codeforces Round #138 - Codeforces",
          "content": "Всем привет!Я рад объявить о том, что сегодня в 19:30 MSKсостоится Codeforces Round #138. Автором этого раунда являюсь я (Василий Вадимов). Это мой первый раунд на Codeforces, до этого я лишь помогал другим авторам в подготовке их раундов.Раунд мне помогал готовить Геральд Gerald Агапов, а условия задач перевела Мария Delinur Белова, за что им большое спасибо. Также я благодарен создателю Codeforces Михаилу MikeMirzayanov Мирзаянову за отличную платформу для проведения соревнований.Успехов на раунде! Надеюсь, задачи будут для вас интересными.Разбалловка в обоих дивизионах стандартная (500-1000-1500-2000-2500).UPD. Внимание! Язык D, который находится на этапе внедрения на Codeforces, на этом контесте не будет доступен.UPD2. Раунд завершен, топ-5 по в каждом из дивизионов:Div1: Petr tourist peter50216 Shik Egor Div2: ecnerwala ordcoder scipianus jonathanpaulson void_rank Поздравляем победителей! Также приношу извинения за неточность в условии в задаче div1 A/div2 C. Разбор будет опубликован завтра.UPD3. Доступен разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1039
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces",
          "content": "Div2 A. ПараллелепипедВ этой задаче были даны площади трех граней прямоугольного параллелепипеда, нужно было найти сумму длин всех его сторон.Пусть длины трех сторон, имеющих одну общую вершину, равны a, b и c. Тогда нетрудно видеть, что нам даны числа s1 = ab, s2 = bc и s3 = ca. Из площадей легко можно выразить длины сторон: , , . Ответом является число 4(a + b + c), поскольку в параллелепипеде есть по 4 стороны с длинами a, b и c. Сложность решения — O(1).Div2 B. МассивВ задаче был дан массив a из n элементов, ai являлись положительными целыми и не превышали 105 для всех 1 ≤ i ≤ n. Также было дано число k. Нужно было найти минимальный по включению отрезок [l, r] такой, что среди чисел al, ... ar ровно k различных. Определение минимальности по включению дано в условии.Заведем массив cnt, изначально элемент cnti будет равен количеству вхождений числа i в массив a. Это можно сделать, поскольку элементы массива a небольшие. Число ненулевых элементов в массиве cnt равно числу различных элементов в массиве a. Если их меньше, чем k, то искомый отрезок найти невозможно. Допустим что это не так, тогда будем строить отрезок ответа [l, r]. Пусть изначально [l, r] = [1, n]. Будем уменьшать на 1 правую границу отрезка r, пока количество различных чисел не станет меньше, чем k. Поддерживать количество различных элементов на отрезке [l, r] можно следующим образом: при удалении элемента номер r из отрезка, уменьшим cntar на единицу. Если после этого cntar стал равным нулю, то уменьшим число различных элементов на 1. После этого вернем обратно последний выкинутый из отрезка элемент, чтобы количество различных стало ровно k. Затем сделаем точно так же с левой границей l, только будем не уменьшать, а увеличивать l на 1 каждый шаг. В результате мы получим отрезок [l, r], на котором есть ровно k различных элементов, а на отрезках [l + 1, r] и [l, r - 1] — меньше, чем k, следовательно это и есть искомый отрезок. Сложность решения — O(n).Div2 C/Div1 A. Скобочная последовательностьВ задаче была дана скобочная последовательность s из двух типов скобок. Нужно было найти правильную скобочную последовательность, являющуюся подстрокой строки s, содержащую наибольшее количество скобок <<>>.Для каждой открывающейся скобки попытаемся определить ей соответствующую закрывающуюся. Более формально, пусть открывающаяся скобка находится на позиции i, тогда скобка на позиции j называется ей соответствующей, если подстрока si... sj является кратчайшей правильной скобочной последовательностью, начинающейся с индекса i. Очевидно, если s не является правильной скобочной последовательностью, то не для каждой скобки найдется ей соответствующая.Будем идти по строке s и складывать позиции, на которых находятся открывающиеся скобки, в стек. Пусть мы находимся на позиции i, если si — открывающаяся скобка, то просто положим ее номер на вершину стека. Если нет, то посмотрим на вершину стека: если стек пустой или последняя открывающаяся скобка не соответствует текущей, то очистим стек. В противном случае запомним, что для скобки, лежащей на вершине, соответствующая есть скобка на позиции j и снимем вершину со стека. Нетрудно понять, что таким образом мы найдем все соответствующие для всех скобок, если они есть.Тогда строку s можно разбить на блоки. Блок — отрезок [l, r] такой, что скобка на позиции r — соответствующая для скобки на позиции l, и нет пары соответствующих скобок на позициях x и y таких, что и [l, r] ≠ [x, y]. Легко понять, что блоки не пересекаются и разбиение на блоки единственно. Мы можем склеивать подряд идущие блоки в правильные скобочные последовательности. При этом выгодно склеить как можно больше блоков, чтобы набрать как можно больше скобок нужного типа. Склеим все подряд идущие блоки, получим несколько подстрок, являющихся правильными скобочными последовательностями. Выберем из получившихся подстрок ту, в которой наибольшее количество скобок <<>>. Сложность решения — O(|s|).Div2 D/Div1 B. Две строкиВ задаче были даны две строки: s и t. Нужно было рассмотреть все вхождения строки t в строку s как подпоследовательность и сказать, верно ли, что для каждой позиции строки s найдется такое вхождение, которое содержит эту позицию.Для каждой позиции i строки s посчитаем две величины li и ri, li — максимально возможное число такое, что строка t1... tli входит как подпоследовательность в строку s1... si, ri — максимально возможное число такое, что строка t|t| - ri + 1... t|t| входит как подпоследовательность в строку si... s|s|. Пусть мы нашли все l для позиций 1... i - 1 и хотим найти li. Если символ tli - 1 + 1 существует и совпадает с символом si, то li = li - 1 + 1, в противном случае li = li - 1. Аналогично можно найти ri, если двигаться с конца строки.Теперь научимся проверять для позиции i в строке s, что она принадлежит хотя бы одному вхождению. Допустим, это так, и символ si соответствует символу tj в строке t. Тогда li - 1 ≥ j - 1 и ri + 1 ≥ |t| - j, по определению l и r. Тогда если существует j, такое что si = tj и li - 1 + 1 ≥ j ≥ |t| - ri + 1, то позиция i строки s принадлежит хотя бы одному вхождению t, в противном случае нет. Это легко проверить, если мы заведем для каждой буквы массив cnta, i — количество букв a в строке t на позициях 1... i. Алфавит небольшой, поэтому никаких проблем с памятью не будет. Сложность решения — O(|s| + |t|)Div2 E/Div1 C. Частичные суммыВ задаче был дан массив a. За одну операцию массив a заменяется массивом из его частичных сумм s. Нужно было найти массив после выполнения k таких операций. Все вычисления производятся по модулю P = 109 + 7.Запишем s в следующем виде: где Bi, j = 1, если i ≥ j и Bi, j = 0, если i < j, для всех 1 ≤ i, j ≤ n. Если a и s представить в виде векторов-столбцов, то применение одной операции соответствует умножению матрицы B на вектор столбец a. Тогда массив, получающийся после выполнения k операций результирующий массив будет равен Bka. Возводить матрицу в степень можно за , что уже неплохо, но недостаточно быстро.Заметим, что = , то есть элементы матрицы Bk на диагоналях, параллельным главным, одинаковы. Это можно легко доказать, используя метод математической индукции, предоставляю это читателю. Тогда можно задавать матрицу набором чисел , равным элементам первого столбца. Элементы первого столбца для произведения BkBl равны . Это следует прямо из формулы умножения двух матриц. Вычисление одного элемента работает за O(n) времени, всего элементов n, поэтому умножение можно производить за O(n2). Таким образом, мы научились решать задачу за времени, что уже укладывается в ограничения.Можно решать эту задачу быстрее, если убедиться, что . Допустим, что эта формула верна для какого-то k, докажем, что из этого следует, что формула верна и для k + 1. Используем формулу умножения для коэффициентов b: Используя формулу Cnk = n! / k!(n - k)!, можно получить, что , поэтому мы можем построить все коэффициенты b, если умеем делить по модулю P, поэтому в этом решении существенна простота P. Обратный для числа x по простому модулю равен в силу малой теоремы Ферма. Таким образом, мы получаем решение за O(n2).Div1 D. ПаукВ этой задаче был дан многоугольник из n вершин, нужно было найти кратчайший путь от одной его вершины до другой, если можно двигаться по границе, а также спускаться вертикально вниз, не выходя наружу.Все стороны многоугольника можно разбить на три группы: верхние, нижние и вертикальные. Вертикальная сторона это сторона, у которой совпадают координаты x ее концов. Нижняя сторона это такая сторона, что внутренность многоугольника лежит сверху от нее. Верхняя сторона это такая сторона, что внутренность многоугольника лежит снизу от нее. Понятно, что мы можем спускаться только с точек верхних сторон в точки нижних сторон. Вертикальные стороны на спуски никак не влияют, поскольку спуск проходящий через вертикальную сторону может быть разбит на два спуска и переход. Докажем, что нужно спускаться либо из вершины либо в вершину. Допустим, что какой-то спуск в оптимальном решении начинается с внутренней точки и заканчивается внутренней точкой. Попробуем немного изменить координату x этого спуска. Поскольку длина пути монотонно (возможно нестрого монотонно) зависит от x, то можно немного сдвинуть x так, что ответ не увеличится, а может быть даже и уменьшится. Нестрогая монотонность ломается только если спуск проходит через какую-то вершину, поэтому нужно рассматривать спуски из вершин и в вершины.Решаем задачу методом сканирующей прямой, будем двигать вертикальную прямую с абсциссой X слева направо и поддерживать множество S пересекающихся с ней сторон. Элементы этого множества будем хранить в отсортированном по y порядке. Поскольку стороны имеют общие точки только в вершинах, порядок всегда можно определить. При движении происходят разные события: какие-то отрезки добавляются в множество S, какие-то удаляются из него. Заведем массив событий, каждое событие описывается координатой x, равное координате X прямой, при котором происходит событие, а также типом события: номером отрезка и удаляется он или добавляется в S. Понятно, что для каждой стороны есть по два события, их координаты x соответствуют абсциссам концов сторон. Вертикальные стороны при этом можно игнорировать.Будем обрабатывать события в порядке неубывания координат x этих событий. Если пришло событие добавления стороны, то добавим сторону в S, после добавления посмотрим на ближайших соседей этой стороны в текущем множестве S. Если только что добавленный отрезок верхний, то проводим спуск из его левой вершины вниз, до пересечения с нижним соседом, а именно находим точку пересечения, запоминаем на каком отрезке она находится и запоминаем, что есть спуск из вершины в эту новую точку. Если добавленная сторона нижняя, то проводим спуск с верхнего соседа в левый конец добавленного отрезка, точно так же запоминая точку пересечения, на какой стороне она лежит и то, что есть спуск из этой точки в вершину. Если же событие соответствует удалению отрезка, то мы точно так же анализируем его соседей, только спуски будут начинаться или заканчиваться в правом конце отрезка, который мы собираемся удалять. Важный момент, если у нас происходит несколько событий одного типа одновременно, мы должны их обработать также одновременно, то есть если есть несколько добавлений в одной и той же координате x, нужно добавить их всех, а только потом рассматривать соседей. Аналогично, если нужно сделать несколько удалений, нужно рассмотреть соседей и только потом удалить отрезки. Также при равенстве координат x события добавления должны идти раньше событий удаления, иначе решение не будет работать в случае двух углов, лежащих по разные стороны от вертикальной прямой, но с вершинами, лежащими на этой вертикальной прямой.Множество S удобно хранить в контейнере типа set, при этом для него нужно аккуратно написать компаратор. Можно делать это следующим образом: Два отрезка могут одновременно находиться в S, если есть вертикальная прямая, которая пересекает каждый из них. В общем случае такая вертикальная прямая не единственная, возможные положения X, при котором это так, лежат на отрезке [l, r], который легко находится по координатам концов отрезков. Тогда можно взять произвольное X внутри [l, r] и сравнить ординаты точек пересечения. Удобно брать именно внутреннюю точку, поскольку не придется рассматривать частные случаи, связанные с тем, что сравниваемые отрезки могут иметь общий конец.После этого строим граф, вершинами которого являются вершины многоугольника и концы возможных спусков, а ребра — отрезки сторон и спуски. Кратчайший путь на таком графе ищется алгоритмом Дейкстры. Сложность решения — .Div1 E. Планарный графВ задаче был дан связный неориентированный планарный граф, без мостов, точек сочленения, кратных ребер и петель, уложенный на плоскость. Также были даны запросы следующего типа: для заданного цикла посчитать количество вершин внутри этого цикла, либо на нем самом.Возьмем произвольную вершину на границе, например вершину с самой маленькой абсциссой. Подвесим к ней новую вершину, причем ребро между вершиной на границе и новой вершиной должно быть снаружи от внешней грани графа. Назовем эту вершину стоком. Из каждой вершины графа, кроме стока, пустим поток величиной 1, текущий в сток. Поток можно пустить по дереву поиска в ширину или глубину, время, затрачиваемое на такую операцию есть O(E).Рассмотрим какой-нибудь запрос. Считаем, что цикл ориентирован против часовой стрелки, если это не так, то перевернем его. Сделаем разрез в графе: в первой доле разреза будут все вершины, которые лежат внутри цикла или на нем самом, во второй доле --- все оставшиеся вершины, в том числе и сток. Докажем, что величина потока через разрез равна количеству вершин в первой доле. Очевидно, что вклад в общий поток от каждой вершины графа можно рассматривать независимо. Пусть вершина находится в первой доле. Единичный поток от нее течет к стоку по какому-то пути. Так как эта вершина и сток находятся в разных долях, то этот путь нечетное число раз проходит по ребрам разреза, поэтому вклад в поток через разрез от этой вершины равен 1. Рассмотрим вершину, находящуюся во второй доле. Так как она в той же доле, что и сток, то поток от нее до стока проходит по ребрам разреза четное число раз, поэтому вклад от нее нулевой. Чтобы найти величину потока через разрез, нужно просуммировать потоки, текущие по ребрам разреза. Заметим, что каждое ребро разреза инцидентно ровно одной вершине, лежащей на цикле, поэтому можно для каждой вершины цикла просуммировать потоки, по ребрам, ведущим из этой вершины наружу цикла. Чтобы найти все ребра, ведущие наружу, отсортируем по углу все ребра, исходящие из вершины, в порядке против часовой стрелки. Тогда все ребра, ведущие наружу из вершины цикла, будут расположены после предыдущей вершины цикла и перед следующей вершиной цикла. Поэтому сумма потоков по ребрам наружу сводится к сумме на отрезке, что успешно решается частичными суммами. Сложность решения на сортировку графа плюс на запрос, где l — длина цикла. Логарифм числа ребер возникает из-за необходимости узнавать номер вершины в списке смежности для другой вершины.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5301",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 14065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #138 - Codeforces - Code 1",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 2",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 3",
          "code": "> ошибки в определении сложности задач случаются регулярно\n\n> совместить с сортировкой по предлагаемому уровню сложности.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 4",
          "code": "> ошибки в определении сложности задач случаются регулярно\n\n> совместить с сортировкой по предлагаемому уровню сложности.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 5",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 6",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 7",
          "code": "5 3\n1 2 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 8",
          "code": "4\n[[]]()[][][()]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 9",
          "code": "100000\n[][][][]...[][][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 10",
          "code": "4 3\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 1",
          "code": "([[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 2",
          "code": "([[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 3",
          "code": "5\n[[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 4",
          "code": "5\n[[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 5",
          "code": "4 * (a + b + c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,200000}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,200000}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,200000}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,200000}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,200000}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,200000}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len_s = opt<int>(\"len_s\");\n    int len_t = opt<int>(\"len_t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s, t;\n\n    if (type == \"random\") {\n        // Generate s and t randomly\n        s = \"\";\n        for (int i = 0; i < len_s; ++i)\n            s += (char)rnd.next('a', 'z');\n        t = \"\";\n        for (int i = 0; i < len_t; ++i)\n            t += (char)rnd.next('a', 'z');\n    } else if (type == \"no_subsequence\") {\n        // Generate s and t such that t is not a subsequence of s\n        // Let's generate s with letters 'a' to 'm', and t with letters 'n' to 'z'\n        s = \"\";\n        for (int i = 0; i < len_s; ++i)\n            s += (char)rnd.next('a', 'm');\n        t = \"\";\n        for (int i = 0; i < len_t; ++i)\n            t += (char)rnd.next('n', 'z');\n    } else if (type == \"full_coverage\") {\n        // Generate s and t such that t is a subsequence of s and all positions in s are used in the subsequences\n        // Let's generate t randomly\n        t = \"\";\n        for (int i = 0; i < len_t; ++i)\n            t += (char)rnd.next('a', 'z');\n        // Now, generate s = t repeated ceil(len_s / len_t) times\n        int repeat = (len_s + len_t - 1) / len_t;\n        s = \"\";\n        for (int i = 0; i < repeat; ++i)\n            s += t;\n        s = s.substr(0, len_s);  // Truncate to len_s\n    } else if (type == \"missing_char\") {\n        // Generate s and t such that t is a subsequence of s but some character position in s is not used in any occurrence of t\n        // Generate t randomly\n        t = \"\";\n        for (int i = 0; i < len_t; ++i)\n            t += (char)rnd.next('a', 'y'); // Exclude 'z' to have an extra character\n\n        // Generate s by inserting an extra character not in t at a random position\n        char extra_char = 'z'; // Since t contains letters 'a' to 'y', we can use 'z'\n        // Now, generate s as t with extra_char inserted at random positions\n        s = \"\";\n        // Let's pick a random position to insert extra_char\n        int pos = rnd.next(0, len_s - 1);\n        int t_pos = 0; // position in t\n        for (int i = 0; i < len_s; ++i) {\n            if (i == pos) {\n                s += extra_char;\n            } else if (t_pos < len_t) {\n                s += t[t_pos++];\n            } else {\n                // Fill with random characters from t (we can repeat characters)\n                s += t[rnd.next(0, len_t - 1)];\n            }\n        }\n\n    } else if (type == \"edge_case\") {\n        // For edge cases, we'll set len_s and len_t to their minimal or maximal values\n        // If len_s or len_t is 1\n        if (len_s == 1) {\n            s = string(1, rnd.next('a', 'z'));\n        } else {\n            s = \"\";\n            for (int i = 0; i < len_s; ++i)\n                s += (char)rnd.next('a', 'z');\n        }\n        if (len_t == 1) {\n            t = string(1, rnd.next('a', 'z'));\n        } else {\n            t = \"\";\n            for (int i = 0; i < len_t; ++i)\n                t += (char)rnd.next('a', 'z');\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output s and t\n    printf(\"%s\\n%s\\n\", s.c_str(), t.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len_s = opt<int>(\"len_s\");\n    int len_t = opt<int>(\"len_t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s, t;\n\n    if (type == \"random\") {\n        // Generate s and t randomly\n        s = \"\";\n        for (int i = 0; i < len_s; ++i)\n            s += (char)rnd.next('a', 'z');\n        t = \"\";\n        for (int i = 0; i < len_t; ++i)\n            t += (char)rnd.next('a', 'z');\n    } else if (type == \"no_subsequence\") {\n        // Generate s and t such that t is not a subsequence of s\n        // Let's generate s with letters 'a' to 'm', and t with letters 'n' to 'z'\n        s = \"\";\n        for (int i = 0; i < len_s; ++i)\n            s += (char)rnd.next('a', 'm');\n        t = \"\";\n        for (int i = 0; i < len_t; ++i)\n            t += (char)rnd.next('n', 'z');\n    } else if (type == \"full_coverage\") {\n        // Generate s and t such that t is a subsequence of s and all positions in s are used in the subsequences\n        // Let's generate t randomly\n        t = \"\";\n        for (int i = 0; i < len_t; ++i)\n            t += (char)rnd.next('a', 'z');\n        // Now, generate s = t repeated ceil(len_s / len_t) times\n        int repeat = (len_s + len_t - 1) / len_t;\n        s = \"\";\n        for (int i = 0; i < repeat; ++i)\n            s += t;\n        s = s.substr(0, len_s);  // Truncate to len_s\n    } else if (type == \"missing_char\") {\n        // Generate s and t such that t is a subsequence of s but some character position in s is not used in any occurrence of t\n        // Generate t randomly\n        t = \"\";\n        for (int i = 0; i < len_t; ++i)\n            t += (char)rnd.next('a', 'y'); // Exclude 'z' to have an extra character\n\n        // Generate s by inserting an extra character not in t at a random position\n        char extra_char = 'z'; // Since t contains letters 'a' to 'y', we can use 'z'\n        // Now, generate s as t with extra_char inserted at random positions\n        s = \"\";\n        // Let's pick a random position to insert extra_char\n        int pos = rnd.next(0, len_s - 1);\n        int t_pos = 0; // position in t\n        for (int i = 0; i < len_s; ++i) {\n            if (i == pos) {\n                s += extra_char;\n            } else if (t_pos < len_t) {\n                s += t[t_pos++];\n            } else {\n                // Fill with random characters from t (we can repeat characters)\n                s += t[rnd.next(0, len_t - 1)];\n            }\n        }\n\n    } else if (type == \"edge_case\") {\n        // For edge cases, we'll set len_s and len_t to their minimal or maximal values\n        // If len_s or len_t is 1\n        if (len_s == 1) {\n            s = string(1, rnd.next('a', 'z'));\n        } else {\n            s = \"\";\n            for (int i = 0; i < len_s; ++i)\n                s += (char)rnd.next('a', 'z');\n        }\n        if (len_t == 1) {\n            t = string(1, rnd.next('a', 'z'));\n        } else {\n            t = \"\";\n            for (int i = 0; i < len_t; ++i)\n                t += (char)rnd.next('a', 'z');\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output s and t\n    printf(\"%s\\n%s\\n\", s.c_str(), t.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len_s 1 -len_t 1 -type random\n./gen -len_s 2 -len_t 1 -type random\n./gen -len_s 10 -len_t 5 -type random\n./gen -len_s 100 -len_t 50 -type random\n./gen -len_s 200000 -len_t 100000 -type random\n\n./gen -len_s 1000 -len_t 500 -type no_subsequence\n./gen -len_s 5000 -len_t 5000 -type no_subsequence\n./gen -len_s 100000 -len_t 100000 -type no_subsequence\n./gen -len_s 200000 -len_t 199999 -type no_subsequence\n\n./gen -len_s 1000 -len_t 100 -type full_coverage\n./gen -len_s 50000 -len_t 500 -type full_coverage\n./gen -len_s 200000 -len_t 10000 -type full_coverage\n./gen -len_s 200000 -len_t 200000 -type full_coverage\n\n./gen -len_s 100000 -len_t 50000 -type missing_char\n./gen -len_s 200000 -len_t 100000 -type missing_char\n./gen -len_s 50000 -len_t 49999 -type missing_char\n./gen -len_s 200000 -len_t 199999 -type missing_char\n\n./gen -len_s 1 -len_t 1 -type edge_case\n./gen -len_s 2 -len_t 2 -type edge_case\n./gen -len_s 200000 -len_t 200000 -type edge_case\n\n./gen -len_s 10000 -len_t 9999 -type edge_case\n./gen -len_s 200000 -len_t 1 -type edge_case\n./gen -len_s 1 -len_t 200000 -type edge_case\n\n./gen -len_s 15 -len_t 20 -type no_subsequence\n./gen -len_s 100000 -len_t 1 -type random\n./gen -len_s 100000 -len_t 1 -type missing_char\n./gen -len_s 200000 -len_t 100000 -type random\n./gen -len_s 200000 -len_t 200000 -type random\n\n./gen -len_s 50 -len_t 25 -type full_coverage\n./gen -len_s 105 -len_t 35 -type full_coverage\n\n./gen -len_s 123456 -len_t 12345 -type missing_char\n./gen -len_s 123456 -len_t 12345 -type random\n\n./gen -len_s 2 -len_t 1 -type missing_char\n./gen -len_s 2 -len_t 1 -type full_coverage\n\n./gen -len_s 200000 -len_t 200000 -type missing_char\n\n./gen -len_s 50000 -len_t 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:23.743579",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "223/C",
      "title": "C. Частичные суммы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа через пробел n и k (1 ≤ n ≤ 2000, 0 ≤ k ≤ 109). В следующей строке записаны n целых чисел через пробел a1, a2, ..., an — элементы массива a (0 ≤ ai ≤ 109).",
      "output_spec": "Выходные данныеВыведите n целых чисел  — элементы массива a после проделанных операций. Элементы выводите в порядке увеличения их индексов в массиве a. Выведенные числа разделяйте пробельными символами.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 11 2 3Выходные данныеСкопировать1 3 6Входные данныеСкопировать5 03 14 15 92 6Выходные данныеСкопировать3 14 15 92 6",
      "description": "C. Частичные суммы\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа через пробел n и k (1 ≤ n ≤ 2000, 0 ≤ k ≤ 109). В следующей строке записаны n целых чисел через пробел a1, a2, ..., an — элементы массива a (0 ≤ ai ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите n целых чисел  — элементы массива a после проделанных операций. Элементы выводите в порядке увеличения их индексов в массиве a. Выведенные числа разделяйте пробельными символами.\n\nВыходные данные\n\nВходные данныеСкопировать3 11 2 3Выходные данныеСкопировать1 3 6Входные данныеСкопировать5 03 14 15 92 6Выходные данныеСкопировать3 14 15 92 6\n\nВходные данныеСкопировать3 11 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 3 6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 03 14 15 92 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 14 15 92 6\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #138 - Codeforces",
          "content": "Всем привет!Я рад объявить о том, что сегодня в 19:30 MSKсостоится Codeforces Round #138. Автором этого раунда являюсь я (Василий Вадимов). Это мой первый раунд на Codeforces, до этого я лишь помогал другим авторам в подготовке их раундов.Раунд мне помогал готовить Геральд Gerald Агапов, а условия задач перевела Мария Delinur Белова, за что им большое спасибо. Также я благодарен создателю Codeforces Михаилу MikeMirzayanov Мирзаянову за отличную платформу для проведения соревнований.Успехов на раунде! Надеюсь, задачи будут для вас интересными.Разбалловка в обоих дивизионах стандартная (500-1000-1500-2000-2500).UPD. Внимание! Язык D, который находится на этапе внедрения на Codeforces, на этом контесте не будет доступен.UPD2. Раунд завершен, топ-5 по в каждом из дивизионов:Div1: Petr tourist peter50216 Shik Egor Div2: ecnerwala ordcoder scipianus jonathanpaulson void_rank Поздравляем победителей! Также приношу извинения за неточность в условии в задаче div1 A/div2 C. Разбор будет опубликован завтра.UPD3. Доступен разбор задач.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1039
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces",
          "content": "Div2 A. ПараллелепипедВ этой задаче были даны площади трех граней прямоугольного параллелепипеда, нужно было найти сумму длин всех его сторон.Пусть длины трех сторон, имеющих одну общую вершину, равны a, b и c. Тогда нетрудно видеть, что нам даны числа s1 = ab, s2 = bc и s3 = ca. Из площадей легко можно выразить длины сторон: , , . Ответом является число 4(a + b + c), поскольку в параллелепипеде есть по 4 стороны с длинами a, b и c. Сложность решения — O(1).Div2 B. МассивВ задаче был дан массив a из n элементов, ai являлись положительными целыми и не превышали 105 для всех 1 ≤ i ≤ n. Также было дано число k. Нужно было найти минимальный по включению отрезок [l, r] такой, что среди чисел al, ... ar ровно k различных. Определение минимальности по включению дано в условии.Заведем массив cnt, изначально элемент cnti будет равен количеству вхождений числа i в массив a. Это можно сделать, поскольку элементы массива a небольшие. Число ненулевых элементов в массиве cnt равно числу различных элементов в массиве a. Если их меньше, чем k, то искомый отрезок найти невозможно. Допустим что это не так, тогда будем строить отрезок ответа [l, r]. Пусть изначально [l, r] = [1, n]. Будем уменьшать на 1 правую границу отрезка r, пока количество различных чисел не станет меньше, чем k. Поддерживать количество различных элементов на отрезке [l, r] можно следующим образом: при удалении элемента номер r из отрезка, уменьшим cntar на единицу. Если после этого cntar стал равным нулю, то уменьшим число различных элементов на 1. После этого вернем обратно последний выкинутый из отрезка элемент, чтобы количество различных стало ровно k. Затем сделаем точно так же с левой границей l, только будем не уменьшать, а увеличивать l на 1 каждый шаг. В результате мы получим отрезок [l, r], на котором есть ровно k различных элементов, а на отрезках [l + 1, r] и [l, r - 1] — меньше, чем k, следовательно это и есть искомый отрезок. Сложность решения — O(n).Div2 C/Div1 A. Скобочная последовательностьВ задаче была дана скобочная последовательность s из двух типов скобок. Нужно было найти правильную скобочную последовательность, являющуюся подстрокой строки s, содержащую наибольшее количество скобок <<>>.Для каждой открывающейся скобки попытаемся определить ей соответствующую закрывающуюся. Более формально, пусть открывающаяся скобка находится на позиции i, тогда скобка на позиции j называется ей соответствующей, если подстрока si... sj является кратчайшей правильной скобочной последовательностью, начинающейся с индекса i. Очевидно, если s не является правильной скобочной последовательностью, то не для каждой скобки найдется ей соответствующая.Будем идти по строке s и складывать позиции, на которых находятся открывающиеся скобки, в стек. Пусть мы находимся на позиции i, если si — открывающаяся скобка, то просто положим ее номер на вершину стека. Если нет, то посмотрим на вершину стека: если стек пустой или последняя открывающаяся скобка не соответствует текущей, то очистим стек. В противном случае запомним, что для скобки, лежащей на вершине, соответствующая есть скобка на позиции j и снимем вершину со стека. Нетрудно понять, что таким образом мы найдем все соответствующие для всех скобок, если они есть.Тогда строку s можно разбить на блоки. Блок — отрезок [l, r] такой, что скобка на позиции r — соответствующая для скобки на позиции l, и нет пары соответствующих скобок на позициях x и y таких, что и [l, r] ≠ [x, y]. Легко понять, что блоки не пересекаются и разбиение на блоки единственно. Мы можем склеивать подряд идущие блоки в правильные скобочные последовательности. При этом выгодно склеить как можно больше блоков, чтобы набрать как можно больше скобок нужного типа. Склеим все подряд идущие блоки, получим несколько подстрок, являющихся правильными скобочными последовательностями. Выберем из получившихся подстрок ту, в которой наибольшее количество скобок <<>>. Сложность решения — O(|s|).Div2 D/Div1 B. Две строкиВ задаче были даны две строки: s и t. Нужно было рассмотреть все вхождения строки t в строку s как подпоследовательность и сказать, верно ли, что для каждой позиции строки s найдется такое вхождение, которое содержит эту позицию.Для каждой позиции i строки s посчитаем две величины li и ri, li — максимально возможное число такое, что строка t1... tli входит как подпоследовательность в строку s1... si, ri — максимально возможное число такое, что строка t|t| - ri + 1... t|t| входит как подпоследовательность в строку si... s|s|. Пусть мы нашли все l для позиций 1... i - 1 и хотим найти li. Если символ tli - 1 + 1 существует и совпадает с символом si, то li = li - 1 + 1, в противном случае li = li - 1. Аналогично можно найти ri, если двигаться с конца строки.Теперь научимся проверять для позиции i в строке s, что она принадлежит хотя бы одному вхождению. Допустим, это так, и символ si соответствует символу tj в строке t. Тогда li - 1 ≥ j - 1 и ri + 1 ≥ |t| - j, по определению l и r. Тогда если существует j, такое что si = tj и li - 1 + 1 ≥ j ≥ |t| - ri + 1, то позиция i строки s принадлежит хотя бы одному вхождению t, в противном случае нет. Это легко проверить, если мы заведем для каждой буквы массив cnta, i — количество букв a в строке t на позициях 1... i. Алфавит небольшой, поэтому никаких проблем с памятью не будет. Сложность решения — O(|s| + |t|)Div2 E/Div1 C. Частичные суммыВ задаче был дан массив a. За одну операцию массив a заменяется массивом из его частичных сумм s. Нужно было найти массив после выполнения k таких операций. Все вычисления производятся по модулю P = 109 + 7.Запишем s в следующем виде: где Bi, j = 1, если i ≥ j и Bi, j = 0, если i < j, для всех 1 ≤ i, j ≤ n. Если a и s представить в виде векторов-столбцов, то применение одной операции соответствует умножению матрицы B на вектор столбец a. Тогда массив, получающийся после выполнения k операций результирующий массив будет равен Bka. Возводить матрицу в степень можно за , что уже неплохо, но недостаточно быстро.Заметим, что = , то есть элементы матрицы Bk на диагоналях, параллельным главным, одинаковы. Это можно легко доказать, используя метод математической индукции, предоставляю это читателю. Тогда можно задавать матрицу набором чисел , равным элементам первого столбца. Элементы первого столбца для произведения BkBl равны . Это следует прямо из формулы умножения двух матриц. Вычисление одного элемента работает за O(n) времени, всего элементов n, поэтому умножение можно производить за O(n2). Таким образом, мы научились решать задачу за времени, что уже укладывается в ограничения.Можно решать эту задачу быстрее, если убедиться, что . Допустим, что эта формула верна для какого-то k, докажем, что из этого следует, что формула верна и для k + 1. Используем формулу умножения для коэффициентов b: Используя формулу Cnk = n! / k!(n - k)!, можно получить, что , поэтому мы можем построить все коэффициенты b, если умеем делить по модулю P, поэтому в этом решении существенна простота P. Обратный для числа x по простому модулю равен в силу малой теоремы Ферма. Таким образом, мы получаем решение за O(n2).Div1 D. ПаукВ этой задаче был дан многоугольник из n вершин, нужно было найти кратчайший путь от одной его вершины до другой, если можно двигаться по границе, а также спускаться вертикально вниз, не выходя наружу.Все стороны многоугольника можно разбить на три группы: верхние, нижние и вертикальные. Вертикальная сторона это сторона, у которой совпадают координаты x ее концов. Нижняя сторона это такая сторона, что внутренность многоугольника лежит сверху от нее. Верхняя сторона это такая сторона, что внутренность многоугольника лежит снизу от нее. Понятно, что мы можем спускаться только с точек верхних сторон в точки нижних сторон. Вертикальные стороны на спуски никак не влияют, поскольку спуск проходящий через вертикальную сторону может быть разбит на два спуска и переход. Докажем, что нужно спускаться либо из вершины либо в вершину. Допустим, что какой-то спуск в оптимальном решении начинается с внутренней точки и заканчивается внутренней точкой. Попробуем немного изменить координату x этого спуска. Поскольку длина пути монотонно (возможно нестрого монотонно) зависит от x, то можно немного сдвинуть x так, что ответ не увеличится, а может быть даже и уменьшится. Нестрогая монотонность ломается только если спуск проходит через какую-то вершину, поэтому нужно рассматривать спуски из вершин и в вершины.Решаем задачу методом сканирующей прямой, будем двигать вертикальную прямую с абсциссой X слева направо и поддерживать множество S пересекающихся с ней сторон. Элементы этого множества будем хранить в отсортированном по y порядке. Поскольку стороны имеют общие точки только в вершинах, порядок всегда можно определить. При движении происходят разные события: какие-то отрезки добавляются в множество S, какие-то удаляются из него. Заведем массив событий, каждое событие описывается координатой x, равное координате X прямой, при котором происходит событие, а также типом события: номером отрезка и удаляется он или добавляется в S. Понятно, что для каждой стороны есть по два события, их координаты x соответствуют абсциссам концов сторон. Вертикальные стороны при этом можно игнорировать.Будем обрабатывать события в порядке неубывания координат x этих событий. Если пришло событие добавления стороны, то добавим сторону в S, после добавления посмотрим на ближайших соседей этой стороны в текущем множестве S. Если только что добавленный отрезок верхний, то проводим спуск из его левой вершины вниз, до пересечения с нижним соседом, а именно находим точку пересечения, запоминаем на каком отрезке она находится и запоминаем, что есть спуск из вершины в эту новую точку. Если добавленная сторона нижняя, то проводим спуск с верхнего соседа в левый конец добавленного отрезка, точно так же запоминая точку пересечения, на какой стороне она лежит и то, что есть спуск из этой точки в вершину. Если же событие соответствует удалению отрезка, то мы точно так же анализируем его соседей, только спуски будут начинаться или заканчиваться в правом конце отрезка, который мы собираемся удалять. Важный момент, если у нас происходит несколько событий одного типа одновременно, мы должны их обработать также одновременно, то есть если есть несколько добавлений в одной и той же координате x, нужно добавить их всех, а только потом рассматривать соседей. Аналогично, если нужно сделать несколько удалений, нужно рассмотреть соседей и только потом удалить отрезки. Также при равенстве координат x события добавления должны идти раньше событий удаления, иначе решение не будет работать в случае двух углов, лежащих по разные стороны от вертикальной прямой, но с вершинами, лежащими на этой вертикальной прямой.Множество S удобно хранить в контейнере типа set, при этом для него нужно аккуратно написать компаратор. Можно делать это следующим образом: Два отрезка могут одновременно находиться в S, если есть вертикальная прямая, которая пересекает каждый из них. В общем случае такая вертикальная прямая не единственная, возможные положения X, при котором это так, лежат на отрезке [l, r], который легко находится по координатам концов отрезков. Тогда можно взять произвольное X внутри [l, r] и сравнить ординаты точек пересечения. Удобно брать именно внутреннюю точку, поскольку не придется рассматривать частные случаи, связанные с тем, что сравниваемые отрезки могут иметь общий конец.После этого строим граф, вершинами которого являются вершины многоугольника и концы возможных спусков, а ребра — отрезки сторон и спуски. Кратчайший путь на таком графе ищется алгоритмом Дейкстры. Сложность решения — .Div1 E. Планарный графВ задаче был дан связный неориентированный планарный граф, без мостов, точек сочленения, кратных ребер и петель, уложенный на плоскость. Также были даны запросы следующего типа: для заданного цикла посчитать количество вершин внутри этого цикла, либо на нем самом.Возьмем произвольную вершину на границе, например вершину с самой маленькой абсциссой. Подвесим к ней новую вершину, причем ребро между вершиной на границе и новой вершиной должно быть снаружи от внешней грани графа. Назовем эту вершину стоком. Из каждой вершины графа, кроме стока, пустим поток величиной 1, текущий в сток. Поток можно пустить по дереву поиска в ширину или глубину, время, затрачиваемое на такую операцию есть O(E).Рассмотрим какой-нибудь запрос. Считаем, что цикл ориентирован против часовой стрелки, если это не так, то перевернем его. Сделаем разрез в графе: в первой доле разреза будут все вершины, которые лежат внутри цикла или на нем самом, во второй доле --- все оставшиеся вершины, в том числе и сток. Докажем, что величина потока через разрез равна количеству вершин в первой доле. Очевидно, что вклад в общий поток от каждой вершины графа можно рассматривать независимо. Пусть вершина находится в первой доле. Единичный поток от нее течет к стоку по какому-то пути. Так как эта вершина и сток находятся в разных долях, то этот путь нечетное число раз проходит по ребрам разреза, поэтому вклад в поток через разрез от этой вершины равен 1. Рассмотрим вершину, находящуюся во второй доле. Так как она в той же доле, что и сток, то поток от нее до стока проходит по ребрам разреза четное число раз, поэтому вклад от нее нулевой. Чтобы найти величину потока через разрез, нужно просуммировать потоки, текущие по ребрам разреза. Заметим, что каждое ребро разреза инцидентно ровно одной вершине, лежащей на цикле, поэтому можно для каждой вершины цикла просуммировать потоки, по ребрам, ведущим из этой вершины наружу цикла. Чтобы найти все ребра, ведущие наружу, отсортируем по углу все ребра, исходящие из вершины, в порядке против часовой стрелки. Тогда все ребра, ведущие наружу из вершины цикла, будут расположены после предыдущей вершины цикла и перед следующей вершиной цикла. Поэтому сумма потоков по ребрам наружу сводится к сумме на отрезке, что успешно решается частичными суммами. Сложность решения на сортировку графа плюс на запрос, где l — длина цикла. Логарифм числа ребер возникает из-за необходимости узнавать номер вершины в списке смежности для другой вершины.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5301",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 14065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #138 - Codeforces - Code 1",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 2",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 3",
          "code": "> ошибки в определении сложности задач случаются регулярно\n\n> совместить с сортировкой по предлагаемому уровню сложности.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 4",
          "code": "> ошибки в определении сложности задач случаются регулярно\n\n> совместить с сортировкой по предлагаемому уровню сложности.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 5",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 6",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 7",
          "code": "5 3\n1 2 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 8",
          "code": "4\n[[]]()[][][()]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 9",
          "code": "100000\n[][][][]...[][][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 10",
          "code": "4 3\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 1",
          "code": "([[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 2",
          "code": "([[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 3",
          "code": "5\n[[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 4",
          "code": "5\n[[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 5",
          "code": "4 * (a + b + c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<long long> a(n);\n    \n    if (type == \"zeros\") {\n        // All zeros\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"ones\") {\n        // All ones\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"increasing\") {\n        // a_i = i + 1\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        // a_i = n - i\n        for(int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"max\") {\n        // a_i = 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = 1000000000LL;\n    } else if (type == \"alternating\") {\n        // a_i = 0 if i%2==0 else 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 0LL : 1000000000LL;\n    } else if (type == \"random\") {\n        // Random between 0 and 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1000000000);\n    } else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n    \n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output array a\n    for(int i = 0; i < n; ++i)\n        printf(\"%lld%c\", a[i], (i+1 == n) ? '\\n' : ' ');\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<long long> a(n);\n    \n    if (type == \"zeros\") {\n        // All zeros\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"ones\") {\n        // All ones\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"increasing\") {\n        // a_i = i + 1\n        for(int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        // a_i = n - i\n        for(int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"max\") {\n        // a_i = 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = 1000000000LL;\n    } else if (type == \"alternating\") {\n        // a_i = 0 if i%2==0 else 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 0LL : 1000000000LL;\n    } else if (type == \"random\") {\n        // Random between 0 and 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1000000000);\n    } else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n    \n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output array a\n    for(int i = 0; i < n; ++i)\n        printf(\"%lld%c\", a[i], (i+1 == n) ? '\\n' : ' ');\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type zeros\n./gen -n 1 -k 1 -type zeros\n\n./gen -n 10 -k 0 -type ones\n./gen -n 10 -k 0 -type increasing\n./gen -n 10 -k 0 -type decreasing\n\n./gen -n 10 -k 1 -type ones\n./gen -n 10 -k 1 -type increasing\n./gen -n 10 -k 1 -type decreasing\n\n./gen -n 10 -k 1000000000 -type random\n\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 1 -type random\n./gen -n 1000 -k 1000 -type random\n\n./gen -n 2000 -k 0 -type zeros\n./gen -n 2000 -k 1 -type ones\n./gen -n 2000 -k 1000000000 -type increasing\n\n./gen -n 2000 -k 1000000000 -type zeros\n./gen -n 2000 -k 1000000000 -type ones\n./gen -n 2000 -k 1000000000 -type max\n./gen -n 2000 -k 1000000000 -type alternating\n\n./gen -n 2000 -k 0 -type random\n./gen -n 2000 -k 1 -type random\n./gen -n 2000 -k 2 -type random\n./gen -n 2000 -k 10 -type random\n./gen -n 2000 -k 100 -type random\n./gen -n 2000 -k 10000 -type random\n\n./gen -n 2000 -k 0 -type decreasing\n./gen -n 2000 -k 1 -type decreasing\n./gen -n 2000 -k 1000000000 -type decreasing\n\n./gen -n 1 -k 1000000000 -type random\n\n./gen -n 2 -k 0 -type increasing\n./gen -n 2 -k 1 -type increasing\n./gen -n 2 -k 1000000000 -type increasing\n\n./gen -n 2000 -k 1000000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:26.068684",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "223/D",
      "title": "D. Паук",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (3 ≤ n ≤ 105) — количество вершин заданного многоугольника. В следующих n строках через пробел записаны по два целых числа — координаты вершин многоугольника. Вершины перечислены в порядке обхода против часовой стрелки. Координаты вершин многоугольника по абсолютной величине не превосходят 104. В последней строке записаны два целых числа через пробел s и t (1 ≤ s, t ≤ n) — стартовая и конечная вершина искомого кратчайшего пути. Считайте, что вершины многоугольника пронумерованы в том же порядке, в котором они заданы во входных данных, то есть координаты первой вершины находятся во второй строке входных данных, а n-ой — в (n + 1)-ой строке. Гарантируется, что заданный многоугольник простой, то есть не имеет самопересечений и самокасаний.",
      "output_spec": "Выходные данныеВ выходной файл выведите единственное вещественное число — длину кратчайшего пути из вершины s в вершину t. Ответ считается правильным, если его абсолютная или относительная погрешность не превосходит 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать40 01 01 10 11 4Выходные данныеСкопировать1.000000000000000000e+000Входные данныеСкопировать40 01 10 2-1 13 3Выходные данныеСкопировать0.000000000000000000e+000Входные данныеСкопировать50 05 01 40 22 13 1Выходные данныеСкопировать5.650281539872884700e+000",
      "description": "ограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (3 ≤ n ≤ 105) — количество вершин заданного многоугольника. В следующих n строках через пробел записаны по два целых числа — координаты вершин многоугольника. Вершины перечислены в порядке обхода против часовой стрелки. Координаты вершин многоугольника по абсолютной величине не превосходят 104. В последней строке записаны два целых числа через пробел s и t (1 ≤ s, t ≤ n) — стартовая и конечная вершина искомого кратчайшего пути. Считайте, что вершины многоугольника пронумерованы в том же порядке, в котором они заданы во входных данных, то есть координаты первой вершины находятся во второй строке входных данных, а n-ой — в (n + 1)-ой строке. Гарантируется, что заданный многоугольник простой, то есть не имеет самопересечений и самокасаний.\n\nВходные данные\n\nВыходные данныеВ выходной файл выведите единственное вещественное число — длину кратчайшего пути из вершины s в вершину t. Ответ считается правильным, если его абсолютная или относительная погрешность не превосходит 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать40 01 01 10 11 4Выходные данныеСкопировать1.000000000000000000e+000Входные данныеСкопировать40 01 10 2-1 13 3Выходные данныеСкопировать0.000000000000000000e+000Входные данныеСкопировать50 05 01 40 22 13 1Выходные данныеСкопировать5.650281539872884700e+000\n\nВходные данныеСкопировать40 01 01 10 11 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.000000000000000000e+000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать40 01 10 2-1 13 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.000000000000000000e+000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать50 05 01 40 22 13 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5.650281539872884700e+000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере паук делает переход по стороне, соединяющей вершины с номерами 1 и 4.Во втором примере пауку никуда не нужно идти, поэтому расстояние равно нулю.В третьем примере пауку выгоднее всего перейти из вершины 3 в точку (2,3), совершить спуск в точку (2,1), а затем сделать переход в вершину 1.",
      "solutions": [
        {
          "title": "Codeforces Round #138 - Codeforces",
          "content": "Всем привет!Я рад объявить о том, что сегодня в 19:30 MSKсостоится Codeforces Round #138. Автором этого раунда являюсь я (Василий Вадимов). Это мой первый раунд на Codeforces, до этого я лишь помогал другим авторам в подготовке их раундов.Раунд мне помогал готовить Геральд Gerald Агапов, а условия задач перевела Мария Delinur Белова, за что им большое спасибо. Также я благодарен создателю Codeforces Михаилу MikeMirzayanov Мирзаянову за отличную платформу для проведения соревнований.Успехов на раунде! Надеюсь, задачи будут для вас интересными.Разбалловка в обоих дивизионах стандартная (500-1000-1500-2000-2500).UPD. Внимание! Язык D, который находится на этапе внедрения на Codeforces, на этом контесте не будет доступен.UPD2. Раунд завершен, топ-5 по в каждом из дивизионов:Div1: Petr tourist peter50216 Shik Egor Div2: ecnerwala ordcoder scipianus jonathanpaulson void_rank Поздравляем победителей! Также приношу извинения за неточность в условии в задаче div1 A/div2 C. Разбор будет опубликован завтра.UPD3. Доступен разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1039
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces",
          "content": "Div2 A. ПараллелепипедВ этой задаче были даны площади трех граней прямоугольного параллелепипеда, нужно было найти сумму длин всех его сторон.Пусть длины трех сторон, имеющих одну общую вершину, равны a, b и c. Тогда нетрудно видеть, что нам даны числа s1 = ab, s2 = bc и s3 = ca. Из площадей легко можно выразить длины сторон: , , . Ответом является число 4(a + b + c), поскольку в параллелепипеде есть по 4 стороны с длинами a, b и c. Сложность решения — O(1).Div2 B. МассивВ задаче был дан массив a из n элементов, ai являлись положительными целыми и не превышали 105 для всех 1 ≤ i ≤ n. Также было дано число k. Нужно было найти минимальный по включению отрезок [l, r] такой, что среди чисел al, ... ar ровно k различных. Определение минимальности по включению дано в условии.Заведем массив cnt, изначально элемент cnti будет равен количеству вхождений числа i в массив a. Это можно сделать, поскольку элементы массива a небольшие. Число ненулевых элементов в массиве cnt равно числу различных элементов в массиве a. Если их меньше, чем k, то искомый отрезок найти невозможно. Допустим что это не так, тогда будем строить отрезок ответа [l, r]. Пусть изначально [l, r] = [1, n]. Будем уменьшать на 1 правую границу отрезка r, пока количество различных чисел не станет меньше, чем k. Поддерживать количество различных элементов на отрезке [l, r] можно следующим образом: при удалении элемента номер r из отрезка, уменьшим cntar на единицу. Если после этого cntar стал равным нулю, то уменьшим число различных элементов на 1. После этого вернем обратно последний выкинутый из отрезка элемент, чтобы количество различных стало ровно k. Затем сделаем точно так же с левой границей l, только будем не уменьшать, а увеличивать l на 1 каждый шаг. В результате мы получим отрезок [l, r], на котором есть ровно k различных элементов, а на отрезках [l + 1, r] и [l, r - 1] — меньше, чем k, следовательно это и есть искомый отрезок. Сложность решения — O(n).Div2 C/Div1 A. Скобочная последовательностьВ задаче была дана скобочная последовательность s из двух типов скобок. Нужно было найти правильную скобочную последовательность, являющуюся подстрокой строки s, содержащую наибольшее количество скобок <<>>.Для каждой открывающейся скобки попытаемся определить ей соответствующую закрывающуюся. Более формально, пусть открывающаяся скобка находится на позиции i, тогда скобка на позиции j называется ей соответствующей, если подстрока si... sj является кратчайшей правильной скобочной последовательностью, начинающейся с индекса i. Очевидно, если s не является правильной скобочной последовательностью, то не для каждой скобки найдется ей соответствующая.Будем идти по строке s и складывать позиции, на которых находятся открывающиеся скобки, в стек. Пусть мы находимся на позиции i, если si — открывающаяся скобка, то просто положим ее номер на вершину стека. Если нет, то посмотрим на вершину стека: если стек пустой или последняя открывающаяся скобка не соответствует текущей, то очистим стек. В противном случае запомним, что для скобки, лежащей на вершине, соответствующая есть скобка на позиции j и снимем вершину со стека. Нетрудно понять, что таким образом мы найдем все соответствующие для всех скобок, если они есть.Тогда строку s можно разбить на блоки. Блок — отрезок [l, r] такой, что скобка на позиции r — соответствующая для скобки на позиции l, и нет пары соответствующих скобок на позициях x и y таких, что и [l, r] ≠ [x, y]. Легко понять, что блоки не пересекаются и разбиение на блоки единственно. Мы можем склеивать подряд идущие блоки в правильные скобочные последовательности. При этом выгодно склеить как можно больше блоков, чтобы набрать как можно больше скобок нужного типа. Склеим все подряд идущие блоки, получим несколько подстрок, являющихся правильными скобочными последовательностями. Выберем из получившихся подстрок ту, в которой наибольшее количество скобок <<>>. Сложность решения — O(|s|).Div2 D/Div1 B. Две строкиВ задаче были даны две строки: s и t. Нужно было рассмотреть все вхождения строки t в строку s как подпоследовательность и сказать, верно ли, что для каждой позиции строки s найдется такое вхождение, которое содержит эту позицию.Для каждой позиции i строки s посчитаем две величины li и ri, li — максимально возможное число такое, что строка t1... tli входит как подпоследовательность в строку s1... si, ri — максимально возможное число такое, что строка t|t| - ri + 1... t|t| входит как подпоследовательность в строку si... s|s|. Пусть мы нашли все l для позиций 1... i - 1 и хотим найти li. Если символ tli - 1 + 1 существует и совпадает с символом si, то li = li - 1 + 1, в противном случае li = li - 1. Аналогично можно найти ri, если двигаться с конца строки.Теперь научимся проверять для позиции i в строке s, что она принадлежит хотя бы одному вхождению. Допустим, это так, и символ si соответствует символу tj в строке t. Тогда li - 1 ≥ j - 1 и ri + 1 ≥ |t| - j, по определению l и r. Тогда если существует j, такое что si = tj и li - 1 + 1 ≥ j ≥ |t| - ri + 1, то позиция i строки s принадлежит хотя бы одному вхождению t, в противном случае нет. Это легко проверить, если мы заведем для каждой буквы массив cnta, i — количество букв a в строке t на позициях 1... i. Алфавит небольшой, поэтому никаких проблем с памятью не будет. Сложность решения — O(|s| + |t|)Div2 E/Div1 C. Частичные суммыВ задаче был дан массив a. За одну операцию массив a заменяется массивом из его частичных сумм s. Нужно было найти массив после выполнения k таких операций. Все вычисления производятся по модулю P = 109 + 7.Запишем s в следующем виде: где Bi, j = 1, если i ≥ j и Bi, j = 0, если i < j, для всех 1 ≤ i, j ≤ n. Если a и s представить в виде векторов-столбцов, то применение одной операции соответствует умножению матрицы B на вектор столбец a. Тогда массив, получающийся после выполнения k операций результирующий массив будет равен Bka. Возводить матрицу в степень можно за , что уже неплохо, но недостаточно быстро.Заметим, что = , то есть элементы матрицы Bk на диагоналях, параллельным главным, одинаковы. Это можно легко доказать, используя метод математической индукции, предоставляю это читателю. Тогда можно задавать матрицу набором чисел , равным элементам первого столбца. Элементы первого столбца для произведения BkBl равны . Это следует прямо из формулы умножения двух матриц. Вычисление одного элемента работает за O(n) времени, всего элементов n, поэтому умножение можно производить за O(n2). Таким образом, мы научились решать задачу за времени, что уже укладывается в ограничения.Можно решать эту задачу быстрее, если убедиться, что . Допустим, что эта формула верна для какого-то k, докажем, что из этого следует, что формула верна и для k + 1. Используем формулу умножения для коэффициентов b: Используя формулу Cnk = n! / k!(n - k)!, можно получить, что , поэтому мы можем построить все коэффициенты b, если умеем делить по модулю P, поэтому в этом решении существенна простота P. Обратный для числа x по простому модулю равен в силу малой теоремы Ферма. Таким образом, мы получаем решение за O(n2).Div1 D. ПаукВ этой задаче был дан многоугольник из n вершин, нужно было найти кратчайший путь от одной его вершины до другой, если можно двигаться по границе, а также спускаться вертикально вниз, не выходя наружу.Все стороны многоугольника можно разбить на три группы: верхние, нижние и вертикальные. Вертикальная сторона это сторона, у которой совпадают координаты x ее концов. Нижняя сторона это такая сторона, что внутренность многоугольника лежит сверху от нее. Верхняя сторона это такая сторона, что внутренность многоугольника лежит снизу от нее. Понятно, что мы можем спускаться только с точек верхних сторон в точки нижних сторон. Вертикальные стороны на спуски никак не влияют, поскольку спуск проходящий через вертикальную сторону может быть разбит на два спуска и переход. Докажем, что нужно спускаться либо из вершины либо в вершину. Допустим, что какой-то спуск в оптимальном решении начинается с внутренней точки и заканчивается внутренней точкой. Попробуем немного изменить координату x этого спуска. Поскольку длина пути монотонно (возможно нестрого монотонно) зависит от x, то можно немного сдвинуть x так, что ответ не увеличится, а может быть даже и уменьшится. Нестрогая монотонность ломается только если спуск проходит через какую-то вершину, поэтому нужно рассматривать спуски из вершин и в вершины.Решаем задачу методом сканирующей прямой, будем двигать вертикальную прямую с абсциссой X слева направо и поддерживать множество S пересекающихся с ней сторон. Элементы этого множества будем хранить в отсортированном по y порядке. Поскольку стороны имеют общие точки только в вершинах, порядок всегда можно определить. При движении происходят разные события: какие-то отрезки добавляются в множество S, какие-то удаляются из него. Заведем массив событий, каждое событие описывается координатой x, равное координате X прямой, при котором происходит событие, а также типом события: номером отрезка и удаляется он или добавляется в S. Понятно, что для каждой стороны есть по два события, их координаты x соответствуют абсциссам концов сторон. Вертикальные стороны при этом можно игнорировать.Будем обрабатывать события в порядке неубывания координат x этих событий. Если пришло событие добавления стороны, то добавим сторону в S, после добавления посмотрим на ближайших соседей этой стороны в текущем множестве S. Если только что добавленный отрезок верхний, то проводим спуск из его левой вершины вниз, до пересечения с нижним соседом, а именно находим точку пересечения, запоминаем на каком отрезке она находится и запоминаем, что есть спуск из вершины в эту новую точку. Если добавленная сторона нижняя, то проводим спуск с верхнего соседа в левый конец добавленного отрезка, точно так же запоминая точку пересечения, на какой стороне она лежит и то, что есть спуск из этой точки в вершину. Если же событие соответствует удалению отрезка, то мы точно так же анализируем его соседей, только спуски будут начинаться или заканчиваться в правом конце отрезка, который мы собираемся удалять. Важный момент, если у нас происходит несколько событий одного типа одновременно, мы должны их обработать также одновременно, то есть если есть несколько добавлений в одной и той же координате x, нужно добавить их всех, а только потом рассматривать соседей. Аналогично, если нужно сделать несколько удалений, нужно рассмотреть соседей и только потом удалить отрезки. Также при равенстве координат x события добавления должны идти раньше событий удаления, иначе решение не будет работать в случае двух углов, лежащих по разные стороны от вертикальной прямой, но с вершинами, лежащими на этой вертикальной прямой.Множество S удобно хранить в контейнере типа set, при этом для него нужно аккуратно написать компаратор. Можно делать это следующим образом: Два отрезка могут одновременно находиться в S, если есть вертикальная прямая, которая пересекает каждый из них. В общем случае такая вертикальная прямая не единственная, возможные положения X, при котором это так, лежат на отрезке [l, r], который легко находится по координатам концов отрезков. Тогда можно взять произвольное X внутри [l, r] и сравнить ординаты точек пересечения. Удобно брать именно внутреннюю точку, поскольку не придется рассматривать частные случаи, связанные с тем, что сравниваемые отрезки могут иметь общий конец.После этого строим граф, вершинами которого являются вершины многоугольника и концы возможных спусков, а ребра — отрезки сторон и спуски. Кратчайший путь на таком графе ищется алгоритмом Дейкстры. Сложность решения — .Div1 E. Планарный графВ задаче был дан связный неориентированный планарный граф, без мостов, точек сочленения, кратных ребер и петель, уложенный на плоскость. Также были даны запросы следующего типа: для заданного цикла посчитать количество вершин внутри этого цикла, либо на нем самом.Возьмем произвольную вершину на границе, например вершину с самой маленькой абсциссой. Подвесим к ней новую вершину, причем ребро между вершиной на границе и новой вершиной должно быть снаружи от внешней грани графа. Назовем эту вершину стоком. Из каждой вершины графа, кроме стока, пустим поток величиной 1, текущий в сток. Поток можно пустить по дереву поиска в ширину или глубину, время, затрачиваемое на такую операцию есть O(E).Рассмотрим какой-нибудь запрос. Считаем, что цикл ориентирован против часовой стрелки, если это не так, то перевернем его. Сделаем разрез в графе: в первой доле разреза будут все вершины, которые лежат внутри цикла или на нем самом, во второй доле --- все оставшиеся вершины, в том числе и сток. Докажем, что величина потока через разрез равна количеству вершин в первой доле. Очевидно, что вклад в общий поток от каждой вершины графа можно рассматривать независимо. Пусть вершина находится в первой доле. Единичный поток от нее течет к стоку по какому-то пути. Так как эта вершина и сток находятся в разных долях, то этот путь нечетное число раз проходит по ребрам разреза, поэтому вклад в поток через разрез от этой вершины равен 1. Рассмотрим вершину, находящуюся во второй доле. Так как она в той же доле, что и сток, то поток от нее до стока проходит по ребрам разреза четное число раз, поэтому вклад от нее нулевой. Чтобы найти величину потока через разрез, нужно просуммировать потоки, текущие по ребрам разреза. Заметим, что каждое ребро разреза инцидентно ровно одной вершине, лежащей на цикле, поэтому можно для каждой вершины цикла просуммировать потоки, по ребрам, ведущим из этой вершины наружу цикла. Чтобы найти все ребра, ведущие наружу, отсортируем по углу все ребра, исходящие из вершины, в порядке против часовой стрелки. Тогда все ребра, ведущие наружу из вершины цикла, будут расположены после предыдущей вершины цикла и перед следующей вершиной цикла. Поэтому сумма потоков по ребрам наружу сводится к сумме на отрезке, что успешно решается частичными суммами. Сложность решения на сортировку графа плюс на запрос, где l — длина цикла. Логарифм числа ребер возникает из-за необходимости узнавать номер вершины в списке смежности для другой вершины.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5301",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 14065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #138 - Codeforces - Code 1",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 2",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 3",
          "code": "> ошибки в определении сложности задач случаются регулярно\n\n> совместить с сортировкой по предлагаемому уровню сложности.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 4",
          "code": "> ошибки в определении сложности задач случаются регулярно\n\n> совместить с сортировкой по предлагаемому уровню сложности.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 5",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 6",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 7",
          "code": "5 3\n1 2 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 8",
          "code": "4\n[[]]()[][][()]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 9",
          "code": "100000\n[][][][]...[][][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 10",
          "code": "4 3\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 1",
          "code": "([[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 2",
          "code": "([[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 3",
          "code": "5\n[[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 4",
          "code": "5\n[[]][[]]()[]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, разбор задач. - Codeforces - Code 5",
          "code": "4 * (a + b + c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_COORD = 10000;\nconst int MIN_COORD = -10000;\n\nstruct Point {\n    int x, y;\n    int idx;\n    Point(int x = 0, int y = 0, int idx = -1) : x(x), y(y), idx(idx) {}\n};\n\ntypedef long long int64;\n\nstruct Segment {\n    Point p, q;\n    int idx;\n\n    Segment(Point p, Point q, int idx) : p(p), q(q), idx(idx) {\n        // Ensure p.x <= q.x or if x equal, p.y <= q.y\n        if (make_pair(p.x, p.y) > make_pair(q.x, q.y))\n            swap(p, q);\n    }\n};\n\nbool operator<(const Point& a, const Point& b) {\n    return tie(a.x, a.y, a.idx) < tie(b.x, b.y, b.idx);\n}\n\nstruct Event {\n    int x;\n    int type; // 0 = segment start, 1 = segment end\n    Segment *seg;\n    \n    Event(int x, int type, Segment *seg) : x(x), type(type), seg(seg) {}\n    \n    bool operator<(const Event& other) const {\n        if (x != other.x) return x < other.x;\n        return type < other.type; // Start before end\n    }\n};\n\nstruct SweepCmp {\n    double x;\n    bool operator()(Segment* a, Segment* b) const {\n        double y1 = a->p.y + (a->q.y - a->p.y) * (x - a->p.x) / (double)(a->q.x - a->p.x);\n        double y2 = b->p.y + (b->q.y - b->p.y) * (x - b->p.x) / (double)(b->q.x - b->p.x);\n        if (abs(y1 - y2) > 1e-9)\n            return y1 < y2;\n        return a->idx < b->idx;\n    }\n};\n\nbool segmentsIntersect(Segment* a, Segment* b) {\n    auto ccw = [](Point A, Point B, Point C) {\n        return (int64)(C.y - A.y) * (B.x - A.x) > (int64)(B.y - A.y) * (C.x - A.x);\n    };\n    Point A = a->p, B = a->q, C = b->p, D = b->q;\n    if (A.idx == C.idx || A.idx == D.idx || B.idx == C.idx || B.idx == D.idx)\n        return false; // Adjacent segments\n\n    return (ccw(A,C,D) != ccw(B,C,D)) && (ccw(A,B,C) != ccw(A,B,D));\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, MAX_N, \"n\");\n    inf.readEoln();\n\n    vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(MIN_COORD, MAX_COORD, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(MIN_COORD, MAX_COORD, \"y_i\");\n        inf.readEoln();\n        points[i] = Point(x, y, i);\n    }\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    // Ensure that adjacent vertices are not the same\n    for (int i = 0; i < n; ++i) {\n        Point& a = points[i];\n        Point& b = points[(i+1)%n];\n        ensuref(a.x != b.x || a.y != b.y, \"Consecutive vertices %d and %d are the same point\", a.idx + 1, b.idx + 1);\n    }\n\n    // Compute polygon area to check counter-clockwise order\n    int64 area2 = 0;\n    for (int i = 0; i < n; ++i) {\n        Point& a = points[i];\n        Point& b = points[(i+1)%n];\n        area2 += (int64)(a.x) * b.y - (int64)(a.y) * b.x;\n    }\n    ensuref(area2 > 0, \"Polygon is not in counter-clockwise order (area2=%lld)\", area2);\n\n    // Build segments\n    vector<Segment*> segments;\n    for (int i = 0; i < n; ++i) {\n        Segment* seg = new Segment(points[i], points[(i+1)%n], i);\n        segments.push_back(seg);\n    }\n\n    // Build events\n    vector<Event> events;\n    for (Segment* seg : segments) {\n        events.emplace_back(seg->p.x, 0, seg); // Start\n        events.emplace_back(seg->q.x, 1, seg); // End\n    }\n    sort(events.begin(), events.end());\n\n    set<Segment*, SweepCmp> sweepLine;\n    SweepCmp cmp;\n    \n    for (const Event& event : events) {\n        cmp.x = event.x + 1e-8; // Small offset to avoid precision issues\n        if (event.type == 0) {\n            // Insert segment\n            auto it = sweepLine.insert(event.seg).first;\n            // Check with predecessor\n            if (it != sweepLine.begin()) {\n                auto prev = it;\n                prev--;\n                if (segmentsIntersect(*prev, *it)) {\n                    ensuref(false, \"Segments %d and %d intersect\", (*prev)->idx + 1, (*it)->idx + 1);\n                }\n            }\n            // Check with successor\n            auto next = it;\n            next++;\n            if (next != sweepLine.end()) {\n                if (segmentsIntersect(*it, *next)) {\n                    ensuref(false, \"Segments %d and %d intersect\", (*it)->idx + 1, (*next)->idx + 1);\n                }\n            }\n        } else {\n            // Remove segment\n            auto it = sweepLine.find(event.seg);\n            if (it != sweepLine.end()) {\n                auto prev = it;\n                auto next = it;\n                bool hasPrev = false, hasNext = false;\n                if (it != sweepLine.begin()) {\n                    prev--;\n                    hasPrev = true;\n                }\n                next++;\n                if (next != sweepLine.end()) {\n                    hasNext = true;\n                }\n                if (hasPrev && hasNext) {\n                    if (segmentsIntersect(*prev, *next)) {\n                        ensuref(false, \"Segments %d and %d intersect\", (*prev)->idx + 1, (*next)->idx + 1);\n                    }\n                }\n                sweepLine.erase(it);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_COORD = 10000;\nconst int MIN_COORD = -10000;\n\nstruct Point {\n    int x, y;\n    int idx;\n    Point(int x = 0, int y = 0, int idx = -1) : x(x), y(y), idx(idx) {}\n};\n\ntypedef long long int64;\n\nstruct Segment {\n    Point p, q;\n    int idx;\n\n    Segment(Point p, Point q, int idx) : p(p), q(q), idx(idx) {\n        // Ensure p.x <= q.x or if x equal, p.y <= q.y\n        if (make_pair(p.x, p.y) > make_pair(q.x, q.y))\n            swap(p, q);\n    }\n};\n\nbool operator<(const Point& a, const Point& b) {\n    return tie(a.x, a.y, a.idx) < tie(b.x, b.y, b.idx);\n}\n\nstruct Event {\n    int x;\n    int type; // 0 = segment start, 1 = segment end\n    Segment *seg;\n    \n    Event(int x, int type, Segment *seg) : x(x), type(type), seg(seg) {}\n    \n    bool operator<(const Event& other) const {\n        if (x != other.x) return x < other.x;\n        return type < other.type; // Start before end\n    }\n};\n\nstruct SweepCmp {\n    double x;\n    bool operator()(Segment* a, Segment* b) const {\n        double y1 = a->p.y + (a->q.y - a->p.y) * (x - a->p.x) / (double)(a->q.x - a->p.x);\n        double y2 = b->p.y + (b->q.y - b->p.y) * (x - b->p.x) / (double)(b->q.x - b->p.x);\n        if (abs(y1 - y2) > 1e-9)\n            return y1 < y2;\n        return a->idx < b->idx;\n    }\n};\n\nbool segmentsIntersect(Segment* a, Segment* b) {\n    auto ccw = [](Point A, Point B, Point C) {\n        return (int64)(C.y - A.y) * (B.x - A.x) > (int64)(B.y - A.y) * (C.x - A.x);\n    };\n    Point A = a->p, B = a->q, C = b->p, D = b->q;\n    if (A.idx == C.idx || A.idx == D.idx || B.idx == C.idx || B.idx == D.idx)\n        return false; // Adjacent segments\n\n    return (ccw(A,C,D) != ccw(B,C,D)) && (ccw(A,B,C) != ccw(A,B,D));\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, MAX_N, \"n\");\n    inf.readEoln();\n\n    vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(MIN_COORD, MAX_COORD, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(MIN_COORD, MAX_COORD, \"y_i\");\n        inf.readEoln();\n        points[i] = Point(x, y, i);\n    }\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    // Ensure that adjacent vertices are not the same\n    for (int i = 0; i < n; ++i) {\n        Point& a = points[i];\n        Point& b = points[(i+1)%n];\n        ensuref(a.x != b.x || a.y != b.y, \"Consecutive vertices %d and %d are the same point\", a.idx + 1, b.idx + 1);\n    }\n\n    // Compute polygon area to check counter-clockwise order\n    int64 area2 = 0;\n    for (int i = 0; i < n; ++i) {\n        Point& a = points[i];\n        Point& b = points[(i+1)%n];\n        area2 += (int64)(a.x) * b.y - (int64)(a.y) * b.x;\n    }\n    ensuref(area2 > 0, \"Polygon is not in counter-clockwise order (area2=%lld)\", area2);\n\n    // Build segments\n    vector<Segment*> segments;\n    for (int i = 0; i < n; ++i) {\n        Segment* seg = new Segment(points[i], points[(i+1)%n], i);\n        segments.push_back(seg);\n    }\n\n    // Build events\n    vector<Event> events;\n    for (Segment* seg : segments) {\n        events.emplace_back(seg->p.x, 0, seg); // Start\n        events.emplace_back(seg->q.x, 1, seg); // End\n    }\n    sort(events.begin(), events.end());\n\n    set<Segment*, SweepCmp> sweepLine;\n    SweepCmp cmp;\n    \n    for (const Event& event : events) {\n        cmp.x = event.x + 1e-8; // Small offset to avoid precision issues\n        if (event.type == 0) {\n            // Insert segment\n            auto it = sweepLine.insert(event.seg).first;\n            // Check with predecessor\n            if (it != sweepLine.begin()) {\n                auto prev = it;\n                prev--;\n                if (segmentsIntersect(*prev, *it)) {\n                    ensuref(false, \"Segments %d and %d intersect\", (*prev)->idx + 1, (*it)->idx + 1);\n                }\n            }\n            // Check with successor\n            auto next = it;\n            next++;\n            if (next != sweepLine.end()) {\n                if (segmentsIntersect(*it, *next)) {\n                    ensuref(false, \"Segments %d and %d intersect\", (*it)->idx + 1, (*next)->idx + 1);\n                }\n            }\n        } else {\n            // Remove segment\n            auto it = sweepLine.find(event.seg);\n            if (it != sweepLine.end()) {\n                auto prev = it;\n                auto next = it;\n                bool hasPrev = false, hasNext = false;\n                if (it != sweepLine.begin()) {\n                    prev--;\n                    hasPrev = true;\n                }\n                next++;\n                if (next != sweepLine.end()) {\n                    hasNext = true;\n                }\n                if (hasPrev && hasNext) {\n                    if (segmentsIntersect(*prev, *next)) {\n                        ensuref(false, \"Segments %d and %d intersect\", (*prev)->idx + 1, (*next)->idx + 1);\n                    }\n                }\n                sweepLine.erase(it);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_COORD = 10000;\nconst int MIN_COORD = -10000;\n\nstruct Point {\n    int x, y;\n    int idx;\n    Point(int x = 0, int y = 0, int idx = -1) : x(x), y(y), idx(idx) {}\n};\n\ntypedef long long int64;\n\nstruct Segment {\n    Point p, q;\n    int idx;\n\n    Segment(Point p, Point q, int idx) : p(p), q(q), idx(idx) {\n        // Ensure p.x <= q.x or if x equal, p.y <= q.y\n        if (make_pair(p.x, p.y) > make_pair(q.x, q.y))\n            swap(p, q);\n    }\n};\n\nbool operator<(const Point& a, const Point& b) {\n    return tie(a.x, a.y, a.idx) < tie(b.x, b.y, b.idx);\n}\n\nstruct Event {\n    int x;\n    int type; // 0 = segment start, 1 = segment end\n    Segment *seg;\n    \n    Event(int x, int type, Segment *seg) : x(x), type(type), seg(seg) {}\n    \n    bool operator<(const Event& other) const {\n        if (x != other.x) return x < other.x;\n        return type < other.type; // Start before end\n    }\n};\n\nstruct SweepCmp {\n    double x;\n    bool operator()(Segment* a, Segment* b) const {\n        double y1 = a->p.y + (a->q.y - a->p.y) * (x - a->p.x) / (double)(a->q.x - a->p.x);\n        double y2 = b->p.y + (b->q.y - b->p.y) * (x - b->p.x) / (double)(b->q.x - b->p.x);\n        if (abs(y1 - y2) > 1e-9)\n            return y1 < y2;\n        return a->idx < b->idx;\n    }\n};\n\nbool segmentsIntersect(Segment* a, Segment* b) {\n    auto ccw = [](Point A, Point B, Point C) {\n        return (int64)(C.y - A.y) * (B.x - A.x) > (int64)(B.y - A.y) * (C.x - A.x);\n    };\n    Point A = a->p, B = a->q, C = b->p, D = b->q;\n    if (A.idx == C.idx || A.idx == D.idx || B.idx == C.idx || B.idx == D.idx)\n        return false; // Adjacent segments\n\n    return (ccw(A,C,D) != ccw(B,C,D)) && (ccw(A,B,C) != ccw(A,B,D));\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, MAX_N, \"n\");\n    inf.readEoln();\n\n    vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(MIN_COORD, MAX_COORD, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(MIN_COORD, MAX_COORD, \"y_i\");\n        inf.readEoln();\n        points[i] = Point(x, y, i);\n    }\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    // Ensure that adjacent vertices are not the same\n    for (int i = 0; i < n; ++i) {\n        Point& a = points[i];\n        Point& b = points[(i+1)%n];\n        ensuref(a.x != b.x || a.y != b.y, \"Consecutive vertices %d and %d are the same point\", a.idx + 1, b.idx + 1);\n    }\n\n    // Compute polygon area to check counter-clockwise order\n    int64 area2 = 0;\n    for (int i = 0; i < n; ++i) {\n        Point& a = points[i];\n        Point& b = points[(i+1)%n];\n        area2 += (int64)(a.x) * b.y - (int64)(a.y) * b.x;\n    }\n    ensuref(area2 > 0, \"Polygon is not in counter-clockwise order (area2=%lld)\", area2);\n\n    // Build segments\n    vector<Segment*> segments;\n    for (int i = 0; i < n; ++i) {\n        Segment* seg = new Segment(points[i], points[(i+1)%n], i);\n        segments.push_back(seg);\n    }\n\n    // Build events\n    vector<Event> events;\n    for (Segment* seg : segments) {\n        events.emplace_back(seg->p.x, 0, seg); // Start\n        events.emplace_back(seg->q.x, 1, seg); // End\n    }\n    sort(events.begin(), events.end());\n\n    set<Segment*, SweepCmp> sweepLine;\n    SweepCmp cmp;\n    \n    for (const Event& event : events) {\n        cmp.x = event.x + 1e-8; // Small offset to avoid precision issues\n        if (event.type == 0) {\n            // Insert segment\n            auto it = sweepLine.insert(event.seg).first;\n            // Check with predecessor\n            if (it != sweepLine.begin()) {\n                auto prev = it;\n                prev--;\n                if (segmentsIntersect(*prev, *it)) {\n                    ensuref(false, \"Segments %d and %d intersect\", (*prev)->idx + 1, (*it)->idx + 1);\n                }\n            }\n            // Check with successor\n            auto next = it;\n            next++;\n            if (next != sweepLine.end()) {\n                if (segmentsIntersect(*it, *next)) {\n                    ensuref(false, \"Segments %d and %d intersect\", (*it)->idx + 1, (*next)->idx + 1);\n                }\n            }\n        } else {\n            // Remove segment\n            auto it = sweepLine.find(event.seg);\n            if (it != sweepLine.end()) {\n                auto prev = it;\n                auto next = it;\n                bool hasPrev = false, hasNext = false;\n                if (it != sweepLine.begin()) {\n                    prev--;\n                    hasPrev = true;\n                }\n                next++;\n                if (next != sweepLine.end()) {\n                    hasNext = true;\n                }\n                if (hasPrev && hasNext) {\n                    if (segmentsIntersect(*prev, *next)) {\n                        ensuref(false, \"Segments %d and %d intersect\", (*prev)->idx + 1, (*next)->idx + 1);\n                    }\n                }\n                sweepLine.erase(it);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"convex\");\n    int s = opt<int>(\"s\", -1);\n    int t = opt<int>(\"t\", -1);\n    int coord_limit = opt<int>(\"coord_limit\", 10000);\n\n    if (s == -1) {\n        s = rnd.next(1, n);\n    }\n    if (t == -1) {\n        t = rnd.next(1, n);\n    }\n\n    vector<pair<int, int>> points;\n\n    if (type == \"convex\" || type == \"concave\") {\n        double R = coord_limit * 0.8;\n        for (int i = 0; i < n; ++i) {\n            double angle = 2.0 * PI * i / n;\n            double radius = R;\n            // For concave polygon, push every other point inward\n            if (type == \"concave\" && i % 2 == 0) {\n                radius *= 0.5; // Push inward by half\n            }\n            double x = radius * cos(angle);\n            double y = radius * sin(angle);\n            int xi = (int)round(x);\n            int yi = (int)round(y);\n            points.push_back({xi, yi});\n        }\n    } else if (type == \"vertical_sides\") {\n        int W = coord_limit; // Width of rectangle\n        int H = coord_limit; // Height of rectangle\n        vector<pair<int, int>> left_side;\n        vector<pair<int, int>> right_side;\n\n        int half_n = n / 2;\n        if (n % 2 != 0) {\n            half_n = n / 2 + 1;\n        }\n        // Generate points along left side\n        for (int i = 0; i < half_n; ++i) {\n            int x = -W / 2;\n            int y = -H / 2 + i * H / (half_n - 1);\n            left_side.push_back({x, y});\n        }\n        // Generate points along top side\n        if (n % 2 != 0) {\n            int x = W / 2;\n            int y = H / 2;\n            right_side.push_back({x, y});\n        }\n        // Generate points along right side\n        for (int i = half_n - 1; i >= 0; --i) {\n            int x = W / 2;\n            int y = -H / 2 + i * H / (half_n - 1);\n            right_side.push_back({x, y});\n        }\n        points.insert(points.end(), left_side.begin(), left_side.end());\n        points.insert(points.end(), right_side.begin(), right_side.end());\n    } else if (type == \"thin\") {\n        int W = coord_limit; // Width of rectangle\n        int H = 1; // Very small height\n        int half_n = n / 2;\n        if (n % 2 != 0) {\n            half_n = n / 2 + 1;\n        }\n        // Generate points along bottom side\n        for (int i = 0; i < half_n; ++i) {\n            int x = -W / 2 + i * W / (half_n - 1);\n            int y = -H / 2;\n            points.push_back({x, y});\n        }\n        // Generate points along top side in reverse order\n        for (int i = half_n - 1; i >= 0; --i) {\n            int x = -W / 2 + i * W / (half_n - 1);\n            int y = H / 2;\n            points.push_back({x, y});\n        }\n    } else {\n        // Default to convex polygon\n        double R = coord_limit * 0.8;\n        for (int i = 0; i < n; ++i) {\n            double angle = 2.0 * PI * i / n;\n            double x = R * cos(angle);\n            double y = R * sin(angle);\n            int xi = (int)round(x);\n            int yi = (int)round(y);\n            points.push_back({xi, yi});\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output coordinates in counter-clockwise order\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", points[i].first, points[i].second);\n    }\n\n    // Output s and t\n    printf(\"%d %d\\n\", s, t);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"convex\");\n    int s = opt<int>(\"s\", -1);\n    int t = opt<int>(\"t\", -1);\n    int coord_limit = opt<int>(\"coord_limit\", 10000);\n\n    if (s == -1) {\n        s = rnd.next(1, n);\n    }\n    if (t == -1) {\n        t = rnd.next(1, n);\n    }\n\n    vector<pair<int, int>> points;\n\n    if (type == \"convex\" || type == \"concave\") {\n        double R = coord_limit * 0.8;\n        for (int i = 0; i < n; ++i) {\n            double angle = 2.0 * PI * i / n;\n            double radius = R;\n            // For concave polygon, push every other point inward\n            if (type == \"concave\" && i % 2 == 0) {\n                radius *= 0.5; // Push inward by half\n            }\n            double x = radius * cos(angle);\n            double y = radius * sin(angle);\n            int xi = (int)round(x);\n            int yi = (int)round(y);\n            points.push_back({xi, yi});\n        }\n    } else if (type == \"vertical_sides\") {\n        int W = coord_limit; // Width of rectangle\n        int H = coord_limit; // Height of rectangle\n        vector<pair<int, int>> left_side;\n        vector<pair<int, int>> right_side;\n\n        int half_n = n / 2;\n        if (n % 2 != 0) {\n            half_n = n / 2 + 1;\n        }\n        // Generate points along left side\n        for (int i = 0; i < half_n; ++i) {\n            int x = -W / 2;\n            int y = -H / 2 + i * H / (half_n - 1);\n            left_side.push_back({x, y});\n        }\n        // Generate points along top side\n        if (n % 2 != 0) {\n            int x = W / 2;\n            int y = H / 2;\n            right_side.push_back({x, y});\n        }\n        // Generate points along right side\n        for (int i = half_n - 1; i >= 0; --i) {\n            int x = W / 2;\n            int y = -H / 2 + i * H / (half_n - 1);\n            right_side.push_back({x, y});\n        }\n        points.insert(points.end(), left_side.begin(), left_side.end());\n        points.insert(points.end(), right_side.begin(), right_side.end());\n    } else if (type == \"thin\") {\n        int W = coord_limit; // Width of rectangle\n        int H = 1; // Very small height\n        int half_n = n / 2;\n        if (n % 2 != 0) {\n            half_n = n / 2 + 1;\n        }\n        // Generate points along bottom side\n        for (int i = 0; i < half_n; ++i) {\n            int x = -W / 2 + i * W / (half_n - 1);\n            int y = -H / 2;\n            points.push_back({x, y});\n        }\n        // Generate points along top side in reverse order\n        for (int i = half_n - 1; i >= 0; --i) {\n            int x = -W / 2 + i * W / (half_n - 1);\n            int y = H / 2;\n            points.push_back({x, y});\n        }\n    } else {\n        // Default to convex polygon\n        double R = coord_limit * 0.8;\n        for (int i = 0; i < n; ++i) {\n            double angle = 2.0 * PI * i / n;\n            double x = R * cos(angle);\n            double y = R * sin(angle);\n            int xi = (int)round(x);\n            int yi = (int)round(y);\n            points.push_back({xi, yi});\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output coordinates in counter-clockwise order\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", points[i].first, points[i].second);\n    }\n\n    // Output s and t\n    printf(\"%d %d\\n\", s, t);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type convex\n./gen -n 4 -type convex\n./gen -n 5 -type convex\n./gen -n 10 -type convex\n./gen -n 100 -type convex\n./gen -n 1000 -type convex\n./gen -n 100000 -type convex\n\n./gen -n 6 -type concave\n./gen -n 10 -type concave\n./gen -n 100 -type concave\n./gen -n 1000 -type concave\n./gen -n 100000 -type concave\n\n./gen -n 4 -type vertical_sides\n./gen -n 10 -type vertical_sides\n./gen -n 100 -type vertical_sides\n./gen -n 1000 -type vertical_sides\n./gen -n 100000 -type vertical_sides\n\n./gen -n 6 -type thin\n./gen -n 10 -type thin\n./gen -n 100 -type thin\n./gen -n 1000 -type thin\n./gen -n 100000 -type thin\n\n./gen -n 10 -type convex -s 1 -t 1\n./gen -n 10 -type convex -s 5 -t 5\n./gen -n 10 -type convex -s 1 -t 10\n./gen -n 10000 -type concave -s 1 -t 5000\n./gen -n 10000 -type concave -s 10000 -t 1\n./gen -n 10000 -type vertical_sides -s 100 -t 9000\n./gen -n 10000 -type thin -s 1 -t 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:28.290429",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "223/E",
      "title": "E. Planar Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (3 ≤ n, m ≤ 105) — the number of vertexes and edges of the graph. Next m lines contain the edges of the graph: the i-th line contains two space-separated integers ui and vi (1 ≤ ui, vi ≤ n) — the numbers of vertexes, connecting the i-th edge. The next n lines contain the positions of the planar graph vertexes on the plane: the i-th line contains a pair of space-separated integers xi and yi (|xi|, |yi| ≤ 109) — the coordinates of the i-th vertex of the graph on the plane. The next line contains integer q (1 ≤ q ≤ 105) — the number of queries. Then follow q lines that describe the queries: the i-th line contains the sequence of space-separated integers ki, a1, a2, ..., aki (1 ≤ aj ≤ n; ki > 2), where ki is the cycle length in the i-th query, aj are numbers of the vertexes that form a cycle. The numbers of vertexes in the cycle are given in the clockwise or counterclockwise order. The given cycles are simple, that is they cannot go through a graph vertex more than once. The total length of all cycles in all queries does not exceed 105.It is guaranteed that the given graph contains no bridges, articulation points, loops and multiple edges. It is guaranteed that the edge segments can have common points only at the graph's vertexes.",
      "output_spec": "OutputFor each query print a single integer — the number of vertexes inside the cycle or on it. Print the answers in the order, in which the queries follow in the input. Separate the numbers by spaces.",
      "sample_tests": "ExamplesInputCopy3 31 22 33 10 01 00 113 1 2 3OutputCopy3InputCopy5 81 22 33 44 11 52 53 54 50 02 02 20 21 114 1 2 3 4OutputCopy5InputCopy4 51 22 33 44 12 40 01 01 10 133 1 2 43 4 2 34 1 2 3 4OutputCopy334",
      "description": "E. Planar Graph\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (3 ≤ n, m ≤ 105) — the number of vertexes and edges of the graph. Next m lines contain the edges of the graph: the i-th line contains two space-separated integers ui and vi (1 ≤ ui, vi ≤ n) — the numbers of vertexes, connecting the i-th edge. The next n lines contain the positions of the planar graph vertexes on the plane: the i-th line contains a pair of space-separated integers xi and yi (|xi|, |yi| ≤ 109) — the coordinates of the i-th vertex of the graph on the plane. The next line contains integer q (1 ≤ q ≤ 105) — the number of queries. Then follow q lines that describe the queries: the i-th line contains the sequence of space-separated integers ki, a1, a2, ..., aki (1 ≤ aj ≤ n; ki > 2), where ki is the cycle length in the i-th query, aj are numbers of the vertexes that form a cycle. The numbers of vertexes in the cycle are given in the clockwise or counterclockwise order. The given cycles are simple, that is they cannot go through a graph vertex more than once. The total length of all cycles in all queries does not exceed 105.It is guaranteed that the given graph contains no bridges, articulation points, loops and multiple edges. It is guaranteed that the edge segments can have common points only at the graph's vertexes.\n\nOutputFor each query print a single integer — the number of vertexes inside the cycle or on it. Print the answers in the order, in which the queries follow in the input. Separate the numbers by spaces.\n\nInputCopy3 31 22 33 10 01 00 113 1 2 3OutputCopy3InputCopy5 81 22 33 44 11 52 53 54 50 02 02 20 21 114 1 2 3 4OutputCopy5InputCopy4 51 22 33 44 12 40 01 01 10 133 1 2 43 4 2 34 1 2 3 4OutputCopy334\n\nInputCopy3 31 22 33 10 01 00 113 1 2 3\n\nOutputCopy3\n\nInputCopy5 81 22 33 44 11 52 53 54 50 02 02 20 21 114 1 2 3 4\n\nOutputCopy5\n\nInputCopy4 51 22 33 44 12 40 01 01 10 133 1 2 43 4 2 34 1 2 3 4\n\nOutputCopy334",
      "solutions": [
        {
          "title": "Codeforces Round #138 - Codeforces",
          "content": "Hello everybody!I am glad to announce that Codeforces Round #138 will be held today at 19:30 MSK. I (Vasiliy Vadimov) am the author of this round. It is my first Codeforces round, I just helped other authors to prepare their rounds before.I would like to thank Gerald Gerald Agapov for his help in the preparing of the round and Maria Delinur Belova for translation of the problems' statements in English. Also I am grateful to Mike MikeMirzayanov Mirzayanov for such an excellent contest system as Codeforces.Good luck! I hope you will be interested in the problems.The point distribution is standard in both divisions (500-1000-1500-2000-2500).UPD. Attention! D language will not be available on this contest.UPD2. The round is over, top-5 in both divisions:Div1: Petr tourist peter50216 Shik Egor Div2: ecnerwala ordcoder scipianus jonathanpaulson void_rank Congratulations to the winners! Also I am apologising for mistakes in statement of problem div1 A/div2 C. The tutorial will be published tomorrow.UPD3. The tutorial is available here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1044
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces",
          "content": "Div2 A. ParallelepipedYou were given areas of three faces of a rectangular parallelepiped. Your task was to find the sum of lengths of it's sides.Let a, b and c be the lengths of the sides that have one common vertex. Then the numbers we are given are s1 = ab, s2 = bc и s3 = ca. It is easy to find the lengths in terms of faces areas: , , . The answer is 4(a + b + c), because there are four sides that have lengths equal to a, b and c. The complexity is O(1).Div2 B. ArrayYou were given an array a consisting of n integers. Its elements ai were positive and not greater than 105 for each 1 ≤ i ≤ n. Also you were given positive integer k. You had to find minimal by inclusion segment [l, r] such that there were exactly k different numbers among al, ..., ar. The definition of the \"minimal by inclusion\" you can read in the statement.Let us make a new array cnt. In the beginning its element cnti is equal to number of occurencies of number i in array a. It is possible to make this array because elements of a are not very large. Amount of nonzero elements in cnt is equal to amount of different elements in a. There is no solution if this number is less then k.If it is not true, we have to find the answer segment [l, r]. In the beginning let [l, r] = [1, n]. We decrease its right end r by 1 until amount of different elements on the segment [l, r] is less than k. We can keep the amount of different numbers in following way: we decrease cntar by 1 if we delete element number r. Then we have to decrease current number of different elements by 1 if cntar becomes zero. After this we return the last deleted element back to the segment in order to make amount of different elements equal to k. Then we have to do the same with the left end l, but we have not to decrease but to increase its value by 1 on each step. Finally, we get a segment [l, r]. The amount of different numbers on it is equal to k and on every its subsegment is less than k. Therefore, this segment is an answer. The complexity is O(n).Div2 C/Div1 A. Bracket sequenceYou were given a bracket sequence s consisting of brackets of two kinds. You were to find regular bracket sequence that was a substring of s and contains as many <<>> braces as possible.We will try to determine corresponding closing bracket for every opening one. Formally, let a bracket on the i-th position be opening, then the closing bracket on the position j is corresponding to it if and only if a substring si... sj is the shortest regular bracket sequence that begins from the i-th position. In common case there can be brackets with no corresponding ones.We scan the sting s and put positions with the opening brackets into a stack. Let us proceed the i-th position. If si is an opening bracket we simply put i on the top of the stack. Otherwise, we have to clean the stack if the stack is empty or the bracket on the top does not correspond to the current one. But if the bracket on the top is ok we just remove the top of the stack and remember that the bracket on position i is corresponding to the bracket removed from the top. So, we find all the correspondings for all the brackets.Then we can split s into blocks. Let block be a segment [l, r] such that the bracket on the r-th position is corresponding for the bracket on the i-th and there is no couple of corresponding brackets on positions x and y such that and [l, r] ≠ [x, y]. It is easy to understand that the blocks do not intersect and the split is unique. We can join the consequent blocks into the regular bracket sequences. We should join as many blocks as possible in order to get the maximal number of braces. We get several substrings that are regular bracket sequences after we join all the consecutive blocks. The answer is the substring that has the largest amount of braces <<>>. The complexity is O(|s|).Div2 D/Div1 B. Two strings.You were given two strings: s and t. You were required to examine all occurrences of the string t in the string s as subsequence and to find out if it is true that for each position of the s string there are such occurrence, that includes this position. For each position i of the s string we calculate two values li and ri where li is the maximal possible number that the string t1... tli occurs as subsequence in the string s1... si, ri is the maximal possible number that the string t|t| - ri + 1... t|t| occurs in the string si... s|s| as subsequence. Let us find all of l for the position 1... i - 1 and want to find li. If the symbol tli - 1 + 1 exists and concurs with the symbol si then li = li - 1 + 1, in other case li = li - 1. In the same way we can find ri if we move from the end of the string.Now we should check if the position i in the string s belongs to at least one occurrence. Let us assume this to be correct and the symbol si corresponds to the symbol tj of the string t. Then li - 1 ≥ j - 1 and ri + 1 ≥ |t| - j by definition of the l and r. Then if j exists that si = tj and li - 1 + 1 ≥ j ≥ |t| - ri + 1, then the position i of the string s belongs to at least one occurrence of the t, in other case the occurrence doesn’t exist. We can easily check it by creating an array cnta, i for each letter, which is a number of letters a in the positions 1... i of the string t. The complexity of the solution is O(|s| + |t|). Div2 E/Div1 C. Частичные суммыYou were given an array a in this problem. You could replace a by the array of its partial sums by one step. You had to find the array after k such steps. All the calculations were modulo P = 109 + 7.Write partial sums in following way: where Bi, j = 1 if i ≥ j and Bi, j = 0 if i < j, for each 1 ≤ i, j ≤ n. We can represent a and s as vector-columns, therefore one step corresponds to multiplying matrix B and vector-column a. Then the array a after k steps is equal to Bka. We can raise a matrix to a power for . It is not bad, but not fast enough.We can notice, that = , i.e. the elements of the matrix Bk on diagonals parallel to the main are the equal. It is easy to prove this fact using mathematical induction. You may prove it by yourself. Then we can determine the matrix by an array of numbers , equal to the elements of the first column. The elements of the first column of the product BkBl are equal . It is a straight consequence of formula of matrix product. The computing of one element requires O(n) time, there are n elements therefore we can multiply matriсеs in O(n2) time. Then we can solve the problem in time and this solution fits the consrtaints.This problem can be solved faster. We can assure that . Let this formula be correct for some k. Prove that it is correct for k + 1 either. Using the formula of product we get: Используя формулу Cnk = n! / k!(n - k)!, можно получить, что , поэтому мы можем построить все коэффициенты b, если умеем делить по модулю P, поэтому в этом решении существенна простота P. Обратный для числа x по простому модулю равен в силу малой теоремы Ферма. Таким образом, мы получаем решение за O(n2).Using the formula Cnk = n! / k!(n - k)! we can obtain , so we can find all the coefficients b if we can divide modulo P. Therefore it is significant that P is prime. Inverse x modulo P is equal to according to the Fermat little theorem. Therefore we get O(n2)solution.Div1 D. SpiderYou were given a polygon consisting of n vertices, you had to find the shortest way from one of its vertices to another. You were allowed to move along the border and go stricktly down without going outside the polygonAll the sides of the polygon can be divided into three groups: top, bottom and vertical. The side is vertical if and only if the x coordinates of its ends are equal. The side is bottom if and only if the polygon's interior is above the side. The side it top if and only if the polygon's interior is below the side. We can descend only from points of the top sides to the points of the bottom sides. Vertical sides can be ignored because every descend that has common points with a vertical side can be splitted into two descends and one transfer. One can prove that it is useless to descend from a side's interior to side's interior. Len one of the descends in the optimal solution start in the inner point and end in the inner point. We can slightly change the x coordinate of the descend. The path's lenght is monotonically (possibly not strictly) depends on x, so we can move x in order to improve the answer. In case of not strictly monotone dependance the answer do not depend on x, so we also can move it. This proof is wrong if the descend passes through a vertex, therefore we have to examine all possible descends from the vertices and to the vertices.We can solve this problem using scan-line method. We well move a vertical straight line from the left to the right and keep set S of the sides that intersect the line. We store the segments in the S in the sorted by y order. Let X be an abscissa of the line. The events happen during the moving: some segments are added to the S set, some are deleted. We can make an array of events, each events is described by its x coordinate that is equal to X of the line when the corresponding event happens, the number of the segment and a kind of event: adding or deleting. There are two events for every side, their x coordinates correspond to abscissas of their ends. The vertical sides can be ignored.Let us proceed the events in non-decreasing order of x coords. If the current event is adding we add the side to S set. Then we check on its closest neighbours in the set. If the current segment is a top segment we can make a descend from its left vertex down to the intersection with it's lower neighbor. We find the point of the intersection, remember the segment where the point is located and remember that there can be a descend from a vertex to the new point. If the current side is the bottom side we make a descand from the upper neighbour to the left end of the current segment and do the same things. If the current event is deleting we analize its neighbours in the same way, but the descends start or end on the right end of the segment we are going to delete. It is important that if there are many events of one kind we should proceed them simultaneously, i.e. if there are many addings in the same x coordinate we must add all the segments and then examine their neighbours. It is the same for deletings: firstly we analize the neighbours for all the segments and only then we delete them. Also in the case of equal x coords of the events the adding events must be first, otherwise the solution is wrong for the case of two angles separated by a vertical line with vertices lying on this line.Set S is easy to keep in container such as \"set\". We have to write a comparator for segments. We can do it in following way: two segments can be in S simultaneously if and only if there is a vertical line that intersects both of them. In common case such a line is not the unique, all the possible values of X are in segment [l, r] that can be easily found if we know the coors of the ends of the segments. Then we can choose an arbitrary X inside of [l, r] and compare the ordinates of the intersection points. Is better to choose inner point because in this case we don't have to examine special cases of segments having a common point.After this we can build a graph. It's vertices are the vertices of the polygon and the ends of possible descends. The edges of the graphs are the sides of the polygon and the descends. The shortest path can be found using Dijkstra algorithm. The complexity of the solution is .Div1 E. Planar graphIn the problem we were given an undirected planar graph without bridges, cutpoints, loops and multiedge laid on the plane. We get requests of the following type: to calculate the number of vertices inside the cycle or on it.Let us take an arbitrary vertex on the border of the graph, for example a vertex that has the least absciss. Let's add a new vertex with an edge to the chosen vertex in such way that the edge is outside the outer border of the graph. We'll call this new vertex a sink. Let's create a 1 value flow running to the sink from each vertex except the sink. Flow can be created using breadth-first or depth-first search. This operation will take the O(E) time.Let's examine any request. We assume that the cycle is oriented counter-clockwise (if it is not so, we can just reorient it). Let's make a cut on the graph. The first part will contain the vertices laying on the cycle or inside it, the second one — all remaining vertices including the sink. We'll now prove that the flow value through the cut is equal to the vertices number in the first part. It's obvious that we can calculate contribution from every vertex to the flow value independently. Let's assume that the vertex is situated in the first part. A unit flow runs from it to the sink along some path. As soon as this vertex and the sink are situated in different parts the flow passes the edges of the cut an odd number of times, that's why the contribution of this vertex to the flow through the cut is equal to 1. Let's take now a vertex situated in the second part. As soon as it's situated in the same part as the sink the flow passes the edges of the cut an even number of times, that's why the contribution of this vertex to the flow through the cut is zero. In order to calculate the flow value through the cut we need to sum up flow values passing through the cut's edges. It's important to notice that every edge of the cut is incident to only one vertex lying on the cycle, that's why we can sum up flows passing though edges going outside the cycle for each vertex in the cycle. In order to find all edges going outside the cycle we'll sort all edges going from each vertex counter-clockwise by angle. In this case all edges going outside the cycle will be placed after the previous vertex of the cycle and before the following vertex of the cycle. That's why the sum of flow values over the edges going outside reduces to a sum over an segment which is easily calculated using partial sums. The complexity of the solution is for graph sorting plus for the request where l is the cycle length. There is in complexity because we have to know a position of a vertex in the adjacency list of another vertex.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5301",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 14288
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #138 - Codeforces - Code 1",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 2",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 3",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 4",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 5",
          "code": "5 3\n1 2 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 6",
          "code": "4\n[[]]()[][][()]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 7",
          "code": "100000\n[][][][]...[][][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 8",
          "code": "4 3\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces - Code 1",
          "code": "4 * (a + b + c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nvector< vector<int> > adj;\nvector<int> tin, low, visited;\nint time_dfs;\nvoid dfs(int v, int p = -1) {\n    visited[v] = 1;\n    tin[v] = low[v] = ++time_dfs;\n    int children = 0;\n    for (int to : adj[v]) {\n        if (to == p) continue;\n        if (visited[to]) {\n            low[v] = min(low[v], tin[to]);\n        } else {\n            dfs(to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] > tin[v]) {\n                ensuref(false, \"Graph should not contain bridges between %d and %d\", v, to);\n            }\n            if (low[to] >= tin[v] && p != -1) {\n                ensuref(false, \"Graph should not contain articulation point at vertex %d\", v);\n            }\n            ++children;\n        }\n    }\n    if (p == -1 && children > 1) {\n        ensuref(false, \"Graph should not contain articulation point at root vertex %d\", v);\n    }\n}\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n\n    set< pair<int, int> > edges;\n    adj.resize(n + 1);\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge cannot be a loop (edge from %d to %d)\", u, v);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between %d and %d\", u, v);\n        edges.insert(edge);\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector< pair<long long, long long> > positions(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        long long x_i = inf.readLong(-1000000000LL, 1000000000LL, \"x_i\");\n        inf.readSpace();\n        long long y_i = inf.readLong(-1000000000LL, 1000000000LL, \"y_i\");\n        inf.readEoln();\n        positions[i] = make_pair(x_i, y_i);\n    }\n\n    // Check that the graph is connected and has no bridges or articulation points\n    visited.assign(n + 1, 0);\n    tin.assign(n + 1, -1);\n    low.assign(n + 1, -1);\n    time_dfs = 0;\n    dfs(1);\n    for (int v = 1; v <= n; ++v) {\n        ensuref(visited[v], \"Graph is not connected, vertex %d is not reachable\", v);\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    int total_ki = 0;\n\n    for (int query_num = 1; query_num <= q; ++query_num) {\n        int ki = inf.readInt(3, 100000, \"k_i\");\n        ensuref(ki > 2, \"k_i must be greater than 2\");\n        total_ki += ki;\n        ensuref(total_ki <= 100000, \"Total sum of ki exceeds 1e5\");\n\n        vector<int> cycle;\n        for (int j = 0; j < ki; ++j) {\n            inf.readSpace();\n            int ai = inf.readInt(1, n, \"a_i\");\n            cycle.push_back(ai);\n        }\n        inf.readEoln();\n\n        set<int> s;\n        for (int ai : cycle) {\n            ensuref(s.count(ai) == 0, \"Cycle in query %d is not simple\", query_num);\n            s.insert(ai);\n        }\n        // Check that edges exist between consecutive vertices\n        for (int j = 0; j < ki; ++j) {\n            int u = cycle[j];\n            int v = cycle[(j + 1) % ki];\n\n            // Ensure that edge (u,v) exists\n            if (edges.count(make_pair(min(u, v), max(u, v))) == 0) {\n                ensuref(false, \"Edge between %d and %d does not exist in query %d\", u, v, query_num);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nvector< vector<int> > adj;\nvector<int> tin, low, visited;\nint time_dfs;\nvoid dfs(int v, int p = -1) {\n    visited[v] = 1;\n    tin[v] = low[v] = ++time_dfs;\n    int children = 0;\n    for (int to : adj[v]) {\n        if (to == p) continue;\n        if (visited[to]) {\n            low[v] = min(low[v], tin[to]);\n        } else {\n            dfs(to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] > tin[v]) {\n                ensuref(false, \"Graph should not contain bridges between %d and %d\", v, to);\n            }\n            if (low[to] >= tin[v] && p != -1) {\n                ensuref(false, \"Graph should not contain articulation point at vertex %d\", v);\n            }\n            ++children;\n        }\n    }\n    if (p == -1 && children > 1) {\n        ensuref(false, \"Graph should not contain articulation point at root vertex %d\", v);\n    }\n}\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n\n    set< pair<int, int> > edges;\n    adj.resize(n + 1);\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge cannot be a loop (edge from %d to %d)\", u, v);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between %d and %d\", u, v);\n        edges.insert(edge);\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector< pair<long long, long long> > positions(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        long long x_i = inf.readLong(-1000000000LL, 1000000000LL, \"x_i\");\n        inf.readSpace();\n        long long y_i = inf.readLong(-1000000000LL, 1000000000LL, \"y_i\");\n        inf.readEoln();\n        positions[i] = make_pair(x_i, y_i);\n    }\n\n    // Check that the graph is connected and has no bridges or articulation points\n    visited.assign(n + 1, 0);\n    tin.assign(n + 1, -1);\n    low.assign(n + 1, -1);\n    time_dfs = 0;\n    dfs(1);\n    for (int v = 1; v <= n; ++v) {\n        ensuref(visited[v], \"Graph is not connected, vertex %d is not reachable\", v);\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    int total_ki = 0;\n\n    for (int query_num = 1; query_num <= q; ++query_num) {\n        int ki = inf.readInt(3, 100000, \"k_i\");\n        ensuref(ki > 2, \"k_i must be greater than 2\");\n        total_ki += ki;\n        ensuref(total_ki <= 100000, \"Total sum of ki exceeds 1e5\");\n\n        vector<int> cycle;\n        for (int j = 0; j < ki; ++j) {\n            inf.readSpace();\n            int ai = inf.readInt(1, n, \"a_i\");\n            cycle.push_back(ai);\n        }\n        inf.readEoln();\n\n        set<int> s;\n        for (int ai : cycle) {\n            ensuref(s.count(ai) == 0, \"Cycle in query %d is not simple\", query_num);\n            s.insert(ai);\n        }\n        // Check that edges exist between consecutive vertices\n        for (int j = 0; j < ki; ++j) {\n            int u = cycle[j];\n            int v = cycle[(j + 1) % ki];\n\n            // Ensure that edge (u,v) exists\n            if (edges.count(make_pair(min(u, v), max(u, v))) == 0) {\n                ensuref(false, \"Edge between %d and %d does not exist in query %d\", u, v, query_num);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nvector< vector<int> > adj;\nvector<int> tin, low, visited;\nint time_dfs;\nvoid dfs(int v, int p = -1) {\n    visited[v] = 1;\n    tin[v] = low[v] = ++time_dfs;\n    int children = 0;\n    for (int to : adj[v]) {\n        if (to == p) continue;\n        if (visited[to]) {\n            low[v] = min(low[v], tin[to]);\n        } else {\n            dfs(to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] > tin[v]) {\n                ensuref(false, \"Graph should not contain bridges between %d and %d\", v, to);\n            }\n            if (low[to] >= tin[v] && p != -1) {\n                ensuref(false, \"Graph should not contain articulation point at vertex %d\", v);\n            }\n            ++children;\n        }\n    }\n    if (p == -1 && children > 1) {\n        ensuref(false, \"Graph should not contain articulation point at root vertex %d\", v);\n    }\n}\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n\n    set< pair<int, int> > edges;\n    adj.resize(n + 1);\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge cannot be a loop (edge from %d to %d)\", u, v);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between %d and %d\", u, v);\n        edges.insert(edge);\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector< pair<long long, long long> > positions(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        long long x_i = inf.readLong(-1000000000LL, 1000000000LL, \"x_i\");\n        inf.readSpace();\n        long long y_i = inf.readLong(-1000000000LL, 1000000000LL, \"y_i\");\n        inf.readEoln();\n        positions[i] = make_pair(x_i, y_i);\n    }\n\n    // Check that the graph is connected and has no bridges or articulation points\n    visited.assign(n + 1, 0);\n    tin.assign(n + 1, -1);\n    low.assign(n + 1, -1);\n    time_dfs = 0;\n    dfs(1);\n    for (int v = 1; v <= n; ++v) {\n        ensuref(visited[v], \"Graph is not connected, vertex %d is not reachable\", v);\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    int total_ki = 0;\n\n    for (int query_num = 1; query_num <= q; ++query_num) {\n        int ki = inf.readInt(3, 100000, \"k_i\");\n        ensuref(ki > 2, \"k_i must be greater than 2\");\n        total_ki += ki;\n        ensuref(total_ki <= 100000, \"Total sum of ki exceeds 1e5\");\n\n        vector<int> cycle;\n        for (int j = 0; j < ki; ++j) {\n            inf.readSpace();\n            int ai = inf.readInt(1, n, \"a_i\");\n            cycle.push_back(ai);\n        }\n        inf.readEoln();\n\n        set<int> s;\n        for (int ai : cycle) {\n            ensuref(s.count(ai) == 0, \"Cycle in query %d is not simple\", query_num);\n            s.insert(ai);\n        }\n        // Check that edges exist between consecutive vertices\n        for (int j = 0; j < ki; ++j) {\n            int u = cycle[j];\n            int v = cycle[(j + 1) % ki];\n\n            // Ensure that edge (u,v) exists\n            if (edges.count(make_pair(min(u, v), max(u, v))) == 0) {\n                ensuref(false, \"Edge between %d and %d does not exist in query %d\", u, v, query_num);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator creates a connected undirected planar graph with:\n    - no loops,\n    - no multiple edges,\n    - no articulation points,\n    - no bridges.\n\n  We achieve this by either:\n    - Constructing a simple cycle of length n (which is 2-vertex-connected\n      and 2-edge-connected) if adding chords would exceed the limit m <= 100000,\n    - Or, if 2n - 3 <= 100000, constructing a \"fan-triangulated\" cycle:\n         * Outer cycle of length n\n         * (n - 3) chords from vertex 1 to triangulate the polygon\n      This also yields a 2-vertex-connected planar graph.\n\n  Coordinates are placed roughly on a circle, ensuring a planar drawing.\n\n  We then produce q queries, each of which must be a cycle present in the graph.\n  - If n is very large (e.g. 100000) we limit q to 1 to avoid exceeding\n    sum-of-cycle-lengths ≥ 100000.\n  - The first query is the entire outer cycle (length n).\n  - Additional queries are small cycles (triangles in the fan or small arcs\n    on the cycle).\n\n  Usage example:\n     ./gen -n 10 -q 3\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // 1) Parse parameters\n    int n = opt<int>(\"n\", 10);    // number of vertices\n    int q = opt<int>(\"q\", 3);     // number of queries\n\n    // Problem constraints:\n    //   3 <= n <= 100000\n    //   3 <= m <= 100000\n    //   1 <= q <= 100000\n    // In case the user gave unrealistic n or q, clamp them in a minimal sense.\n    n = max(n, 3);\n    // We'll clamp q if n is huge so we don't exceed the sum of cycle lengths limit.\n    // If n = 100000, just allow 1 query, because that one query alone has length = n = 100000.\n    if (n == 100000) {\n        q = 1;\n    } else {\n        // We won't do more than 10 queries to keep total cycle-length sum well under 100000.\n        q = min(q, 10);\n    }\n\n    // 2) Decide which graph to build:\n    //    - If 2n - 3 <= 100000, build \"fan-triangulated\" cycle (m = 2n - 3).\n    //    - Otherwise, build a simple cycle (m = n).\n    bool doFan = false;\n    long long fanEdges = 2LL * n - 3; // \"fan\" approach has 2n-3 edges\n    long long cycleEdges = n;        // simple cycle has n edges\n\n    // Must satisfy m <= 100000 per problem statement\n    if (fanEdges <= 100000)\n        doFan = true;\n\n    // Determine final M\n    int m = (doFan ? (2*n - 3) : n);\n\n    // 3) Build edges\n    vector<pair<int,int>> edges;\n    edges.reserve(m);\n\n    // First, build the outer cycle: (1->2), (2->3), ..., (n-1->n), (n->1)\n    for (int i = 1; i < n; i++) {\n        edges.push_back({i, i+1});\n    }\n    edges.push_back({n, 1});\n\n    // If we are allowed to build \"fan-triangulated\" cycle, add chords from 1 to (3..n-1)\n    if (doFan) {\n        // We already have (1->2) and (1->n) as part of the cycle, so we add the others\n        for (int v = 3; v <= n - 1; v++) {\n            edges.push_back({1, v});\n        }\n    }\n\n    // 4) Output n and m\n    cout << n << \" \" << m << \"\\n\";\n\n    // 5) Generate vertex coordinates on a circle (roughly)\n    //    We place them with integer coordinates to meet problem constraints: |x|,|y| <= 1e9.\n    //    For large n, we choose a large radius to avoid collisions from rounding.\n    //    The maximum n is 100000, so angle steps are 2π / n.\n    //    We'll pick radius ~ 10^9/2 to stay within |x|,|y| <= 10^9.\n    long long R = 500000000; // 5e8\n    vector<long long> vx(n+1), vy(n+1);\n    for (int i = 1; i <= n; i++) {\n        long double angle = 2.0L * M_PI * (i - 1) / n;\n        long double cx = (long double)R * cosl(angle);\n        long double cy = (long double)R * sinl(angle);\n        // round to nearest integer\n        long long ix = (long long)floor(cx + 0.5L);\n        long long iy = (long long)floor(cy + 0.5L);\n        vx[i] = ix;\n        vy[i] = iy;\n    }\n\n    // 6) Print the edges\n    //    The graph uses 1-based indexing, so we can just output them directly.\n    for (auto &e : edges) {\n        cout << e.first << \" \" << e.second << \"\\n\";\n    }\n\n    // 7) Print coordinates\n    //    The i-th line has xi, yi for vertex i\n    for (int i = 1; i <= n; i++) {\n        cout << vx[i] << \" \" << vy[i] << \"\\n\";\n    }\n\n    // 8) Generate queries\n    //    Each query is a cycle in the graph.\n    //    We do at most q queries. \n    //    If q >= 1, the first query is the entire outer cycle.\n    //    Additional queries:\n    //      - if doFan is true, we'll pick random triangles (1, i, i+1),\n    //      - otherwise, for a cycle-only structure, pick small arcs of the cycle.\n    \n    cout << q << \"\\n\";  // number of queries\n\n    // function to print a cycle in the required format: length + vertices\n    auto printCycle = [&](const vector<int>& cyc) {\n        cout << (int)cyc.size();\n        for (auto &v : cyc) {\n            cout << \" \" << v;\n        }\n        cout << \"\\n\";\n    };\n\n    int queriesPrinted = 0;\n    // (a) If we have at least one query, print the entire outer cycle\n    if (q > 0) {\n        vector<int> bigCycle(n);\n        iota(bigCycle.begin(), bigCycle.end(), 1); // 1..n\n        printCycle(bigCycle);\n        queriesPrinted++;\n    }\n\n    // (b) Print additional queries\n    // If doFan -> use triangles (1, i, i+1).\n    // If not doFan -> use small arcs on the cycle.\n    // We'll produce q-1 more queries.\n\n    for (; queriesPrinted < q; queriesPrinted++) {\n        // We'll pick a small cycle of length 3 or 4.\n        // For doFan, let's do triangulated cycle (1, i, i+1).\n        // For the simple cycle, let's pick a random arc of length 3..5.\n\n        // clamp so we don't exceed n\n        if (doFan) {\n            // If n > 3, we can pick i in [2..n-1]\n            // But if n == 3, there's only one triangle anyway. We'll pick (1,2,3).\n            int i = rnd.next(2, n-1);\n            // cycle is (1, i, i+1)\n            // watch out for i+1 = n+1 if i = n, so we do i+1 in mod n?\n            // but if i = n-1, i+1 = n => valid\n            int ip1 = (i == n ? 1 : i + 1);\n            vector<int> cyc = {1, i, ip1};\n            printCycle(cyc);\n        } else {\n            // just the big cycle edges. We'll pick a random arc of length L in [3..5].\n            // Then pick a start in [1..n].\n            int L = rnd.next(3, min(n, 5)); // if n < 5, clamp\n            int start = rnd.next(1, n);\n            vector<int> cyc;\n            cyc.push_back(start);\n            for (int step = 1; step < L; step++) {\n                // next vertex in the cycle is (start + step) mod n\n                // but we want to keep them in 1..n\n                int nxt = start + step;\n                if (nxt > n) {\n                    nxt -= n; // wrap around\n                }\n                cyc.push_back(nxt);\n            }\n            printCycle(cyc);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator creates a connected undirected planar graph with:\n    - no loops,\n    - no multiple edges,\n    - no articulation points,\n    - no bridges.\n\n  We achieve this by either:\n    - Constructing a simple cycle of length n (which is 2-vertex-connected\n      and 2-edge-connected) if adding chords would exceed the limit m <= 100000,\n    - Or, if 2n - 3 <= 100000, constructing a \"fan-triangulated\" cycle:\n         * Outer cycle of length n\n         * (n - 3) chords from vertex 1 to triangulate the polygon\n      This also yields a 2-vertex-connected planar graph.\n\n  Coordinates are placed roughly on a circle, ensuring a planar drawing.\n\n  We then produce q queries, each of which must be a cycle present in the graph.\n  - If n is very large (e.g. 100000) we limit q to 1 to avoid exceeding\n    sum-of-cycle-lengths ≥ 100000.\n  - The first query is the entire outer cycle (length n).\n  - Additional queries are small cycles (triangles in the fan or small arcs\n    on the cycle).\n\n  Usage example:\n     ./gen -n 10 -q 3\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // 1) Parse parameters\n    int n = opt<int>(\"n\", 10);    // number of vertices\n    int q = opt<int>(\"q\", 3);     // number of queries\n\n    // Problem constraints:\n    //   3 <= n <= 100000\n    //   3 <= m <= 100000\n    //   1 <= q <= 100000\n    // In case the user gave unrealistic n or q, clamp them in a minimal sense.\n    n = max(n, 3);\n    // We'll clamp q if n is huge so we don't exceed the sum of cycle lengths limit.\n    // If n = 100000, just allow 1 query, because that one query alone has length = n = 100000.\n    if (n == 100000) {\n        q = 1;\n    } else {\n        // We won't do more than 10 queries to keep total cycle-length sum well under 100000.\n        q = min(q, 10);\n    }\n\n    // 2) Decide which graph to build:\n    //    - If 2n - 3 <= 100000, build \"fan-triangulated\" cycle (m = 2n - 3).\n    //    - Otherwise, build a simple cycle (m = n).\n    bool doFan = false;\n    long long fanEdges = 2LL * n - 3; // \"fan\" approach has 2n-3 edges\n    long long cycleEdges = n;        // simple cycle has n edges\n\n    // Must satisfy m <= 100000 per problem statement\n    if (fanEdges <= 100000)\n        doFan = true;\n\n    // Determine final M\n    int m = (doFan ? (2*n - 3) : n);\n\n    // 3) Build edges\n    vector<pair<int,int>> edges;\n    edges.reserve(m);\n\n    // First, build the outer cycle: (1->2), (2->3), ..., (n-1->n), (n->1)\n    for (int i = 1; i < n; i++) {\n        edges.push_back({i, i+1});\n    }\n    edges.push_back({n, 1});\n\n    // If we are allowed to build \"fan-triangulated\" cycle, add chords from 1 to (3..n-1)\n    if (doFan) {\n        // We already have (1->2) and (1->n) as part of the cycle, so we add the others\n        for (int v = 3; v <= n - 1; v++) {\n            edges.push_back({1, v});\n        }\n    }\n\n    // 4) Output n and m\n    cout << n << \" \" << m << \"\\n\";\n\n    // 5) Generate vertex coordinates on a circle (roughly)\n    //    We place them with integer coordinates to meet problem constraints: |x|,|y| <= 1e9.\n    //    For large n, we choose a large radius to avoid collisions from rounding.\n    //    The maximum n is 100000, so angle steps are 2π / n.\n    //    We'll pick radius ~ 10^9/2 to stay within |x|,|y| <= 10^9.\n    long long R = 500000000; // 5e8\n    vector<long long> vx(n+1), vy(n+1);\n    for (int i = 1; i <= n; i++) {\n        long double angle = 2.0L * M_PI * (i - 1) / n;\n        long double cx = (long double)R * cosl(angle);\n        long double cy = (long double)R * sinl(angle);\n        // round to nearest integer\n        long long ix = (long long)floor(cx + 0.5L);\n        long long iy = (long long)floor(cy + 0.5L);\n        vx[i] = ix;\n        vy[i] = iy;\n    }\n\n    // 6) Print the edges\n    //    The graph uses 1-based indexing, so we can just output them directly.\n    for (auto &e : edges) {\n        cout << e.first << \" \" << e.second << \"\\n\";\n    }\n\n    // 7) Print coordinates\n    //    The i-th line has xi, yi for vertex i\n    for (int i = 1; i <= n; i++) {\n        cout << vx[i] << \" \" << vy[i] << \"\\n\";\n    }\n\n    // 8) Generate queries\n    //    Each query is a cycle in the graph.\n    //    We do at most q queries. \n    //    If q >= 1, the first query is the entire outer cycle.\n    //    Additional queries:\n    //      - if doFan is true, we'll pick random triangles (1, i, i+1),\n    //      - otherwise, for a cycle-only structure, pick small arcs of the cycle.\n    \n    cout << q << \"\\n\";  // number of queries\n\n    // function to print a cycle in the required format: length + vertices\n    auto printCycle = [&](const vector<int>& cyc) {\n        cout << (int)cyc.size();\n        for (auto &v : cyc) {\n            cout << \" \" << v;\n        }\n        cout << \"\\n\";\n    };\n\n    int queriesPrinted = 0;\n    // (a) If we have at least one query, print the entire outer cycle\n    if (q > 0) {\n        vector<int> bigCycle(n);\n        iota(bigCycle.begin(), bigCycle.end(), 1); // 1..n\n        printCycle(bigCycle);\n        queriesPrinted++;\n    }\n\n    // (b) Print additional queries\n    // If doFan -> use triangles (1, i, i+1).\n    // If not doFan -> use small arcs on the cycle.\n    // We'll produce q-1 more queries.\n\n    for (; queriesPrinted < q; queriesPrinted++) {\n        // We'll pick a small cycle of length 3 or 4.\n        // For doFan, let's do triangulated cycle (1, i, i+1).\n        // For the simple cycle, let's pick a random arc of length 3..5.\n\n        // clamp so we don't exceed n\n        if (doFan) {\n            // If n > 3, we can pick i in [2..n-1]\n            // But if n == 3, there's only one triangle anyway. We'll pick (1,2,3).\n            int i = rnd.next(2, n-1);\n            // cycle is (1, i, i+1)\n            // watch out for i+1 = n+1 if i = n, so we do i+1 in mod n?\n            // but if i = n-1, i+1 = n => valid\n            int ip1 = (i == n ? 1 : i + 1);\n            vector<int> cyc = {1, i, ip1};\n            printCycle(cyc);\n        } else {\n            // just the big cycle edges. We'll pick a random arc of length L in [3..5].\n            // Then pick a start in [1..n].\n            int L = rnd.next(3, min(n, 5)); // if n < 5, clamp\n            int start = rnd.next(1, n);\n            vector<int> cyc;\n            cyc.push_back(start);\n            for (int step = 1; step < L; step++) {\n                // next vertex in the cycle is (start + step) mod n\n                // but we want to keep them in 1..n\n                int nxt = start + step;\n                if (nxt > n) {\n                    nxt -= n; // wrap around\n                }\n                cyc.push_back(nxt);\n            }\n            printCycle(cyc);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -q 1\n./gen -n 4 -q 2\n./gen -n 5 -q 5\n./gen -n 6 -q 5\n./gen -n 10 -q 2\n./gen -n 10 -q 10\n./gen -n 12 -q 1\n./gen -n 12 -q 5\n./gen -n 20 -q 3\n./gen -n 20 -q 10\n./gen -n 30 -q 10\n./gen -n 50 -q 10\n./gen -n 50 -q 2\n./gen -n 99 -q 10\n./gen -n 100 -q 1\n./gen -n 200 -q 10\n./gen -n 999 -q 10\n./gen -n 1000 -q 5\n./gen -n 5000 -q 10\n./gen -n 9999 -q 10\n./gen -n 20000 -q 10\n./gen -n 50000 -q 5\n./gen -n 99999 -q 2\n./gen -n 100000 -q 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:29.971652",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "224/A",
      "title": "A. Parallelepiped",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and the single line contains three space-separated integers — the areas of the parallelepiped's faces. The area's values are positive ( > 0) and do not exceed 104. It is guaranteed that there exists at least one parallelepiped that satisfies the problem statement.",
      "output_spec": "OutputPrint a single number — the sum of all edges of the parallelepiped.",
      "sample_tests": "ExamplesInputCopy1 1 1OutputCopy12InputCopy4 6 6OutputCopy28",
      "description": "A. Parallelepiped\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first and the single line contains three space-separated integers — the areas of the parallelepiped's faces. The area's values are positive ( > 0) and do not exceed 104. It is guaranteed that there exists at least one parallelepiped that satisfies the problem statement.\n\nOutputPrint a single number — the sum of all edges of the parallelepiped.\n\nInputCopy1 1 1OutputCopy12InputCopy4 6 6OutputCopy28\n\nInputCopy1 1 1\n\nOutputCopy12\n\nInputCopy4 6 6\n\nOutputCopy28\n\nNoteIn the first sample the parallelepiped has sizes 1 × 1 × 1, in the second one — 2 × 2 × 3.",
      "solutions": [
        {
          "title": "Codeforces Round #138 - Codeforces",
          "content": "Hello everybody!I am glad to announce that Codeforces Round #138 will be held today at 19:30 MSK. I (Vasiliy Vadimov) am the author of this round. It is my first Codeforces round, I just helped other authors to prepare their rounds before.I would like to thank Gerald Gerald Agapov for his help in the preparing of the round and Maria Delinur Belova for translation of the problems' statements in English. Also I am grateful to Mike MikeMirzayanov Mirzayanov for such an excellent contest system as Codeforces.Good luck! I hope you will be interested in the problems.The point distribution is standard in both divisions (500-1000-1500-2000-2500).UPD. Attention! D language will not be available on this contest.UPD2. The round is over, top-5 in both divisions:Div1: Petr tourist peter50216 Shik Egor Div2: ecnerwala ordcoder scipianus jonathanpaulson void_rank Congratulations to the winners! Also I am apologising for mistakes in statement of problem div1 A/div2 C. The tutorial will be published tomorrow.UPD3. The tutorial is available here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1044
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces",
          "content": "Div2 A. ParallelepipedYou were given areas of three faces of a rectangular parallelepiped. Your task was to find the sum of lengths of it's sides.Let a, b and c be the lengths of the sides that have one common vertex. Then the numbers we are given are s1 = ab, s2 = bc и s3 = ca. It is easy to find the lengths in terms of faces areas: , , . The answer is 4(a + b + c), because there are four sides that have lengths equal to a, b and c. The complexity is O(1).Div2 B. ArrayYou were given an array a consisting of n integers. Its elements ai were positive and not greater than 105 for each 1 ≤ i ≤ n. Also you were given positive integer k. You had to find minimal by inclusion segment [l, r] such that there were exactly k different numbers among al, ..., ar. The definition of the \"minimal by inclusion\" you can read in the statement.Let us make a new array cnt. In the beginning its element cnti is equal to number of occurencies of number i in array a. It is possible to make this array because elements of a are not very large. Amount of nonzero elements in cnt is equal to amount of different elements in a. There is no solution if this number is less then k.If it is not true, we have to find the answer segment [l, r]. In the beginning let [l, r] = [1, n]. We decrease its right end r by 1 until amount of different elements on the segment [l, r] is less than k. We can keep the amount of different numbers in following way: we decrease cntar by 1 if we delete element number r. Then we have to decrease current number of different elements by 1 if cntar becomes zero. After this we return the last deleted element back to the segment in order to make amount of different elements equal to k. Then we have to do the same with the left end l, but we have not to decrease but to increase its value by 1 on each step. Finally, we get a segment [l, r]. The amount of different numbers on it is equal to k and on every its subsegment is less than k. Therefore, this segment is an answer. The complexity is O(n).Div2 C/Div1 A. Bracket sequenceYou were given a bracket sequence s consisting of brackets of two kinds. You were to find regular bracket sequence that was a substring of s and contains as many <<>> braces as possible.We will try to determine corresponding closing bracket for every opening one. Formally, let a bracket on the i-th position be opening, then the closing bracket on the position j is corresponding to it if and only if a substring si... sj is the shortest regular bracket sequence that begins from the i-th position. In common case there can be brackets with no corresponding ones.We scan the sting s and put positions with the opening brackets into a stack. Let us proceed the i-th position. If si is an opening bracket we simply put i on the top of the stack. Otherwise, we have to clean the stack if the stack is empty or the bracket on the top does not correspond to the current one. But if the bracket on the top is ok we just remove the top of the stack and remember that the bracket on position i is corresponding to the bracket removed from the top. So, we find all the correspondings for all the brackets.Then we can split s into blocks. Let block be a segment [l, r] such that the bracket on the r-th position is corresponding for the bracket on the i-th and there is no couple of corresponding brackets on positions x and y such that and [l, r] ≠ [x, y]. It is easy to understand that the blocks do not intersect and the split is unique. We can join the consequent blocks into the regular bracket sequences. We should join as many blocks as possible in order to get the maximal number of braces. We get several substrings that are regular bracket sequences after we join all the consecutive blocks. The answer is the substring that has the largest amount of braces <<>>. The complexity is O(|s|).Div2 D/Div1 B. Two strings.You were given two strings: s and t. You were required to examine all occurrences of the string t in the string s as subsequence and to find out if it is true that for each position of the s string there are such occurrence, that includes this position. For each position i of the s string we calculate two values li and ri where li is the maximal possible number that the string t1... tli occurs as subsequence in the string s1... si, ri is the maximal possible number that the string t|t| - ri + 1... t|t| occurs in the string si... s|s| as subsequence. Let us find all of l for the position 1... i - 1 and want to find li. If the symbol tli - 1 + 1 exists and concurs with the symbol si then li = li - 1 + 1, in other case li = li - 1. In the same way we can find ri if we move from the end of the string.Now we should check if the position i in the string s belongs to at least one occurrence. Let us assume this to be correct and the symbol si corresponds to the symbol tj of the string t. Then li - 1 ≥ j - 1 and ri + 1 ≥ |t| - j by definition of the l and r. Then if j exists that si = tj and li - 1 + 1 ≥ j ≥ |t| - ri + 1, then the position i of the string s belongs to at least one occurrence of the t, in other case the occurrence doesn’t exist. We can easily check it by creating an array cnta, i for each letter, which is a number of letters a in the positions 1... i of the string t. The complexity of the solution is O(|s| + |t|). Div2 E/Div1 C. Частичные суммыYou were given an array a in this problem. You could replace a by the array of its partial sums by one step. You had to find the array after k such steps. All the calculations were modulo P = 109 + 7.Write partial sums in following way: where Bi, j = 1 if i ≥ j and Bi, j = 0 if i < j, for each 1 ≤ i, j ≤ n. We can represent a and s as vector-columns, therefore one step corresponds to multiplying matrix B and vector-column a. Then the array a after k steps is equal to Bka. We can raise a matrix to a power for . It is not bad, but not fast enough.We can notice, that = , i.e. the elements of the matrix Bk on diagonals parallel to the main are the equal. It is easy to prove this fact using mathematical induction. You may prove it by yourself. Then we can determine the matrix by an array of numbers , equal to the elements of the first column. The elements of the first column of the product BkBl are equal . It is a straight consequence of formula of matrix product. The computing of one element requires O(n) time, there are n elements therefore we can multiply matriсеs in O(n2) time. Then we can solve the problem in time and this solution fits the consrtaints.This problem can be solved faster. We can assure that . Let this formula be correct for some k. Prove that it is correct for k + 1 either. Using the formula of product we get: Используя формулу Cnk = n! / k!(n - k)!, можно получить, что , поэтому мы можем построить все коэффициенты b, если умеем делить по модулю P, поэтому в этом решении существенна простота P. Обратный для числа x по простому модулю равен в силу малой теоремы Ферма. Таким образом, мы получаем решение за O(n2).Using the formula Cnk = n! / k!(n - k)! we can obtain , so we can find all the coefficients b if we can divide modulo P. Therefore it is significant that P is prime. Inverse x modulo P is equal to according to the Fermat little theorem. Therefore we get O(n2)solution.Div1 D. SpiderYou were given a polygon consisting of n vertices, you had to find the shortest way from one of its vertices to another. You were allowed to move along the border and go stricktly down without going outside the polygonAll the sides of the polygon can be divided into three groups: top, bottom and vertical. The side is vertical if and only if the x coordinates of its ends are equal. The side is bottom if and only if the polygon's interior is above the side. The side it top if and only if the polygon's interior is below the side. We can descend only from points of the top sides to the points of the bottom sides. Vertical sides can be ignored because every descend that has common points with a vertical side can be splitted into two descends and one transfer. One can prove that it is useless to descend from a side's interior to side's interior. Len one of the descends in the optimal solution start in the inner point and end in the inner point. We can slightly change the x coordinate of the descend. The path's lenght is monotonically (possibly not strictly) depends on x, so we can move x in order to improve the answer. In case of not strictly monotone dependance the answer do not depend on x, so we also can move it. This proof is wrong if the descend passes through a vertex, therefore we have to examine all possible descends from the vertices and to the vertices.We can solve this problem using scan-line method. We well move a vertical straight line from the left to the right and keep set S of the sides that intersect the line. We store the segments in the S in the sorted by y order. Let X be an abscissa of the line. The events happen during the moving: some segments are added to the S set, some are deleted. We can make an array of events, each events is described by its x coordinate that is equal to X of the line when the corresponding event happens, the number of the segment and a kind of event: adding or deleting. There are two events for every side, their x coordinates correspond to abscissas of their ends. The vertical sides can be ignored.Let us proceed the events in non-decreasing order of x coords. If the current event is adding we add the side to S set. Then we check on its closest neighbours in the set. If the current segment is a top segment we can make a descend from its left vertex down to the intersection with it's lower neighbor. We find the point of the intersection, remember the segment where the point is located and remember that there can be a descend from a vertex to the new point. If the current side is the bottom side we make a descand from the upper neighbour to the left end of the current segment and do the same things. If the current event is deleting we analize its neighbours in the same way, but the descends start or end on the right end of the segment we are going to delete. It is important that if there are many events of one kind we should proceed them simultaneously, i.e. if there are many addings in the same x coordinate we must add all the segments and then examine their neighbours. It is the same for deletings: firstly we analize the neighbours for all the segments and only then we delete them. Also in the case of equal x coords of the events the adding events must be first, otherwise the solution is wrong for the case of two angles separated by a vertical line with vertices lying on this line.Set S is easy to keep in container such as \"set\". We have to write a comparator for segments. We can do it in following way: two segments can be in S simultaneously if and only if there is a vertical line that intersects both of them. In common case such a line is not the unique, all the possible values of X are in segment [l, r] that can be easily found if we know the coors of the ends of the segments. Then we can choose an arbitrary X inside of [l, r] and compare the ordinates of the intersection points. Is better to choose inner point because in this case we don't have to examine special cases of segments having a common point.After this we can build a graph. It's vertices are the vertices of the polygon and the ends of possible descends. The edges of the graphs are the sides of the polygon and the descends. The shortest path can be found using Dijkstra algorithm. The complexity of the solution is .Div1 E. Planar graphIn the problem we were given an undirected planar graph without bridges, cutpoints, loops and multiedge laid on the plane. We get requests of the following type: to calculate the number of vertices inside the cycle or on it.Let us take an arbitrary vertex on the border of the graph, for example a vertex that has the least absciss. Let's add a new vertex with an edge to the chosen vertex in such way that the edge is outside the outer border of the graph. We'll call this new vertex a sink. Let's create a 1 value flow running to the sink from each vertex except the sink. Flow can be created using breadth-first or depth-first search. This operation will take the O(E) time.Let's examine any request. We assume that the cycle is oriented counter-clockwise (if it is not so, we can just reorient it). Let's make a cut on the graph. The first part will contain the vertices laying on the cycle or inside it, the second one — all remaining vertices including the sink. We'll now prove that the flow value through the cut is equal to the vertices number in the first part. It's obvious that we can calculate contribution from every vertex to the flow value independently. Let's assume that the vertex is situated in the first part. A unit flow runs from it to the sink along some path. As soon as this vertex and the sink are situated in different parts the flow passes the edges of the cut an odd number of times, that's why the contribution of this vertex to the flow through the cut is equal to 1. Let's take now a vertex situated in the second part. As soon as it's situated in the same part as the sink the flow passes the edges of the cut an even number of times, that's why the contribution of this vertex to the flow through the cut is zero. In order to calculate the flow value through the cut we need to sum up flow values passing through the cut's edges. It's important to notice that every edge of the cut is incident to only one vertex lying on the cycle, that's why we can sum up flows passing though edges going outside the cycle for each vertex in the cycle. In order to find all edges going outside the cycle we'll sort all edges going from each vertex counter-clockwise by angle. In this case all edges going outside the cycle will be placed after the previous vertex of the cycle and before the following vertex of the cycle. That's why the sum of flow values over the edges going outside reduces to a sum over an segment which is easily calculated using partial sums. The complexity of the solution is for graph sorting plus for the request where l is the cycle length. There is in complexity because we have to know a position of a vertex in the adjacency list of another vertex.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5301",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 14288
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #138 - Codeforces - Code 1",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 2",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 3",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 4",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 5",
          "code": "5 3\n1 2 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 6",
          "code": "4\n[[]]()[][][()]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 7",
          "code": "100000\n[][][][]...[][][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 8",
          "code": "4 3\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces - Code 1",
          "code": "4 * (a + b + c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int area1 = inf.readInt(1, 10000, \"area1\");\n    inf.readSpace();\n    int area2 = inf.readInt(1, 10000, \"area2\");\n    inf.readSpace();\n    int area3 = inf.readInt(1, 10000, \"area3\");\n    inf.readEoln();\n    inf.readEof();\n\n    // Ensure that the product of the areas is a perfect square\n    long long volume_squared = 1LL * area1 * area2 * area3;\n    long long volume = (long long)(sqrt(volume_squared) + 0.5);\n    ensuref(volume * volume == volume_squared, \"Product of areas is not a perfect square\");\n\n    // Ensure that a^2 = (area1 * area2) / area3 is a perfect square\n    ensuref((1LL * area1 * area2) % area3 == 0, \"(area1 * area2) mod area3 != 0\");\n    long long a_squared = (1LL * area1 * area2) / area3;\n    long long a = (long long)(sqrt(a_squared) + 0.5);\n    ensuref(a * a == a_squared, \"a^2 is not a perfect square\");\n\n    // Ensure that b^2 = (area1 * area3) / area2 is a perfect square\n    ensuref((1LL * area1 * area3) % area2 == 0, \"(area1 * area3) mod area2 != 0\");\n    long long b_squared = (1LL * area1 * area3) / area2;\n    long long b = (long long)(sqrt(b_squared) + 0.5);\n    ensuref(b * b == b_squared, \"b^2 is not a perfect square\");\n\n    // Ensure that c^2 = (area2 * area3) / area1 is a perfect square\n    ensuref((1LL * area2 * area3) % area1 == 0, \"(area2 * area3) mod area1 != 0\");\n    long long c_squared = (1LL * area2 * area3) / area1;\n    long long c = (long long)(sqrt(c_squared) + 0.5);\n    ensuref(c * c == c_squared, \"c^2 is not a perfect square\");\n\n    // Ensure that the edge lengths are positive\n    ensuref(a > 0 && b > 0 && c > 0, \"Edges are not positive\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int area1 = inf.readInt(1, 10000, \"area1\");\n    inf.readSpace();\n    int area2 = inf.readInt(1, 10000, \"area2\");\n    inf.readSpace();\n    int area3 = inf.readInt(1, 10000, \"area3\");\n    inf.readEoln();\n    inf.readEof();\n\n    // Ensure that the product of the areas is a perfect square\n    long long volume_squared = 1LL * area1 * area2 * area3;\n    long long volume = (long long)(sqrt(volume_squared) + 0.5);\n    ensuref(volume * volume == volume_squared, \"Product of areas is not a perfect square\");\n\n    // Ensure that a^2 = (area1 * area2) / area3 is a perfect square\n    ensuref((1LL * area1 * area2) % area3 == 0, \"(area1 * area2) mod area3 != 0\");\n    long long a_squared = (1LL * area1 * area2) / area3;\n    long long a = (long long)(sqrt(a_squared) + 0.5);\n    ensuref(a * a == a_squared, \"a^2 is not a perfect square\");\n\n    // Ensure that b^2 = (area1 * area3) / area2 is a perfect square\n    ensuref((1LL * area1 * area3) % area2 == 0, \"(area1 * area3) mod area2 != 0\");\n    long long b_squared = (1LL * area1 * area3) / area2;\n    long long b = (long long)(sqrt(b_squared) + 0.5);\n    ensuref(b * b == b_squared, \"b^2 is not a perfect square\");\n\n    // Ensure that c^2 = (area2 * area3) / area1 is a perfect square\n    ensuref((1LL * area2 * area3) % area1 == 0, \"(area2 * area3) mod area1 != 0\");\n    long long c_squared = (1LL * area2 * area3) / area1;\n    long long c = (long long)(sqrt(c_squared) + 0.5);\n    ensuref(c * c == c_squared, \"c^2 is not a perfect square\");\n\n    // Ensure that the edge lengths are positive\n    ensuref(a > 0 && b > 0 && c > 0, \"Edges are not positive\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int area1 = inf.readInt(1, 10000, \"area1\");\n    inf.readSpace();\n    int area2 = inf.readInt(1, 10000, \"area2\");\n    inf.readSpace();\n    int area3 = inf.readInt(1, 10000, \"area3\");\n    inf.readEoln();\n    inf.readEof();\n\n    // Ensure that the product of the areas is a perfect square\n    long long volume_squared = 1LL * area1 * area2 * area3;\n    long long volume = (long long)(sqrt(volume_squared) + 0.5);\n    ensuref(volume * volume == volume_squared, \"Product of areas is not a perfect square\");\n\n    // Ensure that a^2 = (area1 * area2) / area3 is a perfect square\n    ensuref((1LL * area1 * area2) % area3 == 0, \"(area1 * area2) mod area3 != 0\");\n    long long a_squared = (1LL * area1 * area2) / area3;\n    long long a = (long long)(sqrt(a_squared) + 0.5);\n    ensuref(a * a == a_squared, \"a^2 is not a perfect square\");\n\n    // Ensure that b^2 = (area1 * area3) / area2 is a perfect square\n    ensuref((1LL * area1 * area3) % area2 == 0, \"(area1 * area3) mod area2 != 0\");\n    long long b_squared = (1LL * area1 * area3) / area2;\n    long long b = (long long)(sqrt(b_squared) + 0.5);\n    ensuref(b * b == b_squared, \"b^2 is not a perfect square\");\n\n    // Ensure that c^2 = (area2 * area3) / area1 is a perfect square\n    ensuref((1LL * area2 * area3) % area1 == 0, \"(area2 * area3) mod area1 != 0\");\n    long long c_squared = (1LL * area2 * area3) / area1;\n    long long c = (long long)(sqrt(c_squared) + 0.5);\n    ensuref(c * c == c_squared, \"c^2 is not a perfect square\");\n\n    // Ensure that the edge lengths are positive\n    ensuref(a > 0 && b > 0 && c > 0, \"Edges are not positive\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int maxEdge = opt<int>(\"n\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    int a = 0, b = 0, c = 0;\n\n    do {\n        if (type == \"equal\") {\n            a = b = c = rnd.next(1, maxEdge);\n        } else if (type == \"two_equal\") {\n            a = b = rnd.next(1, maxEdge);\n            c = rnd.next(1, maxEdge);\n        } else if (type == \"one_large\") {\n            a = rnd.next(1, maxEdge / 5);\n            b = rnd.next(1, maxEdge / 5);\n            c = rnd.next(max(maxEdge * 4 / 5, 1), maxEdge);\n        } else if (type == \"small\") {\n            a = rnd.next(1, min(10, maxEdge));\n            b = rnd.next(1, min(10, maxEdge));\n            c = rnd.next(1, min(10, maxEdge));\n        } else if (type == \"large\") {\n            a = rnd.next(max(maxEdge * 9 / 10, 1), maxEdge);\n            b = rnd.next(max(maxEdge * 9 / 10, 1), maxEdge);\n            c = rnd.next(max(maxEdge * 9 / 10, 1), maxEdge);\n        } else if (type == \"max_area\") {\n            a = b = c = int(sqrt(10000));\n            if (a > maxEdge) a = b = c = maxEdge;\n        } else { // random\n            a = rnd.next(1, maxEdge);\n            b = rnd.next(1, maxEdge);\n            c = rnd.next(1, maxEdge);\n        }\n    } while (a * b > 10000 || a * c > 10000 || b * c > 10000 || a == 0 || b == 0 || c == 0);\n\n    int A1 = a * b;\n    int A2 = a * c;\n    int A3 = b * c;\n\n    // Output areas\n    printf(\"%d %d %d\\n\", A1, A2, A3);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int maxEdge = opt<int>(\"n\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    int a = 0, b = 0, c = 0;\n\n    do {\n        if (type == \"equal\") {\n            a = b = c = rnd.next(1, maxEdge);\n        } else if (type == \"two_equal\") {\n            a = b = rnd.next(1, maxEdge);\n            c = rnd.next(1, maxEdge);\n        } else if (type == \"one_large\") {\n            a = rnd.next(1, maxEdge / 5);\n            b = rnd.next(1, maxEdge / 5);\n            c = rnd.next(max(maxEdge * 4 / 5, 1), maxEdge);\n        } else if (type == \"small\") {\n            a = rnd.next(1, min(10, maxEdge));\n            b = rnd.next(1, min(10, maxEdge));\n            c = rnd.next(1, min(10, maxEdge));\n        } else if (type == \"large\") {\n            a = rnd.next(max(maxEdge * 9 / 10, 1), maxEdge);\n            b = rnd.next(max(maxEdge * 9 / 10, 1), maxEdge);\n            c = rnd.next(max(maxEdge * 9 / 10, 1), maxEdge);\n        } else if (type == \"max_area\") {\n            a = b = c = int(sqrt(10000));\n            if (a > maxEdge) a = b = c = maxEdge;\n        } else { // random\n            a = rnd.next(1, maxEdge);\n            b = rnd.next(1, maxEdge);\n            c = rnd.next(1, maxEdge);\n        }\n    } while (a * b > 10000 || a * c > 10000 || b * c > 10000 || a == 0 || b == 0 || c == 0);\n\n    int A1 = a * b;\n    int A2 = a * c;\n    int A3 = b * c;\n\n    // Output areas\n    printf(\"%d %d %d\\n\", A1, A2, A3);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type small\n./gen -n 10 -type equal\n./gen -n 10 -type two_equal\n./gen -n 10 -type one_large\n./gen -n 10 -type random\n\n./gen -n 50 -type small\n./gen -n 50 -type equal\n./gen -n 50 -type two_equal\n./gen -n 50 -type one_large\n./gen -n 50 -type random\n\n./gen -n 100 -type small\n./gen -n 100 -type equal\n./gen -n 100 -type two_equal\n./gen -n 100 -type one_large\n./gen -n 100 -type random\n\n./gen -n 100 -type large\n./gen -n 100 -type max_area\n\n./gen -n 100 -type equal\n./gen -n 50 -type two_equal\n./gen -n 25 -type random\n\n./gen -n 1 -type equal\n./gen -n 1 -type random\n\n./gen -n 1 -type small\n./gen -n 1 -type max_area\n\n./gen -n 75 -type one_large\n./gen -n 75 -type small\n\n./gen -n 100 -type equal\n./gen -n 100 -type random\n\n./gen -n 99 -type two_equal\n./gen -n 98 -type one_large\n./gen -n 97 -type random\n\n./gen -n 100 -type small\n./gen -n 100 -type large\n\n./gen -n 100 -type max_area\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:32.085377",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "224/B",
      "title": "B. Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).",
      "output_spec": "OutputPrint a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print \"-1 -1\" without the quotes. If there are multiple correct answers, print any of them.",
      "sample_tests": "ExamplesInputCopy4 21 2 2 3OutputCopy1 2InputCopy8 31 1 2 2 3 3 4 5OutputCopy2 5InputCopy7 44 7 7 4 7 4 7OutputCopy-1 -1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).\n\nOutputPrint a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print \"-1 -1\" without the quotes. If there are multiple correct answers, print any of them.\n\nInputCopy4 21 2 2 3OutputCopy1 2InputCopy8 31 1 2 2 3 3 4 5OutputCopy2 5InputCopy7 44 7 7 4 7 4 7OutputCopy-1 -1\n\nInputCopy4 21 2 2 3\n\nOutputCopy1 2\n\nInputCopy8 31 1 2 2 3 3 4 5\n\nOutputCopy2 5\n\nInputCopy7 44 7 7 4 7 4 7\n\nOutputCopy-1 -1\n\nNoteIn the first sample among numbers a1 and a2 there are exactly two distinct numbers.In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.In the third sample there is no segment with four distinct numbers.",
      "solutions": [
        {
          "title": "Codeforces Round #138 - Codeforces",
          "content": "Hello everybody!I am glad to announce that Codeforces Round #138 will be held today at 19:30 MSK. I (Vasiliy Vadimov) am the author of this round. It is my first Codeforces round, I just helped other authors to prepare their rounds before.I would like to thank Gerald Gerald Agapov for his help in the preparing of the round and Maria Delinur Belova for translation of the problems' statements in English. Also I am grateful to Mike MikeMirzayanov Mirzayanov for such an excellent contest system as Codeforces.Good luck! I hope you will be interested in the problems.The point distribution is standard in both divisions (500-1000-1500-2000-2500).UPD. Attention! D language will not be available on this contest.UPD2. The round is over, top-5 in both divisions:Div1: Petr tourist peter50216 Shik Egor Div2: ecnerwala ordcoder scipianus jonathanpaulson void_rank Congratulations to the winners! Also I am apologising for mistakes in statement of problem div1 A/div2 C. The tutorial will be published tomorrow.UPD3. The tutorial is available here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1044
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces",
          "content": "Div2 A. ParallelepipedYou were given areas of three faces of a rectangular parallelepiped. Your task was to find the sum of lengths of it's sides.Let a, b and c be the lengths of the sides that have one common vertex. Then the numbers we are given are s1 = ab, s2 = bc и s3 = ca. It is easy to find the lengths in terms of faces areas: , , . The answer is 4(a + b + c), because there are four sides that have lengths equal to a, b and c. The complexity is O(1).Div2 B. ArrayYou were given an array a consisting of n integers. Its elements ai were positive and not greater than 105 for each 1 ≤ i ≤ n. Also you were given positive integer k. You had to find minimal by inclusion segment [l, r] such that there were exactly k different numbers among al, ..., ar. The definition of the \"minimal by inclusion\" you can read in the statement.Let us make a new array cnt. In the beginning its element cnti is equal to number of occurencies of number i in array a. It is possible to make this array because elements of a are not very large. Amount of nonzero elements in cnt is equal to amount of different elements in a. There is no solution if this number is less then k.If it is not true, we have to find the answer segment [l, r]. In the beginning let [l, r] = [1, n]. We decrease its right end r by 1 until amount of different elements on the segment [l, r] is less than k. We can keep the amount of different numbers in following way: we decrease cntar by 1 if we delete element number r. Then we have to decrease current number of different elements by 1 if cntar becomes zero. After this we return the last deleted element back to the segment in order to make amount of different elements equal to k. Then we have to do the same with the left end l, but we have not to decrease but to increase its value by 1 on each step. Finally, we get a segment [l, r]. The amount of different numbers on it is equal to k and on every its subsegment is less than k. Therefore, this segment is an answer. The complexity is O(n).Div2 C/Div1 A. Bracket sequenceYou were given a bracket sequence s consisting of brackets of two kinds. You were to find regular bracket sequence that was a substring of s and contains as many <<>> braces as possible.We will try to determine corresponding closing bracket for every opening one. Formally, let a bracket on the i-th position be opening, then the closing bracket on the position j is corresponding to it if and only if a substring si... sj is the shortest regular bracket sequence that begins from the i-th position. In common case there can be brackets with no corresponding ones.We scan the sting s and put positions with the opening brackets into a stack. Let us proceed the i-th position. If si is an opening bracket we simply put i on the top of the stack. Otherwise, we have to clean the stack if the stack is empty or the bracket on the top does not correspond to the current one. But if the bracket on the top is ok we just remove the top of the stack and remember that the bracket on position i is corresponding to the bracket removed from the top. So, we find all the correspondings for all the brackets.Then we can split s into blocks. Let block be a segment [l, r] such that the bracket on the r-th position is corresponding for the bracket on the i-th and there is no couple of corresponding brackets on positions x and y such that and [l, r] ≠ [x, y]. It is easy to understand that the blocks do not intersect and the split is unique. We can join the consequent blocks into the regular bracket sequences. We should join as many blocks as possible in order to get the maximal number of braces. We get several substrings that are regular bracket sequences after we join all the consecutive blocks. The answer is the substring that has the largest amount of braces <<>>. The complexity is O(|s|).Div2 D/Div1 B. Two strings.You were given two strings: s and t. You were required to examine all occurrences of the string t in the string s as subsequence and to find out if it is true that for each position of the s string there are such occurrence, that includes this position. For each position i of the s string we calculate two values li and ri where li is the maximal possible number that the string t1... tli occurs as subsequence in the string s1... si, ri is the maximal possible number that the string t|t| - ri + 1... t|t| occurs in the string si... s|s| as subsequence. Let us find all of l for the position 1... i - 1 and want to find li. If the symbol tli - 1 + 1 exists and concurs with the symbol si then li = li - 1 + 1, in other case li = li - 1. In the same way we can find ri if we move from the end of the string.Now we should check if the position i in the string s belongs to at least one occurrence. Let us assume this to be correct and the symbol si corresponds to the symbol tj of the string t. Then li - 1 ≥ j - 1 and ri + 1 ≥ |t| - j by definition of the l and r. Then if j exists that si = tj and li - 1 + 1 ≥ j ≥ |t| - ri + 1, then the position i of the string s belongs to at least one occurrence of the t, in other case the occurrence doesn’t exist. We can easily check it by creating an array cnta, i for each letter, which is a number of letters a in the positions 1... i of the string t. The complexity of the solution is O(|s| + |t|). Div2 E/Div1 C. Частичные суммыYou were given an array a in this problem. You could replace a by the array of its partial sums by one step. You had to find the array after k such steps. All the calculations were modulo P = 109 + 7.Write partial sums in following way: where Bi, j = 1 if i ≥ j and Bi, j = 0 if i < j, for each 1 ≤ i, j ≤ n. We can represent a and s as vector-columns, therefore one step corresponds to multiplying matrix B and vector-column a. Then the array a after k steps is equal to Bka. We can raise a matrix to a power for . It is not bad, but not fast enough.We can notice, that = , i.e. the elements of the matrix Bk on diagonals parallel to the main are the equal. It is easy to prove this fact using mathematical induction. You may prove it by yourself. Then we can determine the matrix by an array of numbers , equal to the elements of the first column. The elements of the first column of the product BkBl are equal . It is a straight consequence of formula of matrix product. The computing of one element requires O(n) time, there are n elements therefore we can multiply matriсеs in O(n2) time. Then we can solve the problem in time and this solution fits the consrtaints.This problem can be solved faster. We can assure that . Let this formula be correct for some k. Prove that it is correct for k + 1 either. Using the formula of product we get: Используя формулу Cnk = n! / k!(n - k)!, можно получить, что , поэтому мы можем построить все коэффициенты b, если умеем делить по модулю P, поэтому в этом решении существенна простота P. Обратный для числа x по простому модулю равен в силу малой теоремы Ферма. Таким образом, мы получаем решение за O(n2).Using the formula Cnk = n! / k!(n - k)! we can obtain , so we can find all the coefficients b if we can divide modulo P. Therefore it is significant that P is prime. Inverse x modulo P is equal to according to the Fermat little theorem. Therefore we get O(n2)solution.Div1 D. SpiderYou were given a polygon consisting of n vertices, you had to find the shortest way from one of its vertices to another. You were allowed to move along the border and go stricktly down without going outside the polygonAll the sides of the polygon can be divided into three groups: top, bottom and vertical. The side is vertical if and only if the x coordinates of its ends are equal. The side is bottom if and only if the polygon's interior is above the side. The side it top if and only if the polygon's interior is below the side. We can descend only from points of the top sides to the points of the bottom sides. Vertical sides can be ignored because every descend that has common points with a vertical side can be splitted into two descends and one transfer. One can prove that it is useless to descend from a side's interior to side's interior. Len one of the descends in the optimal solution start in the inner point and end in the inner point. We can slightly change the x coordinate of the descend. The path's lenght is monotonically (possibly not strictly) depends on x, so we can move x in order to improve the answer. In case of not strictly monotone dependance the answer do not depend on x, so we also can move it. This proof is wrong if the descend passes through a vertex, therefore we have to examine all possible descends from the vertices and to the vertices.We can solve this problem using scan-line method. We well move a vertical straight line from the left to the right and keep set S of the sides that intersect the line. We store the segments in the S in the sorted by y order. Let X be an abscissa of the line. The events happen during the moving: some segments are added to the S set, some are deleted. We can make an array of events, each events is described by its x coordinate that is equal to X of the line when the corresponding event happens, the number of the segment and a kind of event: adding or deleting. There are two events for every side, their x coordinates correspond to abscissas of their ends. The vertical sides can be ignored.Let us proceed the events in non-decreasing order of x coords. If the current event is adding we add the side to S set. Then we check on its closest neighbours in the set. If the current segment is a top segment we can make a descend from its left vertex down to the intersection with it's lower neighbor. We find the point of the intersection, remember the segment where the point is located and remember that there can be a descend from a vertex to the new point. If the current side is the bottom side we make a descand from the upper neighbour to the left end of the current segment and do the same things. If the current event is deleting we analize its neighbours in the same way, but the descends start or end on the right end of the segment we are going to delete. It is important that if there are many events of one kind we should proceed them simultaneously, i.e. if there are many addings in the same x coordinate we must add all the segments and then examine their neighbours. It is the same for deletings: firstly we analize the neighbours for all the segments and only then we delete them. Also in the case of equal x coords of the events the adding events must be first, otherwise the solution is wrong for the case of two angles separated by a vertical line with vertices lying on this line.Set S is easy to keep in container such as \"set\". We have to write a comparator for segments. We can do it in following way: two segments can be in S simultaneously if and only if there is a vertical line that intersects both of them. In common case such a line is not the unique, all the possible values of X are in segment [l, r] that can be easily found if we know the coors of the ends of the segments. Then we can choose an arbitrary X inside of [l, r] and compare the ordinates of the intersection points. Is better to choose inner point because in this case we don't have to examine special cases of segments having a common point.After this we can build a graph. It's vertices are the vertices of the polygon and the ends of possible descends. The edges of the graphs are the sides of the polygon and the descends. The shortest path can be found using Dijkstra algorithm. The complexity of the solution is .Div1 E. Planar graphIn the problem we were given an undirected planar graph without bridges, cutpoints, loops and multiedge laid on the plane. We get requests of the following type: to calculate the number of vertices inside the cycle or on it.Let us take an arbitrary vertex on the border of the graph, for example a vertex that has the least absciss. Let's add a new vertex with an edge to the chosen vertex in such way that the edge is outside the outer border of the graph. We'll call this new vertex a sink. Let's create a 1 value flow running to the sink from each vertex except the sink. Flow can be created using breadth-first or depth-first search. This operation will take the O(E) time.Let's examine any request. We assume that the cycle is oriented counter-clockwise (if it is not so, we can just reorient it). Let's make a cut on the graph. The first part will contain the vertices laying on the cycle or inside it, the second one — all remaining vertices including the sink. We'll now prove that the flow value through the cut is equal to the vertices number in the first part. It's obvious that we can calculate contribution from every vertex to the flow value independently. Let's assume that the vertex is situated in the first part. A unit flow runs from it to the sink along some path. As soon as this vertex and the sink are situated in different parts the flow passes the edges of the cut an odd number of times, that's why the contribution of this vertex to the flow through the cut is equal to 1. Let's take now a vertex situated in the second part. As soon as it's situated in the same part as the sink the flow passes the edges of the cut an even number of times, that's why the contribution of this vertex to the flow through the cut is zero. In order to calculate the flow value through the cut we need to sum up flow values passing through the cut's edges. It's important to notice that every edge of the cut is incident to only one vertex lying on the cycle, that's why we can sum up flows passing though edges going outside the cycle for each vertex in the cycle. In order to find all edges going outside the cycle we'll sort all edges going from each vertex counter-clockwise by angle. In this case all edges going outside the cycle will be placed after the previous vertex of the cycle and before the following vertex of the cycle. That's why the sum of flow values over the edges going outside reduces to a sum over an segment which is easily calculated using partial sums. The complexity of the solution is for graph sorting plus for the request where l is the cycle length. There is in complexity because we have to know a position of a vertex in the adjacency list of another vertex.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5301",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 14288
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #138 - Codeforces - Code 1",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 2",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 3",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 4",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 5",
          "code": "5 3\n1 2 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 6",
          "code": "4\n[[]]()[][][()]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 7",
          "code": "100000\n[][][][]...[][][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 8",
          "code": "4 3\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces - Code 1",
          "code": "4 * (a + b + c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    int k = inf.readInt();\n    vector<int> a(n + 1);\n\n    for (int i = 1; i <= n; ++i) {\n        a[i] = inf.readInt();\n    }\n\n    int jury_l = ans.readInt(-1, n, \"jury l\");\n    int jury_r = ans.readInt(-1, n, \"jury r\");\n\n    int l = ouf.readInt(-1, n, \"participant l\");\n    int r = ouf.readInt(-1, n, \"participant r\");\n\n    if (l == -1 && r == -1) {\n        if (jury_l != -1 || jury_r != -1) {\n            quitf(_wa, \"Participant reports no such segment exists, but jury found one.\");\n        } else {\n            quitf(_ok, \"No such segment exists.\");\n        }\n    } else {\n        if (l == -1 || r == -1) {\n            quitf(_wa, \"Invalid segment indices.\");\n        }\n        if (l < 1 || l > n)\n            quitf(_wa, \"l (%d) is out of range [1, %d]\", l, n);\n        if (r < 1 || r > n)\n            quitf(_wa, \"r (%d) is out of range [1, %d]\", r, n);\n        if (l > r)\n            quitf(_wa, \"l (%d) is greater than r (%d)\", l, r);\n\n        int m = r - l + 1;\n\n        unordered_map<int, int> cnt;\n        for (int i = l; i <= r; ++i) {\n            cnt[a[i]]++;\n        }\n        int distinct = cnt.size();\n        if (distinct != k) {\n            quitf(_wa, \"Segment [%d, %d] contains %d distinct numbers, expected %d\", l, r, distinct, k);\n        }\n\n        unordered_map<int, int> temp_cnt = cnt;\n        int l_temp = l, r_temp = r;\n        // Try to move l forward\n        while (l_temp < r_temp && temp_cnt[a[l_temp]] > 1) {\n            temp_cnt[a[l_temp]]--;\n            l_temp++;\n        }\n        // Try to move r backward\n        while (r_temp > l_temp && temp_cnt[a[r_temp]] > 1) {\n            temp_cnt[a[r_temp]]--;\n            r_temp--;\n        }\n        if ((r_temp - l_temp + 1) < m) {\n            quitf(_wa, \"Segment [%d, %d] is not minimal by inclusion\", l, r);\n        } else {\n            quitf(_ok, \"Correct segment [%d, %d]\", l, r);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        /* Generate random numbers between 1 and 1e5 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"same\") {\n        /* All elements are the same */\n        int val = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        /* Elements are increasing starting from a random point */\n        int start = rnd.next(1, 100000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"smallrange\") {\n        /* Elements are from a small range [1, m] */\n        int m = opt<int>(\"m\", 5); // Default m = 5\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, m);\n        }\n    } else if (type == \"kmax\") {\n        /* Ensure that the number of distinct elements is exactly k */\n        if (k > n) {\n            fprintf(stderr, \"Error: k should not exceed n\\n\");\n            return 1;\n        }\n        set<int> values;\n        for (int i = 0; i < k; ++i) {\n            int val = rnd.next(1, 100000);\n            while (values.count(val)) {\n                val = rnd.next(1, 100000);\n            }\n            values.insert(val);\n            a[i] = val;\n        }\n        vector<int> vals(values.begin(), values.end());\n        for (int i = k; i < n; ++i) {\n            a[i] = vals[rnd.next(0, k - 1)];\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"impossible\") {\n        /* Generate an array where it's impossible to have k distinct elements */\n        int numDistinct = k - 1;\n        if (numDistinct < 1) numDistinct = 1;\n        set<int> values;\n        for (int i = 0; i < numDistinct; ++i) {\n            int val = rnd.next(1, 100000);\n            while (values.count(val)) {\n                val = rnd.next(1, 100000);\n            }\n            values.insert(val);\n        }\n        vector<int> vals(values.begin(), values.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = vals[rnd.next(0, numDistinct - 1)];\n        }\n    } else {\n        /* Default case: generate random numbers */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n\n    /* Output the array */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        /* Generate random numbers between 1 and 1e5 */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"same\") {\n        /* All elements are the same */\n        int val = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        /* Elements are increasing starting from a random point */\n        int start = rnd.next(1, 100000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"smallrange\") {\n        /* Elements are from a small range [1, m] */\n        int m = opt<int>(\"m\", 5); // Default m = 5\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, m);\n        }\n    } else if (type == \"kmax\") {\n        /* Ensure that the number of distinct elements is exactly k */\n        if (k > n) {\n            fprintf(stderr, \"Error: k should not exceed n\\n\");\n            return 1;\n        }\n        set<int> values;\n        for (int i = 0; i < k; ++i) {\n            int val = rnd.next(1, 100000);\n            while (values.count(val)) {\n                val = rnd.next(1, 100000);\n            }\n            values.insert(val);\n            a[i] = val;\n        }\n        vector<int> vals(values.begin(), values.end());\n        for (int i = k; i < n; ++i) {\n            a[i] = vals[rnd.next(0, k - 1)];\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"impossible\") {\n        /* Generate an array where it's impossible to have k distinct elements */\n        int numDistinct = k - 1;\n        if (numDistinct < 1) numDistinct = 1;\n        set<int> values;\n        for (int i = 0; i < numDistinct; ++i) {\n            int val = rnd.next(1, 100000);\n            while (values.count(val)) {\n                val = rnd.next(1, 100000);\n            }\n            values.insert(val);\n        }\n        vector<int> vals(values.begin(), values.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = vals[rnd.next(0, numDistinct - 1)];\n        }\n    } else {\n        /* Default case: generate random numbers */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n\n    /* Output the array */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 2 -type random\n./gen -n 5 -k 1 -type same\n./gen -n 5 -k 5 -type increasing\n./gen -n 5 -k 4 -type impossible\n\n./gen -n 10 -k 3 -type smallrange -m 2\n./gen -n 10 -k 2 -type smallrange -m 2\n\n./gen -n 100 -k 50 -type random\n./gen -n 1000 -k 500 -type random\n./gen -n 100000 -k 100000 -type random\n\n./gen -n 100000 -k 1 -type same\n./gen -n 100000 -k 100000 -type increasing\n./gen -n 100000 -k 100000 -type smallrange -m 100000\n./gen -n 100000 -k 100000 -type kmax\n\n./gen -n 100000 -k 100000 -type impossible\n./gen -n 100000 -k 2 -type impossible\n./gen -n 100000 -k 2 -type same\n\n./gen -n 100000 -k 50000 -type random\n./gen -n 100000 -k 99999 -type kmax\n./gen -n 100000 -k 50000 -type smallrange -m 100\n./gen -n 100000 -k 10000 -type smallrange -m 100\n\n./gen -n 1000 -k 999 -type increasing\n./gen -n 1000 -k 1000 -type increasing\n./gen -n 1000 -k 1000 -type impossible\n\n./gen -n 100000 -k 50000 -type same\n./gen -n 100000 -k 1 -type random\n./gen -n 100000 -k 1 -type increasing\n./gen -n 100000 -k 1 -type smallrange -m 10\n./gen -n 100000 -k 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:33.756715",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "224/C",
      "title": "C. Bracket Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and the only line contains the bracket sequence as a string, consisting only of characters \"(\", \")\", \"[\" and \"]\". It is guaranteed that the string is non-empty and its length doesn't exceed 105 characters.",
      "output_spec": "OutputIn the first line print a single integer — the number of brackets «[» in the required bracket sequence. In the second line print the optimal sequence. If there are more than one optimal solutions print any of them.",
      "sample_tests": "ExamplesInputCopy([])OutputCopy1([])InputCopy(((OutputCopy0",
      "description": "C. Bracket Sequence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first and the only line contains the bracket sequence as a string, consisting only of characters \"(\", \")\", \"[\" and \"]\". It is guaranteed that the string is non-empty and its length doesn't exceed 105 characters.\n\nOutputIn the first line print a single integer — the number of brackets «[» in the required bracket sequence. In the second line print the optimal sequence. If there are more than one optimal solutions print any of them.\n\nInputCopy([])OutputCopy1([])InputCopy(((OutputCopy0\n\nInputCopy([])\n\nOutputCopy1([])\n\nInputCopy(((\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #138 - Codeforces",
          "content": "Hello everybody!I am glad to announce that Codeforces Round #138 will be held today at 19:30 MSK. I (Vasiliy Vadimov) am the author of this round. It is my first Codeforces round, I just helped other authors to prepare their rounds before.I would like to thank Gerald Gerald Agapov for his help in the preparing of the round and Maria Delinur Belova for translation of the problems' statements in English. Also I am grateful to Mike MikeMirzayanov Mirzayanov for such an excellent contest system as Codeforces.Good luck! I hope you will be interested in the problems.The point distribution is standard in both divisions (500-1000-1500-2000-2500).UPD. Attention! D language will not be available on this contest.UPD2. The round is over, top-5 in both divisions:Div1: Petr tourist peter50216 Shik Egor Div2: ecnerwala ordcoder scipianus jonathanpaulson void_rank Congratulations to the winners! Also I am apologising for mistakes in statement of problem div1 A/div2 C. The tutorial will be published tomorrow.UPD3. The tutorial is available here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1044
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces",
          "content": "Div2 A. ParallelepipedYou were given areas of three faces of a rectangular parallelepiped. Your task was to find the sum of lengths of it's sides.Let a, b and c be the lengths of the sides that have one common vertex. Then the numbers we are given are s1 = ab, s2 = bc и s3 = ca. It is easy to find the lengths in terms of faces areas: , , . The answer is 4(a + b + c), because there are four sides that have lengths equal to a, b and c. The complexity is O(1).Div2 B. ArrayYou were given an array a consisting of n integers. Its elements ai were positive and not greater than 105 for each 1 ≤ i ≤ n. Also you were given positive integer k. You had to find minimal by inclusion segment [l, r] such that there were exactly k different numbers among al, ..., ar. The definition of the \"minimal by inclusion\" you can read in the statement.Let us make a new array cnt. In the beginning its element cnti is equal to number of occurencies of number i in array a. It is possible to make this array because elements of a are not very large. Amount of nonzero elements in cnt is equal to amount of different elements in a. There is no solution if this number is less then k.If it is not true, we have to find the answer segment [l, r]. In the beginning let [l, r] = [1, n]. We decrease its right end r by 1 until amount of different elements on the segment [l, r] is less than k. We can keep the amount of different numbers in following way: we decrease cntar by 1 if we delete element number r. Then we have to decrease current number of different elements by 1 if cntar becomes zero. After this we return the last deleted element back to the segment in order to make amount of different elements equal to k. Then we have to do the same with the left end l, but we have not to decrease but to increase its value by 1 on each step. Finally, we get a segment [l, r]. The amount of different numbers on it is equal to k and on every its subsegment is less than k. Therefore, this segment is an answer. The complexity is O(n).Div2 C/Div1 A. Bracket sequenceYou were given a bracket sequence s consisting of brackets of two kinds. You were to find regular bracket sequence that was a substring of s and contains as many <<>> braces as possible.We will try to determine corresponding closing bracket for every opening one. Formally, let a bracket on the i-th position be opening, then the closing bracket on the position j is corresponding to it if and only if a substring si... sj is the shortest regular bracket sequence that begins from the i-th position. In common case there can be brackets with no corresponding ones.We scan the sting s and put positions with the opening brackets into a stack. Let us proceed the i-th position. If si is an opening bracket we simply put i on the top of the stack. Otherwise, we have to clean the stack if the stack is empty or the bracket on the top does not correspond to the current one. But if the bracket on the top is ok we just remove the top of the stack and remember that the bracket on position i is corresponding to the bracket removed from the top. So, we find all the correspondings for all the brackets.Then we can split s into blocks. Let block be a segment [l, r] such that the bracket on the r-th position is corresponding for the bracket on the i-th and there is no couple of corresponding brackets on positions x and y such that and [l, r] ≠ [x, y]. It is easy to understand that the blocks do not intersect and the split is unique. We can join the consequent blocks into the regular bracket sequences. We should join as many blocks as possible in order to get the maximal number of braces. We get several substrings that are regular bracket sequences after we join all the consecutive blocks. The answer is the substring that has the largest amount of braces <<>>. The complexity is O(|s|).Div2 D/Div1 B. Two strings.You were given two strings: s and t. You were required to examine all occurrences of the string t in the string s as subsequence and to find out if it is true that for each position of the s string there are such occurrence, that includes this position. For each position i of the s string we calculate two values li and ri where li is the maximal possible number that the string t1... tli occurs as subsequence in the string s1... si, ri is the maximal possible number that the string t|t| - ri + 1... t|t| occurs in the string si... s|s| as subsequence. Let us find all of l for the position 1... i - 1 and want to find li. If the symbol tli - 1 + 1 exists and concurs with the symbol si then li = li - 1 + 1, in other case li = li - 1. In the same way we can find ri if we move from the end of the string.Now we should check if the position i in the string s belongs to at least one occurrence. Let us assume this to be correct and the symbol si corresponds to the symbol tj of the string t. Then li - 1 ≥ j - 1 and ri + 1 ≥ |t| - j by definition of the l and r. Then if j exists that si = tj and li - 1 + 1 ≥ j ≥ |t| - ri + 1, then the position i of the string s belongs to at least one occurrence of the t, in other case the occurrence doesn’t exist. We can easily check it by creating an array cnta, i for each letter, which is a number of letters a in the positions 1... i of the string t. The complexity of the solution is O(|s| + |t|). Div2 E/Div1 C. Частичные суммыYou were given an array a in this problem. You could replace a by the array of its partial sums by one step. You had to find the array after k such steps. All the calculations were modulo P = 109 + 7.Write partial sums in following way: where Bi, j = 1 if i ≥ j and Bi, j = 0 if i < j, for each 1 ≤ i, j ≤ n. We can represent a and s as vector-columns, therefore one step corresponds to multiplying matrix B and vector-column a. Then the array a after k steps is equal to Bka. We can raise a matrix to a power for . It is not bad, but not fast enough.We can notice, that = , i.e. the elements of the matrix Bk on diagonals parallel to the main are the equal. It is easy to prove this fact using mathematical induction. You may prove it by yourself. Then we can determine the matrix by an array of numbers , equal to the elements of the first column. The elements of the first column of the product BkBl are equal . It is a straight consequence of formula of matrix product. The computing of one element requires O(n) time, there are n elements therefore we can multiply matriсеs in O(n2) time. Then we can solve the problem in time and this solution fits the consrtaints.This problem can be solved faster. We can assure that . Let this formula be correct for some k. Prove that it is correct for k + 1 either. Using the formula of product we get: Используя формулу Cnk = n! / k!(n - k)!, можно получить, что , поэтому мы можем построить все коэффициенты b, если умеем делить по модулю P, поэтому в этом решении существенна простота P. Обратный для числа x по простому модулю равен в силу малой теоремы Ферма. Таким образом, мы получаем решение за O(n2).Using the formula Cnk = n! / k!(n - k)! we can obtain , so we can find all the coefficients b if we can divide modulo P. Therefore it is significant that P is prime. Inverse x modulo P is equal to according to the Fermat little theorem. Therefore we get O(n2)solution.Div1 D. SpiderYou were given a polygon consisting of n vertices, you had to find the shortest way from one of its vertices to another. You were allowed to move along the border and go stricktly down without going outside the polygonAll the sides of the polygon can be divided into three groups: top, bottom and vertical. The side is vertical if and only if the x coordinates of its ends are equal. The side is bottom if and only if the polygon's interior is above the side. The side it top if and only if the polygon's interior is below the side. We can descend only from points of the top sides to the points of the bottom sides. Vertical sides can be ignored because every descend that has common points with a vertical side can be splitted into two descends and one transfer. One can prove that it is useless to descend from a side's interior to side's interior. Len one of the descends in the optimal solution start in the inner point and end in the inner point. We can slightly change the x coordinate of the descend. The path's lenght is monotonically (possibly not strictly) depends on x, so we can move x in order to improve the answer. In case of not strictly monotone dependance the answer do not depend on x, so we also can move it. This proof is wrong if the descend passes through a vertex, therefore we have to examine all possible descends from the vertices and to the vertices.We can solve this problem using scan-line method. We well move a vertical straight line from the left to the right and keep set S of the sides that intersect the line. We store the segments in the S in the sorted by y order. Let X be an abscissa of the line. The events happen during the moving: some segments are added to the S set, some are deleted. We can make an array of events, each events is described by its x coordinate that is equal to X of the line when the corresponding event happens, the number of the segment and a kind of event: adding or deleting. There are two events for every side, their x coordinates correspond to abscissas of their ends. The vertical sides can be ignored.Let us proceed the events in non-decreasing order of x coords. If the current event is adding we add the side to S set. Then we check on its closest neighbours in the set. If the current segment is a top segment we can make a descend from its left vertex down to the intersection with it's lower neighbor. We find the point of the intersection, remember the segment where the point is located and remember that there can be a descend from a vertex to the new point. If the current side is the bottom side we make a descand from the upper neighbour to the left end of the current segment and do the same things. If the current event is deleting we analize its neighbours in the same way, but the descends start or end on the right end of the segment we are going to delete. It is important that if there are many events of one kind we should proceed them simultaneously, i.e. if there are many addings in the same x coordinate we must add all the segments and then examine their neighbours. It is the same for deletings: firstly we analize the neighbours for all the segments and only then we delete them. Also in the case of equal x coords of the events the adding events must be first, otherwise the solution is wrong for the case of two angles separated by a vertical line with vertices lying on this line.Set S is easy to keep in container such as \"set\". We have to write a comparator for segments. We can do it in following way: two segments can be in S simultaneously if and only if there is a vertical line that intersects both of them. In common case such a line is not the unique, all the possible values of X are in segment [l, r] that can be easily found if we know the coors of the ends of the segments. Then we can choose an arbitrary X inside of [l, r] and compare the ordinates of the intersection points. Is better to choose inner point because in this case we don't have to examine special cases of segments having a common point.After this we can build a graph. It's vertices are the vertices of the polygon and the ends of possible descends. The edges of the graphs are the sides of the polygon and the descends. The shortest path can be found using Dijkstra algorithm. The complexity of the solution is .Div1 E. Planar graphIn the problem we were given an undirected planar graph without bridges, cutpoints, loops and multiedge laid on the plane. We get requests of the following type: to calculate the number of vertices inside the cycle or on it.Let us take an arbitrary vertex on the border of the graph, for example a vertex that has the least absciss. Let's add a new vertex with an edge to the chosen vertex in such way that the edge is outside the outer border of the graph. We'll call this new vertex a sink. Let's create a 1 value flow running to the sink from each vertex except the sink. Flow can be created using breadth-first or depth-first search. This operation will take the O(E) time.Let's examine any request. We assume that the cycle is oriented counter-clockwise (if it is not so, we can just reorient it). Let's make a cut on the graph. The first part will contain the vertices laying on the cycle or inside it, the second one — all remaining vertices including the sink. We'll now prove that the flow value through the cut is equal to the vertices number in the first part. It's obvious that we can calculate contribution from every vertex to the flow value independently. Let's assume that the vertex is situated in the first part. A unit flow runs from it to the sink along some path. As soon as this vertex and the sink are situated in different parts the flow passes the edges of the cut an odd number of times, that's why the contribution of this vertex to the flow through the cut is equal to 1. Let's take now a vertex situated in the second part. As soon as it's situated in the same part as the sink the flow passes the edges of the cut an even number of times, that's why the contribution of this vertex to the flow through the cut is zero. In order to calculate the flow value through the cut we need to sum up flow values passing through the cut's edges. It's important to notice that every edge of the cut is incident to only one vertex lying on the cycle, that's why we can sum up flows passing though edges going outside the cycle for each vertex in the cycle. In order to find all edges going outside the cycle we'll sort all edges going from each vertex counter-clockwise by angle. In this case all edges going outside the cycle will be placed after the previous vertex of the cycle and before the following vertex of the cycle. That's why the sum of flow values over the edges going outside reduces to a sum over an segment which is easily calculated using partial sums. The complexity of the solution is for graph sorting plus for the request where l is the cycle length. There is in complexity because we have to know a position of a vertex in the adjacency list of another vertex.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5301",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 14288
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #138 - Codeforces - Code 1",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 2",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 3",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 4",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 5",
          "code": "5 3\n1 2 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 6",
          "code": "4\n[[]]()[][][()]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 7",
          "code": "100000\n[][][][]...[][][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 8",
          "code": "4 3\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces - Code 1",
          "code": "4 * (a + b + c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the bracket sequence, ensuring it contains only '(', ')', '[' and ']',\n    // has length between 1 and 1e5, and is assigned to variable \"s\" for clear error messages.\n    string s = inf.readLine(\"[()\\\\[\\\\]]{1,100000}\", \"s\");\n\n    // Ensure that there is no extra input after the bracket sequence.\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the bracket sequence, ensuring it contains only '(', ')', '[' and ']',\n    // has length between 1 and 1e5, and is assigned to variable \"s\" for clear error messages.\n    string s = inf.readLine(\"[()\\\\[\\\\]]{1,100000}\", \"s\");\n\n    // Ensure that there is no extra input after the bracket sequence.\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the bracket sequence, ensuring it contains only '(', ')', '[' and ']',\n    // has length between 1 and 1e5, and is assigned to variable \"s\" for clear error messages.\n    string s = inf.readLine(\"[()\\\\[\\\\]]{1,100000}\", \"s\");\n\n    // Ensure that there is no extra input after the bracket sequence.\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    string s = inf.readString(); // Read the input string from the input file\n\n    int k_jury = ans.readInt(); // Read the judge's answer for k from the answer file\n\n    int k_contestant = ouf.readInt(); // Read the contestant's answer for k\n\n    if (k_contestant != k_jury) {\n        quitf(_wa, \"Wrong number of '[': expected %d, found %d\", k_jury, k_contestant);\n    }\n\n    string s_contestant;\n\n    if (k_contestant == 0) {\n        // Try to read the next line, which may or may not exist\n        if (ouf.seekEof()) {\n            s_contestant = \"\"; // Empty string\n        } else {\n            s_contestant = ouf.readLine();\n        }\n    } else {\n        // k_contestant > 0, must read the next line\n        if (ouf.seekEof()) {\n            quitf(_wa, \"Expected bracket sequence, but found EOF\");\n        }\n        s_contestant = ouf.readLine();\n    }\n\n    // Check that number of '[' in s_contestant equals k_contestant\n    int count_open_brackets = count(s_contestant.begin(), s_contestant.end(), '[');\n    if (count_open_brackets != k_contestant) {\n        quitf(_wa, \"Number of '[' in the sequence doesn't match k: expected %d, found %d\", k_contestant, count_open_brackets);\n    }\n\n    // Check that s_contestant is a substring of s\n    if (s_contestant != \"\" && s.find(s_contestant) == string::npos) {\n        quitf(_wa, \"The provided sequence is not a substring of the input string\");\n    }\n\n    // Check that s_contestant is a correct bracket sequence\n    stack<char> stk;\n    for (char c : s_contestant) {\n        if (c == '(' || c == '[') {\n            stk.push(c);\n        } else if (c == ')' || c == ']') {\n            if (stk.empty()) {\n                quitf(_wa, \"The sequence is not a correct bracket sequence (too many closing brackets)\");\n            }\n            char open_bracket = stk.top();\n            stk.pop();\n            if ((open_bracket == '(' && c != ')') || (open_bracket == '[' && c != ']')) {\n                quitf(_wa, \"The sequence is not a correct bracket sequence (mismatched brackets)\");\n            }\n        } else {\n            quitf(_fail, \"Invalid character '%c' in the sequence\", c);\n        }\n    }\n    if (!stk.empty()) {\n        quitf(_wa, \"The sequence is not a correct bracket sequence (too many opening brackets)\");\n    }\n\n    // All checks passed\n    quitf(_ok, \"Correct solution with %d '['\", k_contestant);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s = \"\";\n\n    if (type == \"random\") {\n        // Randomly generate sequence of length n\n        string chars = \"[]()\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(4)];\n        }\n    } else if (type == \"correct\") {\n        // Generate a correct bracket sequence of length close to n\n        vector<char> brackets;\n        int pairs = n / 2;\n        for (int i = 0; i < pairs; ++i) {\n            // Randomly choose '(' or '['\n            brackets.push_back(rnd.next(2) ? '(' : '[');\n        }\n        // Now, add closing brackets\n        for (int i = pairs - 1; i >= 0; --i) {\n            if (brackets[i] == '(')\n                brackets.push_back(')');\n            else\n                brackets.push_back(']');\n        }\n        // If n is odd, add an extra pair\n        if (n % 2 != 0) {\n            brackets.insert(brackets.begin(), rnd.next(2) ? '(' : '[');\n            char last_open = brackets[0];\n            brackets.push_back(last_open == '(' ? ')' : ']');\n        }\n        n = brackets.size(); // Update n to the actual length\n        for (char c : brackets) {\n            s += c;\n        }\n        // If s.size() < n, fill the rest with random brackets\n        while ((int)s.size() < n) {\n            s += \"[]()\"[rnd.next(4)];\n        }\n    } else if (type == \"incorrect\") {\n        // Generate an incorrect bracket sequence of length n\n        string chars = \"[]()\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(4)];\n        }\n        // Make sure it's incorrect by making the last character an opening bracket\n        if (n > 0) {\n            s[n - 1] = rnd.next(2) ? '(' : '[';\n        }\n    } else if (type == \"unbalanced_left\") {\n        // More opening brackets\n        string chars = \"([\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(2)];\n        }\n    } else if (type == \"unbalanced_right\") {\n        // More closing brackets\n        string chars = \")]\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(2)];\n        }\n    } else if (type == \"max_open_square\") {\n        // Generate sequence where the max correct substring has max '['\n        int num_pairs = n / 2;\n        for (int i = 0; i < num_pairs; ++i) {\n            s += '[';\n        }\n        for (int i = 0; i < num_pairs; ++i) {\n            s += ']';\n        }\n    } else if (type == \"max_open_round\") {\n        // Generate sequence where the max correct substring has max '('\n        int num_pairs = n / 2;\n        for (int i = 0; i < num_pairs; ++i) {\n            s += '(';\n        }\n        for (int i = 0; i < num_pairs; ++i) {\n            s += ')';\n        }\n    } else if (type == \"alternating\") {\n        // Generate an alternating sequence of brackets\n        vector<char> brackets;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                brackets.push_back(rnd.next(2) ? '(' : '[');\n            else {\n                char last_open = brackets[i - 1];\n                brackets.push_back(last_open == '(' ? ')' : ']');\n            }\n        }\n        for (char c : brackets) s += c;\n    } else if (type == \"only_opening\") {\n        // Generate a sequence with only opening brackets\n        string chars = \"([\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(2)];\n        }\n    } else if (type == \"only_closing\") {\n        // Generate a sequence with only closing brackets\n        string chars = \")]\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(2)];\n        }\n    } else if (type == \"nested_same\") {\n        // Generate nested brackets like (((...)))\n        char open_bracket = rnd.next(2) ? '(' : '[';\n        char close_bracket = (open_bracket == '(') ? ')' : ']';\n        for (int i = 0; i < n / 2; ++i) {\n            s += open_bracket;\n        }\n        for (int i = 0; i < n / 2; ++i) {\n            s += close_bracket;\n        }\n        if (n % 2 != 0) {\n            // Add an extra opening bracket\n            s += open_bracket;\n        }\n    } else if (type == \"nested_alternate\") {\n        // Generate nested brackets alternating between '(' and '['\n        vector<char> brackets;\n        for (int i = 0; i < n / 2; ++i) {\n            brackets.push_back(i % 2 == 0 ? '(' : '[');\n        }\n        for (int i = n / 2 - 1; i >= 0; --i) {\n            char c = brackets[i];\n            brackets.push_back(c == '(' ? ')' : ']');\n        }\n        for (char c : brackets) s += c;\n        if (n % 2 != 0) {\n            s += \"([)]\"[rnd.next(4)];\n        }\n    } else if (type == \"max_close_brackets_in_long_correct_substring\") {\n        // Generate a sequence with a long correct substring that has many ']' brackets\n        int num_pairs = n / 2;\n        for (int i = 0; i < num_pairs; ++i) {\n            s += '[';\n        }\n        for (int i = 0; i < num_pairs; ++i) {\n            s += ']';\n        }\n        // Insert random characters in random positions\n        int random_chars = n - num_pairs * 2;\n        for (int i = 0; i < random_chars; ++i) {\n            s.insert(rnd.next(s.size() + 1), 1, \"[]()\"[rnd.next(4)]);\n        }\n    } else if (type == \"empty_correct_substring\") {\n        // Generate a sequence where the correct substring is empty\n        // So generate a fully incorrect sequence\n        string chars = \"([)]\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(4)];\n        }\n        // Ensure that there are no correct substrings\n        if (n >= 2) {\n            for (int i = 0; i < n - 1; i += 2) {\n                s[i] = '(';\n                s[i + 1] = ']';\n            }\n        }\n    } else if (type == \"long_incorrect_prefix\") {\n        // Generate a sequence with long incorrect prefix, and correct substring at the end\n        for (int i = 0; i < n / 2; ++i) {\n            s += \"([)]\"[rnd.next(4)];\n        }\n        // Now append correct bracket sequence\n        int remaining = n - s.size();\n        vector<char> brackets;\n        for (int i = 0; i < remaining / 2; ++i) {\n            brackets.push_back(rnd.next(2) ? '(' : '[');\n        }\n        for (int i = brackets.size() - 1; i >= 0; --i) {\n            if (brackets[i] == '(')\n                brackets.push_back(')');\n            else\n                brackets.push_back(']');\n        }\n        for (char c : brackets) s += c;\n        // If s.size() < n, fill rest with random characters\n        while ((int)s.size() < n) {\n            s += \"([)]\"[rnd.next(4)];\n        }\n    } else {\n        // Default to random\n        string chars = \"[]()\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(4)];\n        }\n    }\n\n    // Output the string\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s = \"\";\n\n    if (type == \"random\") {\n        // Randomly generate sequence of length n\n        string chars = \"[]()\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(4)];\n        }\n    } else if (type == \"correct\") {\n        // Generate a correct bracket sequence of length close to n\n        vector<char> brackets;\n        int pairs = n / 2;\n        for (int i = 0; i < pairs; ++i) {\n            // Randomly choose '(' or '['\n            brackets.push_back(rnd.next(2) ? '(' : '[');\n        }\n        // Now, add closing brackets\n        for (int i = pairs - 1; i >= 0; --i) {\n            if (brackets[i] == '(')\n                brackets.push_back(')');\n            else\n                brackets.push_back(']');\n        }\n        // If n is odd, add an extra pair\n        if (n % 2 != 0) {\n            brackets.insert(brackets.begin(), rnd.next(2) ? '(' : '[');\n            char last_open = brackets[0];\n            brackets.push_back(last_open == '(' ? ')' : ']');\n        }\n        n = brackets.size(); // Update n to the actual length\n        for (char c : brackets) {\n            s += c;\n        }\n        // If s.size() < n, fill the rest with random brackets\n        while ((int)s.size() < n) {\n            s += \"[]()\"[rnd.next(4)];\n        }\n    } else if (type == \"incorrect\") {\n        // Generate an incorrect bracket sequence of length n\n        string chars = \"[]()\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(4)];\n        }\n        // Make sure it's incorrect by making the last character an opening bracket\n        if (n > 0) {\n            s[n - 1] = rnd.next(2) ? '(' : '[';\n        }\n    } else if (type == \"unbalanced_left\") {\n        // More opening brackets\n        string chars = \"([\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(2)];\n        }\n    } else if (type == \"unbalanced_right\") {\n        // More closing brackets\n        string chars = \")]\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(2)];\n        }\n    } else if (type == \"max_open_square\") {\n        // Generate sequence where the max correct substring has max '['\n        int num_pairs = n / 2;\n        for (int i = 0; i < num_pairs; ++i) {\n            s += '[';\n        }\n        for (int i = 0; i < num_pairs; ++i) {\n            s += ']';\n        }\n    } else if (type == \"max_open_round\") {\n        // Generate sequence where the max correct substring has max '('\n        int num_pairs = n / 2;\n        for (int i = 0; i < num_pairs; ++i) {\n            s += '(';\n        }\n        for (int i = 0; i < num_pairs; ++i) {\n            s += ')';\n        }\n    } else if (type == \"alternating\") {\n        // Generate an alternating sequence of brackets\n        vector<char> brackets;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                brackets.push_back(rnd.next(2) ? '(' : '[');\n            else {\n                char last_open = brackets[i - 1];\n                brackets.push_back(last_open == '(' ? ')' : ']');\n            }\n        }\n        for (char c : brackets) s += c;\n    } else if (type == \"only_opening\") {\n        // Generate a sequence with only opening brackets\n        string chars = \"([\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(2)];\n        }\n    } else if (type == \"only_closing\") {\n        // Generate a sequence with only closing brackets\n        string chars = \")]\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(2)];\n        }\n    } else if (type == \"nested_same\") {\n        // Generate nested brackets like (((...)))\n        char open_bracket = rnd.next(2) ? '(' : '[';\n        char close_bracket = (open_bracket == '(') ? ')' : ']';\n        for (int i = 0; i < n / 2; ++i) {\n            s += open_bracket;\n        }\n        for (int i = 0; i < n / 2; ++i) {\n            s += close_bracket;\n        }\n        if (n % 2 != 0) {\n            // Add an extra opening bracket\n            s += open_bracket;\n        }\n    } else if (type == \"nested_alternate\") {\n        // Generate nested brackets alternating between '(' and '['\n        vector<char> brackets;\n        for (int i = 0; i < n / 2; ++i) {\n            brackets.push_back(i % 2 == 0 ? '(' : '[');\n        }\n        for (int i = n / 2 - 1; i >= 0; --i) {\n            char c = brackets[i];\n            brackets.push_back(c == '(' ? ')' : ']');\n        }\n        for (char c : brackets) s += c;\n        if (n % 2 != 0) {\n            s += \"([)]\"[rnd.next(4)];\n        }\n    } else if (type == \"max_close_brackets_in_long_correct_substring\") {\n        // Generate a sequence with a long correct substring that has many ']' brackets\n        int num_pairs = n / 2;\n        for (int i = 0; i < num_pairs; ++i) {\n            s += '[';\n        }\n        for (int i = 0; i < num_pairs; ++i) {\n            s += ']';\n        }\n        // Insert random characters in random positions\n        int random_chars = n - num_pairs * 2;\n        for (int i = 0; i < random_chars; ++i) {\n            s.insert(rnd.next(s.size() + 1), 1, \"[]()\"[rnd.next(4)]);\n        }\n    } else if (type == \"empty_correct_substring\") {\n        // Generate a sequence where the correct substring is empty\n        // So generate a fully incorrect sequence\n        string chars = \"([)]\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(4)];\n        }\n        // Ensure that there are no correct substrings\n        if (n >= 2) {\n            for (int i = 0; i < n - 1; i += 2) {\n                s[i] = '(';\n                s[i + 1] = ']';\n            }\n        }\n    } else if (type == \"long_incorrect_prefix\") {\n        // Generate a sequence with long incorrect prefix, and correct substring at the end\n        for (int i = 0; i < n / 2; ++i) {\n            s += \"([)]\"[rnd.next(4)];\n        }\n        // Now append correct bracket sequence\n        int remaining = n - s.size();\n        vector<char> brackets;\n        for (int i = 0; i < remaining / 2; ++i) {\n            brackets.push_back(rnd.next(2) ? '(' : '[');\n        }\n        for (int i = brackets.size() - 1; i >= 0; --i) {\n            if (brackets[i] == '(')\n                brackets.push_back(')');\n            else\n                brackets.push_back(']');\n        }\n        for (char c : brackets) s += c;\n        // If s.size() < n, fill rest with random characters\n        while ((int)s.size() < n) {\n            s += \"([)]\"[rnd.next(4)];\n        }\n    } else {\n        // Default to random\n        string chars = \"[]()\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(4)];\n        }\n    }\n\n    // Output the string\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type correct\n./gen -n 10 -type incorrect\n./gen -n 20 -type unbalanced_left\n./gen -n 20 -type unbalanced_right\n./gen -n 20 -type only_opening\n./gen -n 20 -type only_closing\n./gen -n 50 -type max_open_square\n./gen -n 50 -type max_open_round\n./gen -n 50 -type alternating\n./gen -n 100 -type nested_same\n./gen -n 100 -type nested_alternate\n./gen -n 500 -type random\n./gen -n 500 -type max_close_brackets_in_long_correct_substring\n./gen -n 1000 -type empty_correct_substring\n./gen -n 5000 -type long_incorrect_prefix\n./gen -n 10000 -type long_incorrect_prefix\n./gen -n 50000 -type correct\n./gen -n 100000 -type incorrect\n./gen -n 100000 -type random\n./gen -n 99999 -type nested_same\n./gen -n 100000 -type max_open_square\n./gen -n 99999 -type max_open_round\n./gen -n 100000 -type unbalanced_left\n./gen -n 100000 -type unbalanced_right\n./gen -n 99998 -type only_opening\n./gen -n 99998 -type only_closing\n./gen -n 1 -type empty_correct_substring\n./gen -n 2 -type empty_correct_substring\n./gen -n 5 -type empty_correct_substring\n./gen -n 10 -type empty_correct_substring\n./gen -n 20000 -type max_close_brackets_in_long_correct_substring\n./gen -n 33333 -type alternating\n./gen -n 44444 -type nested_alternate\n./gen -n 55555 -type nested_same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:35.920462",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "224/D",
      "title": "D. Two Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains string s, the second line contains string t. Each line consists only of lowercase English letters. The given strings are non-empty, the length of each string does not exceed 2·105.",
      "output_spec": "OutputPrint \"Yes\" (without the quotes), if each character of the string s occurs in at least one of the described subsequences, or \"No\" (without the quotes) otherwise.",
      "sample_tests": "ExamplesInputCopyabababOutputCopyYesInputCopyabacabaabaOutputCopyNoInputCopyabcbaOutputCopyNo",
      "description": "D. Two Strings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains string s, the second line contains string t. Each line consists only of lowercase English letters. The given strings are non-empty, the length of each string does not exceed 2·105.\n\nOutputPrint \"Yes\" (without the quotes), if each character of the string s occurs in at least one of the described subsequences, or \"No\" (without the quotes) otherwise.\n\nInputCopyabababOutputCopyYesInputCopyabacabaabaOutputCopyNoInputCopyabcbaOutputCopyNo\n\nInputCopyababab\n\nOutputCopyYes\n\nInputCopyabacabaaba\n\nOutputCopyNo\n\nInputCopyabcba\n\nOutputCopyNo\n\nNoteIn the first sample string t can occur in the string s as a subsequence in three ways: abab, abab and abab. In these occurrences each character of string s occurs at least once.In the second sample the 4-th character of the string s doesn't occur in any occurrence of string t.In the third sample there is no occurrence of string t in string s.",
      "solutions": [
        {
          "title": "Codeforces Round #138 - Codeforces",
          "content": "Hello everybody!I am glad to announce that Codeforces Round #138 will be held today at 19:30 MSK. I (Vasiliy Vadimov) am the author of this round. It is my first Codeforces round, I just helped other authors to prepare their rounds before.I would like to thank Gerald Gerald Agapov for his help in the preparing of the round and Maria Delinur Belova for translation of the problems' statements in English. Also I am grateful to Mike MikeMirzayanov Mirzayanov for such an excellent contest system as Codeforces.Good luck! I hope you will be interested in the problems.The point distribution is standard in both divisions (500-1000-1500-2000-2500).UPD. Attention! D language will not be available on this contest.UPD2. The round is over, top-5 in both divisions:Div1: Petr tourist peter50216 Shik Egor Div2: ecnerwala ordcoder scipianus jonathanpaulson void_rank Congratulations to the winners! Also I am apologising for mistakes in statement of problem div1 A/div2 C. The tutorial will be published tomorrow.UPD3. The tutorial is available here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1044
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces",
          "content": "Div2 A. ParallelepipedYou were given areas of three faces of a rectangular parallelepiped. Your task was to find the sum of lengths of it's sides.Let a, b and c be the lengths of the sides that have one common vertex. Then the numbers we are given are s1 = ab, s2 = bc и s3 = ca. It is easy to find the lengths in terms of faces areas: , , . The answer is 4(a + b + c), because there are four sides that have lengths equal to a, b and c. The complexity is O(1).Div2 B. ArrayYou were given an array a consisting of n integers. Its elements ai were positive and not greater than 105 for each 1 ≤ i ≤ n. Also you were given positive integer k. You had to find minimal by inclusion segment [l, r] such that there were exactly k different numbers among al, ..., ar. The definition of the \"minimal by inclusion\" you can read in the statement.Let us make a new array cnt. In the beginning its element cnti is equal to number of occurencies of number i in array a. It is possible to make this array because elements of a are not very large. Amount of nonzero elements in cnt is equal to amount of different elements in a. There is no solution if this number is less then k.If it is not true, we have to find the answer segment [l, r]. In the beginning let [l, r] = [1, n]. We decrease its right end r by 1 until amount of different elements on the segment [l, r] is less than k. We can keep the amount of different numbers in following way: we decrease cntar by 1 if we delete element number r. Then we have to decrease current number of different elements by 1 if cntar becomes zero. After this we return the last deleted element back to the segment in order to make amount of different elements equal to k. Then we have to do the same with the left end l, but we have not to decrease but to increase its value by 1 on each step. Finally, we get a segment [l, r]. The amount of different numbers on it is equal to k and on every its subsegment is less than k. Therefore, this segment is an answer. The complexity is O(n).Div2 C/Div1 A. Bracket sequenceYou were given a bracket sequence s consisting of brackets of two kinds. You were to find regular bracket sequence that was a substring of s and contains as many <<>> braces as possible.We will try to determine corresponding closing bracket for every opening one. Formally, let a bracket on the i-th position be opening, then the closing bracket on the position j is corresponding to it if and only if a substring si... sj is the shortest regular bracket sequence that begins from the i-th position. In common case there can be brackets with no corresponding ones.We scan the sting s and put positions with the opening brackets into a stack. Let us proceed the i-th position. If si is an opening bracket we simply put i on the top of the stack. Otherwise, we have to clean the stack if the stack is empty or the bracket on the top does not correspond to the current one. But if the bracket on the top is ok we just remove the top of the stack and remember that the bracket on position i is corresponding to the bracket removed from the top. So, we find all the correspondings for all the brackets.Then we can split s into blocks. Let block be a segment [l, r] such that the bracket on the r-th position is corresponding for the bracket on the i-th and there is no couple of corresponding brackets on positions x and y such that and [l, r] ≠ [x, y]. It is easy to understand that the blocks do not intersect and the split is unique. We can join the consequent blocks into the regular bracket sequences. We should join as many blocks as possible in order to get the maximal number of braces. We get several substrings that are regular bracket sequences after we join all the consecutive blocks. The answer is the substring that has the largest amount of braces <<>>. The complexity is O(|s|).Div2 D/Div1 B. Two strings.You were given two strings: s and t. You were required to examine all occurrences of the string t in the string s as subsequence and to find out if it is true that for each position of the s string there are such occurrence, that includes this position. For each position i of the s string we calculate two values li and ri where li is the maximal possible number that the string t1... tli occurs as subsequence in the string s1... si, ri is the maximal possible number that the string t|t| - ri + 1... t|t| occurs in the string si... s|s| as subsequence. Let us find all of l for the position 1... i - 1 and want to find li. If the symbol tli - 1 + 1 exists and concurs with the symbol si then li = li - 1 + 1, in other case li = li - 1. In the same way we can find ri if we move from the end of the string.Now we should check if the position i in the string s belongs to at least one occurrence. Let us assume this to be correct and the symbol si corresponds to the symbol tj of the string t. Then li - 1 ≥ j - 1 and ri + 1 ≥ |t| - j by definition of the l and r. Then if j exists that si = tj and li - 1 + 1 ≥ j ≥ |t| - ri + 1, then the position i of the string s belongs to at least one occurrence of the t, in other case the occurrence doesn’t exist. We can easily check it by creating an array cnta, i for each letter, which is a number of letters a in the positions 1... i of the string t. The complexity of the solution is O(|s| + |t|). Div2 E/Div1 C. Частичные суммыYou were given an array a in this problem. You could replace a by the array of its partial sums by one step. You had to find the array after k such steps. All the calculations were modulo P = 109 + 7.Write partial sums in following way: where Bi, j = 1 if i ≥ j and Bi, j = 0 if i < j, for each 1 ≤ i, j ≤ n. We can represent a and s as vector-columns, therefore one step corresponds to multiplying matrix B and vector-column a. Then the array a after k steps is equal to Bka. We can raise a matrix to a power for . It is not bad, but not fast enough.We can notice, that = , i.e. the elements of the matrix Bk on diagonals parallel to the main are the equal. It is easy to prove this fact using mathematical induction. You may prove it by yourself. Then we can determine the matrix by an array of numbers , equal to the elements of the first column. The elements of the first column of the product BkBl are equal . It is a straight consequence of formula of matrix product. The computing of one element requires O(n) time, there are n elements therefore we can multiply matriсеs in O(n2) time. Then we can solve the problem in time and this solution fits the consrtaints.This problem can be solved faster. We can assure that . Let this formula be correct for some k. Prove that it is correct for k + 1 either. Using the formula of product we get: Используя формулу Cnk = n! / k!(n - k)!, можно получить, что , поэтому мы можем построить все коэффициенты b, если умеем делить по модулю P, поэтому в этом решении существенна простота P. Обратный для числа x по простому модулю равен в силу малой теоремы Ферма. Таким образом, мы получаем решение за O(n2).Using the formula Cnk = n! / k!(n - k)! we can obtain , so we can find all the coefficients b if we can divide modulo P. Therefore it is significant that P is prime. Inverse x modulo P is equal to according to the Fermat little theorem. Therefore we get O(n2)solution.Div1 D. SpiderYou were given a polygon consisting of n vertices, you had to find the shortest way from one of its vertices to another. You were allowed to move along the border and go stricktly down without going outside the polygonAll the sides of the polygon can be divided into three groups: top, bottom and vertical. The side is vertical if and only if the x coordinates of its ends are equal. The side is bottom if and only if the polygon's interior is above the side. The side it top if and only if the polygon's interior is below the side. We can descend only from points of the top sides to the points of the bottom sides. Vertical sides can be ignored because every descend that has common points with a vertical side can be splitted into two descends and one transfer. One can prove that it is useless to descend from a side's interior to side's interior. Len one of the descends in the optimal solution start in the inner point and end in the inner point. We can slightly change the x coordinate of the descend. The path's lenght is monotonically (possibly not strictly) depends on x, so we can move x in order to improve the answer. In case of not strictly monotone dependance the answer do not depend on x, so we also can move it. This proof is wrong if the descend passes through a vertex, therefore we have to examine all possible descends from the vertices and to the vertices.We can solve this problem using scan-line method. We well move a vertical straight line from the left to the right and keep set S of the sides that intersect the line. We store the segments in the S in the sorted by y order. Let X be an abscissa of the line. The events happen during the moving: some segments are added to the S set, some are deleted. We can make an array of events, each events is described by its x coordinate that is equal to X of the line when the corresponding event happens, the number of the segment and a kind of event: adding or deleting. There are two events for every side, their x coordinates correspond to abscissas of their ends. The vertical sides can be ignored.Let us proceed the events in non-decreasing order of x coords. If the current event is adding we add the side to S set. Then we check on its closest neighbours in the set. If the current segment is a top segment we can make a descend from its left vertex down to the intersection with it's lower neighbor. We find the point of the intersection, remember the segment where the point is located and remember that there can be a descend from a vertex to the new point. If the current side is the bottom side we make a descand from the upper neighbour to the left end of the current segment and do the same things. If the current event is deleting we analize its neighbours in the same way, but the descends start or end on the right end of the segment we are going to delete. It is important that if there are many events of one kind we should proceed them simultaneously, i.e. if there are many addings in the same x coordinate we must add all the segments and then examine their neighbours. It is the same for deletings: firstly we analize the neighbours for all the segments and only then we delete them. Also in the case of equal x coords of the events the adding events must be first, otherwise the solution is wrong for the case of two angles separated by a vertical line with vertices lying on this line.Set S is easy to keep in container such as \"set\". We have to write a comparator for segments. We can do it in following way: two segments can be in S simultaneously if and only if there is a vertical line that intersects both of them. In common case such a line is not the unique, all the possible values of X are in segment [l, r] that can be easily found if we know the coors of the ends of the segments. Then we can choose an arbitrary X inside of [l, r] and compare the ordinates of the intersection points. Is better to choose inner point because in this case we don't have to examine special cases of segments having a common point.After this we can build a graph. It's vertices are the vertices of the polygon and the ends of possible descends. The edges of the graphs are the sides of the polygon and the descends. The shortest path can be found using Dijkstra algorithm. The complexity of the solution is .Div1 E. Planar graphIn the problem we were given an undirected planar graph without bridges, cutpoints, loops and multiedge laid on the plane. We get requests of the following type: to calculate the number of vertices inside the cycle or on it.Let us take an arbitrary vertex on the border of the graph, for example a vertex that has the least absciss. Let's add a new vertex with an edge to the chosen vertex in such way that the edge is outside the outer border of the graph. We'll call this new vertex a sink. Let's create a 1 value flow running to the sink from each vertex except the sink. Flow can be created using breadth-first or depth-first search. This operation will take the O(E) time.Let's examine any request. We assume that the cycle is oriented counter-clockwise (if it is not so, we can just reorient it). Let's make a cut on the graph. The first part will contain the vertices laying on the cycle or inside it, the second one — all remaining vertices including the sink. We'll now prove that the flow value through the cut is equal to the vertices number in the first part. It's obvious that we can calculate contribution from every vertex to the flow value independently. Let's assume that the vertex is situated in the first part. A unit flow runs from it to the sink along some path. As soon as this vertex and the sink are situated in different parts the flow passes the edges of the cut an odd number of times, that's why the contribution of this vertex to the flow through the cut is equal to 1. Let's take now a vertex situated in the second part. As soon as it's situated in the same part as the sink the flow passes the edges of the cut an even number of times, that's why the contribution of this vertex to the flow through the cut is zero. In order to calculate the flow value through the cut we need to sum up flow values passing through the cut's edges. It's important to notice that every edge of the cut is incident to only one vertex lying on the cycle, that's why we can sum up flows passing though edges going outside the cycle for each vertex in the cycle. In order to find all edges going outside the cycle we'll sort all edges going from each vertex counter-clockwise by angle. In this case all edges going outside the cycle will be placed after the previous vertex of the cycle and before the following vertex of the cycle. That's why the sum of flow values over the edges going outside reduces to a sum over an segment which is easily calculated using partial sums. The complexity of the solution is for graph sorting plus for the request where l is the cycle length. There is in complexity because we have to know a position of a vertex in the adjacency list of another vertex.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5301",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 14288
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #138 - Codeforces - Code 1",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 2",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 3",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 4",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 5",
          "code": "5 3\n1 2 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 6",
          "code": "4\n[[]]()[][][()]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 7",
          "code": "100000\n[][][][]...[][][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 8",
          "code": "4 3\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces - Code 1",
          "code": "4 * (a + b + c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,200000}\");\n    string t = inf.readLine(\"[a-z]{1,200000}\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,200000}\");\n    string t = inf.readLine(\"[a-z]{1,200000}\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,200000}\");\n    string t = inf.readLine(\"[a-z]{1,200000}\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int length) {\n    string res(length, 'a');\n    for (int i = 0; i < length; ++i) {\n        res[i] = 'a' + rnd.next(26);\n    }\n    return res;\n}\n\n// Function to get a character not present in a given string\nchar get_char_not_in_string(const string &s) {\n    vector<bool> used(26, false);\n    for (char c : s) {\n        used[c - 'a'] = true;\n    }\n    for (int i = 0; i < 26; ++i) {\n        if (!used[i]) {\n            return 'a' + i;\n        }\n    }\n    // If all letters are used, return a random character\n    return 'a' + rnd.next(26);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 100000); // length of s\n    int m = opt<int>(\"m\", 100000); // length of t\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random strings s and t\n        string s = generate_random_string(n);\n        string t = generate_random_string(m);\n        cout << s << endl << t << endl;\n    } else if (type == \"t_not_subsequence\") {\n        // Generate s and t where t is not a subsequence of s\n        string s = generate_random_string(n);\n        string t = generate_random_string(m);\n        // Modify t to include a character not in s\n        char c = get_char_not_in_string(s);\n        if (t.size() > 0)\n            t[rnd.next(t.size())] = c;\n        else\n            t += c;\n        cout << s << endl << t << endl;\n    } else if (type == \"t_subsequence\") {\n        // Generate s and t where t is a subsequence of s\n        string t = generate_random_string(m);\n        int extra_length = n - m;\n        string s;\n        for (int i = 0; i < m; ++i) {\n            s += t[i];\n            int num_extra = (i < m - 1) ? rnd.next(0, extra_length) : extra_length;\n            extra_length -= num_extra;\n            for (int j = 0; j < num_extra; ++j) {\n                s += 'a' + rnd.next(26);\n            }\n        }\n        cout << s << endl << t << endl;\n    } else if (type == \"yes\") {\n        // Generate s and t such that the answer is \"Yes\"\n        string t = generate_random_string(m);\n        vector<int> positions;\n        // Distribute positions for t's characters in s\n        for (int i = 0; i < m; ++i) {\n            positions.push_back(i * (n / m) + rnd.next(0, n / m - 1));\n        }\n        sort(positions.begin(), positions.end());\n        if (positions.size() > 0 && positions.back() >= n) {\n            positions.back() = n - 1;\n        }\n        string s(n, 'a');\n        // Fill s with random letters\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n        // Place t's characters in s\n        for (int i = 0; i < m; ++i) {\n            s[positions[i]] = t[i];\n        }\n        cout << s << endl << t << endl;\n    } else if (type == \"no\") {\n        // Generate s and t such that the answer is \"No\"\n        string t = generate_random_string(m);\n        string s;\n        char c = get_char_not_in_string(t);\n        // Insert character c into s at a random position\n        int pos_c = rnd.next(n);\n        int extra_length = n - m - 1; // Account for the extra character c\n        for (int i = 0; i < m; ++i) {\n            s += t[i];\n            int num_extra = (i < m - 1) ? rnd.next(0, extra_length) : extra_length;\n            extra_length -= num_extra;\n            for (int j = 0; j < num_extra; ++j) {\n                s += 'a' + rnd.next(26);\n            }\n            if (s.size() >= pos_c && pos_c != -1) {\n                s.insert(s.begin() + pos_c, c);\n                pos_c = -1;\n            }\n        }\n        if (pos_c != -1) {\n            s.insert(s.begin() + pos_c, c);\n        }\n        while (s.size() < n) {\n            s += 'a' + rnd.next(26);\n        }\n        if (s.size() > n) {\n            s = s.substr(0, n);\n        }\n        cout << s << endl << t << endl;\n    } else if (type == \"max\") {\n        // Generate maximum length strings s and t\n        n = 200000;\n        m = 200000;\n        string s = generate_random_string(n);\n        string t = s; // t equals s\n        cout << s << endl << t << endl;\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int length) {\n    string res(length, 'a');\n    for (int i = 0; i < length; ++i) {\n        res[i] = 'a' + rnd.next(26);\n    }\n    return res;\n}\n\n// Function to get a character not present in a given string\nchar get_char_not_in_string(const string &s) {\n    vector<bool> used(26, false);\n    for (char c : s) {\n        used[c - 'a'] = true;\n    }\n    for (int i = 0; i < 26; ++i) {\n        if (!used[i]) {\n            return 'a' + i;\n        }\n    }\n    // If all letters are used, return a random character\n    return 'a' + rnd.next(26);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 100000); // length of s\n    int m = opt<int>(\"m\", 100000); // length of t\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random strings s and t\n        string s = generate_random_string(n);\n        string t = generate_random_string(m);\n        cout << s << endl << t << endl;\n    } else if (type == \"t_not_subsequence\") {\n        // Generate s and t where t is not a subsequence of s\n        string s = generate_random_string(n);\n        string t = generate_random_string(m);\n        // Modify t to include a character not in s\n        char c = get_char_not_in_string(s);\n        if (t.size() > 0)\n            t[rnd.next(t.size())] = c;\n        else\n            t += c;\n        cout << s << endl << t << endl;\n    } else if (type == \"t_subsequence\") {\n        // Generate s and t where t is a subsequence of s\n        string t = generate_random_string(m);\n        int extra_length = n - m;\n        string s;\n        for (int i = 0; i < m; ++i) {\n            s += t[i];\n            int num_extra = (i < m - 1) ? rnd.next(0, extra_length) : extra_length;\n            extra_length -= num_extra;\n            for (int j = 0; j < num_extra; ++j) {\n                s += 'a' + rnd.next(26);\n            }\n        }\n        cout << s << endl << t << endl;\n    } else if (type == \"yes\") {\n        // Generate s and t such that the answer is \"Yes\"\n        string t = generate_random_string(m);\n        vector<int> positions;\n        // Distribute positions for t's characters in s\n        for (int i = 0; i < m; ++i) {\n            positions.push_back(i * (n / m) + rnd.next(0, n / m - 1));\n        }\n        sort(positions.begin(), positions.end());\n        if (positions.size() > 0 && positions.back() >= n) {\n            positions.back() = n - 1;\n        }\n        string s(n, 'a');\n        // Fill s with random letters\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n        // Place t's characters in s\n        for (int i = 0; i < m; ++i) {\n            s[positions[i]] = t[i];\n        }\n        cout << s << endl << t << endl;\n    } else if (type == \"no\") {\n        // Generate s and t such that the answer is \"No\"\n        string t = generate_random_string(m);\n        string s;\n        char c = get_char_not_in_string(t);\n        // Insert character c into s at a random position\n        int pos_c = rnd.next(n);\n        int extra_length = n - m - 1; // Account for the extra character c\n        for (int i = 0; i < m; ++i) {\n            s += t[i];\n            int num_extra = (i < m - 1) ? rnd.next(0, extra_length) : extra_length;\n            extra_length -= num_extra;\n            for (int j = 0; j < num_extra; ++j) {\n                s += 'a' + rnd.next(26);\n            }\n            if (s.size() >= pos_c && pos_c != -1) {\n                s.insert(s.begin() + pos_c, c);\n                pos_c = -1;\n            }\n        }\n        if (pos_c != -1) {\n            s.insert(s.begin() + pos_c, c);\n        }\n        while (s.size() < n) {\n            s += 'a' + rnd.next(26);\n        }\n        if (s.size() > n) {\n            s = s.substr(0, n);\n        }\n        cout << s << endl << t << endl;\n    } else if (type == \"max\") {\n        // Generate maximum length strings s and t\n        n = 200000;\n        m = 200000;\n        string s = generate_random_string(n);\n        string t = s; // t equals s\n        cout << s << endl << t << endl;\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -type random\n./gen -n 100 -m 50 -type random\n./gen -n 1000 -m 500 -type random\n./gen -n 10000 -m 5000 -type random\n./gen -n 100000 -m 50000 -type random\n./gen -n 200000 -m 100000 -type random\n\n./gen -n 10 -m 5 -type t_subsequence\n./gen -n 100 -m 50 -type t_subsequence\n./gen -n 1000 -m 500 -type t_subsequence\n./gen -n 10000 -m 5000 -type t_subsequence\n./gen -n 100000 -m 50000 -type t_subsequence\n./gen -n 200000 -m 100000 -type t_subsequence\n\n./gen -n 10 -m 5 -type t_not_subsequence\n./gen -n 100 -m 50 -type t_not_subsequence\n./gen -n 1000 -m 500 -type t_not_subsequence\n./gen -n 10000 -m 5000 -type t_not_subsequence\n./gen -n 100000 -m 50000 -type t_not_subsequence\n./gen -n 200000 -m 100000 -type t_not_subsequence\n\n./gen -n 100000 -m 50000 -type yes\n./gen -n 200000 -m 100000 -type yes\n./gen -n 100000 -m 50000 -type no\n./gen -n 200000 -m 100000 -type no\n\n./gen -type max\n\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 2 -type t_not_subsequence\n./gen -n 2 -m 1 -type t_subsequence\n./gen -n 2 -m 3 -type t_not_subsequence\n\n./gen -n 1 -m 1 -type yes\n./gen -n 1 -m 1 -type no\n\n./gen -n 50000 -m 1000 -type random\n./gen -n 1000 -m 50000 -type t_not_subsequence\n./gen -n 10000 -m 10000 -type random\n./gen -n 50000 -m 50000 -type t_subsequence\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:38.027068",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "224/E",
      "title": "E. Partial Sums",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and k (1 ≤ n ≤ 2000, 0 ≤ k ≤ 109). The next line contains n space-separated integers a1, a2, ..., an — elements of the array a (0 ≤ ai ≤ 109).",
      "output_spec": "OutputPrint n integers  — elements of the array a after the operations are applied to it. Print the elements in the order of increasing of their indexes in the array a. Separate the printed numbers by spaces.",
      "sample_tests": "ExamplesInputCopy3 11 2 3OutputCopy1 3 6InputCopy5 03 14 15 92 6OutputCopy3 14 15 92 6",
      "description": "E. Partial Sums\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and k (1 ≤ n ≤ 2000, 0 ≤ k ≤ 109). The next line contains n space-separated integers a1, a2, ..., an — elements of the array a (0 ≤ ai ≤ 109).\n\nOutputPrint n integers  — elements of the array a after the operations are applied to it. Print the elements in the order of increasing of their indexes in the array a. Separate the printed numbers by spaces.\n\nInputCopy3 11 2 3OutputCopy1 3 6InputCopy5 03 14 15 92 6OutputCopy3 14 15 92 6\n\nInputCopy3 11 2 3\n\nOutputCopy1 3 6\n\nInputCopy5 03 14 15 92 6\n\nOutputCopy3 14 15 92 6",
      "solutions": [
        {
          "title": "Codeforces Round #138 - Codeforces",
          "content": "Hello everybody!I am glad to announce that Codeforces Round #138 will be held today at 19:30 MSK. I (Vasiliy Vadimov) am the author of this round. It is my first Codeforces round, I just helped other authors to prepare their rounds before.I would like to thank Gerald Gerald Agapov for his help in the preparing of the round and Maria Delinur Belova for translation of the problems' statements in English. Also I am grateful to Mike MikeMirzayanov Mirzayanov for such an excellent contest system as Codeforces.Good luck! I hope you will be interested in the problems.The point distribution is standard in both divisions (500-1000-1500-2000-2500).UPD. Attention! D language will not be available on this contest.UPD2. The round is over, top-5 in both divisions:Div1: Petr tourist peter50216 Shik Egor Div2: ecnerwala ordcoder scipianus jonathanpaulson void_rank Congratulations to the winners! Also I am apologising for mistakes in statement of problem div1 A/div2 C. The tutorial will be published tomorrow.UPD3. The tutorial is available here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5287",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1044
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces",
          "content": "Div2 A. ParallelepipedYou were given areas of three faces of a rectangular parallelepiped. Your task was to find the sum of lengths of it's sides.Let a, b and c be the lengths of the sides that have one common vertex. Then the numbers we are given are s1 = ab, s2 = bc и s3 = ca. It is easy to find the lengths in terms of faces areas: , , . The answer is 4(a + b + c), because there are four sides that have lengths equal to a, b and c. The complexity is O(1).Div2 B. ArrayYou were given an array a consisting of n integers. Its elements ai were positive and not greater than 105 for each 1 ≤ i ≤ n. Also you were given positive integer k. You had to find minimal by inclusion segment [l, r] such that there were exactly k different numbers among al, ..., ar. The definition of the \"minimal by inclusion\" you can read in the statement.Let us make a new array cnt. In the beginning its element cnti is equal to number of occurencies of number i in array a. It is possible to make this array because elements of a are not very large. Amount of nonzero elements in cnt is equal to amount of different elements in a. There is no solution if this number is less then k.If it is not true, we have to find the answer segment [l, r]. In the beginning let [l, r] = [1, n]. We decrease its right end r by 1 until amount of different elements on the segment [l, r] is less than k. We can keep the amount of different numbers in following way: we decrease cntar by 1 if we delete element number r. Then we have to decrease current number of different elements by 1 if cntar becomes zero. After this we return the last deleted element back to the segment in order to make amount of different elements equal to k. Then we have to do the same with the left end l, but we have not to decrease but to increase its value by 1 on each step. Finally, we get a segment [l, r]. The amount of different numbers on it is equal to k and on every its subsegment is less than k. Therefore, this segment is an answer. The complexity is O(n).Div2 C/Div1 A. Bracket sequenceYou were given a bracket sequence s consisting of brackets of two kinds. You were to find regular bracket sequence that was a substring of s and contains as many <<>> braces as possible.We will try to determine corresponding closing bracket for every opening one. Formally, let a bracket on the i-th position be opening, then the closing bracket on the position j is corresponding to it if and only if a substring si... sj is the shortest regular bracket sequence that begins from the i-th position. In common case there can be brackets with no corresponding ones.We scan the sting s and put positions with the opening brackets into a stack. Let us proceed the i-th position. If si is an opening bracket we simply put i on the top of the stack. Otherwise, we have to clean the stack if the stack is empty or the bracket on the top does not correspond to the current one. But if the bracket on the top is ok we just remove the top of the stack and remember that the bracket on position i is corresponding to the bracket removed from the top. So, we find all the correspondings for all the brackets.Then we can split s into blocks. Let block be a segment [l, r] such that the bracket on the r-th position is corresponding for the bracket on the i-th and there is no couple of corresponding brackets on positions x and y such that and [l, r] ≠ [x, y]. It is easy to understand that the blocks do not intersect and the split is unique. We can join the consequent blocks into the regular bracket sequences. We should join as many blocks as possible in order to get the maximal number of braces. We get several substrings that are regular bracket sequences after we join all the consecutive blocks. The answer is the substring that has the largest amount of braces <<>>. The complexity is O(|s|).Div2 D/Div1 B. Two strings.You were given two strings: s and t. You were required to examine all occurrences of the string t in the string s as subsequence and to find out if it is true that for each position of the s string there are such occurrence, that includes this position. For each position i of the s string we calculate two values li and ri where li is the maximal possible number that the string t1... tli occurs as subsequence in the string s1... si, ri is the maximal possible number that the string t|t| - ri + 1... t|t| occurs in the string si... s|s| as subsequence. Let us find all of l for the position 1... i - 1 and want to find li. If the symbol tli - 1 + 1 exists and concurs with the symbol si then li = li - 1 + 1, in other case li = li - 1. In the same way we can find ri if we move from the end of the string.Now we should check if the position i in the string s belongs to at least one occurrence. Let us assume this to be correct and the symbol si corresponds to the symbol tj of the string t. Then li - 1 ≥ j - 1 and ri + 1 ≥ |t| - j by definition of the l and r. Then if j exists that si = tj and li - 1 + 1 ≥ j ≥ |t| - ri + 1, then the position i of the string s belongs to at least one occurrence of the t, in other case the occurrence doesn’t exist. We can easily check it by creating an array cnta, i for each letter, which is a number of letters a in the positions 1... i of the string t. The complexity of the solution is O(|s| + |t|). Div2 E/Div1 C. Частичные суммыYou were given an array a in this problem. You could replace a by the array of its partial sums by one step. You had to find the array after k such steps. All the calculations were modulo P = 109 + 7.Write partial sums in following way: where Bi, j = 1 if i ≥ j and Bi, j = 0 if i < j, for each 1 ≤ i, j ≤ n. We can represent a and s as vector-columns, therefore one step corresponds to multiplying matrix B and vector-column a. Then the array a after k steps is equal to Bka. We can raise a matrix to a power for . It is not bad, but not fast enough.We can notice, that = , i.e. the elements of the matrix Bk on diagonals parallel to the main are the equal. It is easy to prove this fact using mathematical induction. You may prove it by yourself. Then we can determine the matrix by an array of numbers , equal to the elements of the first column. The elements of the first column of the product BkBl are equal . It is a straight consequence of formula of matrix product. The computing of one element requires O(n) time, there are n elements therefore we can multiply matriсеs in O(n2) time. Then we can solve the problem in time and this solution fits the consrtaints.This problem can be solved faster. We can assure that . Let this formula be correct for some k. Prove that it is correct for k + 1 either. Using the formula of product we get: Используя формулу Cnk = n! / k!(n - k)!, можно получить, что , поэтому мы можем построить все коэффициенты b, если умеем делить по модулю P, поэтому в этом решении существенна простота P. Обратный для числа x по простому модулю равен в силу малой теоремы Ферма. Таким образом, мы получаем решение за O(n2).Using the formula Cnk = n! / k!(n - k)! we can obtain , so we can find all the coefficients b if we can divide modulo P. Therefore it is significant that P is prime. Inverse x modulo P is equal to according to the Fermat little theorem. Therefore we get O(n2)solution.Div1 D. SpiderYou were given a polygon consisting of n vertices, you had to find the shortest way from one of its vertices to another. You were allowed to move along the border and go stricktly down without going outside the polygonAll the sides of the polygon can be divided into three groups: top, bottom and vertical. The side is vertical if and only if the x coordinates of its ends are equal. The side is bottom if and only if the polygon's interior is above the side. The side it top if and only if the polygon's interior is below the side. We can descend only from points of the top sides to the points of the bottom sides. Vertical sides can be ignored because every descend that has common points with a vertical side can be splitted into two descends and one transfer. One can prove that it is useless to descend from a side's interior to side's interior. Len one of the descends in the optimal solution start in the inner point and end in the inner point. We can slightly change the x coordinate of the descend. The path's lenght is monotonically (possibly not strictly) depends on x, so we can move x in order to improve the answer. In case of not strictly monotone dependance the answer do not depend on x, so we also can move it. This proof is wrong if the descend passes through a vertex, therefore we have to examine all possible descends from the vertices and to the vertices.We can solve this problem using scan-line method. We well move a vertical straight line from the left to the right and keep set S of the sides that intersect the line. We store the segments in the S in the sorted by y order. Let X be an abscissa of the line. The events happen during the moving: some segments are added to the S set, some are deleted. We can make an array of events, each events is described by its x coordinate that is equal to X of the line when the corresponding event happens, the number of the segment and a kind of event: adding or deleting. There are two events for every side, their x coordinates correspond to abscissas of their ends. The vertical sides can be ignored.Let us proceed the events in non-decreasing order of x coords. If the current event is adding we add the side to S set. Then we check on its closest neighbours in the set. If the current segment is a top segment we can make a descend from its left vertex down to the intersection with it's lower neighbor. We find the point of the intersection, remember the segment where the point is located and remember that there can be a descend from a vertex to the new point. If the current side is the bottom side we make a descand from the upper neighbour to the left end of the current segment and do the same things. If the current event is deleting we analize its neighbours in the same way, but the descends start or end on the right end of the segment we are going to delete. It is important that if there are many events of one kind we should proceed them simultaneously, i.e. if there are many addings in the same x coordinate we must add all the segments and then examine their neighbours. It is the same for deletings: firstly we analize the neighbours for all the segments and only then we delete them. Also in the case of equal x coords of the events the adding events must be first, otherwise the solution is wrong for the case of two angles separated by a vertical line with vertices lying on this line.Set S is easy to keep in container such as \"set\". We have to write a comparator for segments. We can do it in following way: two segments can be in S simultaneously if and only if there is a vertical line that intersects both of them. In common case such a line is not the unique, all the possible values of X are in segment [l, r] that can be easily found if we know the coors of the ends of the segments. Then we can choose an arbitrary X inside of [l, r] and compare the ordinates of the intersection points. Is better to choose inner point because in this case we don't have to examine special cases of segments having a common point.After this we can build a graph. It's vertices are the vertices of the polygon and the ends of possible descends. The edges of the graphs are the sides of the polygon and the descends. The shortest path can be found using Dijkstra algorithm. The complexity of the solution is .Div1 E. Planar graphIn the problem we were given an undirected planar graph without bridges, cutpoints, loops and multiedge laid on the plane. We get requests of the following type: to calculate the number of vertices inside the cycle or on it.Let us take an arbitrary vertex on the border of the graph, for example a vertex that has the least absciss. Let's add a new vertex with an edge to the chosen vertex in such way that the edge is outside the outer border of the graph. We'll call this new vertex a sink. Let's create a 1 value flow running to the sink from each vertex except the sink. Flow can be created using breadth-first or depth-first search. This operation will take the O(E) time.Let's examine any request. We assume that the cycle is oriented counter-clockwise (if it is not so, we can just reorient it). Let's make a cut on the graph. The first part will contain the vertices laying on the cycle or inside it, the second one — all remaining vertices including the sink. We'll now prove that the flow value through the cut is equal to the vertices number in the first part. It's obvious that we can calculate contribution from every vertex to the flow value independently. Let's assume that the vertex is situated in the first part. A unit flow runs from it to the sink along some path. As soon as this vertex and the sink are situated in different parts the flow passes the edges of the cut an odd number of times, that's why the contribution of this vertex to the flow through the cut is equal to 1. Let's take now a vertex situated in the second part. As soon as it's situated in the same part as the sink the flow passes the edges of the cut an even number of times, that's why the contribution of this vertex to the flow through the cut is zero. In order to calculate the flow value through the cut we need to sum up flow values passing through the cut's edges. It's important to notice that every edge of the cut is incident to only one vertex lying on the cycle, that's why we can sum up flows passing though edges going outside the cycle for each vertex in the cycle. In order to find all edges going outside the cycle we'll sort all edges going from each vertex counter-clockwise by angle. In this case all edges going outside the cycle will be placed after the previous vertex of the cycle and before the following vertex of the cycle. That's why the sum of flow values over the edges going outside reduces to a sum over an segment which is easily calculated using partial sums. The complexity of the solution is for graph sorting plus for the request where l is the cycle length. There is in complexity because we have to know a position of a vertex in the adjacency list of another vertex.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5301",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 14288
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #138 - Codeforces - Code 1",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 2",
          "code": "Комментарий скрыт по причине большого числа негативных отзывов о нем, нажмите здесь для его просмотра",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 3",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 4",
          "code": "> If there are more than one optimal solutions print any of them.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 5",
          "code": "5 3\n1 2 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 6",
          "code": "4\n[[]]()[][][()]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 7",
          "code": "100000\n[][][][]...[][][][]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138 - Codeforces - Code 8",
          "code": "4 3\n1 2 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5287",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #138, tutorial. - Codeforces - Code 1",
          "code": "4 * (a + b + c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5301",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, int(1e9), \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, int(1e9), \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, int(1e9), \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, int(1e9), \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, int(1e9), \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, int(1e9), \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"increasing\") {\n        a[0] = rnd.next(0, 1000000000 / n);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i -1] + rnd.next(1, 1000000);\n            if (a[i] > 1000000000) a[i] = 1000000000;\n        }\n    } else if (type == \"decreasing\") {\n        a[0] = 1000000000;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i -1] - rnd.next(1, 1000000);\n            if (a[i] < 0) a[i] = 0;\n        }\n    } else if (type == \"alternating\") {\n        int val1 = rnd.next(0, 1000000000);\n        int val2 = rnd.next(0, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) a[i] = val1;\n            else a[i] = val2;\n        }\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1000000000 - 10, 1000000000);\n        }\n    } else if (type == \"same\") {\n        int val = rnd.next(0, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %lld\\n\", n, k);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"increasing\") {\n        a[0] = rnd.next(0, 1000000000 / n);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i -1] + rnd.next(1, 1000000);\n            if (a[i] > 1000000000) a[i] = 1000000000;\n        }\n    } else if (type == \"decreasing\") {\n        a[0] = 1000000000;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i -1] - rnd.next(1, 1000000);\n            if (a[i] < 0) a[i] = 0;\n        }\n    } else if (type == \"alternating\") {\n        int val1 = rnd.next(0, 1000000000);\n        int val2 = rnd.next(0, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) a[i] = val1;\n            else a[i] = val2;\n        }\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1000000000 - 10, 1000000000);\n        }\n    } else if (type == \"same\") {\n        int val = rnd.next(0, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %lld\\n\", n, k);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type zeros\n./gen -n 1 -k 0 -type ones\n./gen -n 1 -k 1 -type zeros\n./gen -n 1 -k 1 -type ones\n\n./gen -n 2 -k 0 -type increasing\n./gen -n 2 -k 1 -type decreasing\n./gen -n 2 -k 1000000000 -type alternating\n\n./gen -n 100 -k 1000000000 -type random\n./gen -n 2000 -k 1000000000 -type random\n./gen -n 2000 -k 0 -type random\n./gen -n 2000 -k 1 -type max\n./gen -n 2000 -k 1000000000 -type max\n\n./gen -n 2000 -k 1000000000 -type zeros\n./gen -n 2000 -k 1000000000 -type ones\n./gen -n 2000 -k 1000000000 -type large_numbers\n./gen -n 2000 -k 1000000000 -type small_numbers\n./gen -n 2000 -k 1000000000 -type same\n\n./gen -n 1999 -k 999999999 -type decreasing\n./gen -n 1998 -k 123456789 -type increasing\n\n./gen -n 500 -k 999999999 -type alternating\n./gen -n 500 -k 500000000 -type same\n\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 1 -type random\n./gen -n 1000 -k 1000000000 -type random\n\n./gen -n 2000 -k 999999999 -type alternating\n./gen -n 2000 -k 500000000 -type same\n\n./gen -n 1 -k 1000000000 -type ones\n./gen -n 2 -k 500000000 -type ones\n\n./gen -n 2000 -k 0 -type large_numbers\n./gen -n 2000 -k 1 -type small_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:39.657955",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "225/A",
      "title": "A. Dice Tower",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of dice in the tower.The second line contains an integer x (1 ≤ x ≤ 6) — the number Bob sees at the top of the tower. Next n lines contain two space-separated integers each: the i-th line contains numbers ai, bi (1 ≤ ai, bi ≤ 6; ai ≠ bi) — the numbers Bob sees on the two sidelong faces of the i-th dice in the tower.Consider the dice in the tower indexed from top to bottom from 1 to n. That is, the topmost dice has index 1 (the dice whose top face Bob can see). It is guaranteed that it is possible to make a dice tower that will look as described in the input.",
      "output_spec": "OutputPrint \"YES\" (without the quotes), if it is possible to to uniquely identify the numbers on the faces of all the dice in the tower. If it is impossible, print \"NO\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy363 25 42 4OutputCopyYESInputCopy332 64 15 3OutputCopyNO",
      "description": "A. Dice Tower\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of dice in the tower.The second line contains an integer x (1 ≤ x ≤ 6) — the number Bob sees at the top of the tower. Next n lines contain two space-separated integers each: the i-th line contains numbers ai, bi (1 ≤ ai, bi ≤ 6; ai ≠ bi) — the numbers Bob sees on the two sidelong faces of the i-th dice in the tower.Consider the dice in the tower indexed from top to bottom from 1 to n. That is, the topmost dice has index 1 (the dice whose top face Bob can see). It is guaranteed that it is possible to make a dice tower that will look as described in the input.\n\nOutputPrint \"YES\" (without the quotes), if it is possible to to uniquely identify the numbers on the faces of all the dice in the tower. If it is impossible, print \"NO\" (without the quotes).\n\nInputCopy363 25 42 4OutputCopyYESInputCopy332 64 15 3OutputCopyNO\n\nInputCopy363 25 42 4\n\nOutputCopyYES\n\nInputCopy332 64 15 3\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #139 (div2) - Codeforces",
          "content": "Hello everyone!That is Codeforces Round 139 for the second division only. Members of the first division can participate out of competition.Round is prepared by Ripatti , Gerald , Delinur.We will use dynamic score system. Problems will be ordered in order of expected increasing difficulty.Good luck!UPD. For technical reasons round delays in 15 minutes.UPD2. Testing is complete. Winners:1. wccy2. ttl3. shubhanshu4. Atarashi_Ako5. dvylfz921 2 members solved all 5 problems.English editorial will be tomorrow. You can try to understand russian editorial.UPD3. English editorial.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 578
        },
        {
          "title": "Editorial for Codeforces Round #139 - Codeforces",
          "content": "A. You should iterate over all dices from up to down and restore answer. You can easily find number of the bottom side of the 1st dice. Using known sides of the 2nd dice you can find pair of numbets on top and bottom side of the 2nd dice. If one of them equal to number on bottom of the 1st dice, you can restore all numbers on the 2n dice. Then using this idea you can try restore numbers on the 3rd dice and so on. If you restored all numbers, you should write YES. If for some dice you cannot uniquely determine order of numbers on the top and botton sides, there will be at least 2 placing of numbers. In this case you shoyld write NO.Author is Ripatti .B. Firstly you should generate all k-bonacci numbers less than n. For k ≤ 32 you can do it straightforward, for bigger k you can see that all k-bonacci numbers less 109 are powers of two only (and 0). So you will have no more then 100 numbers.Then you should use greedy algo. You should substract from n maximal possible k-bonacci numbers. You should repeat this operation while n is not decomposed. And in the end you will have answer.Why all numbers will be different? One of possible proves:F(k, n) = F(k, n - 1) + F(k, n - 2) + ... + F(k, n - k)F(k, n - 1) = F(k, n - 2) + F(k, n - 3) + ... + F(k, n - k - 1)You can substract the 2nd equation from the 1st one and you will recieve F(k, n) + F(k, n - k - 1) = 2F(k, n - 1), that equal to 2F(k, n - 1) ≥ F(k, n). This unequation also holds for n ≤ k.Suppose than greedy also constricted 2 equal numbers F(k, x) in decomposition. But then in virtue of unequation we should take number F(k, x + 1) insead these 2 numbers. Сontradiction.But you didn't need prove than greedy algo works, you might believe that it works:)Authors are Gerald , Ripatti .C. Firstly you should calculate number of white and black pixels in every column. After that you should calculate number of white and black pixels for every prefix in sequence of columns. Now you can calculate number of black or white pixels in every vertical line of any width in O(1).Now you should use dynamic programming. Let's dp[i][j] will store numbers of repainted pixels in prefix from the 1st column to the j-th and color of the last column will be white for i = 0 and black for i = 1.Than you can recalculate dp using forlulas: dp[0][0] = dp[1][0] = 0 Answer will be min(dp[0][m], dp[1][m]).This solution works in O(nm + m * (y - x)).Author is Ripatti .D. There is just BFS. State is head place and mask that store place of tail: using 2 bits you can code position of every segment in relation to previous segment. Mask will contain no more than 16 bits, and number of all states will be no more than 48 × 15 × 15 (also you can try understand that number of states no more than 38 × 15 × 15).Then you should just carefully implement it.Author is Ripatti .E. You have z = [x / 2] + y + xy. That is equivalent toz = [2k / 2] + y + 2ky, where x = 2k, k > 0orz = [(2k + 1) / 2] + y + (2k + 1)y, where x = 2k + 1, k ≥ 0.z = k + y + 2ky, k > 0orz = k + y + (2k + 1)y, k ≥ 0.Still more steps:2z + 1 = 2k + 2y + 4ky + 1, k > 0orz + 1 = k + 2y + 2ky + 1, k ≥ 0.2z + 1 = (2k + 1)(2y + 1), k > 0orz + 1 = (2y + 1)(k + 1), k ≥ 0.From the 2nd equation you can see than z should be 2t - 1 because otherwise z + 1 will have odd divisor and we can build solution. From the 1st equation you can see that 2t + 1 - 1 should be prime, otherwise we also can build solution. If z = 2t - 1 and 2t + 1 - 1 is prime, obliviously there are no solutions.Prime numbers like 2a - 1 are Mersenne primes. Only about 46 such numbers are found now. Powers of 2 for the firts 40 numbers you can find for example here.Author is Ripatti .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5322",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3670
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 1",
          "code": "1, 2, 4, 6, 12, 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 2",
          "code": "typedef long long i64;\ni64 K;\ni64 S;\n\ni64 F(i64 n) {\n  if (n >=1 && n < K)\n    return 0;\n  if (n==K)\n    return 1;\n  i64 ans = 0;\n  while(n > K) {\n    ans += F(n-1);\n    --n;\n  }\n  return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"139_B.in\",\"r\", stdin);\n#endif\n\n  cin>>S>>K;\n  for(int i = 1; i <= 15; ++i) {\n    cout<<F(i)<<endl;\n  }\n\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 3",
          "code": "typedef long long i64;\ni64 K;\ni64 S;\n\ni64 F(i64 n) {\n  if (n >=1 && n < K)\n    return 0;\n  if (n==K)\n    return 1;\n  i64 ans = 0;\n  while(n > K) {\n    ans += F(n-1);\n    --n;\n  }\n  return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"139_B.in\",\"r\", stdin);\n#endif\n\n  cin>>S>>K;\n  for(int i = 1; i <= 15; ++i) {\n    cout<<F(i)<<endl;\n  }\n\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 4",
          "code": "while(n > K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 5",
          "code": "FOR(x,n-K-1,n-1) {\n    if (x < 0)\n      break;\n    ans += F(x);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 6",
          "code": "FOR(x,n-K-1,n-1) {\n    if (x < 0)\n      break;\n    ans += F(x);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    int x = inf.readInt(1, 6, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 6, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 6, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai[%d] == bi[%d] (%d == %d)\", i+1, i+1, ai, bi);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    int x = inf.readInt(1, 6, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 6, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 6, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai[%d] == bi[%d] (%d == %d)\", i+1, i+1, ai, bi);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    int x = inf.readInt(1, 6, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(1, 6, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 6, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai[%d] == bi[%d] (%d == %d)\", i+1, i+1, ai, bi);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint oppositeFace(int num) {\n    return 7 - num;\n}\n\nstruct Die {\n    int up, down, left, right, front, back;\n\n    Die() {\n        up = 1;\n        down = 6;\n        left = 2;\n        right = 5;\n        front = 3;\n        back = 4;\n    }\n\n    void rotate(char axis) {\n        int temp;\n        if (axis == 'x') {\n            temp = up;\n            up = back;\n            back = down;\n            down = front;\n            front = temp;\n        } else if (axis == 'y') {\n            temp = up;\n            up = left;\n            left = down;\n            down = right;\n            right = temp;\n        } else if (axis == 'z') {\n            temp = front;\n            front = left;\n            left = back;\n            back = right;\n            right = temp;\n        }\n    }\n\n    void randomizeOrientation() {\n        int numRotations = rnd.next(0, 3);\n        for (int i = 0; i < numRotations; ++i) {\n            rotate('x');\n        }\n        numRotations = rnd.next(0, 3);\n        for (int i = 0; i < numRotations; ++i) {\n            rotate('y');\n        }\n        numRotations = rnd.next(0, 3);\n        for (int i = 0; i < numRotations; ++i) {\n            rotate('z');\n        }\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Die> tower(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            tower[i] = Die();\n            tower[i].randomizeOrientation();\n        }\n    } else if (type == \"yes\") {\n        tower[0] = Die();\n        tower[0].randomizeOrientation();\n        for (int i = 1; i < n; ++i) {\n            int previousDown = tower[i-1].down;\n            tower[i] = Die();\n            vector<Die> possibleOrientations;\n\n            for (int x = 0; x < 4; ++x) {\n                for (int y = 0; y < 4; ++y) {\n                    for (int z = 0; z < 4; ++z) {\n                        Die d = Die();\n                        for (int j = 0; j < x; ++j) d.rotate('x');\n                        for (int j = 0; j < y; ++j) d.rotate('y');\n                        for (int j = 0; j < z; ++j) d.rotate('z');\n                        if (d.up != previousDown) {\n                            possibleOrientations.push_back(d);\n                        }\n                    }\n                }\n            }\n            tower[i] = rnd.any(possibleOrientations);\n        }\n    } else if (type == \"no\") {\n        tower[0] = Die();\n        tower[0].randomizeOrientation();\n        for (int i = 1; i < n; ++i) {\n            tower[i] = Die();\n            tower[i].randomizeOrientation();\n            tower[i].up = tower[i-1].down; // Make adjacent faces the same to create ambiguity\n        }\n    }\n\n    cout << n << endl;\n    int x = tower[0].up;\n    cout << x << endl;\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> sides = {tower[i].left, tower[i].right, tower[i].front, tower[i].back};\n        shuffle(sides.begin(), sides.end());\n        int ai = sides[0];\n        int bi = sides[1];\n        cout << ai << \" \" << bi << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint oppositeFace(int num) {\n    return 7 - num;\n}\n\nstruct Die {\n    int up, down, left, right, front, back;\n\n    Die() {\n        up = 1;\n        down = 6;\n        left = 2;\n        right = 5;\n        front = 3;\n        back = 4;\n    }\n\n    void rotate(char axis) {\n        int temp;\n        if (axis == 'x') {\n            temp = up;\n            up = back;\n            back = down;\n            down = front;\n            front = temp;\n        } else if (axis == 'y') {\n            temp = up;\n            up = left;\n            left = down;\n            down = right;\n            right = temp;\n        } else if (axis == 'z') {\n            temp = front;\n            front = left;\n            left = back;\n            back = right;\n            right = temp;\n        }\n    }\n\n    void randomizeOrientation() {\n        int numRotations = rnd.next(0, 3);\n        for (int i = 0; i < numRotations; ++i) {\n            rotate('x');\n        }\n        numRotations = rnd.next(0, 3);\n        for (int i = 0; i < numRotations; ++i) {\n            rotate('y');\n        }\n        numRotations = rnd.next(0, 3);\n        for (int i = 0; i < numRotations; ++i) {\n            rotate('z');\n        }\n    }\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Die> tower(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            tower[i] = Die();\n            tower[i].randomizeOrientation();\n        }\n    } else if (type == \"yes\") {\n        tower[0] = Die();\n        tower[0].randomizeOrientation();\n        for (int i = 1; i < n; ++i) {\n            int previousDown = tower[i-1].down;\n            tower[i] = Die();\n            vector<Die> possibleOrientations;\n\n            for (int x = 0; x < 4; ++x) {\n                for (int y = 0; y < 4; ++y) {\n                    for (int z = 0; z < 4; ++z) {\n                        Die d = Die();\n                        for (int j = 0; j < x; ++j) d.rotate('x');\n                        for (int j = 0; j < y; ++j) d.rotate('y');\n                        for (int j = 0; j < z; ++j) d.rotate('z');\n                        if (d.up != previousDown) {\n                            possibleOrientations.push_back(d);\n                        }\n                    }\n                }\n            }\n            tower[i] = rnd.any(possibleOrientations);\n        }\n    } else if (type == \"no\") {\n        tower[0] = Die();\n        tower[0].randomizeOrientation();\n        for (int i = 1; i < n; ++i) {\n            tower[i] = Die();\n            tower[i].randomizeOrientation();\n            tower[i].up = tower[i-1].down; // Make adjacent faces the same to create ambiguity\n        }\n    }\n\n    cout << n << endl;\n    int x = tower[0].up;\n    cout << x << endl;\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> sides = {tower[i].left, tower[i].right, tower[i].front, tower[i].back};\n        shuffle(sides.begin(), sides.end());\n        int ai = sides[0];\n        int bi = sides[1];\n        cout << ai << \" \" << bi << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type yes\n./gen -n 2 -type yes\n./gen -n 3 -type yes\n./gen -n 4 -type yes\n./gen -n 5 -type yes\n./gen -n 10 -type yes\n./gen -n 20 -type yes\n./gen -n 50 -type yes\n./gen -n 70 -type yes\n./gen -n 100 -type yes\n\n./gen -n 1 -type no\n./gen -n 2 -type no\n./gen -n 3 -type no\n./gen -n 4 -type no\n./gen -n 5 -type no\n./gen -n 10 -type no\n./gen -n 20 -type no\n./gen -n 50 -type no\n./gen -n 70 -type no\n./gen -n 100 -type no\n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 20 -type random\n./gen -n 50 -type random\n./gen -n 70 -type random\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:42.059104",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "225/B",
      "title": "B. Well-known Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers s and k (1 ≤ s, k ≤ 109; k > 1).",
      "output_spec": "OutputIn the first line print an integer m (m ≥ 2) that shows how many numbers are in the found representation. In the second line print m distinct integers a1, a2, ..., am. Each printed integer should be a k-bonacci number. The sum of printed integers must equal s.It is guaranteed that the answer exists. If there are several possible answers, print any of them.",
      "sample_tests": "ExamplesInputCopy5 2OutputCopy30 2 3InputCopy21 5OutputCopy34 1 16",
      "description": "B. Well-known Numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers s and k (1 ≤ s, k ≤ 109; k > 1).\n\nOutputIn the first line print an integer m (m ≥ 2) that shows how many numbers are in the found representation. In the second line print m distinct integers a1, a2, ..., am. Each printed integer should be a k-bonacci number. The sum of printed integers must equal s.It is guaranteed that the answer exists. If there are several possible answers, print any of them.\n\nInputCopy5 2OutputCopy30 2 3InputCopy21 5OutputCopy34 1 16\n\nInputCopy5 2\n\nOutputCopy30 2 3\n\nInputCopy21 5\n\nOutputCopy34 1 16",
      "solutions": [
        {
          "title": "Codeforces Round #139 (div2) - Codeforces",
          "content": "Hello everyone!That is Codeforces Round 139 for the second division only. Members of the first division can participate out of competition.Round is prepared by Ripatti , Gerald , Delinur.We will use dynamic score system. Problems will be ordered in order of expected increasing difficulty.Good luck!UPD. For technical reasons round delays in 15 minutes.UPD2. Testing is complete. Winners:1. wccy2. ttl3. shubhanshu4. Atarashi_Ako5. dvylfz921 2 members solved all 5 problems.English editorial will be tomorrow. You can try to understand russian editorial.UPD3. English editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 578
        },
        {
          "title": "Editorial for Codeforces Round #139 - Codeforces",
          "content": "A. You should iterate over all dices from up to down and restore answer. You can easily find number of the bottom side of the 1st dice. Using known sides of the 2nd dice you can find pair of numbets on top and bottom side of the 2nd dice. If one of them equal to number on bottom of the 1st dice, you can restore all numbers on the 2n dice. Then using this idea you can try restore numbers on the 3rd dice and so on. If you restored all numbers, you should write YES. If for some dice you cannot uniquely determine order of numbers on the top and botton sides, there will be at least 2 placing of numbers. In this case you shoyld write NO.Author is Ripatti .B. Firstly you should generate all k-bonacci numbers less than n. For k ≤ 32 you can do it straightforward, for bigger k you can see that all k-bonacci numbers less 109 are powers of two only (and 0). So you will have no more then 100 numbers.Then you should use greedy algo. You should substract from n maximal possible k-bonacci numbers. You should repeat this operation while n is not decomposed. And in the end you will have answer.Why all numbers will be different? One of possible proves:F(k, n) = F(k, n - 1) + F(k, n - 2) + ... + F(k, n - k)F(k, n - 1) = F(k, n - 2) + F(k, n - 3) + ... + F(k, n - k - 1)You can substract the 2nd equation from the 1st one and you will recieve F(k, n) + F(k, n - k - 1) = 2F(k, n - 1), that equal to 2F(k, n - 1) ≥ F(k, n). This unequation also holds for n ≤ k.Suppose than greedy also constricted 2 equal numbers F(k, x) in decomposition. But then in virtue of unequation we should take number F(k, x + 1) insead these 2 numbers. Сontradiction.But you didn't need prove than greedy algo works, you might believe that it works:)Authors are Gerald , Ripatti .C. Firstly you should calculate number of white and black pixels in every column. After that you should calculate number of white and black pixels for every prefix in sequence of columns. Now you can calculate number of black or white pixels in every vertical line of any width in O(1).Now you should use dynamic programming. Let's dp[i][j] will store numbers of repainted pixels in prefix from the 1st column to the j-th and color of the last column will be white for i = 0 and black for i = 1.Than you can recalculate dp using forlulas: dp[0][0] = dp[1][0] = 0 Answer will be min(dp[0][m], dp[1][m]).This solution works in O(nm + m * (y - x)).Author is Ripatti .D. There is just BFS. State is head place and mask that store place of tail: using 2 bits you can code position of every segment in relation to previous segment. Mask will contain no more than 16 bits, and number of all states will be no more than 48 × 15 × 15 (also you can try understand that number of states no more than 38 × 15 × 15).Then you should just carefully implement it.Author is Ripatti .E. You have z = [x / 2] + y + xy. That is equivalent toz = [2k / 2] + y + 2ky, where x = 2k, k > 0orz = [(2k + 1) / 2] + y + (2k + 1)y, where x = 2k + 1, k ≥ 0.z = k + y + 2ky, k > 0orz = k + y + (2k + 1)y, k ≥ 0.Still more steps:2z + 1 = 2k + 2y + 4ky + 1, k > 0orz + 1 = k + 2y + 2ky + 1, k ≥ 0.2z + 1 = (2k + 1)(2y + 1), k > 0orz + 1 = (2y + 1)(k + 1), k ≥ 0.From the 2nd equation you can see than z should be 2t - 1 because otherwise z + 1 will have odd divisor and we can build solution. From the 1st equation you can see that 2t + 1 - 1 should be prime, otherwise we also can build solution. If z = 2t - 1 and 2t + 1 - 1 is prime, obliviously there are no solutions.Prime numbers like 2a - 1 are Mersenne primes. Only about 46 such numbers are found now. Powers of 2 for the firts 40 numbers you can find for example here.Author is Ripatti .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5322",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3670
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 1",
          "code": "1, 2, 4, 6, 12, 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 2",
          "code": "typedef long long i64;\ni64 K;\ni64 S;\n\ni64 F(i64 n) {\n  if (n >=1 && n < K)\n    return 0;\n  if (n==K)\n    return 1;\n  i64 ans = 0;\n  while(n > K) {\n    ans += F(n-1);\n    --n;\n  }\n  return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"139_B.in\",\"r\", stdin);\n#endif\n\n  cin>>S>>K;\n  for(int i = 1; i <= 15; ++i) {\n    cout<<F(i)<<endl;\n  }\n\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 3",
          "code": "typedef long long i64;\ni64 K;\ni64 S;\n\ni64 F(i64 n) {\n  if (n >=1 && n < K)\n    return 0;\n  if (n==K)\n    return 1;\n  i64 ans = 0;\n  while(n > K) {\n    ans += F(n-1);\n    --n;\n  }\n  return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"139_B.in\",\"r\", stdin);\n#endif\n\n  cin>>S>>K;\n  for(int i = 1; i <= 15; ++i) {\n    cout<<F(i)<<endl;\n  }\n\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 4",
          "code": "while(n > K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 5",
          "code": "FOR(x,n-K-1,n-1) {\n    if (x < 0)\n      break;\n    ans += F(x);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 6",
          "code": "FOR(x,n-K-1,n-1) {\n    if (x < 0)\n      break;\n    ans += F(x);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int s = inf.readInt(1, 1000000000, \"s\");\n    inf.readSpace();\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int s = inf.readInt(1, 1000000000, \"s\");\n    inf.readSpace();\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int s = inf.readInt(1, 1000000000, \"s\");\n    inf.readSpace();\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   Checker for the k-bonacci sum problem:\n   We are given s and k, and a representation of s as a sum of distinct k-bonacci numbers.\n\n   The output format:\n   1) The first line contains m (m >= 2).\n   2) The second line contains m distinct k-bonacci numbers whose sum is exactly s.\n\n   Because multiple solutions are allowed, we need a custom checker to verify:\n   - m >= 2.\n   - All output numbers are valid k-bonacci numbers for the given k.\n   - They are distinct.\n   - Their sum equals s.\n\n   Approach to check \"valid k-bonacci number\":\n   We generate all k-bonacci numbers up to s and store them in a set.\n   Then each contestant's output number must be in that set.\n\n   \"k-bonacci\" is defined as:\n   F(k,1) = 0,\n   F(k,2) = 0,\n   ...\n   F(k,k-1) = 0,\n   F(k,k) = 1,\n   and for n > k:\n     F(k,n) = F(k,n-1) + F(k,n-2) + ... + F(k,n-k).\n\n   Since s ≤ 10^9, the length of the k-bonacci sequence up to s will be relatively small \n   because each new term (beyond the first k) is the sum of the previous k terms, \n   which grows at least exponentially once the sequence becomes non-zero.\n\n   We'll generate these numbers carefully using a sliding window to maintain \n   the sum of the last k terms, stopping once we exceed s.\n*/\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    long long s = inf.readLong(); // s\n    long long k = inf.readLong(); // k\n\n    // Generate all k-bonacci numbers up to s\n    // We'll store them in a vector and add to a set for O(log N) membership checks.\n    // The first (k-1) terms are 0, the k-th is 1, then each subsequent is sum of last k terms.\n\n    // Special edge cases:\n    // - k-1 zeros might be large, but we only store them once. We cannot simply push back million/billion zeros,\n    //   so we handle them carefully in a queue.\n\n    // We'll keep a small queue of (at most) the last k elements to compute the next F(k,n).\n    // Because the numbers grow quickly, we won't exceed a few dozen terms before exceeding s.\n\n    vector<long long> kb;  // to hold unique k-bonacci numbers up to s\n    kb.reserve(200);       // just a safe reserve to avoid frequent reallocation\n    deque<long long> window;\n\n    // Add (k - 1) zeros in the \"conceptual\" sense, but no need to push all individually if k is huge:\n    // We push back zeros as needed to the queue for the sum calculation.\n    // Then we push the \"1\" at index k.\n\n    // We do it step by step:\n    // 1. For i in [1..k-1], F(k,i) = 0.\n    // 2. F(k,k) = 1.\n    // 3. Then subsequent terms.\n\n    // Let's implement it with a loop that terminates once we exceed s.\n\n    long long current_sum = 0; // sum of elements in the window\n\n    // We'll effectively simulate F(k,1), F(k,2),..., F(k,k-1) = 0\n    // but we won't store them all if k is huge. We'll store them in the vector if they're unique\n    // and <= s (which is 0 or 1).\n    // However, 0 is also a valid k-bonacci number by definition. It's repeated (k-1) times,\n    // but a \"number\" doesn't need repeating in the set. We'll push it once into the \"kb\" set, \n    // because we only check membership. A candidate output \"0\" is valid as long as 0 is in the set.\n    // We place \"0\" in kb exactly once if k > 1.\n\n    // Because the definition says for n = 1..(k-1), F(k,n) = 0, that does not create distinct values\n    // (they're all zero). So we only keep a single \"0\" as a valid k-bonacci \"value\".\n\n    // Let's do that:\n    if (k > 1) {\n        kb.push_back(0); // We record zero as a valid k-bonacci number\n    }\n    // We push (k-1) zeroes into the queue for sum calculations:\n    for (int i = 1; i < k; i++){\n        window.push_back(0);\n        current_sum += 0;\n    }\n\n    // Next is F(k,k) = 1\n    // We'll store that if <= s\n    if (1 <= s) {\n        kb.push_back(1);\n        window.push_back(1);\n        current_sum += 1;\n    }\n\n    // Now generate further terms:\n    while (true) {\n        // The next term is current_sum, the sum of the last k terms in the deque\n        long long nextVal = current_sum;\n        if (nextVal > s) break; // no need to generate beyond s\n        kb.push_back(nextVal);\n\n        // push nextVal in queue for future sums\n        window.push_back(nextVal);\n        current_sum += nextVal;\n\n        // If the queue has size > k, pop the oldest\n        if ((int)window.size() > k) {\n            long long frontVal = window.front();\n            window.pop_front();\n            current_sum -= frontVal;\n        }\n    }\n\n    // Put all k-bonacci numbers up to s into a set for quick membership check\n    unordered_set<long long> kbSet(kb.begin(), kb.end());\n\n    // Now read the contestant's output\n    int m = ouf.readInt(2, 1000000000, \"m\"); \n    // We only limit upper bound of m to something large to avoid unbounded read. \n    // The problem states m >= 2, doesn't specify an upper bound, \n    // but we can safely place a large upper bound for practical reasons.\n\n    vector<long long> ans(m);\n    for (int i = 0; i < m; i++){\n        ans[i] = ouf.readLong(-10000000000LL, 10000000000LL, \"k-bonacci term\"); \n        // We allow a broad range, but will check validity below.\n    }\n\n    // Check distinctness\n    // We can use a set or so\n    unordered_set<long long> used;\n    used.reserve(m);\n    for (auto &x : ans) {\n        if (used.find(x) != used.end())\n            quitf(_wa, \"the output contains duplicate k-bonacci number %lld\", x);\n        used.insert(x);\n    }\n\n    // Check all are in our kbSet\n    for (auto &x : ans){\n        if (kbSet.find(x) == kbSet.end()){\n            quitf(_wa, \"output uses a number which is not a valid k-bonacci: %lld\", x);\n        }\n    }\n\n    // Finally, check the sum\n    long long sumOut = 0;\n    for (auto &x : ans) {\n        sumOut += x;\n        // We also need to check for possible overflow when summing, \n        // but since s <= 1e9 and each term is at most s, \n        // the maximum sum in the worst case won't exceed ~1e14 if extremely unlucky. \n        // That fits into 64-bit. We'll assume no overflow occurs in normal usage here.\n    }\n\n    if (sumOut != s) {\n        quitf(_wa, \"the sum of the output k-bonacci numbers is %lld, expected %lld\", sumOut, s);\n    }\n\n    // If all checks passed\n    quitf(_ok, \"correct representation of %lld with %d distinct k-bonacci numbers\", s, m);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long s = opt<long long>(\"s\", -1);\n    long long k = opt<long long>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (s == -1 || k == -1) {\n        if (type == \"max\") {\n            s = 1000000000LL;\n            k = 1000000000LL;\n        } else if (type == \"min\") {\n            s = 1LL;\n            k = 2LL;\n        } else if (type == \"small_s\") {\n            s = rnd.next(1LL, 100LL);\n            k = rnd.next(2LL, 1000000000LL);\n        } else if (type == \"small_k\") {\n            s = rnd.next(1LL, 1000000000LL);\n            k = rnd.next(2LL, 10LL);\n        } else if (type == \"small\") {\n            s = rnd.next(1LL, 100LL);\n            k = rnd.next(2LL, 100LL);\n        } else if (type == \"large_s_small_k\") {\n            s = rnd.next(100000000LL, 1000000000LL);\n            k = rnd.next(2LL, 10LL);\n        } else if (type == \"small_s_large_k\") {\n            s = rnd.next(1LL, 100LL);\n            k = rnd.next(100000000LL, 1000000000LL);\n        } else if (type == \"random\") {\n            s = rnd.next(1LL, 1000000000LL);\n            k = rnd.next(2LL, 1000000000LL);\n        } else {\n            // default to random\n            s = rnd.next(1LL, 1000000000LL);\n            k = rnd.next(2LL, 1000000000LL);\n        }\n    }\n\n    printf(\"%lld %lld\\n\", s, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long s = opt<long long>(\"s\", -1);\n    long long k = opt<long long>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (s == -1 || k == -1) {\n        if (type == \"max\") {\n            s = 1000000000LL;\n            k = 1000000000LL;\n        } else if (type == \"min\") {\n            s = 1LL;\n            k = 2LL;\n        } else if (type == \"small_s\") {\n            s = rnd.next(1LL, 100LL);\n            k = rnd.next(2LL, 1000000000LL);\n        } else if (type == \"small_k\") {\n            s = rnd.next(1LL, 1000000000LL);\n            k = rnd.next(2LL, 10LL);\n        } else if (type == \"small\") {\n            s = rnd.next(1LL, 100LL);\n            k = rnd.next(2LL, 100LL);\n        } else if (type == \"large_s_small_k\") {\n            s = rnd.next(100000000LL, 1000000000LL);\n            k = rnd.next(2LL, 10LL);\n        } else if (type == \"small_s_large_k\") {\n            s = rnd.next(1LL, 100LL);\n            k = rnd.next(100000000LL, 1000000000LL);\n        } else if (type == \"random\") {\n            s = rnd.next(1LL, 1000000000LL);\n            k = rnd.next(2LL, 1000000000LL);\n        } else {\n            // default to random\n            s = rnd.next(1LL, 1000000000LL);\n            k = rnd.next(2LL, 1000000000LL);\n        }\n    }\n\n    printf(\"%lld %lld\\n\", s, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -s 1 -k 2 -type min\n./gen -type min\n\n./gen -type max\n\n./gen -type small_s\n./gen -type small_k\n./gen -type small\n\n./gen -type large_s_small_k\n./gen -type small_s_large_k\n\n./gen\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -s 1000000000 -k 2\n\n./gen -s 1 -k 1000000000\n\n./gen -s 123456789 -k 987654321\n\n./gen -s 987654321 -k 123456789\n\n./gen -s 500000000 -k 500000000\n\n./gen -type small_s\n\n./gen -type small_k\n\n./gen -s 17 -k 1000000000\n\n./gen -s 999999999 -k 2\n\n./gen -s 999999999 -k 1000000000\n\n./gen -s 100 -k 2 -type small\n\n./gen -s 2 -k 1000000000 -type small_s_large_k\n\n./gen -s 1000000000 -k 2 -type large_s_small_k\n\n./gen -type random\n\n./gen -s 1 -k 2\n\n./gen -s 1 -k 3\n\n./gen -s 1 -k 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:43.901208",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "225/C",
      "title": "C. Barcode",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four space-separated integers n, m, x and y (1 ≤ n, m, x, y ≤ 1000; x ≤ y).Then follow n lines, describing the original image. Each of these lines contains exactly m characters. Character \".\" represents a white pixel and \"#\" represents a black pixel. The picture description doesn't have any other characters besides \".\" and \"#\".",
      "output_spec": "OutputIn the first line print the minimum number of pixels to repaint. It is guaranteed that the answer exists.",
      "sample_tests": "ExamplesInputCopy6 5 1 2##.#..###.###..#...#.##.####..OutputCopy11InputCopy2 5 1 1#####.....OutputCopy5",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four space-separated integers n, m, x and y (1 ≤ n, m, x, y ≤ 1000; x ≤ y).Then follow n lines, describing the original image. Each of these lines contains exactly m characters. Character \".\" represents a white pixel and \"#\" represents a black pixel. The picture description doesn't have any other characters besides \".\" and \"#\".\n\nOutputIn the first line print the minimum number of pixels to repaint. It is guaranteed that the answer exists.\n\nInputCopy6 5 1 2##.#..###.###..#...#.##.####..OutputCopy11InputCopy2 5 1 1#####.....OutputCopy5\n\nInputCopy6 5 1 2##.#..###.###..#...#.##.####..\n\nOutputCopy11\n\nInputCopy2 5 1 1#####.....\n\nOutputCopy5\n\nNoteIn the first test sample the picture after changing some colors can looks as follows:  .##...##...##...##...##...##.. In the second test sample the picture after changing some colors can looks as follows:  .#.#..#.#.",
      "solutions": [
        {
          "title": "Codeforces Round #139 (div2) - Codeforces",
          "content": "Hello everyone!That is Codeforces Round 139 for the second division only. Members of the first division can participate out of competition.Round is prepared by Ripatti , Gerald , Delinur.We will use dynamic score system. Problems will be ordered in order of expected increasing difficulty.Good luck!UPD. For technical reasons round delays in 15 minutes.UPD2. Testing is complete. Winners:1. wccy2. ttl3. shubhanshu4. Atarashi_Ako5. dvylfz921 2 members solved all 5 problems.English editorial will be tomorrow. You can try to understand russian editorial.UPD3. English editorial.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 578
        },
        {
          "title": "Editorial for Codeforces Round #139 - Codeforces",
          "content": "A. You should iterate over all dices from up to down and restore answer. You can easily find number of the bottom side of the 1st dice. Using known sides of the 2nd dice you can find pair of numbets on top and bottom side of the 2nd dice. If one of them equal to number on bottom of the 1st dice, you can restore all numbers on the 2n dice. Then using this idea you can try restore numbers on the 3rd dice and so on. If you restored all numbers, you should write YES. If for some dice you cannot uniquely determine order of numbers on the top and botton sides, there will be at least 2 placing of numbers. In this case you shoyld write NO.Author is Ripatti .B. Firstly you should generate all k-bonacci numbers less than n. For k ≤ 32 you can do it straightforward, for bigger k you can see that all k-bonacci numbers less 109 are powers of two only (and 0). So you will have no more then 100 numbers.Then you should use greedy algo. You should substract from n maximal possible k-bonacci numbers. You should repeat this operation while n is not decomposed. And in the end you will have answer.Why all numbers will be different? One of possible proves:F(k, n) = F(k, n - 1) + F(k, n - 2) + ... + F(k, n - k)F(k, n - 1) = F(k, n - 2) + F(k, n - 3) + ... + F(k, n - k - 1)You can substract the 2nd equation from the 1st one and you will recieve F(k, n) + F(k, n - k - 1) = 2F(k, n - 1), that equal to 2F(k, n - 1) ≥ F(k, n). This unequation also holds for n ≤ k.Suppose than greedy also constricted 2 equal numbers F(k, x) in decomposition. But then in virtue of unequation we should take number F(k, x + 1) insead these 2 numbers. Сontradiction.But you didn't need prove than greedy algo works, you might believe that it works:)Authors are Gerald , Ripatti .C. Firstly you should calculate number of white and black pixels in every column. After that you should calculate number of white and black pixels for every prefix in sequence of columns. Now you can calculate number of black or white pixels in every vertical line of any width in O(1).Now you should use dynamic programming. Let's dp[i][j] will store numbers of repainted pixels in prefix from the 1st column to the j-th and color of the last column will be white for i = 0 and black for i = 1.Than you can recalculate dp using forlulas: dp[0][0] = dp[1][0] = 0 Answer will be min(dp[0][m], dp[1][m]).This solution works in O(nm + m * (y - x)).Author is Ripatti .D. There is just BFS. State is head place and mask that store place of tail: using 2 bits you can code position of every segment in relation to previous segment. Mask will contain no more than 16 bits, and number of all states will be no more than 48 × 15 × 15 (also you can try understand that number of states no more than 38 × 15 × 15).Then you should just carefully implement it.Author is Ripatti .E. You have z = [x / 2] + y + xy. That is equivalent toz = [2k / 2] + y + 2ky, where x = 2k, k > 0orz = [(2k + 1) / 2] + y + (2k + 1)y, where x = 2k + 1, k ≥ 0.z = k + y + 2ky, k > 0orz = k + y + (2k + 1)y, k ≥ 0.Still more steps:2z + 1 = 2k + 2y + 4ky + 1, k > 0orz + 1 = k + 2y + 2ky + 1, k ≥ 0.2z + 1 = (2k + 1)(2y + 1), k > 0orz + 1 = (2y + 1)(k + 1), k ≥ 0.From the 2nd equation you can see than z should be 2t - 1 because otherwise z + 1 will have odd divisor and we can build solution. From the 1st equation you can see that 2t + 1 - 1 should be prime, otherwise we also can build solution. If z = 2t - 1 and 2t + 1 - 1 is prime, obliviously there are no solutions.Prime numbers like 2a - 1 are Mersenne primes. Only about 46 such numbers are found now. Powers of 2 for the firts 40 numbers you can find for example here.Author is Ripatti .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5322",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3670
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 1",
          "code": "1, 2, 4, 6, 12, 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 2",
          "code": "typedef long long i64;\ni64 K;\ni64 S;\n\ni64 F(i64 n) {\n  if (n >=1 && n < K)\n    return 0;\n  if (n==K)\n    return 1;\n  i64 ans = 0;\n  while(n > K) {\n    ans += F(n-1);\n    --n;\n  }\n  return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"139_B.in\",\"r\", stdin);\n#endif\n\n  cin>>S>>K;\n  for(int i = 1; i <= 15; ++i) {\n    cout<<F(i)<<endl;\n  }\n\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 3",
          "code": "typedef long long i64;\ni64 K;\ni64 S;\n\ni64 F(i64 n) {\n  if (n >=1 && n < K)\n    return 0;\n  if (n==K)\n    return 1;\n  i64 ans = 0;\n  while(n > K) {\n    ans += F(n-1);\n    --n;\n  }\n  return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"139_B.in\",\"r\", stdin);\n#endif\n\n  cin>>S>>K;\n  for(int i = 1; i <= 15; ++i) {\n    cout<<F(i)<<endl;\n  }\n\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 4",
          "code": "while(n > K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 5",
          "code": "FOR(x,n-K-1,n-1) {\n    if (x < 0)\n      break;\n    ans += F(x);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 6",
          "code": "FOR(x,n-K-1,n-1) {\n    if (x < 0)\n      break;\n    ans += F(x);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000, \"y\");\n    inf.readEoln();\n    ensuref(x <= y, \"x should be less than or equal to y\");\n    string pattern = \"^[.#]{\" + to_string(m) + \"}$\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000, \"y\");\n    inf.readEoln();\n    ensuref(x <= y, \"x should be less than or equal to y\");\n    string pattern = \"^[.#]{\" + to_string(m) + \"}$\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(1, 1000, \"y\");\n    inf.readEoln();\n    ensuref(x <= y, \"x should be less than or equal to y\");\n    string pattern = \"^[.#]{\" + to_string(m) + \"}$\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure constraints are met\n    ensure(1 <= n && n <= 1000);\n    ensure(1 <= m && m <= 1000);\n    ensure(1 <= x && x <= 1000);\n    ensure(1 <= y && y <= 1000);\n    ensure(x <= y);\n\n    // Initialize the picture with white pixels\n    vector<string> picture(n, string(m, '.'));\n\n    if (type == \"random\") {\n        // Generate random pixels\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                picture[i][j] = (rnd.next(2) ? '.' : '#');\n            }\n        }\n    } else if (type == \"all_white\") {\n        // All pixels are '.', already initialized\n    } else if (type == \"all_black\") {\n        // All pixels are '#'\n        for (int i = 0; i < n; ++i) {\n            picture[i] = string(m, '#');\n        }\n    } else if (type == \"alternating_columns\") {\n        // Columns alternate between '.' and '#'\n        for (int j = 0; j < m; ++j) {\n            char c = (j % 2 == 0) ? '.' : '#';\n            for (int i = 0; i < n; ++i) {\n                picture[i][j] = c;\n            }\n        }\n    } else if (type == \"block_size_min\") {\n        // Construct barcode with block sizes of x\n        int col = 0;\n        char colors[2] = {'.', '#'};\n        int color_idx = 0;\n        while (col < m) {\n            int width = x;\n            for (int j = 0; j < width && col + j < m; ++j) {\n                for (int i = 0; i < n; ++i) {\n                    picture[i][col + j] = colors[color_idx];\n                }\n            }\n            col += width;\n            color_idx ^= 1; // Switch colors\n        }\n    } else if (type == \"block_size_max\") {\n        // Construct barcode with block sizes of y\n        int col = 0;\n        char colors[2] = {'.', '#'};\n        int color_idx = 0;\n        while (col < m) {\n            int width = y;\n            for (int j = 0; j < width && col + j < m; ++j) {\n                for (int i = 0; i < n; ++i) {\n                    picture[i][col + j] = colors[color_idx];\n                }\n            }\n            col += width;\n            color_idx ^= 1;\n        }\n    } else if (type == \"worst_case\") {\n        // Construct a worst-case picture\n        char colors[2] = {'.', '#'};\n        int color_idx = 0;\n        int col = 0;\n        while (col < m) {\n            int width = rnd.next(1, max(1, x - 1)); // width less than x\n            for (int j = 0; j < width && col + j < m; ++j) {\n                for (int i = 0; i < n; ++i) {\n                    picture[i][col + j] = colors[color_idx];\n                }\n            }\n            col += width;\n            color_idx ^= 1;\n        }\n    } else {\n        // Default to random if type is unknown\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                picture[i][j] = (rnd.next(2) ? '.' : '#');\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, x, y);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", picture[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure constraints are met\n    ensure(1 <= n && n <= 1000);\n    ensure(1 <= m && m <= 1000);\n    ensure(1 <= x && x <= 1000);\n    ensure(1 <= y && y <= 1000);\n    ensure(x <= y);\n\n    // Initialize the picture with white pixels\n    vector<string> picture(n, string(m, '.'));\n\n    if (type == \"random\") {\n        // Generate random pixels\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                picture[i][j] = (rnd.next(2) ? '.' : '#');\n            }\n        }\n    } else if (type == \"all_white\") {\n        // All pixels are '.', already initialized\n    } else if (type == \"all_black\") {\n        // All pixels are '#'\n        for (int i = 0; i < n; ++i) {\n            picture[i] = string(m, '#');\n        }\n    } else if (type == \"alternating_columns\") {\n        // Columns alternate between '.' and '#'\n        for (int j = 0; j < m; ++j) {\n            char c = (j % 2 == 0) ? '.' : '#';\n            for (int i = 0; i < n; ++i) {\n                picture[i][j] = c;\n            }\n        }\n    } else if (type == \"block_size_min\") {\n        // Construct barcode with block sizes of x\n        int col = 0;\n        char colors[2] = {'.', '#'};\n        int color_idx = 0;\n        while (col < m) {\n            int width = x;\n            for (int j = 0; j < width && col + j < m; ++j) {\n                for (int i = 0; i < n; ++i) {\n                    picture[i][col + j] = colors[color_idx];\n                }\n            }\n            col += width;\n            color_idx ^= 1; // Switch colors\n        }\n    } else if (type == \"block_size_max\") {\n        // Construct barcode with block sizes of y\n        int col = 0;\n        char colors[2] = {'.', '#'};\n        int color_idx = 0;\n        while (col < m) {\n            int width = y;\n            for (int j = 0; j < width && col + j < m; ++j) {\n                for (int i = 0; i < n; ++i) {\n                    picture[i][col + j] = colors[color_idx];\n                }\n            }\n            col += width;\n            color_idx ^= 1;\n        }\n    } else if (type == \"worst_case\") {\n        // Construct a worst-case picture\n        char colors[2] = {'.', '#'};\n        int color_idx = 0;\n        int col = 0;\n        while (col < m) {\n            int width = rnd.next(1, max(1, x - 1)); // width less than x\n            for (int j = 0; j < width && col + j < m; ++j) {\n                for (int i = 0; i < n; ++i) {\n                    picture[i][col + j] = colors[color_idx];\n                }\n            }\n            col += width;\n            color_idx ^= 1;\n        }\n    } else {\n        // Default to random if type is unknown\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                picture[i][j] = (rnd.next(2) ? '.' : '#');\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, x, y);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", picture[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -x 1 -y 1 -type all_white\n./gen -n 1 -m 1 -x 1 -y 1 -type all_black\n./gen -n 1 -m 1 -x 1 -y 1 -type random\n\n./gen -n 10 -m 10 -x 1 -y 10 -type random\n./gen -n 10 -m 10 -x 3 -y 3 -type block_size_min\n./gen -n 10 -m 10 -x 5 -y 5 -type block_size_max\n\n./gen -n 50 -m 50 -x 1 -y 50 -type worst_case\n./gen -n 50 -m 50 -x 1 -y 1 -type alternating_columns\n\n./gen -n 100 -m 100 -x 1 -y 100 -type random\n./gen -n 100 -m 100 -x 10 -y 20 -type block_size_min\n\n./gen -n 200 -m 200 -x 1 -y 1000 -type worst_case\n\n./gen -n 500 -m 500 -x 100 -y 200 -type block_size_max\n\n./gen -n 1000 -m 1000 -x 1 -y 1000 -type all_white\n./gen -n 1000 -m 1000 -x 1 -y 1000 -type all_black\n\n./gen -n 1000 -m 1000 -x 1000 -y 1000 -type block_size_min\n./gen -n 1000 -m 1000 -x 1 -y 1 -type alternating_columns\n\n./gen -n 1000 -m 1000 -x 1 -y 1000 -type worst_case\n./gen -n 1000 -m 1000 -x 500 -y 500 -type block_size_min\n\n./gen -n 500 -m 1000 -x 1 -y 1000 -type worst_case\n./gen -n 1000 -m 500 -x 1 -y 1000 -type random\n./gen -n 1 -m 1000 -x 1 -y 1000 -type block_size_max\n./gen -n 1000 -m 1 -x 1 -y 1 -type random\n\n./gen -n 999 -m 500 -x 2 -y 5 -type random\n\n./gen -n 500 -m 999 -x 5 -y 10 -type block_size_min\n\n./gen -n 1000 -m 1000 -x 250 -y 750 -type random\n\n./gen -n 1000 -m 1000 -x 1 -y 2 -type worst_case\n\n./gen -n 1000 -m 1000 -x 999 -y 1000 -type block_size_max\n\n./gen -n 1000 -m 1000 -x 100 -y 200 -type alternating_columns\n\n./gen -n 1000 -m 1000 -x 1 -y 1 -type block_size_min\n\n./gen -n 100 -m 100 -x 20 -y 30 -type random\n\n./gen -n 1000 -m 1000 -x 1 -y 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:45.850899",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "225/D",
      "title": "D. Snake",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 15) — the number of rows and columns of the game field.Next n lines describe the game field. Each of these lines contains m characters. Character \"#\" represents a wall, \".\" is a passable square, \"@\" is an apple. The snake's first segment is represented by character \"1\", the second one segment — by character \"2\" and so on.The game field description doesn't contain any characters besides \"#', \".\", \"@\" and digits (except 0). It is guaranteed that the described field is correct. It is guaranteed that the described field contains exactly one apple and exactly one snake, the snake's length is at least 3 and at most 9.",
      "output_spec": "OutputPrint a single integer to the output — the minimum number of moves needed to reach the apple. If the snake can't reach the apple, print -1.",
      "sample_tests": "ExamplesInputCopy4 5##.....1#@432#....#.OutputCopy4InputCopy4 4#78#.612.543..@.OutputCopy6InputCopy3 23@2#1#OutputCopy-1",
      "description": "time limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 15) — the number of rows and columns of the game field.Next n lines describe the game field. Each of these lines contains m characters. Character \"#\" represents a wall, \".\" is a passable square, \"@\" is an apple. The snake's first segment is represented by character \"1\", the second one segment — by character \"2\" and so on.The game field description doesn't contain any characters besides \"#', \".\", \"@\" and digits (except 0). It is guaranteed that the described field is correct. It is guaranteed that the described field contains exactly one apple and exactly one snake, the snake's length is at least 3 and at most 9.\n\nOutputPrint a single integer to the output — the minimum number of moves needed to reach the apple. If the snake can't reach the apple, print -1.\n\nInputCopy4 5##.....1#@432#....#.OutputCopy4InputCopy4 4#78#.612.543..@.OutputCopy6InputCopy3 23@2#1#OutputCopy-1\n\nInputCopy4 5##.....1#@432#....#.\n\nOutputCopy4\n\nInputCopy4 4#78#.612.543..@.\n\nOutputCopy6\n\nInputCopy3 23@2#1#\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #139 (div2) - Codeforces",
          "content": "Hello everyone!That is Codeforces Round 139 for the second division only. Members of the first division can participate out of competition.Round is prepared by Ripatti , Gerald , Delinur.We will use dynamic score system. Problems will be ordered in order of expected increasing difficulty.Good luck!UPD. For technical reasons round delays in 15 minutes.UPD2. Testing is complete. Winners:1. wccy2. ttl3. shubhanshu4. Atarashi_Ako5. dvylfz921 2 members solved all 5 problems.English editorial will be tomorrow. You can try to understand russian editorial.UPD3. English editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 578
        },
        {
          "title": "Editorial for Codeforces Round #139 - Codeforces",
          "content": "A. You should iterate over all dices from up to down and restore answer. You can easily find number of the bottom side of the 1st dice. Using known sides of the 2nd dice you can find pair of numbets on top and bottom side of the 2nd dice. If one of them equal to number on bottom of the 1st dice, you can restore all numbers on the 2n dice. Then using this idea you can try restore numbers on the 3rd dice and so on. If you restored all numbers, you should write YES. If for some dice you cannot uniquely determine order of numbers on the top and botton sides, there will be at least 2 placing of numbers. In this case you shoyld write NO.Author is Ripatti .B. Firstly you should generate all k-bonacci numbers less than n. For k ≤ 32 you can do it straightforward, for bigger k you can see that all k-bonacci numbers less 109 are powers of two only (and 0). So you will have no more then 100 numbers.Then you should use greedy algo. You should substract from n maximal possible k-bonacci numbers. You should repeat this operation while n is not decomposed. And in the end you will have answer.Why all numbers will be different? One of possible proves:F(k, n) = F(k, n - 1) + F(k, n - 2) + ... + F(k, n - k)F(k, n - 1) = F(k, n - 2) + F(k, n - 3) + ... + F(k, n - k - 1)You can substract the 2nd equation from the 1st one and you will recieve F(k, n) + F(k, n - k - 1) = 2F(k, n - 1), that equal to 2F(k, n - 1) ≥ F(k, n). This unequation also holds for n ≤ k.Suppose than greedy also constricted 2 equal numbers F(k, x) in decomposition. But then in virtue of unequation we should take number F(k, x + 1) insead these 2 numbers. Сontradiction.But you didn't need prove than greedy algo works, you might believe that it works:)Authors are Gerald , Ripatti .C. Firstly you should calculate number of white and black pixels in every column. After that you should calculate number of white and black pixels for every prefix in sequence of columns. Now you can calculate number of black or white pixels in every vertical line of any width in O(1).Now you should use dynamic programming. Let's dp[i][j] will store numbers of repainted pixels in prefix from the 1st column to the j-th and color of the last column will be white for i = 0 and black for i = 1.Than you can recalculate dp using forlulas: dp[0][0] = dp[1][0] = 0 Answer will be min(dp[0][m], dp[1][m]).This solution works in O(nm + m * (y - x)).Author is Ripatti .D. There is just BFS. State is head place and mask that store place of tail: using 2 bits you can code position of every segment in relation to previous segment. Mask will contain no more than 16 bits, and number of all states will be no more than 48 × 15 × 15 (also you can try understand that number of states no more than 38 × 15 × 15).Then you should just carefully implement it.Author is Ripatti .E. You have z = [x / 2] + y + xy. That is equivalent toz = [2k / 2] + y + 2ky, where x = 2k, k > 0orz = [(2k + 1) / 2] + y + (2k + 1)y, where x = 2k + 1, k ≥ 0.z = k + y + 2ky, k > 0orz = k + y + (2k + 1)y, k ≥ 0.Still more steps:2z + 1 = 2k + 2y + 4ky + 1, k > 0orz + 1 = k + 2y + 2ky + 1, k ≥ 0.2z + 1 = (2k + 1)(2y + 1), k > 0orz + 1 = (2y + 1)(k + 1), k ≥ 0.From the 2nd equation you can see than z should be 2t - 1 because otherwise z + 1 will have odd divisor and we can build solution. From the 1st equation you can see that 2t + 1 - 1 should be prime, otherwise we also can build solution. If z = 2t - 1 and 2t + 1 - 1 is prime, obliviously there are no solutions.Prime numbers like 2a - 1 are Mersenne primes. Only about 46 such numbers are found now. Powers of 2 for the firts 40 numbers you can find for example here.Author is Ripatti .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5322",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3670
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 1",
          "code": "1, 2, 4, 6, 12, 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 2",
          "code": "typedef long long i64;\ni64 K;\ni64 S;\n\ni64 F(i64 n) {\n  if (n >=1 && n < K)\n    return 0;\n  if (n==K)\n    return 1;\n  i64 ans = 0;\n  while(n > K) {\n    ans += F(n-1);\n    --n;\n  }\n  return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"139_B.in\",\"r\", stdin);\n#endif\n\n  cin>>S>>K;\n  for(int i = 1; i <= 15; ++i) {\n    cout<<F(i)<<endl;\n  }\n\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 3",
          "code": "typedef long long i64;\ni64 K;\ni64 S;\n\ni64 F(i64 n) {\n  if (n >=1 && n < K)\n    return 0;\n  if (n==K)\n    return 1;\n  i64 ans = 0;\n  while(n > K) {\n    ans += F(n-1);\n    --n;\n  }\n  return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"139_B.in\",\"r\", stdin);\n#endif\n\n  cin>>S>>K;\n  for(int i = 1; i <= 15; ++i) {\n    cout<<F(i)<<endl;\n  }\n\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 4",
          "code": "while(n > K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 5",
          "code": "FOR(x,n-K-1,n-1) {\n    if (x < 0)\n      break;\n    ans += F(x);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 6",
          "code": "FOR(x,n-K-1,n-1) {\n    if (x < 0)\n      break;\n    ans += F(x);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 15, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    int apple_count = 0;\n    map<int, pair<int, int>> snake_segments; // label -> position\n    set<pair<int, int>> snake_positions; // to check for overlapping segments\n    set<int> segment_labels;\n\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine();\n        ensuref((int)line.length() == m, \"Line %d length (%d) does not match m (%d)\", i + 1, (int)line.length(), m);\n        for (int j = 0; j < m; ++j) {\n            char c = line[j];\n            ensuref(c == '#' || c == '.' || c == '@' || (c >= '1' && c <= '9'),\n                    \"Invalid character '%c' at position (%d, %d)\", c, i + 1, j + 1);\n            if (c == '@') {\n                ++apple_count;\n            }\n            if (c >= '1' && c <= '9') {\n                int label = c - '0';\n                snake_segments[label] = make_pair(i, j);\n                snake_positions.insert(make_pair(i, j));\n                segment_labels.insert(label);\n            }\n        }\n        grid[i] = line;\n    }\n\n    inf.readEof();\n\n    ensuref(apple_count == 1, \"Number of apples is %d, but should be 1\", apple_count);\n\n    int k = snake_segments.size();\n    ensuref(k >= 3 && k <= 9, \"Snake length is %d, but should be between 3 and 9 inclusive\", k);\n\n    // Check that labels from 1 to k are present\n    for (int label = 1; label <= k; ++label) {\n        ensuref(segment_labels.count(label), \"Snake segment '%d' is missing\", label);\n    }\n\n    // Check that segments are on passable squares (i.e., not walls)\n    for (auto& p : snake_segments) {\n        int label = p.first;\n        int x = p.second.first;\n        int y = p.second.second;\n        char cell = grid[x][y];\n        ensuref(cell != '#', \"Snake segment '%d' is on an impassable square at position (%d, %d)\", label, x + 1, y + 1);\n    }\n\n    // Check that segments are on unique positions\n    ensuref((int)snake_positions.size() == k, \"Snake segments overlap\");\n\n    // Check that each pair of adjacent segments are adjacent on the grid\n    for (int label = 1; label < k; ++label) {\n        auto pos1 = snake_segments[label];\n        auto pos2 = snake_segments[label + 1];\n        int dx = abs(pos1.first - pos2.first);\n        int dy = abs(pos1.second - pos2.second);\n        ensuref((dx == 1 && dy == 0) || (dx == 0 && dy == 1),\n                \"Snake segments '%d' and '%d' are not adjacent\", label, label + 1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 15, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    int apple_count = 0;\n    map<int, pair<int, int>> snake_segments; // label -> position\n    set<pair<int, int>> snake_positions; // to check for overlapping segments\n    set<int> segment_labels;\n\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine();\n        ensuref((int)line.length() == m, \"Line %d length (%d) does not match m (%d)\", i + 1, (int)line.length(), m);\n        for (int j = 0; j < m; ++j) {\n            char c = line[j];\n            ensuref(c == '#' || c == '.' || c == '@' || (c >= '1' && c <= '9'),\n                    \"Invalid character '%c' at position (%d, %d)\", c, i + 1, j + 1);\n            if (c == '@') {\n                ++apple_count;\n            }\n            if (c >= '1' && c <= '9') {\n                int label = c - '0';\n                snake_segments[label] = make_pair(i, j);\n                snake_positions.insert(make_pair(i, j));\n                segment_labels.insert(label);\n            }\n        }\n        grid[i] = line;\n    }\n\n    inf.readEof();\n\n    ensuref(apple_count == 1, \"Number of apples is %d, but should be 1\", apple_count);\n\n    int k = snake_segments.size();\n    ensuref(k >= 3 && k <= 9, \"Snake length is %d, but should be between 3 and 9 inclusive\", k);\n\n    // Check that labels from 1 to k are present\n    for (int label = 1; label <= k; ++label) {\n        ensuref(segment_labels.count(label), \"Snake segment '%d' is missing\", label);\n    }\n\n    // Check that segments are on passable squares (i.e., not walls)\n    for (auto& p : snake_segments) {\n        int label = p.first;\n        int x = p.second.first;\n        int y = p.second.second;\n        char cell = grid[x][y];\n        ensuref(cell != '#', \"Snake segment '%d' is on an impassable square at position (%d, %d)\", label, x + 1, y + 1);\n    }\n\n    // Check that segments are on unique positions\n    ensuref((int)snake_positions.size() == k, \"Snake segments overlap\");\n\n    // Check that each pair of adjacent segments are adjacent on the grid\n    for (int label = 1; label < k; ++label) {\n        auto pos1 = snake_segments[label];\n        auto pos2 = snake_segments[label + 1];\n        int dx = abs(pos1.first - pos2.first);\n        int dy = abs(pos1.second - pos2.second);\n        ensuref((dx == 1 && dy == 0) || (dx == 0 && dy == 1),\n                \"Snake segments '%d' and '%d' are not adjacent\", label, label + 1);\n    }\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 15, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    int apple_count = 0;\n    map<int, pair<int, int>> snake_segments; // label -> position\n    set<pair<int, int>> snake_positions; // to check for overlapping segments\n    set<int> segment_labels;\n\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine();\n        ensuref((int)line.length() == m, \"Line %d length (%d) does not match m (%d)\", i + 1, (int)line.length(), m);\n        for (int j = 0; j < m; ++j) {\n            char c = line[j];\n            ensuref(c == '#' || c == '.' || c == '@' || (c >= '1' && c <= '9'),\n                    \"Invalid character '%c' at position (%d, %d)\", c, i + 1, j + 1);\n            if (c == '@') {\n                ++apple_count;\n            }\n            if (c >= '1' && c <= '9') {\n                int label = c - '0';\n                snake_segments[label] = make_pair(i, j);\n                snake_positions.insert(make_pair(i, j));\n                segment_labels.insert(label);\n            }\n        }\n        grid[i] = line;\n    }\n\n    inf.readEof();\n\n    ensuref(apple_count == 1, \"Number of apples is %d, but should be 1\", apple_count);\n\n    int k = snake_segments.size();\n    ensuref(k >= 3 && k <= 9, \"Snake length is %d, but should be between 3 and 9 inclusive\", k);\n\n    // Check that labels from 1 to k are present\n    for (int label = 1; label <= k; ++label) {\n        ensuref(segment_labels.count(label), \"Snake segment '%d' is missing\", label);\n    }\n\n    // Check that segments are on passable squares (i.e., not walls)\n    for (auto& p : snake_segments) {\n        int label = p.first;\n        int x = p.second.first;\n        int y = p.second.second;\n        char cell = grid[x][y];\n        ensuref(cell != '#', \"Snake segment '%d' is on an impassable square at position (%d, %d)\", label, x + 1, y + 1);\n    }\n\n    // Check that segments are on unique positions\n    ensuref((int)snake_positions.size() == k, \"Snake segments overlap\");\n\n    // Check that each pair of adjacent segments are adjacent on the grid\n    for (int label = 1; label < k; ++label) {\n        auto pos1 = snake_segments[label];\n        auto pos2 = snake_segments[label + 1];\n        int dx = abs(pos1.first - pos2.first);\n        int dy = abs(pos1.second - pos2.second);\n        ensuref((dx == 1 && dy == 0) || (dx == 0 && dy == 1),\n                \"Snake segments '%d' and '%d' are not adjacent\", label, label + 1);\n    }\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst char WALL = '#';\nconst char PASSABLE = '.';\nconst char APPLE = '@';\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int snake_length = opt<int>(\"snake_length\", 5); // default to 5\n    string test_type = opt<string>(\"test_type\", \"random\");\n\n    // Ensure constraints\n    ensure(1 <= n && n <= 15);\n    ensure(1 <= m && m <= 15);\n    ensure(3 <= snake_length && snake_length <= 9);\n\n    vector<string> grid(n, string(m, PASSABLE));\n\n    if (test_type == \"random\") {\n        // Random walls\n        int wall_percentage = rnd.next(10, 30); // 10% to 30% walls\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (rnd.next(100) < wall_percentage) {\n                    grid[i][j] = WALL;\n                }\n            }\n        }\n\n        // Collect passable positions\n        vector<pair<int, int>> passable_positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (grid[i][j] == PASSABLE)\n                    passable_positions.push_back({i, j});\n\n        // Ensure enough passable squares\n        if (passable_positions.size() < snake_length + 1) {\n            // Not enough passable squares, clear walls\n            grid.assign(n, string(m, PASSABLE));\n            passable_positions.clear();\n            for (int i = 0; i < n; ++i)\n                for (int j = 0; j < m; ++j)\n                    passable_positions.push_back({i, j});\n        }\n\n        // Place apple\n        int apple_idx = rnd.next(passable_positions.size());\n        int apple_x = passable_positions[apple_idx].first;\n        int apple_y = passable_positions[apple_idx].second;\n        grid[apple_x][apple_y] = APPLE;\n        passable_positions.erase(passable_positions.begin() + apple_idx);\n\n        // Generate snake\n        vector<vector<bool>> used(n, vector<bool>(m, false));\n        vector<pair<int, int>> snake_positions;\n\n        // Start from random position\n        int start_idx = rnd.next(passable_positions.size());\n        int x = passable_positions[start_idx].first;\n        int y = passable_positions[start_idx].second;\n        used[x][y] = true;\n        snake_positions.push_back({x, y});\n\n        while ((int)snake_positions.size() < snake_length) {\n            vector<pair<int, int>> neighbors;\n            const int dx[4] = {0, 0, 1, -1};\n            const int dy[4] = {1, -1, 0, 0};\n            for (int dir = 0; dir < 4; dir++) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                    if (grid[nx][ny] != WALL && !used[nx][ny]) {\n                        neighbors.push_back({nx, ny});\n                    }\n                }\n            }\n            if (neighbors.empty()) {\n                break;\n            }\n            int idx = rnd.next(neighbors.size());\n            x = neighbors[idx].first;\n            y = neighbors[idx].second;\n            used[x][y] = true;\n            snake_positions.push_back({x, y});\n        }\n\n        // If snake is too short, extend it manually\n        while ((int)snake_positions.size() < snake_length) {\n            for (int i = 0; i < n && (int)snake_positions.size() < snake_length; ++i)\n                for (int j = 0; j < m && (int)snake_positions.size() < snake_length; ++j)\n                    if (grid[i][j] == PASSABLE && !used[i][j]) {\n                        used[i][j] = true;\n                        snake_positions.push_back({i, j});\n                    }\n            break;\n        }\n\n        // Place snake segments\n        for (int i = 0; i < (int)snake_positions.size(); ++i) {\n            int xi = snake_positions[i].first;\n            int yi = snake_positions[i].second;\n            grid[xi][yi] = '1' + i;\n        }\n\n    } else if (test_type == \"blocked_by_walls\") {\n        // Create walls separating snake and apple\n        int barrier_row = rnd.next(1, n - 2);\n        for (int j = 0; j < m; ++j) {\n            grid[barrier_row][j] = WALL;\n        }\n\n        // Place snake above barrier\n        int x = rnd.next(0, barrier_row - 1);\n        int y = rnd.next(0, m - 1);\n        vector<pair<int, int>> snake_positions = {{x, y}};\n        grid[x][y] = '1';\n        for (int i = 1; i < snake_length; ++i) {\n            if (x + i < barrier_row) {\n                grid[x + i][y] = '1' + i;\n                snake_positions.push_back({x + i, y});\n            } else {\n                break;\n            }\n        }\n\n        // Place apple below barrier\n        int ax = rnd.next(barrier_row + 1, n - 1);\n        int ay = rnd.next(0, m - 1);\n        grid[ax][ay] = APPLE;\n\n    } else if (test_type == \"blocked_by_self\") {\n        // Snake loops around itself\n        // Create a small area for the snake to occupy completely\n        int size = snake_length / 2 + 1;\n        int start_x = rnd.next(0, n - size);\n        int start_y = rnd.next(0, m - size);\n        int idx = 0;\n\n        for (int i = 0; i < size && idx < snake_length; ++i) {\n            grid[start_x + i][start_y] = '1' + idx++;\n        }\n        for (int j = 1; j < size && idx < snake_length; ++j) {\n            grid[start_x + size - 1][start_y + j] = '1' + idx++;\n        }\n        for (int i = size - 2; i >= 0 && idx < snake_length; --i) {\n            grid[start_x + i][start_y + size - 1] = '1' + idx++;\n        }\n        for (int j = size - 2; j > 0 && idx < snake_length; --j) {\n            grid[start_x][start_y + j] = '1' + idx++;\n        }\n\n        // Place apple inside the loop, unreachable\n        int ax = start_x + 1;\n        int ay = start_y + 1;\n        grid[ax][ay] = APPLE;\n\n    } else if (test_type == \"minimal_moves\") {\n        // Place apple next to snake's head\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = '1'; // Snake head\n\n        // Place remaining snake segments\n        int idx = 1;\n        if (x + snake_length - 1 < n) {\n            for (int i = 1; i < snake_length; ++i) {\n                grid[x + i][y] = '1' + idx++;\n            }\n        } else {\n            for (int i = 1; i < snake_length; ++i) {\n                grid[x][(y + i) % m] = '1' + idx++;\n            }\n        }\n\n        // Place apple next to head\n        if (x > 0 && grid[x - 1][y] == PASSABLE) {\n            grid[x - 1][y] = APPLE;\n        } else if (x < n - 1 && grid[x + 1][y] == PASSABLE) {\n            grid[x + 1][y] = APPLE;\n        } else if (y > 0 && grid[x][y - 1] == PASSABLE) {\n            grid[x][y - 1] = APPLE;\n        } else if (y < m - 1 && grid[x][y + 1] == PASSABLE) {\n            grid[x][y + 1] = APPLE;\n        } else {\n            // Place apple somewhere else\n            for (int i = 0; i < n && grid[x][y] != APPLE; ++i)\n                for (int j = 0; j < m && grid[x][y] != APPLE; ++j)\n                    if (grid[i][j] == PASSABLE)\n                        grid[i][j] = APPLE;\n        }\n\n    } else if (test_type == \"maximal_moves\") {\n        // Place snake's head at (0, 0)\n        grid[0][0] = '1';\n        int idx = 1;\n        // Place snake segments along first row\n        for (int j = 1; j < snake_length && j < m; ++j) {\n            grid[0][j] = '1' + idx++;\n        }\n        if (idx < snake_length) {\n            // Place remaining segments in next rows\n            for (int i = 1; i < n && idx < snake_length; ++i)\n                grid[i][m - 1] = '1' + idx++;\n        }\n\n        // Place apple at bottom-right corner\n        grid[n - 1][m - 1] = APPLE;\n\n    } else if (test_type == \"edge_n1\") {\n        // n = 1\n        n = 1;\n        ensure(m >= snake_length + 1);\n        grid.assign(n, string(m, PASSABLE));\n\n        for (int j = 0; j < snake_length; ++j) {\n            grid[0][j] = '1' + j;\n        }\n\n        grid[0][m - 1] = APPLE;\n\n    } else if (test_type == \"edge_m1\") {\n        // m = 1\n        m = 1;\n        ensure(n >= snake_length + 1);\n        grid.assign(n, string(m, PASSABLE));\n\n        for (int i = 0; i < snake_length; ++i) {\n            grid[i][0] = '1' + i;\n        }\n\n        grid[n - 1][0] = APPLE;\n\n    } else if (test_type == \"maximal_snake\") {\n        snake_length = 9;\n        // Place snake in a line\n        int x = 0, y = 0;\n        for (int i = 0; i < snake_length; ++i) {\n            if (y >= m) {\n                x++;\n                y = 0;\n            }\n            grid[x][y++] = '1' + i;\n        }\n\n        // Place apple far from head\n        for (int i = n - 1; i >= 0; --i)\n            for (int j = m - 1; j >= 0; --j)\n                if (grid[i][j] == PASSABLE) {\n                    grid[i][j] = APPLE;\n                    i = -1;\n                    break;\n                }\n\n    } else if (test_type == \"minimal_snake\") {\n        snake_length = 3;\n        // Place snake in a corner\n        int x = 0, y = 0;\n        grid[x][y] = '1';\n        grid[x][y + 1] = '2';\n        grid[x][y + 2] = '3';\n\n        // Place apple far from head\n        for (int i = n - 1; i >= 0; --i)\n            for (int j = m - 1; j >= 0; --j)\n                if (grid[i][j] == PASSABLE) {\n                    grid[i][j] = APPLE;\n                    i = -1;\n                    break;\n                }\n\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst char WALL = '#';\nconst char PASSABLE = '.';\nconst char APPLE = '@';\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int snake_length = opt<int>(\"snake_length\", 5); // default to 5\n    string test_type = opt<string>(\"test_type\", \"random\");\n\n    // Ensure constraints\n    ensure(1 <= n && n <= 15);\n    ensure(1 <= m && m <= 15);\n    ensure(3 <= snake_length && snake_length <= 9);\n\n    vector<string> grid(n, string(m, PASSABLE));\n\n    if (test_type == \"random\") {\n        // Random walls\n        int wall_percentage = rnd.next(10, 30); // 10% to 30% walls\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (rnd.next(100) < wall_percentage) {\n                    grid[i][j] = WALL;\n                }\n            }\n        }\n\n        // Collect passable positions\n        vector<pair<int, int>> passable_positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (grid[i][j] == PASSABLE)\n                    passable_positions.push_back({i, j});\n\n        // Ensure enough passable squares\n        if (passable_positions.size() < snake_length + 1) {\n            // Not enough passable squares, clear walls\n            grid.assign(n, string(m, PASSABLE));\n            passable_positions.clear();\n            for (int i = 0; i < n; ++i)\n                for (int j = 0; j < m; ++j)\n                    passable_positions.push_back({i, j});\n        }\n\n        // Place apple\n        int apple_idx = rnd.next(passable_positions.size());\n        int apple_x = passable_positions[apple_idx].first;\n        int apple_y = passable_positions[apple_idx].second;\n        grid[apple_x][apple_y] = APPLE;\n        passable_positions.erase(passable_positions.begin() + apple_idx);\n\n        // Generate snake\n        vector<vector<bool>> used(n, vector<bool>(m, false));\n        vector<pair<int, int>> snake_positions;\n\n        // Start from random position\n        int start_idx = rnd.next(passable_positions.size());\n        int x = passable_positions[start_idx].first;\n        int y = passable_positions[start_idx].second;\n        used[x][y] = true;\n        snake_positions.push_back({x, y});\n\n        while ((int)snake_positions.size() < snake_length) {\n            vector<pair<int, int>> neighbors;\n            const int dx[4] = {0, 0, 1, -1};\n            const int dy[4] = {1, -1, 0, 0};\n            for (int dir = 0; dir < 4; dir++) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                    if (grid[nx][ny] != WALL && !used[nx][ny]) {\n                        neighbors.push_back({nx, ny});\n                    }\n                }\n            }\n            if (neighbors.empty()) {\n                break;\n            }\n            int idx = rnd.next(neighbors.size());\n            x = neighbors[idx].first;\n            y = neighbors[idx].second;\n            used[x][y] = true;\n            snake_positions.push_back({x, y});\n        }\n\n        // If snake is too short, extend it manually\n        while ((int)snake_positions.size() < snake_length) {\n            for (int i = 0; i < n && (int)snake_positions.size() < snake_length; ++i)\n                for (int j = 0; j < m && (int)snake_positions.size() < snake_length; ++j)\n                    if (grid[i][j] == PASSABLE && !used[i][j]) {\n                        used[i][j] = true;\n                        snake_positions.push_back({i, j});\n                    }\n            break;\n        }\n\n        // Place snake segments\n        for (int i = 0; i < (int)snake_positions.size(); ++i) {\n            int xi = snake_positions[i].first;\n            int yi = snake_positions[i].second;\n            grid[xi][yi] = '1' + i;\n        }\n\n    } else if (test_type == \"blocked_by_walls\") {\n        // Create walls separating snake and apple\n        int barrier_row = rnd.next(1, n - 2);\n        for (int j = 0; j < m; ++j) {\n            grid[barrier_row][j] = WALL;\n        }\n\n        // Place snake above barrier\n        int x = rnd.next(0, barrier_row - 1);\n        int y = rnd.next(0, m - 1);\n        vector<pair<int, int>> snake_positions = {{x, y}};\n        grid[x][y] = '1';\n        for (int i = 1; i < snake_length; ++i) {\n            if (x + i < barrier_row) {\n                grid[x + i][y] = '1' + i;\n                snake_positions.push_back({x + i, y});\n            } else {\n                break;\n            }\n        }\n\n        // Place apple below barrier\n        int ax = rnd.next(barrier_row + 1, n - 1);\n        int ay = rnd.next(0, m - 1);\n        grid[ax][ay] = APPLE;\n\n    } else if (test_type == \"blocked_by_self\") {\n        // Snake loops around itself\n        // Create a small area for the snake to occupy completely\n        int size = snake_length / 2 + 1;\n        int start_x = rnd.next(0, n - size);\n        int start_y = rnd.next(0, m - size);\n        int idx = 0;\n\n        for (int i = 0; i < size && idx < snake_length; ++i) {\n            grid[start_x + i][start_y] = '1' + idx++;\n        }\n        for (int j = 1; j < size && idx < snake_length; ++j) {\n            grid[start_x + size - 1][start_y + j] = '1' + idx++;\n        }\n        for (int i = size - 2; i >= 0 && idx < snake_length; --i) {\n            grid[start_x + i][start_y + size - 1] = '1' + idx++;\n        }\n        for (int j = size - 2; j > 0 && idx < snake_length; --j) {\n            grid[start_x][start_y + j] = '1' + idx++;\n        }\n\n        // Place apple inside the loop, unreachable\n        int ax = start_x + 1;\n        int ay = start_y + 1;\n        grid[ax][ay] = APPLE;\n\n    } else if (test_type == \"minimal_moves\") {\n        // Place apple next to snake's head\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = '1'; // Snake head\n\n        // Place remaining snake segments\n        int idx = 1;\n        if (x + snake_length - 1 < n) {\n            for (int i = 1; i < snake_length; ++i) {\n                grid[x + i][y] = '1' + idx++;\n            }\n        } else {\n            for (int i = 1; i < snake_length; ++i) {\n                grid[x][(y + i) % m] = '1' + idx++;\n            }\n        }\n\n        // Place apple next to head\n        if (x > 0 && grid[x - 1][y] == PASSABLE) {\n            grid[x - 1][y] = APPLE;\n        } else if (x < n - 1 && grid[x + 1][y] == PASSABLE) {\n            grid[x + 1][y] = APPLE;\n        } else if (y > 0 && grid[x][y - 1] == PASSABLE) {\n            grid[x][y - 1] = APPLE;\n        } else if (y < m - 1 && grid[x][y + 1] == PASSABLE) {\n            grid[x][y + 1] = APPLE;\n        } else {\n            // Place apple somewhere else\n            for (int i = 0; i < n && grid[x][y] != APPLE; ++i)\n                for (int j = 0; j < m && grid[x][y] != APPLE; ++j)\n                    if (grid[i][j] == PASSABLE)\n                        grid[i][j] = APPLE;\n        }\n\n    } else if (test_type == \"maximal_moves\") {\n        // Place snake's head at (0, 0)\n        grid[0][0] = '1';\n        int idx = 1;\n        // Place snake segments along first row\n        for (int j = 1; j < snake_length && j < m; ++j) {\n            grid[0][j] = '1' + idx++;\n        }\n        if (idx < snake_length) {\n            // Place remaining segments in next rows\n            for (int i = 1; i < n && idx < snake_length; ++i)\n                grid[i][m - 1] = '1' + idx++;\n        }\n\n        // Place apple at bottom-right corner\n        grid[n - 1][m - 1] = APPLE;\n\n    } else if (test_type == \"edge_n1\") {\n        // n = 1\n        n = 1;\n        ensure(m >= snake_length + 1);\n        grid.assign(n, string(m, PASSABLE));\n\n        for (int j = 0; j < snake_length; ++j) {\n            grid[0][j] = '1' + j;\n        }\n\n        grid[0][m - 1] = APPLE;\n\n    } else if (test_type == \"edge_m1\") {\n        // m = 1\n        m = 1;\n        ensure(n >= snake_length + 1);\n        grid.assign(n, string(m, PASSABLE));\n\n        for (int i = 0; i < snake_length; ++i) {\n            grid[i][0] = '1' + i;\n        }\n\n        grid[n - 1][0] = APPLE;\n\n    } else if (test_type == \"maximal_snake\") {\n        snake_length = 9;\n        // Place snake in a line\n        int x = 0, y = 0;\n        for (int i = 0; i < snake_length; ++i) {\n            if (y >= m) {\n                x++;\n                y = 0;\n            }\n            grid[x][y++] = '1' + i;\n        }\n\n        // Place apple far from head\n        for (int i = n - 1; i >= 0; --i)\n            for (int j = m - 1; j >= 0; --j)\n                if (grid[i][j] == PASSABLE) {\n                    grid[i][j] = APPLE;\n                    i = -1;\n                    break;\n                }\n\n    } else if (test_type == \"minimal_snake\") {\n        snake_length = 3;\n        // Place snake in a corner\n        int x = 0, y = 0;\n        grid[x][y] = '1';\n        grid[x][y + 1] = '2';\n        grid[x][y + 2] = '3';\n\n        // Place apple far from head\n        for (int i = n - 1; i >= 0; --i)\n            for (int j = m - 1; j >= 0; --j)\n                if (grid[i][j] == PASSABLE) {\n                    grid[i][j] = APPLE;\n                    i = -1;\n                    break;\n                }\n\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 3 -snake_length 3 -test_type random\n./gen -n 3 -m 3 -snake_length 3 -test_type minimal_moves\n./gen -n 15 -m 15 -snake_length 5 -test_type maximal_moves\n./gen -n 15 -m 15 -snake_length 9 -test_type blocked_by_walls\n./gen -n 1 -m 10 -snake_length 3 -test_type edge_n1\n./gen -n 10 -m 1 -snake_length 3 -test_type edge_m1\n./gen -n 10 -m 10 -snake_length 8 -test_type blocked_by_self\n./gen -n 15 -m 15 -snake_length 9 -test_type maximal_snake\n./gen -n 15 -m 15 -snake_length 3 -test_type minimal_snake\n./gen -n 5 -m 5 -snake_length 5 -test_type random\n./gen -n 7 -m 7 -snake_length 4 -test_type minimal_moves\n./gen -n 7 -m 7 -snake_length 7 -test_type blocked_by_walls\n./gen -n 5 -m 5 -snake_length 5 -test_type blocked_by_self\n./gen -n 9 -m 9 -snake_length 6 -test_type maximal_moves\n./gen -n 10 -m 10 -snake_length 9 -test_type random\n./gen -n 15 -m 15 -snake_length 5 -test_type minimal_snake\n./gen -n 3 -m 3 -snake_length 3 -test_type maximal_snake\n./gen -n 12 -m 12 -snake_length 8 -test_type random\n./gen -n 8 -m 8 -snake_length 5 -test_type minimal_moves\n./gen -n 14 -m 14 -snake_length 7 -test_type blocked_by_walls\n./gen -n 13 -m 13 -snake_length 9 -test_type blocked_by_self\n./gen -n 2 -m 15 -snake_length 4 -test_type edge_n1\n./gen -n 15 -m 2 -snake_length 4 -test_type edge_m1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:47.692247",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "225/E",
      "title": "E. Неразрешимость",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 40).",
      "output_spec": "Выходные данныеВыведите единственное целое число — остаток от деления числа zn на 1000000007 (109 + 7). Гарантируется, что ответ существует.",
      "sample_tests": "ПримерыВходные данныеСкопировать1Выходные данныеСкопировать1Входные данныеСкопировать2Выходные данныеСкопировать3Входные данныеСкопировать3Выходные данныеСкопировать15",
      "description": "E. Неразрешимость\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 40).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — остаток от деления числа zn на 1000000007 (109 + 7). Гарантируется, что ответ существует.\n\nВыходные данные\n\nВходные данныеСкопировать1Выходные данныеСкопировать1Входные данныеСкопировать2Выходные данныеСкопировать3Входные данныеСкопировать3Выходные данныеСкопировать15\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать15\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #139 (div2) - Codeforces",
          "content": "Привет всем!Это 139 раунд на Codeforces специально для 2го дивизиона. Участники из 1го дивизиона могут принять в нем участие вне конкурса.Раунд готовили Ripatti , Gerald , Delinur.Разбалловка будет динамической, но задачи будут расположены в предполагаемом порядке увеличения сложности.Удачи!UPD. По техническим причинам контест откладывается на 15 минут.UPD2. Тестирование завершено. Победители:1. wccy2. ttl3. shubhanshu4. Atarashi_Ako5. dvylfz921 2 участника решили все предложенные задачи.Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5317",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 500
        },
        {
          "title": "Разбор задач Codeforces Round #139 - Codeforces",
          "content": "A. Будем идти сверху вниз и восстанавливать ответ. Нижнюю грань 1й кости восстановить легко. Далее по двум граням 2й кости можно установить какая пара чисел должна быть на верхней и нижней грани. Если одно из чисел совпадает с числов на нижней грани 1й кости, то 2я кость восстанавливается однозначно, и так далее. Если мы смогли восстановить все кости — выводим YES. Если где то возникла неоднозначность, то можно показать, что эта однозначность будет сохраняться и для всех последующих костей. То есть получится хотя бы 2 разничных ответа, поэтому нужно выводить NO.Автор — Ripatti .B. Сначала сгенерируем все числа k-боначчи, не превышающие n. Для k ≤ 32 это можно сделать в лоб, а для больших k можно заметить, что числа k-боначчи до 109 являются только степени двойки (и еще 0). Итого получим не более 100 чисел.Далее предлагается действовать жадно — отнимать от n самое большое число k-боначчи, не превышающее n до тех пор, пока не разложим полностью.Почему все полученные числа будут различны? Вот одно из возможных доказательств:F(k, n) = F(k, n - 1) + F(k, n - 2) + ... + F(k, n - k)F(k, n - 1) = F(k, n - 2) + F(k, n - 3) + ... + F(k, n - k - 1)Вычтеми из 1го равенства 2е и получим F(k, n) + F(k, n - k - 1) = 2F(k, n - 1), то есть 2F(k, n - 1) ≥ F(k, n). Это неравенство так же справедливо и для n ≤ k.теперь предположим, что жадный алгоритм даст 2 одинаковых числа F(k, x) в разложении. Но тогда, в силу неравенства, мы должны были взять число F(k, x + 1). Противоречие.Впрочем, доказывать это не требовалось, можно было просто поверить что жадность пройдет:)Авторы — Gerald , Ripatti .C. Сначала посчитаем число белых и черных пикселов в каждом столбике. После этого посчитаем сумму черных и белых пикселов на каждом префиксе в последовательности столбиков. Это позволит нам за O(1) вычислять количество черных и белых пикселов на любом отрезке столбиков.Далее воспользуемся динамическим программированием. dp[i][j] будет хранить наименьшее число перекрашиваемых пикселов на префиксе от 1го столбика до j-го, причем цвет последней полосы будет белым для i = 0 и черным для i = 1.Далее dp пересчитывается следующим образом: dp[0][0] = dp[1][0] = 0 Ответом будет min(dp[0][m], dp[1][m]).Итого решение за O(nm + m * (y - x)).Автор — Ripatti .D. Обычный поиск в ширину. Состояние — положение головы + маска, которая задает положение хвоста, а именно: двумя битами кодируется относительное положение каждого сегмента (кроме головы) относительно предыдущего. Итого в маске максимум 16 бит, оценка на общее число состояний — 48 × 15 × 15 (на самом деле можно даже показать оценку порядка 38 × 15 × 15).Далее нужно просто все очень аккуратно реализовать.Автор — Ripatti .E. Дано: z = [x / 2] + y + xy. Это равносильноz = [2k / 2] + y + 2ky, где x = 2k, k > 0илиz = [(2k + 1) / 2] + y + (2k + 1)y, где x = 2k + 1, k ≥ 0.Преобразуем:z = k + y + 2ky, k > 0илиz = k + y + (2k + 1)y, k ≥ 0.Еще пару шагов:2z + 1 = 2k + 2y + 4ky + 1, k > 0илиz + 1 = k + 2y + 2ky + 1, k ≥ 0.2z + 1 = (2k + 1)(2y + 1), k > 0илиz + 1 = (2y + 1)(k + 1), k ≥ 0.Из второго уравнения видно, что z должно быть вида 2t - 1, иначе z + 1 имеет нечетный делитель и мы можем подобрать решение. Из первого же уравнения получаем, что 2t + 1 - 1 должно быть простым, иначе опять можно подобрать решение. Если же z = 2t - 1, а 2t + 1 - 1 — простое, то очевидно, что уравнение неразрешимо.Простые числа вида 2a - 1 являются простыми числами Мерсенна, на данный момент найдено всего 46 чисел такого вида. Показатели степени для первых 40 из них можно найти, например, здесь.Автор — Ripatti .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5322",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3556
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 1",
          "code": "1, 2, 4, 6, 12, 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 2",
          "code": "typedef long long i64;\ni64 K;\ni64 S;\n\ni64 F(i64 n) {\n  if (n >=1 && n < K)\n    return 0;\n  if (n==K)\n    return 1;\n  i64 ans = 0;\n  while(n > K) {\n    ans += F(n-1);\n    --n;\n  }\n  return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"139_B.in\",\"r\", stdin);\n#endif\n\n  cin>>S>>K;\n  for(int i = 1; i <= 15; ++i) {\n    cout<<F(i)<<endl;\n  }\n\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 3",
          "code": "typedef long long i64;\ni64 K;\ni64 S;\n\ni64 F(i64 n) {\n  if (n >=1 && n < K)\n    return 0;\n  if (n==K)\n    return 1;\n  i64 ans = 0;\n  while(n > K) {\n    ans += F(n-1);\n    --n;\n  }\n  return ans;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"139_B.in\",\"r\", stdin);\n#endif\n\n  cin>>S>>K;\n  for(int i = 1; i <= 15; ++i) {\n    cout<<F(i)<<endl;\n  }\n\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 4",
          "code": "while(n > K)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 5",
          "code": "FOR(x,n-K-1,n-1) {\n    if (x < 0)\n      break;\n    ans += F(x);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #139 (div2) - Codeforces - Code 6",
          "code": "FOR(x,n-K-1,n-1) {\n    if (x < 0)\n      break;\n    ans += F(x);\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5317",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #139 - Codeforces - Code 1",
          "code": "15 15\n@..............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n.............9.\n.............8.\n...........567.\n.............",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5322",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #139 - Codeforces - Code 2",
          "code": "15 15\n@..............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n.............9.\n.............8.\n...........567.\n.............",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5322",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #139 - Codeforces - Code 3",
          "code": "15 15\n@..............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n.............9.\n.............8.\n...........567.\n...........4321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5322",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #139 - Codeforces - Code 4",
          "code": "15 15\n@..............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n...............\n.............9.\n.............8.\n...........567.\n...........4321",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5322",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #139 - Codeforces - Code 5",
          "code": "15 15\n...#####......#\n.##...##.#.#.##\n.##.#.#.......#\n.##.....#######\n.######.#......\n....###.####.#.\n#.#.###.####...\n#..........##.#\n#.###########.#\n#..##...#......\n##....#.#.##.#.\n##.##......#...\n##############.\n#@987654321....\n##########...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5322",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #139 - Codeforces - Code 6",
          "code": "15 15\n...#####......#\n.##...##.#.#.##\n.##.#.#.......#\n.##.....#######\n.######.#......\n....###.####.#.\n#.#.###.####...\n#..........##.#\n#.###########.#\n#..##...#......\n##....#.#.##.#.\n##.##......#...\n##############.\n#@987654321....\n##########...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5322",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #139 - Codeforces - Code 7",
          "code": "0 0 ... 0 1 1 2 4 8 16 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5322",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 40, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    int n;\n    if (type == \"small\") {\n        n = 1;\n    } else if (type == \"large\") {\n        n = 40;\n    } else if (type == \"middle\") {\n        n = 20;\n    } else if (type == \"custom\") {\n        n = opt<int>(\"n\");\n        ensure(1 <= n && n <= 40); // Ensure n is within the constraints\n    } else {\n        // For random type or any other unspecified type\n        n = rnd.next(1, 40);\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    int n;\n    if (type == \"small\") {\n        n = 1;\n    } else if (type == \"large\") {\n        n = 40;\n    } else if (type == \"middle\") {\n        n = 20;\n    } else if (type == \"custom\") {\n        n = opt<int>(\"n\");\n        ensure(1 <= n && n <= 40); // Ensure n is within the constraints\n    } else {\n        // For random type or any other unspecified type\n        n = rnd.next(1, 40);\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type small\n./gen -type large\n./gen -type middle\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type custom -n 1\n./gen -type custom -n 2\n./gen -type custom -n 3\n./gen -type custom -n 4\n./gen -type custom -n 5\n./gen -type custom -n 10\n./gen -type custom -n 15\n./gen -type custom -n 20\n./gen -type custom -n 25\n./gen -type custom -n 30\n./gen -type custom -n 35\n./gen -type custom -n 40\n\n# Edge cases near the boundaries\n./gen -type custom -n 1\n./gen -type custom -n 2\n./gen -type custom -n 39\n./gen -type custom -n 40\n\n# Additional specific cases\n./gen -type custom -n 6\n./gen -type custom -n 7\n./gen -type custom -n 8\n./gen -type custom -n 9\n./gen -type custom -n 37\n./gen -type custom -n 38\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:49.338842",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "226/A",
      "title": "A. Flying Saucer Segments",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers: n and m (1 ≤ n, m ≤ 109) — the number of aliens on the saucer and the number, modulo which you should print the answer, correspondingly.",
      "output_spec": "OutputPrint a single number — the answer to the problem modulo m.",
      "sample_tests": "ExamplesInputCopy1 10OutputCopy2InputCopy3 8OutputCopy2",
      "description": "A. Flying Saucer Segments\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers: n and m (1 ≤ n, m ≤ 109) — the number of aliens on the saucer and the number, modulo which you should print the answer, correspondingly.\n\nOutputPrint a single number — the answer to the problem modulo m.\n\nInputCopy1 10OutputCopy2InputCopy3 8OutputCopy2\n\nInputCopy1 10\n\nOutputCopy2\n\nInputCopy3 8\n\nOutputCopy2\n\nNoteIn the first sample the only crew member moves from segment 3 to segment 2, and then from segment 2 to segment 1 without any problems. Thus, the whole moving will take two minutes.To briefly describe the movements in the second sample we will use value , which would correspond to an alien with rank i moving from the segment in which it is at the moment, to the segment number j. Using these values, we will describe the movements between the segments in the second sample: , , , , , , , , , , , , , , , , , , , , , , , , , ; In total: the aliens need 26 moves. The remainder after dividing 26 by 8 equals 2, so the answer to this test is 2.",
      "solutions": [
        {
          "title": "Codeforces Round #140 - Codeforces",
          "content": "Hello everyone!Today, at 19:30 MSK Codeforces Round #140 will take place. The competition will be held in both divisions.I'am the author of today's competition. My name is Ilya Malinovsky, I'm student of Saint-Petersburg State University. This is my first Codeforces round.I want to express my gratitude to Gerald Agapov (Gerald) for his help during the work on the round, Maria Belova (Delinur) for statements' translation from Russian into English, Mikhail Mirzayanov (MikeMirzayanov) for the possibility to prerare contests (and, of course, to compete in them) here, on Codeforces. As usual, in most of the problems participants will help different characters to cope with their troubles and misfortunes. You will have only two hours to help epical hero, an alien, noble knight and other characters. Also, insidious stone heaps will resist you in one of the problems...I hope, most of participants will enjoy the tasks.Good luck!P.S. Information about score distribution will appear not long before the round starts.upd. Score distribution is stadart (500-1000-1500-2000-2500) in both divisions.upd 2 Round is over! Congratulations for winners!div1: peter50216 Dmitry_Egorov Egor RAVEman bmerry Winners have from 3 to 4 solved problems. Noone managed to solve E.div2: Velicue (he is the only div2-participant, who got 5 \"OK\"s) Frommi Aerolight Shahriar_sust bzdbz Thanks to everyone for participating! I hope, you've enjoeyd the round. Full editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1454
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #140 - Codeforces - Code 1",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 2",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 3",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 4",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 5",
          "code": "V1 if C else V2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 6",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 7",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 8",
          "code": "((VALUE%m)+m)%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 9",
          "code": "-1 % 5 == 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 10",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 11",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 12",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 13",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Set n\n    if (n == -1) {\n        if (type == \"min\") {\n            n = 1;\n        } else if (type == \"max\") {\n            n = 1000000000;\n        } else {\n            n = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Set m\n    if (m == -1) {\n        if (type == \"min\") {\n            m = 1;\n        } else if (type == \"max\") {\n            m = 1000000000;\n        } else if (type == \"small_m\") {\n            m = rnd.next(1, 10);\n        } else if (type == \"m_is_one\") {\n            m = 1;\n        } else if (type == \"m_is_prime\") {\n            m = 999999937; // large prime\n        } else if (type == \"n_equals_m\") {\n            m = n;\n        } else {\n            m = rnd.next(1, 1000000000);\n        }\n    } else {\n        if (type == \"n_equals_m\") {\n            n = m;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Set n\n    if (n == -1) {\n        if (type == \"min\") {\n            n = 1;\n        } else if (type == \"max\") {\n            n = 1000000000;\n        } else {\n            n = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Set m\n    if (m == -1) {\n        if (type == \"min\") {\n            m = 1;\n        } else if (type == \"max\") {\n            m = 1000000000;\n        } else if (type == \"small_m\") {\n            m = rnd.next(1, 10);\n        } else if (type == \"m_is_one\") {\n            m = 1;\n        } else if (type == \"m_is_prime\") {\n            m = 999999937; // large prime\n        } else if (type == \"n_equals_m\") {\n            m = n;\n        } else {\n            m = rnd.next(1, 1000000000);\n        }\n    } else {\n        if (type == \"n_equals_m\") {\n            n = m;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test Case 1: Minimal n and m\n./gen -type min\n\n# Test Case 2: Maximal n and m\n./gen -type max\n\n# Test Case 3: Small n and m\n./gen -n 5 -m 7\n\n# Test Case 4: Random n and m\n./gen\n\n# Test Case 5: Small n, large m\n./gen -n 10 -m 1000000000\n\n# Test Case 6: Large n, small m\n./gen -n 1000000000 -type small_m\n\n# Test Case 7: m is one\n./gen -n 500000000 -type m_is_one\n\n# Test Case 8: m is large prime\n./gen -n 999999999 -type m_is_prime\n\n# Test Case 9: n equals m\n./gen -type n_equals_m\n\n# Test Case 10: n equals m, large values\n./gen -n 999999999 -type n_equals_m\n\n# Test Case 11: n is m minus one\n./gen -n 999999999 -m 1000000000\n\n# Test Case 12: Random n, small m\n./gen -m 5\n\n# Test Case 13: Random n, random m\n./gen\n\n# Test Case 14: n is maximum, m is minimum\n./gen -n 1000000000 -m 1\n\n# Test Case 15: n and m are large values\n./gen -n 999999000 -m 999999500\n\n# Test Case 16: n is maximum, m is random\n./gen -n 1000000000\n\n# Test Case 17: n is random, m is maximum\n./gen -m 1000000000\n\n# Test Case 18: n and m are consecutive\n./gen -n 500000000 -m 500000001\n\n# Test Case 19: n is 1, m is maximum\n./gen -n 1 -m 1000000000\n\n# Test Case 20: n is maximum, m is 1\n./gen -n 1000000000 -m 1\n\n# Test Case 21: n is random, m is small prime\n./gen -m 7\n\n# Test Case 22: n is small, m is small\n./gen -n 2 -m 3\n\n# Test Case 23: Both n and m are maximum prime numbers less than 1e9\n./gen -n 999999937 -m 999999937\n\n# Test Case 24: Random test case\n./gen\n\n# Test Case 25: Random test case\n./gen\n\n# Test Case 26: Random test case\n./gen\n\n# Test Case 27: Random test case\n./gen\n\n# Test Case 28: Random test case\n./gen\n\n# Test Case 29: Random test case\n./gen\n\n# Test Case 30: Random test case\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:51.016870",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "226/B",
      "title": "B. Непослушные кучки камней",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество кучек камней. Во второй строке записаны n целых чисел через пробел: a1, a2, ..., an (1 ≤ ai ≤ 109) — первоначальные размеры кучек камней. В третьей строке записано целое число q (1 ≤ q ≤ 105) — количество запросов. В последней строке — q целых чисел через пробел k1, k2, ..., kq (1 ≤ ki ≤ 105) — значения числа k для разных запросов. Обратите внимание, числа ki могут повторяться.",
      "output_spec": "Выходные данныеВыведите q чисел — ответы на запросы в том порядке, в котором запросы заданы во входных данных. Выведенные числа разделяйте пробельными символами.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать52 3 4 1 122 3Выходные данныеСкопировать9 8",
      "description": "B. Непослушные кучки камней\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество кучек камней. Во второй строке записаны n целых чисел через пробел: a1, a2, ..., an (1 ≤ ai ≤ 109) — первоначальные размеры кучек камней. В третьей строке записано целое число q (1 ≤ q ≤ 105) — количество запросов. В последней строке — q целых чисел через пробел k1, k2, ..., kq (1 ≤ ki ≤ 105) — значения числа k для разных запросов. Обратите внимание, числа ki могут повторяться.\n\nВходные данные\n\nВыходные данныеВыведите q чисел — ответы на запросы в том порядке, в котором запросы заданы во входных данных. Выведенные числа разделяйте пробельными символами.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать52 3 4 1 122 3Выходные данныеСкопировать9 8\n\nВходные данныеСкопировать52 3 4 1 122 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9 8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом случае одним из способов достижения оптимального ответа является следующий: поочередно добавить 4-ю и 5-ю кучки ко 2-й; затем добавить 1-ю кучку к 3-й; добавить 2-ю кучку к 3-й. Первые две операции стоят по 1; третья — 2, четвертая — 5 (размер 2-й кучки после первых двух операций уже не 3, а 5). Во втором случае можно добавить 2-ю кучку к 3-й (стоимость операции — 3); затем 1-ю к 3-й (стоимость — 2); далее 5-ю к 4-й (стоимость — 1); и, наконец, 4-ю к 3-й (стоимость — 2).",
      "solutions": [
        {
          "title": "Codeforces Round #140 - Codeforces",
          "content": "Всем привет!Сегодня в 19:30 по Московскому времени состоится 140-й раунд Codeforces. Соревнование пройдет в обоих дивизионах.Автором задач сегодняшнего раунда являюсь я, Илья Малиновский, студент 1-го курса мат-меха СПбГУ. Это мой первый контест на Codeforces.Хочется поблагодарить Геральда Агапова (Gerald) за колоссальную помощь в подготовке раунда, Марию Белову (Delinur) за перевод условий на английский язык и Михаила Мирзаянова (MikeMirzayanov) за саму возможность готовить контесты (а также в них участвовать) на базе Codeforces.Участникам предстоит традиционно выступить в роли спасителей всех и вся от разнообразных бед и невзгод. У вас будет два часа на то, чтобы помочь былинному богатырю, инопланетянину, благородному рыцарю и другим персонажам. Кроме того, в одной из задач найдется место и антагонистам: в их роли выступят коварные кучки камней...Надеюсь, что задачи понравятся всем участникам (зачем хотеть того, чего не бывает) подавляющему большинству участников.Успехов!P.S. Информация о разбалловке появится незадолго до начала раунда.upd. Разбалловка стандартная в обоих дивизионах.upd 2 Раунд завершён! Поздравляем победителей!div1: peter50216 Dmitry_Egorov Egor RAVEman bmerry У победителей по 3-4 задачи. Задача E не покорилась ни одному участнику.div2: Velicue (он единственный в дивизионе сдал все 5 задач) Frommi Aerolight Shahriar_sust bzdbz Всем спасибо за участие! Надеюсь, в целом все понравилось. До новых встреч!P.S. Разбор будет опубликован завтра вечером.Полный разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1502
        },
        {
          "title": "Разбор задач Codeforces Round #140 - Codeforces",
          "content": "A div2. Куда свернуть?Посмотрим на векторное произведение на , численно равное . Знак векторного произведения определяется знаком синуса ориентированного угла между векторами (т.к. векторное произведение также равно ), а именно этот-то знак нам и нужно узнать.Если произведение равно нулю, то это в данной задаче означает, что A, B и C лежат на одной прямой, а значит ответ — <>.Если произведение больше нуля, то ответ — <>.И, наконец, если оно меньше нуля, то ответ — <>.Также стоит обратить внимание, что вычисление векторного произведения требуется производить в 64-битном типе, чтобы избежать переполнения.РешениеB div2. Эффективный подходПусть число t стоит на позиции indt в первоначальной перестановке. Тогда, очевидно, пробегом слева направо это число будет найдено за indt сравнений, а пробегом справа налево — за n - indt + 1 сравнений. Заведем доп.массив, в i-й ячейке которого будет стоять число j такое, что aj = i. Этот массив позволит обрабатывать каждый запрос за O(1) при помощи указанных выше формул. Доп. массив строится за O(n) пробегом по массиву a. Таким образом, окончательная асимптотика решения O(n + m).РешениеC div2 — A div1. Отсеки летающей тарелки.Обозначим за Fn ответ на задачу, где n — число инопланетян. Давайте предположим, что мы уже решили задачу для n - 1 инопланетянина, т.е. знаем значение Fn - 1. Попытаемся найти его для n инопланетян. Заметим, что младший по рангу (далее — просто младший) инопланетянин сможет покинуть 3-й отсек только тогда, когда все остальные инопланетяне перейдут в 1-й отсек. Значит, первые Fn - 1 действий нам известны. Далее младший инопланетянин может перейти во второй отсек. Чтобы он попал в 1-й отсек, требуется, чтобы остальные вернулись в первый. Значит, требуется еще Fn - 1 действий. Наконец, после того, как младший инопланетянин перейдет в 1-й отсек требуется еще Fn - 1 действий на возвращение n - 1 инопланетянина в 1-й отсек из 3-го. Таким образом, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. Это уже позволяет найти Fn быстрым возведением матрицы в степень, но мы пойдем чуть дальше. Прибавим по 1 к левой и правой части равенства и после элементарных преобразований получим Fn = 3·(Fn - 1 + 1) - 1. Теперь легко угадать решение рекуррентного соотношения: Fn = 3n - 1. Осталось научиться быстро вычислять значение Fn. В этом нам поможет бинарное возведение в степень. Асимптотика решения — O(log n).Осталось упомянуть один \"подводный камень\": если 3n mod m = 0, необходимо не забыть, что ответ равен m - 1, а не  - 1, и разобрать этот случай.И напоследок маленькая аналогия: перед вами только что была задача о Ханойских башнях с модификацией, заключающейся в том, что переносы дисков разрешены только между двумя парами стержней.РешениеD div2 — B div1. Непослушные кучки камнейРассмотрим следующую интерпретацию задачи: кучкам камней соответствуют вершины. Операции добавить кучку a к кучке b соответствует операция подвешивания поддерева вершины b к вершине a. Числа, записанные на вершинах, — размеры кучек. Задача — добиться такой конфигурации дерева, чтобы к каждой вершине было подвешено не более k поддеревьев, а сумма произведений чисел, записанных на вершинах, на глубину вершин (где глубина корня равна 0) минимальна. Чтобы добиться минимальности, требуется, во-первых, чтобы вершина с большим числом находилась не ниже, чем вершина с меньшим (иначе их можно просто поменять и получить меньшую сумму), а во-вторых, чтобы у каждой внутренней вершины, кроме, может быть, одной было ровно k потомков (второе условие также доказывается методом от противного). Осталось научиться быстро считать для такой конфигурации саму сумму. Для этого отсортируем массив размеров кучек, а затем будем действовать так: вначале прибавим к ответу сумму размеров кучек с 1-й по k-ю (в 0-индексированном, отсортированном в порядке невозрастания массиве), домноженную на 1; затем сумму размеров следующих k^2 кучек, домноженную на 2; и т.д. до конца массива. Чтобы быстро отвечать на запрос о сумме на отрезке, предподсчитаем суммы на префиксах сразу после того, как отсортируем массив. Теперь при k > 1 мы умеем находить ответ на запрос за O(log n). Если тем же соображениям следовать при k = 1, ответ на запрос будет занимать O(n) операций, а потому решение получит TL, если в большей части запросов k будет равно 1. Поэтому следует заранее посчитать ответ для k = 1 и запомнить его, чтобы отвечать на такие запросы за O(1).Асимптотика решения — O(n · log n  +  q · log n).РешениеE div2 — C div1. ЮбилейСначала докажем ключевое утверждение: НОД(Fn, Fm) = FНОД(n, m).Начнем издалека: выразим Fn + k через Fn и Fk. Получим следующую формулу: Fn + k = Fk·Fn + 1 + Fk - 1·Fn. Эта формула доказывается по индукции.Теперь воспользуемся полученной формулой и заметим, что НОД(Fn + k, Fn) = НОД(Fk, Fn). Осталось заметить в последней формулой аналогию с алгоритмом Евклида и осознать, что мы получили требуемое нам соотношение для НОД двух чисел Фибоначчи.Итак, мы свели задачу к следующей: найти в заданном множестве подмножество из k (или хотя бы из k) элементов с максимально возможным НОД. А точнее, найти сам НОД такого подмножества. Пусть ответ равен q. Тогда должно выполняться  -  ⌉ + 1 ≥ k (1).Заметим, что для каждого из слагаемых из левой части неравенства существует отрезков, на которых его значение постоянно. Причем мы можем найти все эти отрезки и значения за . Точнее, нас интересуют такие q, что в q - 1 значение хотя бы одного из слагаемых меняется (очевидно, увеличивается). Таких значений тоже . Осталось перебрать их все и каждое попробовать в роли ответа (т.е., для каждого проверить неравенство (1)), а из подошедших выбрать максимум. Ответ всегда будет, т.к. единица подходит на роль q при любых входных данных.Таким образом, мы нашли индекс искомого числа Фибоначчи. Само же число можно вычислить, быстро возведя матрицу в степень.РешениеАсимптотика решения — .D div1. Всего лишь таблица.Научимся получать ответ. Поступим следующим образом: будем находить любую строку или столбец с отрицательной суммой и инвертировать его/ее. Заметим, что сумма всех чисел в таблице после таких операций неизменно будет возрастать. Очевидно, что возрастать бесконечно сумма не может. За один шаг сумма возрастает хотя бы на 2, а максимальное возможное изменение суммы относительно начальной — 200·n·m. Таким образом, всего потребуется не более 100·n·m операций (применения заклинания), каждая из которых выполняется за время O(n) или O(m). Итак, мы научились получать нужную таблицу за ~ 1004 действий.Осталось восстановить ответ. Легко понять, что в него войдут те строки и столбцы, которые мы инвертировали нечётное число раз.РешениеE div1. Путь благородного рыцаряРешение 1Нетрудно догадаться, что замки образуют дерево. Построим на этом дереве heavy-light decomposition. Над каждым путем построим персистентное дерево отрезков на сумму. В вершине дерева отрезков будет храниться 0, если замок на текущий момент не тронут варварами, и 1 в противном случае.Каждый путь рыцаря можно при помощи нахождения lca разбить на не более чем два подпути, лежащие на пути от одного из концов маршрута к корню. Теперь будем решать задачу для каждого из подпутей отдельно. Будем последовательно обрабатывать пути из heavy-light decomposition и одиночные вершины, принадлежащие подпути. Нас интересует количество вершин на подпути, которые не посещались с года y + 1 по текущий, т.е. (в случае пути из декомпозиции) таких, что разность между значениями в текущей версии персистентного дерева и в версии, соответствующей году y (требуемая версия ищется бинпоиском в списке версий) равна нулю (случай с одиночной вершиной тривиальнее: достаточно просто хранить время посещения вершины). Как только количество подходящих вершин станет не меньше k, нам останется синхронно спуститься по двум версиям дерева, чтобы получить ответ.Если на первом подпути k-я вершина не найдена, то следует обратить внимание, что поскольку мы идем по дереву всегда снизу вверх, то надо аккуратно пересчитать номер вершины, чтобы узнать, какой она должна быть по счету на втором подпути, считая снизу вверх.Асимптотика решения: O(m·log2 n) — в каждом запросе первого типа нам может потребоваться обновить какое-нибудь дерево отрезков, на что уйдет O(log n) операций; в каждом запросе второго типа нам встречается O(log n) путей декомпозиции, каждый из которых обрабатывается за O(log n) (вначале бинпоиск по версиям, затем запрос к дереву/спуск по дереву).РеализацияРешение 2Обойдем дерево dfs'ом, записывая в массив номер вершины в моменты входа и выхода (аналогия с правильными скобочными последовательностями). Причем как записи о входе, так и записи о выходе сопоставим 0. На этом массиве построим персистентное дерево отрезков. Теперь, когда нам будет поступать запрос первого типа, будем сопоставлять позиции первого вхождения вершины в массив  + 1, а позиции последнего вхождения —  - 1.Для того чтобы научиться обрабатывать второй запрос, заметим, что для нахождения количества посещенных вершин на произвольном подпути между вершинами a и b такими, что обе вершина a лежит на пути от вершины b до корня, нам требуется найти сумму чисел, сопоставленных позициям между первыми вхождениями вершин в созданном обходом в глубину массиве.Теперь на каждом из подпутей в отдельности запустим двоичный поиск по ответу — позиции искомого замка. Для проверки ответа воспользуемся приведенным в предыдущем абзаце соображением.Асимптотика решения: O(m·log2 n) — в каждом запросе первого типа нам может потребоваться обновить дерево отрезков, на что уйдет O(log n) операций; в каждом запросе второго типа O(log n) итераций бинпоиска по ответу, каждая из которых обрабатывается за O(log n).Реализацияupd. Исправил маленькую неточность в неравенстве в разборе E div2 — C div1. В левой части добавился +1.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 9728
        },
        {
          "title": "Разбор задач Codeforces Round #140 - Codeforces",
          "content": "A div2. Куда свернуть?Посмотрим на векторное произведение на , численно равное . Знак векторного произведения определяется знаком синуса ориентированного угла между векторами (т.к. векторное произведение также равно ), а именно этот-то знак нам и нужно узнать.Если произведение равно нулю, то это в данной задаче означает, что A, B и C лежат на одной прямой, а значит ответ — <>.Если произведение больше нуля, то ответ — <>.И, наконец, если оно меньше нуля, то ответ — <>.Также стоит обратить внимание, что вычисление векторного произведения требуется производить в 64-битном типе, чтобы избежать переполнения.РешениеB div2. Эффективный подходПусть число t стоит на позиции indt в первоначальной перестановке. Тогда, очевидно, пробегом слева направо это число будет найдено за indt сравнений, а пробегом справа налево — за n - indt + 1 сравнений. Заведем доп.массив, в i-й ячейке которого будет стоять число j такое, что aj = i. Этот массив позволит обрабатывать каждый запрос за O(1) при помощи указанных выше формул. Доп. массив строится за O(n) пробегом по массиву a. Таким образом, окончательная асимптотика решения O(n + m).РешениеC div2 — A div1. Отсеки летающей тарелки.Обозначим за Fn ответ на задачу, где n — число инопланетян. Давайте предположим, что мы уже решили задачу для n - 1 инопланетянина, т.е. знаем значение Fn - 1. Попытаемся найти его для n инопланетян. Заметим, что младший по рангу (далее — просто младший) инопланетянин сможет покинуть 3-й отсек только тогда, когда все остальные инопланетяне перейдут в 1-й отсек. Значит, первые Fn - 1 действий нам известны. Далее младший инопланетянин может перейти во второй отсек. Чтобы он попал в 1-й отсек, требуется, чтобы остальные вернулись в первый. Значит, требуется еще Fn - 1 действий. Наконец, после того, как младший инопланетянин перейдет в 1-й отсек требуется еще Fn - 1 действий на возвращение n - 1 инопланетянина в 1-й отсек из 3-го. Таким образом, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. Это уже позволяет найти Fn быстрым возведением матрицы в степень, но мы пойдем чуть дальше. Прибавим по 1 к левой и правой части равенства и после элементарных преобразований получим Fn = 3·(Fn - 1 + 1) - 1. Теперь легко угадать решение рекуррентного соотношения: Fn = 3n - 1. Осталось научиться быстро вычислять значение Fn. В этом нам поможет бинарное возведение в степень. Асимптотика решения — O(log n).Осталось упомянуть один \"подводный камень\": если 3n mod m = 0, необходимо не забыть, что ответ равен m - 1, а не  - 1, и разобрать этот случай.И напоследок маленькая аналогия: перед вами только что была задача о Ханойских башнях с модификацией, заключающейся в том, что переносы дисков разрешены только между двумя парами стержней.РешениеD div2 — B div1. Непослушные кучки камнейРассмотрим следующую интерпретацию задачи: кучкам камней соответствуют вершины. Операции добавить кучку a к кучке b соответствует операция подвешивания поддерева вершины b к вершине a. Числа, записанные на вершинах, — размеры кучек. Задача — добиться такой конфигурации дерева, чтобы к каждой вершине было подвешено не более k поддеревьев, а сумма произведений чисел, записанных на вершинах, на глубину вершин (где глубина корня равна 0) минимальна. Чтобы добиться минимальности, требуется, во-первых, чтобы вершина с большим числом находилась не ниже, чем вершина с меньшим (иначе их можно просто поменять и получить меньшую сумму), а во-вторых, чтобы у каждой внутренней вершины, кроме, может быть, одной было ровно k потомков (второе условие также доказывается методом от противного). Осталось научиться быстро считать для такой конфигурации саму сумму. Для этого отсортируем массив размеров кучек, а затем будем действовать так: вначале прибавим к ответу сумму размеров кучек с 1-й по k-ю (в 0-индексированном, отсортированном в порядке невозрастания массиве), домноженную на 1; затем сумму размеров следующих k^2 кучек, домноженную на 2; и т.д. до конца массива. Чтобы быстро отвечать на запрос о сумме на отрезке, предподсчитаем суммы на префиксах сразу после того, как отсортируем массив. Теперь при k > 1 мы умеем находить ответ на запрос за O(log n). Если тем же соображениям следовать при k = 1, ответ на запрос будет занимать O(n) операций, а потому решение получит TL, если в большей части запросов k будет равно 1. Поэтому следует заранее посчитать ответ для k = 1 и запомнить его, чтобы отвечать на такие запросы за O(1).Асимптотика решения — O(n · log n  +  q · log n).РешениеE div2 — C div1. ЮбилейСначала докажем ключевое утверждение: НОД(Fn, Fm) = FНОД(n, m).Начнем издалека: выразим Fn + k через Fn и Fk. Получим следующую формулу: Fn + k = Fk·Fn + 1 + Fk - 1·Fn. Эта формула доказывается по индукции.Теперь воспользуемся полученной формулой и заметим, что НОД(Fn + k, Fn) = НОД(Fk, Fn). Осталось заметить в последней формулой аналогию с алгоритмом Евклида и осознать, что мы получили требуемое нам соотношение для НОД двух чисел Фибоначчи.Итак, мы свели задачу к следующей: найти в заданном множестве подмножество из k (или хотя бы из k) элементов с максимально возможным НОД. А точнее, найти сам НОД такого подмножества. Пусть ответ равен q. Тогда должно выполняться  -  ⌉ + 1 ≥ k (1).Заметим, что для каждого из слагаемых из левой части неравенства существует отрезков, на которых его значение постоянно. Причем мы можем найти все эти отрезки и значения за . Точнее, нас интересуют такие q, что в q - 1 значение хотя бы одного из слагаемых меняется (очевидно, увеличивается). Таких значений тоже . Осталось перебрать их все и каждое попробовать в роли ответа (т.е., для каждого проверить неравенство (1)), а из подошедших выбрать максимум. Ответ всегда будет, т.к. единица подходит на роль q при любых входных данных.Таким образом, мы нашли индекс искомого числа Фибоначчи. Само же число можно вычислить, быстро возведя матрицу в степень.РешениеАсимптотика решения — .D div1. Всего лишь таблица.Научимся получать ответ. Поступим следующим образом: будем находить любую строку или столбец с отрицательной суммой и инвертировать его/ее. Заметим, что сумма всех чисел в таблице после таких операций неизменно будет возрастать. Очевидно, что возрастать бесконечно сумма не может. За один шаг сумма возрастает хотя бы на 2, а максимальное возможное изменение суммы относительно начальной — 200·n·m. Таким образом, всего потребуется не более 100·n·m операций (применения заклинания), каждая из которых выполняется за время O(n) или O(m). Итак, мы научились получать нужную таблицу за ~ 1004 действий.Осталось восстановить ответ. Легко понять, что в него войдут те строки и столбцы, которые мы инвертировали нечётное число раз.РешениеE div1. Путь благородного рыцаряРешение 1Нетрудно догадаться, что замки образуют дерево. Построим на этом дереве heavy-light decomposition. Над каждым путем построим персистентное дерево отрезков на сумму. В вершине дерева отрезков будет храниться 0, если замок на текущий момент не тронут варварами, и 1 в противном случае.Каждый путь рыцаря можно при помощи нахождения lca разбить на не более чем два подпути, лежащие на пути от одного из концов маршрута к корню. Теперь будем решать задачу для каждого из подпутей отдельно. Будем последовательно обрабатывать пути из heavy-light decomposition и одиночные вершины, принадлежащие подпути. Нас интересует количество вершин на подпути, которые не посещались с года y + 1 по текущий, т.е. (в случае пути из декомпозиции) таких, что разность между значениями в текущей версии персистентного дерева и в версии, соответствующей году y (требуемая версия ищется бинпоиском в списке версий) равна нулю (случай с одиночной вершиной тривиальнее: достаточно просто хранить время посещения вершины). Как только количество подходящих вершин станет не меньше k, нам останется синхронно спуститься по двум версиям дерева, чтобы получить ответ.Если на первом подпути k-я вершина не найдена, то следует обратить внимание, что поскольку мы идем по дереву всегда снизу вверх, то надо аккуратно пересчитать номер вершины, чтобы узнать, какой она должна быть по счету на втором подпути, считая снизу вверх.Асимптотика решения: O(m·log2 n) — в каждом запросе первого типа нам может потребоваться обновить какое-нибудь дерево отрезков, на что уйдет O(log n) операций; в каждом запросе второго типа нам встречается O(log n) путей декомпозиции, каждый из которых обрабатывается за O(log n) (вначале бинпоиск по версиям, затем запрос к дереву/спуск по дереву).РеализацияРешение 2Обойдем дерево dfs'ом, записывая в массив номер вершины в моменты входа и выхода (аналогия с правильными скобочными последовательностями). Причем как записи о входе, так и записи о выходе сопоставим 0. На этом массиве построим персистентное дерево отрезков. Теперь, когда нам будет поступать запрос первого типа, будем сопоставлять позиции первого вхождения вершины в массив  + 1, а позиции последнего вхождения —  - 1.Для того чтобы научиться обрабатывать второй запрос, заметим, что для нахождения количества посещенных вершин на произвольном подпути между вершинами a и b такими, что обе вершина a лежит на пути от вершины b до корня, нам требуется найти сумму чисел, сопоставленных позициям между первыми вхождениями вершин в созданном обходом в глубину массиве.Теперь на каждом из подпутей в отдельности запустим двоичный поиск по ответу — позиции искомого замка. Для проверки ответа воспользуемся приведенным в предыдущем абзаце соображением.Асимптотика решения: O(m·log2 n) — в каждом запросе первого типа нам может потребоваться обновить дерево отрезков, на что уйдет O(log n) операций; в каждом запросе второго типа O(log n) итераций бинпоиска по ответу, каждая из которых обрабатывается за O(log n).Реализацияupd. Исправил маленькую неточность в неравенстве в разборе E div2 — C div1. В левой части добавился +1.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 9728
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #140 - Codeforces - Code 1",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 2",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 3",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 4",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 5",
          "code": "V1 if C else V2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 6",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 7",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 8",
          "code": "((VALUE%m)+m)%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 9",
          "code": "-1 % 5 == 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 10",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 11",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 12",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 13",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #140 - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #140 - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> k = inf.readInts(q, 1, 100000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> k = inf.readInts(q, 1, 100000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> k = inf.readInts(q, 1, 100000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", n); // default q = n\n    string type = opt<string>(\"type\", \"random\");\n    int amin = opt<int>(\"amin\", 1);\n    int amax = opt<int>(\"amax\", (int)1e9);\n    int kvalue = opt<int>(\"kvalue\", -1); // if -1, generate random k_i\n\n    vector<int> a(n);\n    vector<int> k(q);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(amin, amax);\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"maxsize\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = amax;\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"minsize\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = amin;\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"equal\") {\n        int val = rnd.next(amin, amax);\n        for(int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"sortedinc\") {\n        a[0] = rnd.next(amin, amin + max(1,(amax - amin) / n));\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + rnd.next(0, max(1, (amax - a[i-1]) / (n - i)));\n            if (a[i] > amax) a[i] = amax;\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"sorteddec\") {\n        a[0] = amax;\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] - rnd.next(0, max(1, (a[i-1] - amin) / (n - i)));\n            if (a[i] < amin) a[i] = amin;\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"smallk\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(amin, amax);\n        }\n        for(int i = 0; i < q; ++i) {\n            k[i] = 1;\n        }\n    } else if (type == \"largek\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(amin, amax);\n        }\n        for(int i = 0; i < q; ++i) {\n            k[i] = 1e5;\n        }\n    } else if (type == \"alternatek\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(amin, amax);\n        }\n        for(int i = 0; i < q; ++i) {\n            if(i % 2 == 0) k[i] = 1;\n            else k[i] = 1e5;\n        }\n    } else if (type == \"duplicatek\") {\n        int val = rnd.next(1, (int)1e5);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(amin, amax);\n        }\n        for(int i = 0; i < q; ++i) {\n            k[i] = val;\n        }\n    } else {\n        // unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n-1 ? '\\n' : ' '));\n    }\n    printf(\"%d\\n\", q);\n    for(int i = 0; i < q; ++i) {\n        printf(\"%d%c\", k[i], (i == q-1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", n); // default q = n\n    string type = opt<string>(\"type\", \"random\");\n    int amin = opt<int>(\"amin\", 1);\n    int amax = opt<int>(\"amax\", (int)1e9);\n    int kvalue = opt<int>(\"kvalue\", -1); // if -1, generate random k_i\n\n    vector<int> a(n);\n    vector<int> k(q);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(amin, amax);\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"maxsize\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = amax;\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"minsize\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = amin;\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"equal\") {\n        int val = rnd.next(amin, amax);\n        for(int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"sortedinc\") {\n        a[0] = rnd.next(amin, amin + max(1,(amax - amin) / n));\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + rnd.next(0, max(1, (amax - a[i-1]) / (n - i)));\n            if (a[i] > amax) a[i] = amax;\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"sorteddec\") {\n        a[0] = amax;\n        for(int i = 1; i < n; ++i) {\n            a[i] = a[i-1] - rnd.next(0, max(1, (a[i-1] - amin) / (n - i)));\n            if (a[i] < amin) a[i] = amin;\n        }\n        if (kvalue != -1) {\n            for(int i = 0; i < q; ++i) {\n                k[i] = kvalue;\n            }\n        } else {\n            for(int i = 0; i < q; ++i) {\n                k[i] = rnd.next(1, (int)1e5);\n            }\n        }\n    } else if (type == \"smallk\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(amin, amax);\n        }\n        for(int i = 0; i < q; ++i) {\n            k[i] = 1;\n        }\n    } else if (type == \"largek\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(amin, amax);\n        }\n        for(int i = 0; i < q; ++i) {\n            k[i] = 1e5;\n        }\n    } else if (type == \"alternatek\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(amin, amax);\n        }\n        for(int i = 0; i < q; ++i) {\n            if(i % 2 == 0) k[i] = 1;\n            else k[i] = 1e5;\n        }\n    } else if (type == \"duplicatek\") {\n        int val = rnd.next(1, (int)1e5);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(amin, amax);\n        }\n        for(int i = 0; i < q; ++i) {\n            k[i] = val;\n        }\n    } else {\n        // unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n-1 ? '\\n' : ' '));\n    }\n    printf(\"%d\\n\", q);\n    for(int i = 0; i < q; ++i) {\n        printf(\"%d%c\", k[i], (i == q-1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -type random\n./gen -n 5 -q 2 -type random\n./gen -n 10 -q 10 -type random\n\n./gen -n 100 -q 100 -type random\n./gen -n 1000 -q 1000 -type random\n\n./gen -n 100000 -q 100000 -type random\n\n./gen -n 100000 -q 100000 -type maxsize -amin 1000000000 -amax 1000000000\n\n./gen -n 100000 -q 100000 -type minsize -amin 1 -amax 1\n\n./gen -n 100000 -q 100000 -type equal\n\n./gen -n 100000 -q 100000 -type smallk\n\n./gen -n 100000 -q 100000 -type largek\n\n./gen -n 100000 -q 100000 -type sortedinc\n\n./gen -n 100000 -q 100000 -type sorteddec\n\n./gen -n 100000 -q 100000 -type alternatek\n\n./gen -n 1 -q 100000 -type random\n\n./gen -n 100000 -q 1 -type random\n\n./gen -n 100000 -q 100000 -type duplicatek\n\n./gen -n 100000 -q 100000 -type random -amin 1 -amax 1 -kvalue 1\n\n./gen -n 100000 -q 100000 -type random -amin 1000000000 -amax 1000000000 -kvalue 100000\n\n./gen -n 50000 -q 50000 -type random\n./gen -n 50000 -q 50000 -type sortedinc\n./gen -n 50000 -q 50000 -type sorteddec\n\n./gen -n 100000 -q 100000 -type random -amin 1 -amax 100 -kvalue 1\n\n./gen -n 100000 -q 100000 -type random -amin 1000000000 -amax 1000000000 -kvalue 1\n\n./gen -n 100000 -q 100000 -type equal -kvalue 1\n\n./gen -n 100000 -q 100000 -type equal -kvalue 100000\n\n./gen -n 100000 -q 100000 -type random -kvalue 50000\n\n./gen -n 100000 -q 100000 -type random -kvalue 100000\n\n./gen -n 1000 -q 1000 -type random -kvalue 1\n\n./gen -n 1000 -q 1000 -type random -kvalue 100000\n\n./gen -n 2 -q 2 -type random\n\n./gen -n 100000 -q 100000 -type random -amin 1 -amax 1000000000 -kvalue 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:53.426417",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "226/C",
      "title": "C. Anniversary",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four space-separated integers m, l, r and k (1 ≤ m ≤ 109; 1 ≤ l < r ≤ 1012; 2 ≤ k ≤ r - l + 1).Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint a single integer — the residue from dividing the sought greatest common divisor by m.",
      "sample_tests": "ExamplesInputCopy10 1 8 2OutputCopy3InputCopy10 1 8 3OutputCopy1",
      "description": "C. Anniversary\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four space-separated integers m, l, r and k (1 ≤ m ≤ 109; 1 ≤ l < r ≤ 1012; 2 ≤ k ≤ r - l + 1).Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nOutputPrint a single integer — the residue from dividing the sought greatest common divisor by m.\n\nInputCopy10 1 8 2OutputCopy3InputCopy10 1 8 3OutputCopy1\n\nInputCopy10 1 8 2\n\nOutputCopy3\n\nInputCopy10 1 8 3\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Round #140 - Codeforces",
          "content": "Hello everyone!Today, at 19:30 MSK Codeforces Round #140 will take place. The competition will be held in both divisions.I'am the author of today's competition. My name is Ilya Malinovsky, I'm student of Saint-Petersburg State University. This is my first Codeforces round.I want to express my gratitude to Gerald Agapov (Gerald) for his help during the work on the round, Maria Belova (Delinur) for statements' translation from Russian into English, Mikhail Mirzayanov (MikeMirzayanov) for the possibility to prerare contests (and, of course, to compete in them) here, on Codeforces. As usual, in most of the problems participants will help different characters to cope with their troubles and misfortunes. You will have only two hours to help epical hero, an alien, noble knight and other characters. Also, insidious stone heaps will resist you in one of the problems...I hope, most of participants will enjoy the tasks.Good luck!P.S. Information about score distribution will appear not long before the round starts.upd. Score distribution is stadart (500-1000-1500-2000-2500) in both divisions.upd 2 Round is over! Congratulations for winners!div1: peter50216 Dmitry_Egorov Egor RAVEman bmerry Winners have from 3 to 4 solved problems. Noone managed to solve E.div2: Velicue (he is the only div2-participant, who got 5 \"OK\"s) Frommi Aerolight Shahriar_sust bzdbz Thanks to everyone for participating! I hope, you've enjoeyd the round. Full editorial.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1454
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #140 - Codeforces - Code 1",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 2",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 3",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 4",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 5",
          "code": "V1 if C else V2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 6",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 7",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 8",
          "code": "((VALUE%m)+m)%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 9",
          "code": "-1 % 5 == 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 10",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 11",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 12",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 13",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1LL, 1000000000000LL, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(2LL, 1000000000000LL, \"k\");\n    inf.readEoln();\n\n    ensuref(l < r, \"l (%lld) must be less than r (%lld)\", l, r);\n\n    long long maxK = r - l + 1;\n    ensuref(k <= maxK, \"k (%lld) must be ≤ r - l + 1 (%lld)\", k, maxK);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1LL, 1000000000000LL, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(2LL, 1000000000000LL, \"k\");\n    inf.readEoln();\n\n    ensuref(l < r, \"l (%lld) must be less than r (%lld)\", l, r);\n\n    long long maxK = r - l + 1;\n    ensuref(k <= maxK, \"k (%lld) must be ≤ r - l + 1 (%lld)\", k, maxK);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1LL, 1000000000000LL, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(2LL, 1000000000000LL, \"k\");\n    inf.readEoln();\n\n    ensuref(l < r, \"l (%lld) must be less than r (%lld)\", l, r);\n\n    long long maxK = r - l + 1;\n    ensuref(k <= maxK, \"k (%lld) must be ≤ r - l + 1 (%lld)\", k, maxK);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long max_m = 1000000000;\n    long long max_l = 1000000000000LL;\n    long long max_r = 1000000000000LL;\n\n    long long m = opt<long long>(\"m\", -1);\n    long long l = opt<long long>(\"l\", -1);\n    long long r = opt<long long>(\"r\", -1);\n    long long k = opt<long long>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        m = 1;\n        l = 1;\n        r = 2;\n        k = 2;\n    } else if (type == \"max\") {\n        m = max_m;\n        l = 1;\n        r = max_r;\n        k = r - l + 1;\n    } else {\n        if (m == -1) {\n            if (type == \"mone\" || type == \"m_one\") {\n                m = 1;\n            } else {\n                m = rnd.next(1LL, max_m);\n            }\n        }\n\n        if (l == -1) {\n            l = rnd.next(1LL, max_l - 1);\n        }\n\n        if (r == -1) {\n            r = rnd.next(l + 1, max_r);\n        } else {\n            r = max(l + 1, r);\n        }\n\n        if (k == -1) {\n            if (type == \"kmax\" || type == \"k_max\") {\n                k = r - l + 1;\n            } else if (type == \"kmin\" || type == \"k_two\" || type == \"ktwo\") {\n                k = 2;\n            } else {\n                k = rnd.next(2LL, r - l + 1);\n            }\n        }\n    }\n\n    // Make sure k is within allowed range\n    k = min(k, r - l + 1);\n    k = max(k, 2LL);\n\n    // Output m l r k\n    printf(\"%lld %lld %lld %lld\\n\", m, l, r, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    long long max_m = 1000000000;\n    long long max_l = 1000000000000LL;\n    long long max_r = 1000000000000LL;\n\n    long long m = opt<long long>(\"m\", -1);\n    long long l = opt<long long>(\"l\", -1);\n    long long r = opt<long long>(\"r\", -1);\n    long long k = opt<long long>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        m = 1;\n        l = 1;\n        r = 2;\n        k = 2;\n    } else if (type == \"max\") {\n        m = max_m;\n        l = 1;\n        r = max_r;\n        k = r - l + 1;\n    } else {\n        if (m == -1) {\n            if (type == \"mone\" || type == \"m_one\") {\n                m = 1;\n            } else {\n                m = rnd.next(1LL, max_m);\n            }\n        }\n\n        if (l == -1) {\n            l = rnd.next(1LL, max_l - 1);\n        }\n\n        if (r == -1) {\n            r = rnd.next(l + 1, max_r);\n        } else {\n            r = max(l + 1, r);\n        }\n\n        if (k == -1) {\n            if (type == \"kmax\" || type == \"k_max\") {\n                k = r - l + 1;\n            } else if (type == \"kmin\" || type == \"k_two\" || type == \"ktwo\") {\n                k = 2;\n            } else {\n                k = rnd.next(2LL, r - l + 1);\n            }\n        }\n    }\n\n    // Make sure k is within allowed range\n    k = min(k, r - l + 1);\n    k = max(k, 2LL);\n\n    // Output m l r k\n    printf(\"%lld %lld %lld %lld\\n\", m, l, r, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal values\n./gen -type min\n\n# Maximal values\n./gen -type max\n\n# m = 1\n./gen -m 1\n./gen -m 1 -type k_two\n./gen -m 1 -type k_max\n\n# Small l and r\n./gen -l 1 -r 5\n./gen -l 1 -r 5 -type k_two\n\n# Large l and r\n./gen -l 999999999990 -r 1000000000000\n./gen -l 999999999990 -r 1000000000000 -type k_two\n\n# k minimal\n./gen -k 2\n./gen -k 2 -type m_one\n\n# k maximal\n./gen -type k_max\n./gen -type k_max -m 1\n\n# Random test cases\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:55.073653",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "226/D",
      "title": "D. The table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n,  m ≤ 100) — the number of rows and the number of columns. Next n lines follow, each contains m integers: j-th integer in the i-th line is ai, j (|ai, j| ≤ 100), the number in the i-th row and j-th column of the table.The rows of the table numbered from 1 to n. The columns of the table numbered from 1 to m.",
      "output_spec": "OutputIn the first line print the number a — the number of required applications of the first spell. Next print a space-separated integers — the row numbers, you want to apply a spell. These row numbers must be distinct!In the second line print the number b — the number of required applications of the second spell. Next print b space-separated integers — the column numbers, you want to apply a spell. These column numbers must be distinct!If there are several solutions are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy4 1-1-1-1-1OutputCopy4 1 2 3 4 0 InputCopy2 4-1 -1 -1 21 1 1 1OutputCopy1 1 1 4",
      "description": "D. The table\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n,  m ≤ 100) — the number of rows and the number of columns. Next n lines follow, each contains m integers: j-th integer in the i-th line is ai, j (|ai, j| ≤ 100), the number in the i-th row and j-th column of the table.The rows of the table numbered from 1 to n. The columns of the table numbered from 1 to m.\n\nOutputIn the first line print the number a — the number of required applications of the first spell. Next print a space-separated integers — the row numbers, you want to apply a spell. These row numbers must be distinct!In the second line print the number b — the number of required applications of the second spell. Next print b space-separated integers — the column numbers, you want to apply a spell. These column numbers must be distinct!If there are several solutions are allowed to print any of them.\n\nInputCopy4 1-1-1-1-1OutputCopy4 1 2 3 4 0 InputCopy2 4-1 -1 -1 21 1 1 1OutputCopy1 1 1 4\n\nInputCopy4 1-1-1-1-1\n\nOutputCopy4 1 2 3 4 0\n\nInputCopy2 4-1 -1 -1 21 1 1 1\n\nOutputCopy1 1 1 4",
      "solutions": [
        {
          "title": "Codeforces Round #140 - Codeforces",
          "content": "Hello everyone!Today, at 19:30 MSK Codeforces Round #140 will take place. The competition will be held in both divisions.I'am the author of today's competition. My name is Ilya Malinovsky, I'm student of Saint-Petersburg State University. This is my first Codeforces round.I want to express my gratitude to Gerald Agapov (Gerald) for his help during the work on the round, Maria Belova (Delinur) for statements' translation from Russian into English, Mikhail Mirzayanov (MikeMirzayanov) for the possibility to prerare contests (and, of course, to compete in them) here, on Codeforces. As usual, in most of the problems participants will help different characters to cope with their troubles and misfortunes. You will have only two hours to help epical hero, an alien, noble knight and other characters. Also, insidious stone heaps will resist you in one of the problems...I hope, most of participants will enjoy the tasks.Good luck!P.S. Information about score distribution will appear not long before the round starts.upd. Score distribution is stadart (500-1000-1500-2000-2500) in both divisions.upd 2 Round is over! Congratulations for winners!div1: peter50216 Dmitry_Egorov Egor RAVEman bmerry Winners have from 3 to 4 solved problems. Noone managed to solve E.div2: Velicue (he is the only div2-participant, who got 5 \"OK\"s) Frommi Aerolight Shahriar_sust bzdbz Thanks to everyone for participating! I hope, you've enjoeyd the round. Full editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1454
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #140 - Codeforces - Code 1",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 2",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 3",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 4",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 5",
          "code": "V1 if C else V2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 6",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 7",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 8",
          "code": "((VALUE%m)+m)%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 9",
          "code": "-1 % 5 == 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 10",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 11",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 12",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 13",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, -100, 100);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, -100, 100);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, -100, 100);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and m from inf\n    int n = inf.readInt(1, 100, \"n\");\n    int m = inf.readInt(1, 100, \"m\");\n\n    vector<vector<int>> matrix(n, vector<int>(m));\n    for (int i = 0; i < n; i++) {\n        // Read m integers for row i+1\n        for (int j = 0; j < m; j++) {\n            matrix[i][j] = inf.readInt(-100, 100, format(\"a[%d][%d]\", i+1, j+1).c_str());\n        }\n    }\n\n    // Read participant's output from ouf\n    int a = ouf.readInt(0, n, \"a\");\n    set<int> selectedRowsSet;\n    vector<int> selectedRows;\n\n    for (int i = 0; i < a; i++) {\n        int rowNum = ouf.readInt(1, n, format(\"row[%d]\", i+1).c_str());\n        if (selectedRowsSet.count(rowNum)) {\n            ouf.quitf(_wa, \"Row number %d is repeated\", rowNum);\n        }\n        selectedRowsSet.insert(rowNum);\n        selectedRows.push_back(rowNum);\n    }\n\n    int b = ouf.readInt(0, m, \"b\");\n    set<int> selectedColsSet;\n    vector<int> selectedCols;\n\n    for (int i = 0; i < b; i++) {\n        int colNum = ouf.readInt(1, m, format(\"col[%d]\", i+1).c_str());\n        if (selectedColsSet.count(colNum)) {\n            ouf.quitf(_wa, \"Column number %d is repeated\", colNum);\n        }\n        selectedColsSet.insert(colNum);\n        selectedCols.push_back(colNum);\n    }\n\n    // Apply the spells to the matrix\n    vector<vector<int>> mat = matrix;\n\n    // Apply spells to selected rows\n    for (int rowNum : selectedRows) {\n        int rowIndex = rowNum - 1;\n        for (int j = 0; j < m; j++) {\n            mat[rowIndex][j] = -mat[rowIndex][j];\n        }\n    }\n\n    // Apply spells to selected columns\n    for (int colNum : selectedCols) {\n        int colIndex = colNum - 1;\n        for (int i = 0; i < n; i++) {\n            mat[i][colIndex] = -mat[i][colIndex];\n        }\n    }\n\n    // Compute sums of each row and each column\n    vector<int> rowSums(n, 0);\n    vector<int> colSums(m, 0);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            rowSums[i] += mat[i][j];\n            colSums[j] += mat[i][j];\n        }\n    }\n\n    // Check that all row sums are non-negative\n    for (int i = 0; i < n; i++) {\n        if (rowSums[i] < 0) {\n            ouf.quitf(_wa, \"Sum of row %d is negative after applying spells\", i+1);\n        }\n    }\n\n    // Check that all column sums are non-negative\n    for (int j = 0; j < m; j++) {\n        if (colSums[j] < 0) {\n            ouf.quitf(_wa, \"Sum of column %d is negative after applying spells\", j+1);\n        }\n    }\n\n    // If everything is okay\n    quitf(_ok, \"The sums of all rows and columns are non-negative\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxval = opt<int>(\"maxval\", 100);\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random numbers between -maxval and maxval\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = rnd.next(-maxval, maxval);\n            }\n        }\n    } else if (type == \"all_negative\") {\n        // Generate numbers between -maxval and -1\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = -rnd.next(1, maxval);\n            }\n        }\n    } else if (type == \"all_positive\") {\n        // Generate numbers between 1 and maxval\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = rnd.next(1, maxval);\n            }\n        }\n    } else if (type == \"zeros\") {\n        // Generate zeros and random numbers between -maxval and maxval\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int val = rnd.next(-maxval, maxval);\n                if (rnd.next(0, 1) == 0) {\n                    val = 0;\n                }\n                a[i][j] = val;\n            }\n        }\n    } else if (type == \"per_row_neg\") {\n        // Each row has mostly positive numbers except for one negative number\n        for (int i = 0; i < n; ++i) {\n            int neg_pos = rnd.next(0, m - 1);\n            for (int j = 0; j < m; ++j) {\n                if (j == neg_pos) {\n                    a[i][j] = -rnd.next(1, maxval);\n                } else {\n                    a[i][j] = rnd.next(1, maxval);\n                }\n            }\n        }\n    } else if (type == \"per_col_neg\") {\n        // Each column has mostly positive numbers except for one negative number\n        for (int j = 0; j < m; ++j) {\n            int neg_pos = rnd.next(0, n - 1);\n            for (int i = 0; i < n; ++i) {\n                if (i == neg_pos) {\n                    a[i][j] = -rnd.next(1, maxval);\n                } else {\n                    a[i][j] = rnd.next(1, maxval);\n                }\n            }\n        }\n    } else if (type == \"checkerboard\") {\n        // Alternating negative and positive numbers\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int val = rnd.next(1, maxval);\n                if ((i + j) % 2 == 0) {\n                    a[i][j] = val;\n                } else {\n                    a[i][j] = -val;\n                }\n            }\n        }\n    } else if (type == \"max_values\") {\n        // Numbers are either -maxval or maxval\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int val = maxval;\n                if (rnd.next(0, 1) == 0) {\n                    a[i][j] = val;\n                } else {\n                    a[i][j] = -val;\n                }\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = rnd.next(-maxval, maxval);\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the matrix\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", a[i][j], (j == m - 1) ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxval = opt<int>(\"maxval\", 100);\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random numbers between -maxval and maxval\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = rnd.next(-maxval, maxval);\n            }\n        }\n    } else if (type == \"all_negative\") {\n        // Generate numbers between -maxval and -1\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = -rnd.next(1, maxval);\n            }\n        }\n    } else if (type == \"all_positive\") {\n        // Generate numbers between 1 and maxval\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = rnd.next(1, maxval);\n            }\n        }\n    } else if (type == \"zeros\") {\n        // Generate zeros and random numbers between -maxval and maxval\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int val = rnd.next(-maxval, maxval);\n                if (rnd.next(0, 1) == 0) {\n                    val = 0;\n                }\n                a[i][j] = val;\n            }\n        }\n    } else if (type == \"per_row_neg\") {\n        // Each row has mostly positive numbers except for one negative number\n        for (int i = 0; i < n; ++i) {\n            int neg_pos = rnd.next(0, m - 1);\n            for (int j = 0; j < m; ++j) {\n                if (j == neg_pos) {\n                    a[i][j] = -rnd.next(1, maxval);\n                } else {\n                    a[i][j] = rnd.next(1, maxval);\n                }\n            }\n        }\n    } else if (type == \"per_col_neg\") {\n        // Each column has mostly positive numbers except for one negative number\n        for (int j = 0; j < m; ++j) {\n            int neg_pos = rnd.next(0, n - 1);\n            for (int i = 0; i < n; ++i) {\n                if (i == neg_pos) {\n                    a[i][j] = -rnd.next(1, maxval);\n                } else {\n                    a[i][j] = rnd.next(1, maxval);\n                }\n            }\n        }\n    } else if (type == \"checkerboard\") {\n        // Alternating negative and positive numbers\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int val = rnd.next(1, maxval);\n                if ((i + j) % 2 == 0) {\n                    a[i][j] = val;\n                } else {\n                    a[i][j] = -val;\n                }\n            }\n        }\n    } else if (type == \"max_values\") {\n        // Numbers are either -maxval or maxval\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int val = maxval;\n                if (rnd.next(0, 1) == 0) {\n                    a[i][j] = val;\n                } else {\n                    a[i][j] = -val;\n                }\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                a[i][j] = rnd.next(-maxval, maxval);\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the matrix\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", a[i][j], (j == m - 1) ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 100 -type random\n./gen -n 100 -m 1 -type random\n./gen -n 100 -m 100 -type random\n\n./gen -n 10 -m 10 -type all_negative\n./gen -n 10 -m 10 -type all_positive\n./gen -n 10 -m 10 -type zeros\n./gen -n 10 -m 10 -type per_row_neg\n./gen -n 10 -m 10 -type per_col_neg\n./gen -n 10 -m 10 -type checkerboard\n./gen -n 10 -m 10 -type max_values\n\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type zeros\n./gen -n 50 -m 50 -type per_row_neg\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type all_negative\n./gen -n 100 -m 100 -type all_positive\n\n./gen -n 99 -m 100 -type per_col_neg\n./gen -n 100 -m 99 -type per_row_neg\n\n./gen -n 100 -m 100 -type checkerboard\n\n./gen -n 1 -m 100 -type max_values\n./gen -n 100 -m 1 -type max_values\n\n./gen -n 1 -m 100 -type zeros\n./gen -n 100 -m 1 -type zeros\n\n./gen -n 2 -m 2 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type per_col_neg\n\n./gen -n 3 -m 3 -type random\n./gen -n 50 -m 50 -type checkerboard\n./gen -n 100 -m 100 -type max_values\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:56.705359",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "226/E",
      "title": "E. Noble Knight's Path",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains integer n (2 ≤ n ≤ 105) — the number of feudals. The next line contains n space-separated integers: the i-th integer shows either the number of the i-th feudal's master, or a 0, if the i-th feudal is the King. The third line contains integer m (1 ≤ m ≤ 105) — the number of queries.Then follow m lines that describe the events. The i-th line (the lines are indexed starting from 1) contains the description of the event that occurred in year i. Each event is characterised by type ti (1 ≤ ti ≤ 2). The description of the first type event looks as two space-separated integers ti ci (ti = 1; 1 ≤ ci ≤ n), where ci is the number of the castle that was attacked by the barbarians in the i-th year. The description of the second type contains five space-separated integers: ti ai bi ki yi (ti = 2; 1 ≤ ai, bi, ki ≤ n; ai ≠ bi; 0 ≤ yi < i), where ai is the number of the castle from which the knight is setting off, bi is the number of the castle to which the knight is going, ki and yi are the k and y from the second event's description.You can consider the feudals indexed from 1 to n. It is guaranteed that there is only one king among the feudals. It is guaranteed that for the first type events all values ci are different.",
      "output_spec": "OutputFor each second type event print an integer — the number of the castle where the knight must stay to rest, or -1, if he will have to cover the distance from ai to bi without a rest. Separate the answers by whitespaces.Print the answers in the order, in which the second type events are given in the input.",
      "sample_tests": "ExamplesInputCopy30 1 252 1 3 1 01 22 1 3 1 02 1 3 1 12 1 3 1 2OutputCopy2-1-12InputCopy62 5 2 2 0 532 1 6 2 01 22 4 5 1 0OutputCopy5-1",
      "description": "E. Noble Knight's Path\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains integer n (2 ≤ n ≤ 105) — the number of feudals. The next line contains n space-separated integers: the i-th integer shows either the number of the i-th feudal's master, or a 0, if the i-th feudal is the King. The third line contains integer m (1 ≤ m ≤ 105) — the number of queries.Then follow m lines that describe the events. The i-th line (the lines are indexed starting from 1) contains the description of the event that occurred in year i. Each event is characterised by type ti (1 ≤ ti ≤ 2). The description of the first type event looks as two space-separated integers ti ci (ti = 1; 1 ≤ ci ≤ n), where ci is the number of the castle that was attacked by the barbarians in the i-th year. The description of the second type contains five space-separated integers: ti ai bi ki yi (ti = 2; 1 ≤ ai, bi, ki ≤ n; ai ≠ bi; 0 ≤ yi < i), where ai is the number of the castle from which the knight is setting off, bi is the number of the castle to which the knight is going, ki and yi are the k and y from the second event's description.You can consider the feudals indexed from 1 to n. It is guaranteed that there is only one king among the feudals. It is guaranteed that for the first type events all values ci are different.\n\nOutputFor each second type event print an integer — the number of the castle where the knight must stay to rest, or -1, if he will have to cover the distance from ai to bi without a rest. Separate the answers by whitespaces.Print the answers in the order, in which the second type events are given in the input.\n\nInputCopy30 1 252 1 3 1 01 22 1 3 1 02 1 3 1 12 1 3 1 2OutputCopy2-1-12InputCopy62 5 2 2 0 532 1 6 2 01 22 4 5 1 0OutputCopy5-1\n\nInputCopy30 1 252 1 3 1 01 22 1 3 1 02 1 3 1 12 1 3 1 2\n\nOutputCopy2-1-12\n\nInputCopy62 5 2 2 0 532 1 6 2 01 22 4 5 1 0\n\nOutputCopy5-1\n\nNoteIn the first sample there is only castle 2 on the knight's way from castle 1 to castle 3. When the knight covers the path 1 - 3 for the first time, castle 2 won't be desecrated by an enemy and the knight will stay there. In the second year the castle 2 will become desecrated, so the knight won't have anywhere to stay for the next two years (as finding a castle that hasn't been desecrated from years 1 and 2, correspondingly, is important for him). In the fifth year the knight won't consider the castle 2 desecrated, so he will stay there again.",
      "solutions": [
        {
          "title": "Codeforces Round #140 - Codeforces",
          "content": "Hello everyone!Today, at 19:30 MSK Codeforces Round #140 will take place. The competition will be held in both divisions.I'am the author of today's competition. My name is Ilya Malinovsky, I'm student of Saint-Petersburg State University. This is my first Codeforces round.I want to express my gratitude to Gerald Agapov (Gerald) for his help during the work on the round, Maria Belova (Delinur) for statements' translation from Russian into English, Mikhail Mirzayanov (MikeMirzayanov) for the possibility to prerare contests (and, of course, to compete in them) here, on Codeforces. As usual, in most of the problems participants will help different characters to cope with their troubles and misfortunes. You will have only two hours to help epical hero, an alien, noble knight and other characters. Also, insidious stone heaps will resist you in one of the problems...I hope, most of participants will enjoy the tasks.Good luck!P.S. Information about score distribution will appear not long before the round starts.upd. Score distribution is stadart (500-1000-1500-2000-2500) in both divisions.upd 2 Round is over! Congratulations for winners!div1: peter50216 Dmitry_Egorov Egor RAVEman bmerry Winners have from 3 to 4 solved problems. Noone managed to solve E.div2: Velicue (he is the only div2-participant, who got 5 \"OK\"s) Frommi Aerolight Shahriar_sust bzdbz Thanks to everyone for participating! I hope, you've enjoeyd the round. Full editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1454
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #140 - Codeforces - Code 1",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 2",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 3",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 4",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 5",
          "code": "V1 if C else V2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 6",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 7",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 8",
          "code": "((VALUE%m)+m)%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 9",
          "code": "-1 % 5 == 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 10",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 11",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 12",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 13",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        ensuref(!visited[v], \"Cycle detected in the feudal hierarchy at node %d\", v);\n        dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    int kingCount = 0;\n    for (int i = 1; i <= n; i++) {\n        int p = inf.readInt(0, n);\n        ensuref(p != i, \"Feudal %d cannot be its own master\", i);\n        parent[i] = p;\n        if (p == 0) {\n            kingCount++;\n        }\n        if (i < n) {\n            inf.readSpace();\n        }\n    }\n    inf.readEoln();\n    ensuref(kingCount == 1, \"There must be exactly one king (1 feudal with master 0), found %d\", kingCount);\n\n    // Build adjacency list\n    adj.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        int p = parent[i];\n        if (p != 0) {\n            adj[p].push_back(i);\n        }\n    }\n\n    // DFS to check for cycles and connectivity\n    visited.resize(n + 1, false);\n\n    // Find the king\n    int king = -1;\n    for (int i = 1; i <= n; i++) {\n        if (parent[i] == 0) {\n            king = i;\n            break;\n        }\n    }\n    ensuref(king != -1, \"No king found\");\n    dfs(king);\n\n    // Check that all nodes visited\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Feudal %d is not connected to the king\", i);\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<int> attacked_castles;\n\n    for (int i = 1; i <= m; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int ci = inf.readInt(1, n, \"ci\");\n            ensuref(!attacked_castles.count(ci), \"Castle %d has already been attacked\", ci);\n            attacked_castles.insert(ci);\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int ai = inf.readInt(1, n, \"ai\");\n            inf.readSpace();\n            int bi = inf.readInt(1, n, \"bi\");\n            ensuref(ai != bi, \"ai (%d) == bi (%d) at event %d\", ai, bi, i);\n            inf.readSpace();\n            int ki = inf.readInt(1, n, \"ki\");\n            inf.readSpace();\n            int yi = inf.readInt(0, i - 1, \"yi\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Invalid event type %d at line %d\", t, i + 3);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        ensuref(!visited[v], \"Cycle detected in the feudal hierarchy at node %d\", v);\n        dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    int kingCount = 0;\n    for (int i = 1; i <= n; i++) {\n        int p = inf.readInt(0, n);\n        ensuref(p != i, \"Feudal %d cannot be its own master\", i);\n        parent[i] = p;\n        if (p == 0) {\n            kingCount++;\n        }\n        if (i < n) {\n            inf.readSpace();\n        }\n    }\n    inf.readEoln();\n    ensuref(kingCount == 1, \"There must be exactly one king (1 feudal with master 0), found %d\", kingCount);\n\n    // Build adjacency list\n    adj.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        int p = parent[i];\n        if (p != 0) {\n            adj[p].push_back(i);\n        }\n    }\n\n    // DFS to check for cycles and connectivity\n    visited.resize(n + 1, false);\n\n    // Find the king\n    int king = -1;\n    for (int i = 1; i <= n; i++) {\n        if (parent[i] == 0) {\n            king = i;\n            break;\n        }\n    }\n    ensuref(king != -1, \"No king found\");\n    dfs(king);\n\n    // Check that all nodes visited\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Feudal %d is not connected to the king\", i);\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<int> attacked_castles;\n\n    for (int i = 1; i <= m; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int ci = inf.readInt(1, n, \"ci\");\n            ensuref(!attacked_castles.count(ci), \"Castle %d has already been attacked\", ci);\n            attacked_castles.insert(ci);\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int ai = inf.readInt(1, n, \"ai\");\n            inf.readSpace();\n            int bi = inf.readInt(1, n, \"bi\");\n            ensuref(ai != bi, \"ai (%d) == bi (%d) at event %d\", ai, bi, i);\n            inf.readSpace();\n            int ki = inf.readInt(1, n, \"ki\");\n            inf.readSpace();\n            int yi = inf.readInt(0, i - 1, \"yi\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Invalid event type %d at line %d\", t, i + 3);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        ensuref(!visited[v], \"Cycle detected in the feudal hierarchy at node %d\", v);\n        dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    int kingCount = 0;\n    for (int i = 1; i <= n; i++) {\n        int p = inf.readInt(0, n);\n        ensuref(p != i, \"Feudal %d cannot be its own master\", i);\n        parent[i] = p;\n        if (p == 0) {\n            kingCount++;\n        }\n        if (i < n) {\n            inf.readSpace();\n        }\n    }\n    inf.readEoln();\n    ensuref(kingCount == 1, \"There must be exactly one king (1 feudal with master 0), found %d\", kingCount);\n\n    // Build adjacency list\n    adj.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        int p = parent[i];\n        if (p != 0) {\n            adj[p].push_back(i);\n        }\n    }\n\n    // DFS to check for cycles and connectivity\n    visited.resize(n + 1, false);\n\n    // Find the king\n    int king = -1;\n    for (int i = 1; i <= n; i++) {\n        if (parent[i] == 0) {\n            king = i;\n            break;\n        }\n    }\n    ensuref(king != -1, \"No king found\");\n    dfs(king);\n\n    // Check that all nodes visited\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Feudal %d is not connected to the king\", i);\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<int> attacked_castles;\n\n    for (int i = 1; i <= m; i++) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int ci = inf.readInt(1, n, \"ci\");\n            ensuref(!attacked_castles.count(ci), \"Castle %d has already been attacked\", ci);\n            attacked_castles.insert(ci);\n            inf.readEoln();\n        } else if (t == 2) {\n            inf.readSpace();\n            int ai = inf.readInt(1, n, \"ai\");\n            inf.readSpace();\n            int bi = inf.readInt(1, n, \"bi\");\n            ensuref(ai != bi, \"ai (%d) == bi (%d) at event %d\", ai, bi, i);\n            inf.readSpace();\n            int ki = inf.readInt(1, n, \"ki\");\n            inf.readSpace();\n            int yi = inf.readInt(0, i - 1, \"yi\");\n            inf.readEoln();\n        } else {\n            ensuref(false, \"Invalid event type %d at line %d\", t, i + 3);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse options\n    int n = opt<int>(\"n\"); // number of castles\n    int m = opt<int>(\"m\"); // number of events\n    string treeType = opt<string>(\"treeType\", \"random\"); // type of tree\n    int attackRatio = opt<int>(\"attackRatio\", -1); // percentage of attacks, -1 means random\n    int maxK = opt<int>(\"maxK\", n);\n    int maxY = opt<int>(\"maxY\", m - 1);\n\n    // Ensure maxK and maxY are within valid ranges\n    maxK = min(maxK, n);\n    maxY = min(maxY, m - 1);\n\n    // Generate the tree\n    vector<int> master(n + 1); // 1-based indexing\n    if (treeType == \"chain\") {\n        master[1] = 0; // King\n        for (int i = 2; i <= n; ++i) {\n            master[i] = i - 1;\n        }\n    } else if (treeType == \"star\") {\n        master[1] = 0; // King\n        for (int i = 2; i <= n; ++i) {\n            master[i] = 1;\n        }\n    } else if (treeType == \"random\") {\n        master[1] = 0; // King\n        for (int i = 2; i <= n; ++i) {\n            master[i] = rnd.next(1, i - 1); // parent is any of [1, i - 1]\n        }\n    } else if (treeType == \"balanced\") {\n        master[1] = 0; // King\n        for (int i = 2; i <= n; ++i) {\n            master[i] = i / 2; // parent is floor(i / 2)\n        }\n    } else {\n        // If treeType is invalid, default to random\n        master[1] = 0;\n        for (int i = 2; i <= n; ++i) {\n            master[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Now, output the initial tree\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", master[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Now, generate the m events.\n    // Keep track of castles that have been attacked\n    set<int> attacked; // stores castles that have been attacked\n\n    // Let's generate events\n    // Since we can't attack the same castle twice, we need to have at most n attacks.\n    // We need to consider that.\n\n    // Let's create a vector of events to output at the end\n    vector<string> events(m + 1); // 1-based indexing, events[year]\n\n    // Let's create a list of castles that can be attacked (not attacked yet)\n    vector<int> castles;\n    for (int i = 1; i <= n; ++i) {\n        castles.push_back(i);\n    }\n\n    // For attackRatio, if -1, we can set to a random value between 0 and 100\n    if (attackRatio == -1) {\n        attackRatio = rnd.next(0, 100);\n    }\n\n    // Now, compute number of attacks\n    int maxAttacks = min(n, m); // We can have at most n attacks (since castles can't be attacked twice)\n    int numAttacks = (attackRatio * m) / 100;\n\n    numAttacks = min(numAttacks, maxAttacks);\n\n    // Now, generate the positions where attacks will occur\n    // For simplicity, let's decide in advance which years will have attacks\n    vector<int> attackYears;\n    for (int i = 1; i <= m; ++i) {\n        attackYears.push_back(i);\n    }\n    shuffle(attackYears.begin(), attackYears.end());\n    attackYears.resize(numAttacks);\n    sort(attackYears.begin(), attackYears.end()); // So attacks happen in these years\n\n    // Now, we need to generate the attacks\n    int attackIdx = 0;\n    int eventIdx = 1;\n    for (int i = 1; i <= m; ++i) {\n        if (attackIdx < attackYears.size() && attackYears[attackIdx] == i) {\n            // This year is an attack\n            if (castles.empty()) {\n                // Should not happen\n                printf(\"1 1\\n\"); // Output a dummy attack\n            } else {\n                int idx = rnd.next(0, (int)castles.size() - 1);\n                int ci = castles[idx];\n                swap(castles[idx], castles.back());\n                castles.pop_back();\n\n                attacked.insert(ci);\n\n                events[i] = \"1 \" + to_string(ci);\n            }\n            attackIdx++;\n        } else {\n            // This year is a query\n            // Generate a type 2 event\n            int ai, bi, ki, yi;\n\n            // ai and bi should be different castles between 1 and n\n            ai = rnd.next(1, n);\n            do {\n                bi = rnd.next(1, n);\n            } while (bi == ai);\n\n            // ki can be from 1 to maxK\n            ki = rnd.next(1, maxK);\n\n            // yi can be from 0 to maxY (but less than current year i)\n            yi = rnd.next(0, min(maxY, i - 1));\n\n            // Build the event string\n            events[i] = \"2 \" + to_string(ai) + \" \" + to_string(bi) + \" \" + to_string(ki) + \" \" + to_string(yi);\n        }\n    }\n\n    // Now, output m\n    printf(\"%d\\n\", m);\n\n    // Output the events\n    for (int i = 1; i <= m; ++i) {\n        printf(\"%s\\n\", events[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse options\n    int n = opt<int>(\"n\"); // number of castles\n    int m = opt<int>(\"m\"); // number of events\n    string treeType = opt<string>(\"treeType\", \"random\"); // type of tree\n    int attackRatio = opt<int>(\"attackRatio\", -1); // percentage of attacks, -1 means random\n    int maxK = opt<int>(\"maxK\", n);\n    int maxY = opt<int>(\"maxY\", m - 1);\n\n    // Ensure maxK and maxY are within valid ranges\n    maxK = min(maxK, n);\n    maxY = min(maxY, m - 1);\n\n    // Generate the tree\n    vector<int> master(n + 1); // 1-based indexing\n    if (treeType == \"chain\") {\n        master[1] = 0; // King\n        for (int i = 2; i <= n; ++i) {\n            master[i] = i - 1;\n        }\n    } else if (treeType == \"star\") {\n        master[1] = 0; // King\n        for (int i = 2; i <= n; ++i) {\n            master[i] = 1;\n        }\n    } else if (treeType == \"random\") {\n        master[1] = 0; // King\n        for (int i = 2; i <= n; ++i) {\n            master[i] = rnd.next(1, i - 1); // parent is any of [1, i - 1]\n        }\n    } else if (treeType == \"balanced\") {\n        master[1] = 0; // King\n        for (int i = 2; i <= n; ++i) {\n            master[i] = i / 2; // parent is floor(i / 2)\n        }\n    } else {\n        // If treeType is invalid, default to random\n        master[1] = 0;\n        for (int i = 2; i <= n; ++i) {\n            master[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Now, output the initial tree\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", master[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Now, generate the m events.\n    // Keep track of castles that have been attacked\n    set<int> attacked; // stores castles that have been attacked\n\n    // Let's generate events\n    // Since we can't attack the same castle twice, we need to have at most n attacks.\n    // We need to consider that.\n\n    // Let's create a vector of events to output at the end\n    vector<string> events(m + 1); // 1-based indexing, events[year]\n\n    // Let's create a list of castles that can be attacked (not attacked yet)\n    vector<int> castles;\n    for (int i = 1; i <= n; ++i) {\n        castles.push_back(i);\n    }\n\n    // For attackRatio, if -1, we can set to a random value between 0 and 100\n    if (attackRatio == -1) {\n        attackRatio = rnd.next(0, 100);\n    }\n\n    // Now, compute number of attacks\n    int maxAttacks = min(n, m); // We can have at most n attacks (since castles can't be attacked twice)\n    int numAttacks = (attackRatio * m) / 100;\n\n    numAttacks = min(numAttacks, maxAttacks);\n\n    // Now, generate the positions where attacks will occur\n    // For simplicity, let's decide in advance which years will have attacks\n    vector<int> attackYears;\n    for (int i = 1; i <= m; ++i) {\n        attackYears.push_back(i);\n    }\n    shuffle(attackYears.begin(), attackYears.end());\n    attackYears.resize(numAttacks);\n    sort(attackYears.begin(), attackYears.end()); // So attacks happen in these years\n\n    // Now, we need to generate the attacks\n    int attackIdx = 0;\n    int eventIdx = 1;\n    for (int i = 1; i <= m; ++i) {\n        if (attackIdx < attackYears.size() && attackYears[attackIdx] == i) {\n            // This year is an attack\n            if (castles.empty()) {\n                // Should not happen\n                printf(\"1 1\\n\"); // Output a dummy attack\n            } else {\n                int idx = rnd.next(0, (int)castles.size() - 1);\n                int ci = castles[idx];\n                swap(castles[idx], castles.back());\n                castles.pop_back();\n\n                attacked.insert(ci);\n\n                events[i] = \"1 \" + to_string(ci);\n            }\n            attackIdx++;\n        } else {\n            // This year is a query\n            // Generate a type 2 event\n            int ai, bi, ki, yi;\n\n            // ai and bi should be different castles between 1 and n\n            ai = rnd.next(1, n);\n            do {\n                bi = rnd.next(1, n);\n            } while (bi == ai);\n\n            // ki can be from 1 to maxK\n            ki = rnd.next(1, maxK);\n\n            // yi can be from 0 to maxY (but less than current year i)\n            yi = rnd.next(0, min(maxY, i - 1));\n\n            // Build the event string\n            events[i] = \"2 \" + to_string(ai) + \" \" + to_string(bi) + \" \" + to_string(ki) + \" \" + to_string(yi);\n        }\n    }\n\n    // Now, output m\n    printf(\"%d\\n\", m);\n\n    // Output the events\n    for (int i = 1; i <= m; ++i) {\n        printf(\"%s\\n\", events[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, small m, chain tree, mostly attacks\n./gen -n 5 -m 5 -treeType chain -attackRatio 100 -maxK 5\n\n# Small n, small m, star tree, mostly queries\n./gen -n 5 -m 5 -treeType star -attackRatio 0 -maxK 5\n\n# Mid-size n and m, random tree, randomly mixed events\n./gen -n 100 -m 100 -treeType random -attackRatio 50\n\n# Mid-size n and m, chain tree, alternate events\n./gen -n 100 -m 100 -treeType chain -attackRatio 50\n\n# Large n and m, random tree, mostly attacks\n./gen -n 100000 -m 100000 -treeType random -attackRatio 80\n\n# Large n and m, star tree, mostly queries\n./gen -n 100000 -m 100000 -treeType star -attackRatio 20\n\n# Large n and m, chain tree, maximum ki\n./gen -n 100000 -m 100000 -treeType chain -attackRatio 50 -maxK 100000\n\n# Large n and m, chain tree, ki always 1\n./gen -n 100000 -m 100000 -treeType chain -attackRatio 50 -maxK 1\n\n# Large n and m, chain tree, y always 0\n./gen -n 100000 -m 100000 -treeType chain -attackRatio 50 -maxY 0\n\n# Large n and m, chain tree, y always current year -1 (so yi is i -1)\n./gen -n 100000 -m 100000 -treeType chain -attackRatio 50 -maxY 99999\n\n# Random tree, ki larger than possible path lengths, to test -1 outputs\n./gen -n 1000 -m 1000 -treeType random -attackRatio 50 -maxK 10000\n\n# Random tree, no attacks, all yi = 0\n./gen -n 100000 -m 100000 -treeType random -attackRatio 0 -maxY 0\n\n# Random tree, attacks every year\n./gen -n 100000 -m 100000 -treeType random -attackRatio 100\n\n# Balanced tree, mixed events\n./gen -n 100000 -m 100000 -treeType balanced -attackRatio 50\n\n# Balanced tree, minimal ki\n./gen -n 100000 -m 100000 -treeType balanced -attackRatio 50 -maxK 1\n\n# Generate chain tree, attacks only in first years\n./gen -n 100000 -m 100000 -treeType chain -attackRatio 50 -maxY 10\n\n# Generate chain tree, attacks only in last years\n./gen -n 100000 -m 100000 -treeType chain -attackRatio 50\n\n# Generate chain tree, ki always equals path length -1\n./gen -n 100000 -m 100000 -treeType chain -attackRatio 50 -maxK 99999\n\n# Generate random tree, varying ki and yi\n./gen -n 100000 -m 100000 -treeType random -attackRatio 50 -maxK 50000 -maxY 50000\n\n# Small tree, ki = 1, yi = 0\n./gen -n 5 -m 5 -treeType random -attackRatio 0 -maxK 1 -maxY 0\n\n# Edge case: all castles attacked before any query\n./gen -n 100 -m 100 -treeType random -attackRatio 100\n\n# Edge case: zero attacks\n./gen -n 1000 -m 1000 -treeType random -attackRatio 0\n\n# Edge case: maximum possible attacks\n./gen -n 100000 -m 100000 -treeType random -attackRatio 100\n\n# Edge case: ki is always larger than path length\n./gen -n 1000 -m 1000 -treeType random -attackRatio 50 -maxK 2000\n\n# Edge case: yi always zero, to find castles never attacked\n./gen -n 100000 -m 100000 -treeType random -attackRatio 50 -maxY 0\n\n# Edge case: yi always current year - 1 (maximum)\n./gen -n 100000 -m 100000 -treeType random -attackRatio 50 -maxY 99999\n\n# Edge case: m equals n (minimum possible attacks)\n./gen -n 100000 -m 100000 -treeType random -attackRatio 1\n\n# Edge case: n minimal, m maximal\n./gen -n 2 -m 100000 -treeType chain -attackRatio 50 -maxK 2\n\n# Edge case: n maximal, m minimal\n./gen -n 100000 -m 1 -treeType random -attackRatio 50\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:51:58.961305",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "227/A",
      "title": "A. Where do I Turn?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains two space-separated integers xa, ya (|xa|, |ya| ≤ 109) — the coordinates of point A. The second line contains the coordinates of point B in the same form, the third line contains the coordinates of point C.It is guaranteed that all points are pairwise different. It is also guaranteed that either point B lies on segment AC, or angle ABC is right.",
      "output_spec": "OutputPrint a single line. If a hero must turn left, print \"LEFT\" (without the quotes); If he must go straight ahead, print \"TOWARDS\" (without the quotes); if he should turn right, print \"RIGHT\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy0 00 11 1OutputCopyRIGHTInputCopy-1 -1-3 -3-4 -4OutputCopyTOWARDSInputCopy-4 -6-3 -7-2 -6OutputCopyLEFT",
      "description": "A. Where do I Turn?\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains two space-separated integers xa, ya (|xa|, |ya| ≤ 109) — the coordinates of point A. The second line contains the coordinates of point B in the same form, the third line contains the coordinates of point C.It is guaranteed that all points are pairwise different. It is also guaranteed that either point B lies on segment AC, or angle ABC is right.\n\nOutputPrint a single line. If a hero must turn left, print \"LEFT\" (without the quotes); If he must go straight ahead, print \"TOWARDS\" (without the quotes); if he should turn right, print \"RIGHT\" (without the quotes).\n\nInputCopy0 00 11 1OutputCopyRIGHTInputCopy-1 -1-3 -3-4 -4OutputCopyTOWARDSInputCopy-4 -6-3 -7-2 -6OutputCopyLEFT\n\nInputCopy0 00 11 1\n\nOutputCopyRIGHT\n\nInputCopy-1 -1-3 -3-4 -4\n\nOutputCopyTOWARDS\n\nInputCopy-4 -6-3 -7-2 -6\n\nOutputCopyLEFT\n\nNoteThe picture to the first sample: The red color shows points A, B and C. The blue arrow shows the hero's direction. The green color shows the hero's trajectory.The picture to the second sample:",
      "solutions": [
        {
          "title": "Codeforces Round #140 - Codeforces",
          "content": "Hello everyone!Today, at 19:30 MSK Codeforces Round #140 will take place. The competition will be held in both divisions.I'am the author of today's competition. My name is Ilya Malinovsky, I'm student of Saint-Petersburg State University. This is my first Codeforces round.I want to express my gratitude to Gerald Agapov (Gerald) for his help during the work on the round, Maria Belova (Delinur) for statements' translation from Russian into English, Mikhail Mirzayanov (MikeMirzayanov) for the possibility to prerare contests (and, of course, to compete in them) here, on Codeforces. As usual, in most of the problems participants will help different characters to cope with their troubles and misfortunes. You will have only two hours to help epical hero, an alien, noble knight and other characters. Also, insidious stone heaps will resist you in one of the problems...I hope, most of participants will enjoy the tasks.Good luck!P.S. Information about score distribution will appear not long before the round starts.upd. Score distribution is stadart (500-1000-1500-2000-2500) in both divisions.upd 2 Round is over! Congratulations for winners!div1: peter50216 Dmitry_Egorov Egor RAVEman bmerry Winners have from 3 to 4 solved problems. Noone managed to solve E.div2: Velicue (he is the only div2-participant, who got 5 \"OK\"s) Frommi Aerolight Shahriar_sust bzdbz Thanks to everyone for participating! I hope, you've enjoeyd the round. Full editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1454
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #140 - Codeforces - Code 1",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 2",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 3",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 4",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 5",
          "code": "V1 if C else V2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 6",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 7",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 8",
          "code": "((VALUE%m)+m)%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 9",
          "code": "-1 % 5 == 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 10",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 11",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 12",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 13",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378?locale=en",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Reading first point (A)\n    int xa = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int ya = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    // Reading second point (B)\n    int xb = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int yb = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    // Reading third point (C)\n    int xc = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int yc = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    // Ensure that all points are pairwise different\n    ensuref(xa != xb || ya != yb, \"Points A and B should be different\");\n    ensuref(xa != xc || ya != yc, \"Points A and C should be different\");\n    ensuref(xb != xc || yb != yc, \"Points B and C should be different\");\n\n    // Check that either point B lies on segment AC, or angle ABC is right\n    int abx = xb - xa;\n    int aby = yb - ya;\n    int bcx = xc - xb;\n    int bcy = yc - yb;\n\n    // Check if angle ABC is right (dot product is zero)\n    bool angle_right = (abx * bcx + aby * bcy) == 0;\n\n    // Check if point B lies on segment AC\n    int acx = xc - xa;\n    int acy = yc - ya;\n    int cross = abx * acy - aby * acx;\n    bool colinear = (cross == 0);\n\n    bool b_in_segment_ac = false;\n    if (colinear) {\n        int minx = min(xa, xc);\n        int maxx = max(xa, xc);\n        int miny = min(ya, yc);\n        int maxy = max(ya, yc);\n        if (xb >= minx && xb <= maxx && yb >= miny && yb <= maxy) {\n            b_in_segment_ac = true;\n        }\n    }\n\n    ensuref(angle_right || b_in_segment_ac, \"Either point B lies on segment AC, or angle ABC is right\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Reading first point (A)\n    int xa = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int ya = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    // Reading second point (B)\n    int xb = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int yb = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    // Reading third point (C)\n    int xc = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int yc = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    // Ensure that all points are pairwise different\n    ensuref(xa != xb || ya != yb, \"Points A and B should be different\");\n    ensuref(xa != xc || ya != yc, \"Points A and C should be different\");\n    ensuref(xb != xc || yb != yc, \"Points B and C should be different\");\n\n    // Check that either point B lies on segment AC, or angle ABC is right\n    int abx = xb - xa;\n    int aby = yb - ya;\n    int bcx = xc - xb;\n    int bcy = yc - yb;\n\n    // Check if angle ABC is right (dot product is zero)\n    bool angle_right = (abx * bcx + aby * bcy) == 0;\n\n    // Check if point B lies on segment AC\n    int acx = xc - xa;\n    int acy = yc - ya;\n    int cross = abx * acy - aby * acx;\n    bool colinear = (cross == 0);\n\n    bool b_in_segment_ac = false;\n    if (colinear) {\n        int minx = min(xa, xc);\n        int maxx = max(xa, xc);\n        int miny = min(ya, yc);\n        int maxy = max(ya, yc);\n        if (xb >= minx && xb <= maxx && yb >= miny && yb <= maxy) {\n            b_in_segment_ac = true;\n        }\n    }\n\n    ensuref(angle_right || b_in_segment_ac, \"Either point B lies on segment AC, or angle ABC is right\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Reading first point (A)\n    int xa = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int ya = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    // Reading second point (B)\n    int xb = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int yb = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    // Reading third point (C)\n    int xc = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int yc = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    // Ensure that all points are pairwise different\n    ensuref(xa != xb || ya != yb, \"Points A and B should be different\");\n    ensuref(xa != xc || ya != yc, \"Points A and C should be different\");\n    ensuref(xb != xc || yb != yc, \"Points B and C should be different\");\n\n    // Check that either point B lies on segment AC, or angle ABC is right\n    int abx = xb - xa;\n    int aby = yb - ya;\n    int bcx = xc - xb;\n    int bcy = yc - yb;\n\n    // Check if angle ABC is right (dot product is zero)\n    bool angle_right = (abx * bcx + aby * bcy) == 0;\n\n    // Check if point B lies on segment AC\n    int acx = xc - xa;\n    int acy = yc - ya;\n    int cross = abx * acy - aby * acx;\n    bool colinear = (cross == 0);\n\n    bool b_in_segment_ac = false;\n    if (colinear) {\n        int minx = min(xa, xc);\n        int maxx = max(xa, xc);\n        int miny = min(ya, yc);\n        int maxy = max(ya, yc);\n        if (xb >= minx && xb <= maxx && yb >= miny && yb <= maxy) {\n            b_in_segment_ac = true;\n        }\n    }\n\n    ensuref(angle_right || b_in_segment_ac, \"Either point B lies on segment AC, or angle ABC is right\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_coord = opt<int>(\"max_coord\", 1000000000);\n\n    if (type == \"left\") {\n        // Choose A randomly\n        int xa = rnd.next(-max_coord/2, max_coord/2);\n        int ya = rnd.next(-max_coord/2, max_coord/2);\n        // Choose a non-zero small integer vector v1x, v1y\n        int v1x, v1y;\n        do {\n            v1x = rnd.next(-1000, 1000);\n            v1y = rnd.next(-1000, 1000);\n        } while (v1x == 0 && v1y == 0);\n        // Compute B = A + v1\n        ll xb = xa + v1x;\n        ll yb = ya + v1y;\n        // Ensure B within limits\n        if (abs(xb) > max_coord || abs(yb) > max_coord) {\n            xb = xa - v1x;\n            yb = ya - v1y;\n        }\n        // Compute v2 = (-v1y, v1x) // Left turn\n        int v2x = -v1y;\n        int v2y = v1x;\n        // Compute C = B + v2\n        ll xc = xb + v2x;\n        ll yc = yb + v2y;\n        // Ensure C within limits\n        if (abs(xc) > max_coord || abs(yc) > max_coord) {\n            xc = xb - v2x;\n            yc = yb - v2y;\n        }\n        // Ensure all points are distinct\n        if ((xa == xb && ya == yb) || (xa == xc && ya == yc) || (xb == xc && yb == yc)) {\n            xc += 1;\n            yc += 1;\n        }\n        // Output\n        printf(\"%d %d\\n\", xa, ya);\n        printf(\"%lld %lld\\n\", xb, yb);\n        printf(\"%lld %lld\\n\", xc, yc);\n    } else if (type == \"right\") {\n        // Choose A randomly\n        int xa = rnd.next(-max_coord/2, max_coord/2);\n        int ya = rnd.next(-max_coord/2, max_coord/2);\n        // Choose a non-zero small integer vector v1x, v1y\n        int v1x, v1y;\n        do {\n            v1x = rnd.next(-1000, 1000);\n            v1y = rnd.next(-1000, 1000);\n        } while (v1x == 0 && v1y == 0);\n        // Compute B = A + v1\n        ll xb = xa + v1x;\n        ll yb = ya + v1y;\n        // Ensure B within limits\n        if (abs(xb) > max_coord || abs(yb) > max_coord) {\n            xb = xa - v1x;\n            yb = ya - v1y;\n        }\n        // Compute v2 = (v1y, -v1x) // Right turn\n        int v2x = v1y;\n        int v2y = -v1x;\n        // Compute C = B + v2\n        ll xc = xb + v2x;\n        ll yc = yb + v2y;\n        // Ensure C within limits\n        if (abs(xc) > max_coord || abs(yc) > max_coord) {\n            xc = xb - v2x;\n            yc = yb - v2y;\n        }\n        // Ensure all points are distinct\n        if ((xa == xb && ya == yb) || (xa == xc && ya == yc) || (xb == xc && yb == yc)) {\n            xc += 1;\n            yc += 1;\n        }\n        // Output\n        printf(\"%d %d\\n\", xa, ya);\n        printf(\"%lld %lld\\n\", xb, yb);\n        printf(\"%lld %lld\\n\", xc, yc);\n    } else if (type == \"straight\") {\n        // Choose A randomly\n        int xa = rnd.next(-max_coord/2, max_coord/2);\n        int ya = rnd.next(-max_coord/2, max_coord/2);\n        // Choose a non-zero small integer vector v1x, v1y\n        int v1x, v1y;\n        do {\n            v1x = rnd.next(-1000, 1000);\n            v1y = rnd.next(-1000, 1000);\n        } while (v1x == 0 && v1y == 0);\n        // Compute B = A + v1\n        ll xb = xa + v1x;\n        ll yb = ya + v1y;\n        // Ensure B within limits\n        if (abs(xb) > max_coord || abs(yb) > max_coord) {\n            xb = xa - v1x;\n            yb = ya - v1y;\n        }\n        // Compute C = B + v1\n        ll xc = xb + v1x;\n        ll yc = yb + v1y;\n        // Ensure C within limits\n        if (abs(xc) > max_coord || abs(yc) > max_coord) {\n            xc = xb - v1x;\n            yc = yb - v1y;\n        }\n        // Ensure all points are distinct\n        if ((xa == xb && ya == yb) || (xa == xc && ya == yc) || (xb == xc && yb == yc)) {\n            xc += 1;\n            yc += 1;\n        }\n        // Output\n        printf(\"%d %d\\n\", xa, ya);\n        printf(\"%lld %lld\\n\", xb, yb);\n        printf(\"%lld %lld\\n\", xc, yc);\n    } else if (type == \"random\") {\n        int choice = rnd.next(2); // 0 or 1\n        if (choice == 0) {\n            // Generate a case where B lies on segment AC\n            // Pick A and C randomly\n            int xa = rnd.next(-max_coord/2, max_coord/2);\n            int ya = rnd.next(-max_coord/2, max_coord/2);\n            int xc = rnd.next(-max_coord/2, max_coord/2);\n            int yc = rnd.next(-max_coord/2, max_coord/2);\n            // Ensure A and C are distinct\n            while (xa == xc && ya == yc) {\n                xc = rnd.next(-max_coord/2, max_coord/2);\n                yc = rnd.next(-max_coord/2, max_coord/2);\n            }\n            // Generate B on segment AC\n            int t_numer = rnd.next(1, 99); // t_numer in [1,99]\n            int t_denom = 100; // t = t_numer / t_denom\n            ll xb = xa + (xc - xa) * t_numer / t_denom;\n            ll yb = ya + (yc - ya) * t_numer / t_denom;\n            // Ensure B is distinct from A and C\n            if ((xb == xa && yb == ya) || (xb == xc && yb == yc)) {\n                xb += 1;\n                yb += 1;\n            }\n            // Output\n            printf(\"%d %d\\n\", xa, ya);\n            printf(\"%lld %lld\\n\", xb, yb);\n            printf(\"%d %d\\n\", xc, yc);\n        } else {\n            // Generate a case where angle ABC is right\n            // Generate B randomly\n            int xb = rnd.next(-max_coord/2, max_coord/2);\n            int yb = rnd.next(-max_coord/2, max_coord/2);\n            // Choose a non-zero small integer vector v1\n            int v1x, v1y;\n            do {\n                v1x = rnd.next(-1000, 1000);\n                v1y = rnd.next(-1000, 1000);\n            } while (v1x == 0 && v1y == 0);\n            // Compute A = B - v1\n            ll xa = xb - v1x;\n            ll ya = yb - v1y;\n            // Ensure A within limits\n            if (abs(xa) > max_coord || abs(ya) > max_coord) {\n                xa = xb + v1x;\n                ya = yb + v1y;\n            }\n            // Compute v2 = rotate v1 by 90 degrees\n            int v2x = -v1y;\n            int v2y = v1x;\n            // Compute C = B + v2\n            ll xc = xb + v2x;\n            ll yc = yb + v2y;\n            // Ensure C within limits\n            if (abs(xc) > max_coord || abs(yc) > max_coord) {\n                xc = xb - v2x;\n                yc = yb - v2y;\n            }\n            // Ensure all points are distinct\n            if ((xa == xb && ya == yb) || (xa == xc && ya == yc) || (xb == xc && yb == yc)) {\n                xc += 1;\n                yc += 1;\n            }\n            // Output\n            printf(\"%lld %lld\\n\", xa, ya);\n            printf(\"%d %d\\n\", xb, yb);\n            printf(\"%lld %lld\\n\", xc, yc);\n        }\n    } else if (type == \"max_coord\") {\n        // Coordinates near maximum values\n        int xa = -max_coord;\n        int ya = -max_coord;\n        int xb = 0;\n        int yb = 0;\n        int xc = max_coord;\n        int yc = max_coord;\n        // Output\n        printf(\"%d %d\\n\", xa, ya);\n        printf(\"%d %d\\n\", xb, yb);\n        printf(\"%d %d\\n\", xc, yc);\n    } else if (type == \"vertical\") {\n        // Choose x-coordinate\n        int x = rnd.next(-max_coord/2, max_coord/2);\n        // Choose ya and yb such that ya != yb\n        int ya = rnd.next(-max_coord/2, max_coord/2);\n        int yb;\n        do {\n            yb = rnd.next(-max_coord/2, max_coord/2);\n        } while (yb == ya);\n        // So A = (x, ya), B = (x, yb)\n        // vector v1 = (0, yb - ya)\n        int v1x = 0;\n        int v1y = yb - ya;\n        // For LEFT turn, v2 = (-v1y, v1x)\n        int v2x = -v1y;\n        int v2y = 0;\n        // Compute C = B + v2\n        ll xc = x + v2x;\n        ll yc = yb + v2y;\n        // Ensure coordinates within limits\n        if (abs(xc) > max_coord || abs(yc) > max_coord) {\n            v2x = v1y;\n            xc = x + v2x;\n        }\n        // Output A, B, C\n        printf(\"%d %d\\n\", x, ya);\n        printf(\"%d %d\\n\", x, yb);\n        printf(\"%lld %lld\\n\", xc, yc);\n    } else if (type == \"horizontal\") {\n        // Choose y-coordinate\n        int y = rnd.next(-max_coord/2, max_coord/2);\n        // Choose xa and xb such that xa != xb\n        int xa = rnd.next(-max_coord/2, max_coord/2);\n        int xb;\n        do {\n            xb = rnd.next(-max_coord/2, max_coord/2);\n        } while (xb == xa);\n        // So A = (xa, y), B = (xb, y)\n        // vector v1 = (xb - xa, 0)\n        int v1x = xb - xa;\n        int v1y = 0;\n        // For LEFT turn, v2 = (-v1y, v1x)\n        int v2x = 0;\n        int v2y = v1x;\n        // Compute C = B + v2\n        ll xc = xb + v2x;\n        ll yc = y + v2y;\n        // Ensure coordinates within limits\n        if (abs(xc) > max_coord || abs(yc) > max_coord) {\n            v2y = -v1x;\n            yc = y + v2y;\n        }\n        // Output A, B, C\n        printf(\"%d %d\\n\", xa, y);\n        printf(\"%d %d\\n\", xb, y);\n        printf(\"%lld %lld\\n\", xc, yc);\n    } else {\n        // Default to random type\n        // ... (same as random case above)\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_coord = opt<int>(\"max_coord\", 1000000000);\n\n    if (type == \"left\") {\n        // Choose A randomly\n        int xa = rnd.next(-max_coord/2, max_coord/2);\n        int ya = rnd.next(-max_coord/2, max_coord/2);\n        // Choose a non-zero small integer vector v1x, v1y\n        int v1x, v1y;\n        do {\n            v1x = rnd.next(-1000, 1000);\n            v1y = rnd.next(-1000, 1000);\n        } while (v1x == 0 && v1y == 0);\n        // Compute B = A + v1\n        ll xb = xa + v1x;\n        ll yb = ya + v1y;\n        // Ensure B within limits\n        if (abs(xb) > max_coord || abs(yb) > max_coord) {\n            xb = xa - v1x;\n            yb = ya - v1y;\n        }\n        // Compute v2 = (-v1y, v1x) // Left turn\n        int v2x = -v1y;\n        int v2y = v1x;\n        // Compute C = B + v2\n        ll xc = xb + v2x;\n        ll yc = yb + v2y;\n        // Ensure C within limits\n        if (abs(xc) > max_coord || abs(yc) > max_coord) {\n            xc = xb - v2x;\n            yc = yb - v2y;\n        }\n        // Ensure all points are distinct\n        if ((xa == xb && ya == yb) || (xa == xc && ya == yc) || (xb == xc && yb == yc)) {\n            xc += 1;\n            yc += 1;\n        }\n        // Output\n        printf(\"%d %d\\n\", xa, ya);\n        printf(\"%lld %lld\\n\", xb, yb);\n        printf(\"%lld %lld\\n\", xc, yc);\n    } else if (type == \"right\") {\n        // Choose A randomly\n        int xa = rnd.next(-max_coord/2, max_coord/2);\n        int ya = rnd.next(-max_coord/2, max_coord/2);\n        // Choose a non-zero small integer vector v1x, v1y\n        int v1x, v1y;\n        do {\n            v1x = rnd.next(-1000, 1000);\n            v1y = rnd.next(-1000, 1000);\n        } while (v1x == 0 && v1y == 0);\n        // Compute B = A + v1\n        ll xb = xa + v1x;\n        ll yb = ya + v1y;\n        // Ensure B within limits\n        if (abs(xb) > max_coord || abs(yb) > max_coord) {\n            xb = xa - v1x;\n            yb = ya - v1y;\n        }\n        // Compute v2 = (v1y, -v1x) // Right turn\n        int v2x = v1y;\n        int v2y = -v1x;\n        // Compute C = B + v2\n        ll xc = xb + v2x;\n        ll yc = yb + v2y;\n        // Ensure C within limits\n        if (abs(xc) > max_coord || abs(yc) > max_coord) {\n            xc = xb - v2x;\n            yc = yb - v2y;\n        }\n        // Ensure all points are distinct\n        if ((xa == xb && ya == yb) || (xa == xc && ya == yc) || (xb == xc && yb == yc)) {\n            xc += 1;\n            yc += 1;\n        }\n        // Output\n        printf(\"%d %d\\n\", xa, ya);\n        printf(\"%lld %lld\\n\", xb, yb);\n        printf(\"%lld %lld\\n\", xc, yc);\n    } else if (type == \"straight\") {\n        // Choose A randomly\n        int xa = rnd.next(-max_coord/2, max_coord/2);\n        int ya = rnd.next(-max_coord/2, max_coord/2);\n        // Choose a non-zero small integer vector v1x, v1y\n        int v1x, v1y;\n        do {\n            v1x = rnd.next(-1000, 1000);\n            v1y = rnd.next(-1000, 1000);\n        } while (v1x == 0 && v1y == 0);\n        // Compute B = A + v1\n        ll xb = xa + v1x;\n        ll yb = ya + v1y;\n        // Ensure B within limits\n        if (abs(xb) > max_coord || abs(yb) > max_coord) {\n            xb = xa - v1x;\n            yb = ya - v1y;\n        }\n        // Compute C = B + v1\n        ll xc = xb + v1x;\n        ll yc = yb + v1y;\n        // Ensure C within limits\n        if (abs(xc) > max_coord || abs(yc) > max_coord) {\n            xc = xb - v1x;\n            yc = yb - v1y;\n        }\n        // Ensure all points are distinct\n        if ((xa == xb && ya == yb) || (xa == xc && ya == yc) || (xb == xc && yb == yc)) {\n            xc += 1;\n            yc += 1;\n        }\n        // Output\n        printf(\"%d %d\\n\", xa, ya);\n        printf(\"%lld %lld\\n\", xb, yb);\n        printf(\"%lld %lld\\n\", xc, yc);\n    } else if (type == \"random\") {\n        int choice = rnd.next(2); // 0 or 1\n        if (choice == 0) {\n            // Generate a case where B lies on segment AC\n            // Pick A and C randomly\n            int xa = rnd.next(-max_coord/2, max_coord/2);\n            int ya = rnd.next(-max_coord/2, max_coord/2);\n            int xc = rnd.next(-max_coord/2, max_coord/2);\n            int yc = rnd.next(-max_coord/2, max_coord/2);\n            // Ensure A and C are distinct\n            while (xa == xc && ya == yc) {\n                xc = rnd.next(-max_coord/2, max_coord/2);\n                yc = rnd.next(-max_coord/2, max_coord/2);\n            }\n            // Generate B on segment AC\n            int t_numer = rnd.next(1, 99); // t_numer in [1,99]\n            int t_denom = 100; // t = t_numer / t_denom\n            ll xb = xa + (xc - xa) * t_numer / t_denom;\n            ll yb = ya + (yc - ya) * t_numer / t_denom;\n            // Ensure B is distinct from A and C\n            if ((xb == xa && yb == ya) || (xb == xc && yb == yc)) {\n                xb += 1;\n                yb += 1;\n            }\n            // Output\n            printf(\"%d %d\\n\", xa, ya);\n            printf(\"%lld %lld\\n\", xb, yb);\n            printf(\"%d %d\\n\", xc, yc);\n        } else {\n            // Generate a case where angle ABC is right\n            // Generate B randomly\n            int xb = rnd.next(-max_coord/2, max_coord/2);\n            int yb = rnd.next(-max_coord/2, max_coord/2);\n            // Choose a non-zero small integer vector v1\n            int v1x, v1y;\n            do {\n                v1x = rnd.next(-1000, 1000);\n                v1y = rnd.next(-1000, 1000);\n            } while (v1x == 0 && v1y == 0);\n            // Compute A = B - v1\n            ll xa = xb - v1x;\n            ll ya = yb - v1y;\n            // Ensure A within limits\n            if (abs(xa) > max_coord || abs(ya) > max_coord) {\n                xa = xb + v1x;\n                ya = yb + v1y;\n            }\n            // Compute v2 = rotate v1 by 90 degrees\n            int v2x = -v1y;\n            int v2y = v1x;\n            // Compute C = B + v2\n            ll xc = xb + v2x;\n            ll yc = yb + v2y;\n            // Ensure C within limits\n            if (abs(xc) > max_coord || abs(yc) > max_coord) {\n                xc = xb - v2x;\n                yc = yb - v2y;\n            }\n            // Ensure all points are distinct\n            if ((xa == xb && ya == yb) || (xa == xc && ya == yc) || (xb == xc && yb == yc)) {\n                xc += 1;\n                yc += 1;\n            }\n            // Output\n            printf(\"%lld %lld\\n\", xa, ya);\n            printf(\"%d %d\\n\", xb, yb);\n            printf(\"%lld %lld\\n\", xc, yc);\n        }\n    } else if (type == \"max_coord\") {\n        // Coordinates near maximum values\n        int xa = -max_coord;\n        int ya = -max_coord;\n        int xb = 0;\n        int yb = 0;\n        int xc = max_coord;\n        int yc = max_coord;\n        // Output\n        printf(\"%d %d\\n\", xa, ya);\n        printf(\"%d %d\\n\", xb, yb);\n        printf(\"%d %d\\n\", xc, yc);\n    } else if (type == \"vertical\") {\n        // Choose x-coordinate\n        int x = rnd.next(-max_coord/2, max_coord/2);\n        // Choose ya and yb such that ya != yb\n        int ya = rnd.next(-max_coord/2, max_coord/2);\n        int yb;\n        do {\n            yb = rnd.next(-max_coord/2, max_coord/2);\n        } while (yb == ya);\n        // So A = (x, ya), B = (x, yb)\n        // vector v1 = (0, yb - ya)\n        int v1x = 0;\n        int v1y = yb - ya;\n        // For LEFT turn, v2 = (-v1y, v1x)\n        int v2x = -v1y;\n        int v2y = 0;\n        // Compute C = B + v2\n        ll xc = x + v2x;\n        ll yc = yb + v2y;\n        // Ensure coordinates within limits\n        if (abs(xc) > max_coord || abs(yc) > max_coord) {\n            v2x = v1y;\n            xc = x + v2x;\n        }\n        // Output A, B, C\n        printf(\"%d %d\\n\", x, ya);\n        printf(\"%d %d\\n\", x, yb);\n        printf(\"%lld %lld\\n\", xc, yc);\n    } else if (type == \"horizontal\") {\n        // Choose y-coordinate\n        int y = rnd.next(-max_coord/2, max_coord/2);\n        // Choose xa and xb such that xa != xb\n        int xa = rnd.next(-max_coord/2, max_coord/2);\n        int xb;\n        do {\n            xb = rnd.next(-max_coord/2, max_coord/2);\n        } while (xb == xa);\n        // So A = (xa, y), B = (xb, y)\n        // vector v1 = (xb - xa, 0)\n        int v1x = xb - xa;\n        int v1y = 0;\n        // For LEFT turn, v2 = (-v1y, v1x)\n        int v2x = 0;\n        int v2y = v1x;\n        // Compute C = B + v2\n        ll xc = xb + v2x;\n        ll yc = y + v2y;\n        // Ensure coordinates within limits\n        if (abs(xc) > max_coord || abs(yc) > max_coord) {\n            v2y = -v1x;\n            yc = y + v2y;\n        }\n        // Output A, B, C\n        printf(\"%d %d\\n\", xa, y);\n        printf(\"%d %d\\n\", xb, y);\n        printf(\"%lld %lld\\n\", xc, yc);\n    } else {\n        // Default to random type\n        // ... (same as random case above)\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random -max_coord 1000\n./gen -type random -max_coord 1000000000\n./gen -type left\n./gen -type left -max_coord 1000000000\n./gen -type right\n./gen -type right -max_coord 1000000000\n./gen -type straight\n./gen -type straight -max_coord 1000000000\n./gen -type vertical\n./gen -type vertical -max_coord 1000000000\n./gen -type horizontal\n./gen -type horizontal -max_coord 1000000000\n./gen -type max_coord -max_coord 1000000000\n./gen -type left -max_coord 1\n./gen -type right -max_coord 1\n./gen -type straight -max_coord 1\n./gen -type random -max_coord 1\n./gen -type left -max_coord 1000000\n./gen -type right -max_coord 1000000\n./gen -type straight -max_coord 1000000\n./gen -type random -max_coord 1000000\n./gen -type random -max_coord 999999999\n./gen -type random -max_coord 1000000000\n./gen -type left -max_coord 1000000000\n./gen -type right -max_coord 1000000000\n./gen -type straight -max_coord 1000000000\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:01.170628",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "227/B",
      "title": "B. Effective Approach",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of elements in the array. The second line contains n distinct space-separated integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of array. The third line contains integer m (1 ≤ m ≤ 105) — the number of queries. The last line contains m space-separated integers b1, b2, ..., bm (1 ≤ bi ≤ n) — the search queries. Note that the queries can repeat.",
      "output_spec": "OutputPrint two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy21 211OutputCopy1 2InputCopy22 111OutputCopy2 1InputCopy33 1 231 2 3OutputCopy6 6",
      "description": "B. Effective Approach\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of elements in the array. The second line contains n distinct space-separated integers a1, a2, ..., an (1 ≤ ai ≤ n) — the elements of array. The third line contains integer m (1 ≤ m ≤ 105) — the number of queries. The last line contains m space-separated integers b1, b2, ..., bm (1 ≤ bi ≤ n) — the search queries. Note that the queries can repeat.\n\nOutputPrint two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nInputCopy21 211OutputCopy1 2InputCopy22 111OutputCopy2 1InputCopy33 1 231 2 3OutputCopy6 6\n\nInputCopy21 211\n\nOutputCopy1 2\n\nInputCopy22 111\n\nOutputCopy2 1\n\nInputCopy33 1 231 2 3\n\nOutputCopy6 6\n\nNoteIn the first sample Vasya's approach will make one comparison (it starts with the 1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the 2-nd array element, doesn't find the search item and compares with the 1-st element).In the second sample, on the contrary, Vasya's approach will need two comparisons (first with 1-st element, and then with the 2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the 2-nd element).",
      "solutions": [
        {
          "title": "Codeforces Round #140 - Codeforces",
          "content": "Hello everyone!Today, at 19:30 MSK Codeforces Round #140 will take place. The competition will be held in both divisions.I'am the author of today's competition. My name is Ilya Malinovsky, I'm student of Saint-Petersburg State University. This is my first Codeforces round.I want to express my gratitude to Gerald Agapov (Gerald) for his help during the work on the round, Maria Belova (Delinur) for statements' translation from Russian into English, Mikhail Mirzayanov (MikeMirzayanov) for the possibility to prerare contests (and, of course, to compete in them) here, on Codeforces. As usual, in most of the problems participants will help different characters to cope with their troubles and misfortunes. You will have only two hours to help epical hero, an alien, noble knight and other characters. Also, insidious stone heaps will resist you in one of the problems...I hope, most of participants will enjoy the tasks.Good luck!P.S. Information about score distribution will appear not long before the round starts.upd. Score distribution is stadart (500-1000-1500-2000-2500) in both divisions.upd 2 Round is over! Congratulations for winners!div1: peter50216 Dmitry_Egorov Egor RAVEman bmerry Winners have from 3 to 4 solved problems. Noone managed to solve E.div2: Velicue (he is the only div2-participant, who got 5 \"OK\"s) Frommi Aerolight Shahriar_sust bzdbz Thanks to everyone for participating! I hope, you've enjoeyd the round. Full editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1454
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #140 - Codeforces - Code 1",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 2",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 3",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 4",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 5",
          "code": "V1 if C else V2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 6",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 7",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 8",
          "code": "((VALUE%m)+m)%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 9",
          "code": "-1 % 5 == 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 10",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 11",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 12",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 13",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378?locale=en",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read a_i's\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    // Check that a_i's are distinct\n    vector<bool> seen(n+1, false); // Indexing from 1 to n\n    for (int i = 0; i < n; ++i) {\n        int val = a[i];\n        ensuref(!seen[val], \"Array 'a' contains duplicate value %d at position %d\", val, i+1);\n        seen[val] = true;\n    }\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read b_i's\n    vector<int> b = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    // Reached EOF\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read a_i's\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    // Check that a_i's are distinct\n    vector<bool> seen(n+1, false); // Indexing from 1 to n\n    for (int i = 0; i < n; ++i) {\n        int val = a[i];\n        ensuref(!seen[val], \"Array 'a' contains duplicate value %d at position %d\", val, i+1);\n        seen[val] = true;\n    }\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read b_i's\n    vector<int> b = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    // Reached EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read a_i's\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    // Check that a_i's are distinct\n    vector<bool> seen(n+1, false); // Indexing from 1 to n\n    for (int i = 0; i < n; ++i) {\n        int val = a[i];\n        ensuref(!seen[val], \"Array 'a' contains duplicate value %d at position %d\", val, i+1);\n        seen[val] = true;\n    }\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read b_i's\n    vector<int> b = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    // Reached EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string array_type = opt<string>(\"array_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate array a[1..n], which is a permutation of 1 to n\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = i + 1;\n    }\n\n    if (array_type == \"sorted\") {\n        // Already sorted\n    } else if (array_type == \"reversed\") {\n        reverse(a.begin(), a.end());\n    } else if (array_type == \"random\") {\n        shuffle(a.begin(), a.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    }\n\n    // Generate queries b[1..m], elements between 1 and n\n    vector<int> b(m);\n    if (query_type == \"first_element\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = a[0]; // First element of the array\n        }\n    } else if (query_type == \"last_element\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = a[n - 1]; // Last element of the array\n        }\n    } else if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, n);\n        }\n    } else if (query_type == \"all_elements\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = a[i % n];\n        }\n    } else if (query_type == \"alternate_first_last\") {\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0)\n                b[i] = a[0];\n            else\n                b[i] = a[n - 1];\n        }\n    } else if (query_type == \"middle_element\") {\n        int mid = n / 2;\n        for (int i = 0; i < m; ++i) {\n            b[i] = a[mid];\n        }\n    } else if (query_type == \"few_distinct\") {\n        int k = opt<int>(\"k\", 5);\n        set<int> choices_set;\n        while ((int)choices_set.size() < k) {\n            int val = rnd.next(1, n);\n            choices_set.insert(val);\n        }\n        vector<int> choices(choices_set.begin(), choices_set.end());\n        for (int i = 0; i < m; ++i) {\n            b[i] = choices[rnd.next(0, k - 1)];\n        }\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output array b\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], \" \\n\"[i == m - 1]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string array_type = opt<string>(\"array_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate array a[1..n], which is a permutation of 1 to n\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = i + 1;\n    }\n\n    if (array_type == \"sorted\") {\n        // Already sorted\n    } else if (array_type == \"reversed\") {\n        reverse(a.begin(), a.end());\n    } else if (array_type == \"random\") {\n        shuffle(a.begin(), a.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n    }\n\n    // Generate queries b[1..m], elements between 1 and n\n    vector<int> b(m);\n    if (query_type == \"first_element\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = a[0]; // First element of the array\n        }\n    } else if (query_type == \"last_element\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = a[n - 1]; // Last element of the array\n        }\n    } else if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, n);\n        }\n    } else if (query_type == \"all_elements\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = a[i % n];\n        }\n    } else if (query_type == \"alternate_first_last\") {\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0)\n                b[i] = a[0];\n            else\n                b[i] = a[n - 1];\n        }\n    } else if (query_type == \"middle_element\") {\n        int mid = n / 2;\n        for (int i = 0; i < m; ++i) {\n            b[i] = a[mid];\n        }\n    } else if (query_type == \"few_distinct\") {\n        int k = opt<int>(\"k\", 5);\n        set<int> choices_set;\n        while ((int)choices_set.size() < k) {\n            int val = rnd.next(1, n);\n            choices_set.insert(val);\n        }\n        vector<int> choices(choices_set.begin(), choices_set.end());\n        for (int i = 0; i < m; ++i) {\n            b[i] = choices[rnd.next(0, k - 1)];\n        }\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output array b\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], \" \\n\"[i == m - 1]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m\n./gen -n 1 -m 1 -array_type sorted -query_type first_element\n./gen -n 2 -m 2 -array_type reversed -query_type last_element\n./gen -n 5 -m 5 -array_type random -query_type random\n./gen -n 10 -m 10 -array_type sorted -query_type all_elements\n./gen -n 10 -m 10 -array_type reversed -query_type all_elements\n\n# Medium n and m\n./gen -n 1000 -m 1000 -array_type random -query_type random\n./gen -n 1000 -m 1000 -array_type sorted -query_type first_element\n./gen -n 1000 -m 1000 -array_type reversed -query_type last_element\n\n# Large n and m\n./gen -n 100000 -m 100000 -array_type random -query_type random\n./gen -n 100000 -m 100000 -array_type sorted -query_type first_element\n./gen -n 100000 -m 100000 -array_type reversed -query_type last_element\n\n# Cases where Vasya's approach is better\n./gen -n 100000 -m 100000 -array_type random -query_type first_element\n./gen -n 100000 -m 100000 -array_type sorted -query_type first_element\n\n# Cases where Petya's approach is better\n./gen -n 100000 -m 100000 -array_type random -query_type last_element\n./gen -n 100000 -m 100000 -array_type reversed -query_type last_element\n\n# Cases where both approaches have the same number of comparisons\n./gen -n 100000 -m 100000 -array_type random -query_type random\n\n# Queries for the middle element\n./gen -n 100000 -m 100000 -array_type random -query_type middle_element\n\n# Alternate between first and last elements\n./gen -n 100000 -m 100000 -array_type random -query_type alternate_first_last\n\n# Queries covering all elements\n./gen -n 100000 -m 100000 -array_type random -query_type all_elements\n\n# Few distinct queries, k=1\n./gen -n 100000 -m 100000 -array_type random -query_type few_distinct -k 1\n\n# Few distinct queries, k=5\n./gen -n 100000 -m 100000 -array_type random -query_type few_distinct -k 5\n\n# Small m, large n\n./gen -n 100000 -m 1 -array_type random -query_type first_element\n./gen -n 100000 -m 1 -array_type random -query_type last_element\n\n# Edge cases\n./gen -n 99999 -m 99999 -array_type random -query_type random\n./gen -n 1 -m 100000 -array_type random -query_type first_element\n./gen -n 100000 -m 1 -array_type random -query_type random\n\n# Reversed array with first_element queries\n./gen -n 100000 -m 100000 -array_type reversed -query_type first_element\n\n# Sorted array with last_element queries\n./gen -n 100000 -m 100000 -array_type sorted -query_type last_element\n\n# Maximum n and m with random settings\n./gen -n 100000 -m 100000 -array_type random -query_type random\n\n# Minimum n and m with random settings\n./gen -n 1 -m 1 -array_type random -query_type random\n\n# Alternate n and m sizes\n./gen -n 50000 -m 100000 -array_type random -query_type random\n./gen -n 100000 -m 50000 -array_type random -query_type random\n\n# Testing with maximum n and m\n./gen -n 100000 -m 100000 -array_type random -query_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:03.355047",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "227/C",
      "title": "C. Flying Saucer Segments",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers: n and m (1 ≤ n, m ≤ 109) — the number of aliens on the saucer and the number, modulo which you should print the answer, correspondingly.",
      "output_spec": "OutputPrint a single number — the answer to the problem modulo m.",
      "sample_tests": "ExamplesInputCopy1 10OutputCopy2InputCopy3 8OutputCopy2",
      "description": "C. Flying Saucer Segments\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers: n and m (1 ≤ n, m ≤ 109) — the number of aliens on the saucer and the number, modulo which you should print the answer, correspondingly.\n\nOutputPrint a single number — the answer to the problem modulo m.\n\nInputCopy1 10OutputCopy2InputCopy3 8OutputCopy2\n\nInputCopy1 10\n\nOutputCopy2\n\nInputCopy3 8\n\nOutputCopy2\n\nNoteIn the first sample the only crew member moves from segment 3 to segment 2, and then from segment 2 to segment 1 without any problems. Thus, the whole moving will take two minutes.To briefly describe the movements in the second sample we will use value , which would correspond to an alien with rank i moving from the segment in which it is at the moment, to the segment number j. Using these values, we will describe the movements between the segments in the second sample: , , , , , , , , , , , , , , , , , , , , , , , , , ; In total: the aliens need 26 moves. The remainder after dividing 26 by 8 equals 2, so the answer to this test is 2.",
      "solutions": [
        {
          "title": "Codeforces Round #140 - Codeforces",
          "content": "Hello everyone!Today, at 19:30 MSK Codeforces Round #140 will take place. The competition will be held in both divisions.I'am the author of today's competition. My name is Ilya Malinovsky, I'm student of Saint-Petersburg State University. This is my first Codeforces round.I want to express my gratitude to Gerald Agapov (Gerald) for his help during the work on the round, Maria Belova (Delinur) for statements' translation from Russian into English, Mikhail Mirzayanov (MikeMirzayanov) for the possibility to prerare contests (and, of course, to compete in them) here, on Codeforces. As usual, in most of the problems participants will help different characters to cope with their troubles and misfortunes. You will have only two hours to help epical hero, an alien, noble knight and other characters. Also, insidious stone heaps will resist you in one of the problems...I hope, most of participants will enjoy the tasks.Good luck!P.S. Information about score distribution will appear not long before the round starts.upd. Score distribution is stadart (500-1000-1500-2000-2500) in both divisions.upd 2 Round is over! Congratulations for winners!div1: peter50216 Dmitry_Egorov Egor RAVEman bmerry Winners have from 3 to 4 solved problems. Noone managed to solve E.div2: Velicue (he is the only div2-participant, who got 5 \"OK\"s) Frommi Aerolight Shahriar_sust bzdbz Thanks to everyone for participating! I hope, you've enjoeyd the round. Full editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1454
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #140 - Codeforces - Code 1",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 2",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 3",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 4",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 5",
          "code": "V1 if C else V2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 6",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 7",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 8",
          "code": "((VALUE%m)+m)%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 9",
          "code": "-1 % 5 == 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 10",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 11",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 12",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 13",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378?locale=en",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly one test case per run.\n\n  Usage examples:\n    1) ./gen -n 10 -m 100 -type single\n       This will simply output \"10 100\".\n\n    2) ./gen -type corner\n       This will randomly pick one corner-case pair (n, m) and output it.\n\n    3) ./gen -type random\n       This will randomly pick n and m in the range [1..10^9] and output them.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    long long userN = opt<long long>(\"n\", -1LL);\n    long long userM = opt<long long>(\"m\", -1LL);\n    string type      = opt<string>(\"type\", \"random\");\n\n    // A few corner cases that might catch common mistakes\n    // (Feel free to add or remove pairs to your liking.)\n    static vector<pair<long long, long long>> cornerCases = {\n        {1, 1},\n        {1, 10},\n        {3, 8},\n        {2, 2},\n        {10, 100},\n        {999999999LL, 999999999LL},\n        {1000000000LL, 999999999LL},\n        {999999999LL, 1}\n    };\n\n    long long n = 0, m = 0;\n\n    // If type == \"single\", we simply use userN, userM as is (must not be -1).\n    // If type == \"corner\", we pick one corner pair at random.\n    // If type == \"random\", we generate random n,m in [1..10^9], unless the user overrides with -n / -m.\n    if (type == \"single\") {\n        // user must supply n and m\n        // minimal checks (the problem constraints are 1 <= n,m <= 10^9)\n        // although in many real contests the generator might do additional checks or corrections\n        if (userN < 1 || userN > 1000000000LL) {\n            cerr << \"Error: invalid n in single mode.\\n\";\n            return 1;\n        }\n        if (userM < 1 || userM > 1000000000LL) {\n            cerr << \"Error: invalid m in single mode.\\n\";\n            return 1;\n        }\n        n = userN;\n        m = userM;\n    }\n    else if (type == \"corner\") {\n        // pick one corner case pair\n        auto chosen = cornerCases[rnd.next((int)cornerCases.size())];\n        n = chosen.first;\n        m = chosen.second;\n    }\n    else {\n        // type == \"random\"\n        // if user supplies n != -1, we use that; otherwise pick random\n        // likewise for m\n        if (userN == -1LL) {\n            n = rnd.next(1LL, 1000000000LL);\n        } else {\n            if (userN < 1 || userN > 1000000000LL) {\n                cerr << \"Error: invalid userN in random mode.\\n\";\n                return 1;\n            }\n            n = userN;\n        }\n        if (userM == -1LL) {\n            m = rnd.next(1LL, 1000000000LL);\n        } else {\n            if (userM < 1 || userM > 1000000000LL) {\n                cerr << \"Error: invalid userM in random mode.\\n\";\n                return 1;\n            }\n            m = userM;\n        }\n    }\n\n    // Output the single test case\n    // Format: \"n m\"\n    cout << n << \" \" << m << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly one test case per run.\n\n  Usage examples:\n    1) ./gen -n 10 -m 100 -type single\n       This will simply output \"10 100\".\n\n    2) ./gen -type corner\n       This will randomly pick one corner-case pair (n, m) and output it.\n\n    3) ./gen -type random\n       This will randomly pick n and m in the range [1..10^9] and output them.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    long long userN = opt<long long>(\"n\", -1LL);\n    long long userM = opt<long long>(\"m\", -1LL);\n    string type      = opt<string>(\"type\", \"random\");\n\n    // A few corner cases that might catch common mistakes\n    // (Feel free to add or remove pairs to your liking.)\n    static vector<pair<long long, long long>> cornerCases = {\n        {1, 1},\n        {1, 10},\n        {3, 8},\n        {2, 2},\n        {10, 100},\n        {999999999LL, 999999999LL},\n        {1000000000LL, 999999999LL},\n        {999999999LL, 1}\n    };\n\n    long long n = 0, m = 0;\n\n    // If type == \"single\", we simply use userN, userM as is (must not be -1).\n    // If type == \"corner\", we pick one corner pair at random.\n    // If type == \"random\", we generate random n,m in [1..10^9], unless the user overrides with -n / -m.\n    if (type == \"single\") {\n        // user must supply n and m\n        // minimal checks (the problem constraints are 1 <= n,m <= 10^9)\n        // although in many real contests the generator might do additional checks or corrections\n        if (userN < 1 || userN > 1000000000LL) {\n            cerr << \"Error: invalid n in single mode.\\n\";\n            return 1;\n        }\n        if (userM < 1 || userM > 1000000000LL) {\n            cerr << \"Error: invalid m in single mode.\\n\";\n            return 1;\n        }\n        n = userN;\n        m = userM;\n    }\n    else if (type == \"corner\") {\n        // pick one corner case pair\n        auto chosen = cornerCases[rnd.next((int)cornerCases.size())];\n        n = chosen.first;\n        m = chosen.second;\n    }\n    else {\n        // type == \"random\"\n        // if user supplies n != -1, we use that; otherwise pick random\n        // likewise for m\n        if (userN == -1LL) {\n            n = rnd.next(1LL, 1000000000LL);\n        } else {\n            if (userN < 1 || userN > 1000000000LL) {\n                cerr << \"Error: invalid userN in random mode.\\n\";\n                return 1;\n            }\n            n = userN;\n        }\n        if (userM == -1LL) {\n            m = rnd.next(1LL, 1000000000LL);\n        } else {\n            if (userM < 1 || userM > 1000000000LL) {\n                cerr << \"Error: invalid userM in random mode.\\n\";\n                return 1;\n            }\n            m = userM;\n        }\n    }\n\n    // Output the single test case\n    // Format: \"n m\"\n    cout << n << \" \" << m << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# 1) A trivial corner: n=1, m=1\n./gen -n 1 -m 1 -type single\n\n# 2) Another small single: n=1, m=10\n./gen -n 1 -m 10 -type single\n\n# 3) Matches the sample in the statement: n=3, m=8\n./gen -n 3 -m 8 -type single\n\n# 4) Medium single: n=10, m=100\n./gen -n 10 -m 100 -type single\n\n# 5) Large single: n=999999999, m=999999999\n./gen -n 999999999 -m 999999999 -type single\n\n# 6) A corner test, randomly chosen from the built-in corner cases\n./gen -type corner\n\n# 7) Another corner test (again random pick from corner list)\n./gen -type corner\n\n# 8) Another corner test\n./gen -type corner\n\n# 9) Random test, no manual n/m\n./gen -type random\n\n# 10) Random test, no manual n/m\n./gen -type random\n\n# 11) Random test, no manual n/m\n./gen -type random\n\n# 12) Random test, no manual n/m\n./gen -type random\n\n# 13) Random test, no manual n/m\n./gen -type random\n\n# 14) Random test, no manual n/m\n./gen -type random\n\n# 15) Random test, no manual n/m\n./gen -type random\n\n# 16) Random test, no manual n/m\n./gen -type random\n\n# 17) Large random n but fixed m\n./gen -n 999999999 -type random\n\n# 18) Large random m but fixed n\n./gen -m 999999999 -type random\n\n# 19) Fixed moderate n but random m\n./gen -n 500000 -type random\n\n# 20) Fixed moderate m but random n\n./gen -m 500000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:05.352871",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "227/D",
      "title": "D. Naughty Stone Piles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of stone piles. The second line contains n space-separated integers: a1, a2, ..., an (1 ≤ ai ≤ 109) — the initial sizes of the stone piles. The third line contains integer q (1 ≤ q ≤ 105) — the number of queries. The last line contains q space-separated integers k1, k2, ..., kq (1 ≤ ki ≤ 105) — the values of number k for distinct queries. Note that numbers ki can repeat.",
      "output_spec": "OutputPrint q whitespace-separated integers — the answers to the queries in the order, in which the queries are given in the input.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy52 3 4 1 122 3OutputCopy9 8",
      "description": "D. Naughty Stone Piles\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of stone piles. The second line contains n space-separated integers: a1, a2, ..., an (1 ≤ ai ≤ 109) — the initial sizes of the stone piles. The third line contains integer q (1 ≤ q ≤ 105) — the number of queries. The last line contains q space-separated integers k1, k2, ..., kq (1 ≤ ki ≤ 105) — the values of number k for distinct queries. Note that numbers ki can repeat.\n\nOutputPrint q whitespace-separated integers — the answers to the queries in the order, in which the queries are given in the input.Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy52 3 4 1 122 3OutputCopy9 8\n\nInputCopy52 3 4 1 122 3\n\nOutputCopy9 8\n\nNoteIn the first sample one way to get the optimal answer goes like this: we add in turns the 4-th and the 5-th piles to the 2-nd one; then we add the 1-st pile to the 3-rd one; we add the 2-nd pile to the 3-rd one. The first two operations cost 1 each; the third one costs 2, the fourth one costs 5 (the size of the 2-nd pile after the first two operations is not 3, it already is 5). In the second sample you can add the 2-nd pile to the 3-rd one (the operations costs 3); then the 1-st one to the 3-th one (the cost is 2); then the 5-th one to the 4-th one (the costs is 1); and at last, the 4-th one to the 3-rd one (the cost is 2).",
      "solutions": [
        {
          "title": "Codeforces Round #140 - Codeforces",
          "content": "Hello everyone!Today, at 19:30 MSK Codeforces Round #140 will take place. The competition will be held in both divisions.I'am the author of today's competition. My name is Ilya Malinovsky, I'm student of Saint-Petersburg State University. This is my first Codeforces round.I want to express my gratitude to Gerald Agapov (Gerald) for his help during the work on the round, Maria Belova (Delinur) for statements' translation from Russian into English, Mikhail Mirzayanov (MikeMirzayanov) for the possibility to prerare contests (and, of course, to compete in them) here, on Codeforces. As usual, in most of the problems participants will help different characters to cope with their troubles and misfortunes. You will have only two hours to help epical hero, an alien, noble knight and other characters. Also, insidious stone heaps will resist you in one of the problems...I hope, most of participants will enjoy the tasks.Good luck!P.S. Information about score distribution will appear not long before the round starts.upd. Score distribution is stadart (500-1000-1500-2000-2500) in both divisions.upd 2 Round is over! Congratulations for winners!div1: peter50216 Dmitry_Egorov Egor RAVEman bmerry Winners have from 3 to 4 solved problems. Noone managed to solve E.div2: Velicue (he is the only div2-participant, who got 5 \"OK\"s) Frommi Aerolight Shahriar_sust bzdbz Thanks to everyone for participating! I hope, you've enjoeyd the round. Full editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1454
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #140 - Codeforces - Code 1",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 2",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 3",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 4",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 5",
          "code": "V1 if C else V2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 6",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 7",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 8",
          "code": "((VALUE%m)+m)%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 9",
          "code": "-1 % 5 == 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 10",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 11",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 12",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 13",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378?locale=en",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    \n    vector<int> k = inf.readInts(q, 1, 100000, \"k_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    \n    vector<int> k = inf.readInts(q, 1, 100000, \"k_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    \n    vector<int> k = inf.readInts(q, 1, 100000, \"k_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    string k_type = opt<string>(\"k_type\", \"random\");\n\n    int max_ai = opt<int>(\"max_ai\", 1000000000);\n    int max_k = opt<int>(\"max_k\", n);\n\n    vector<int> a(n);\n    vector<int> k(q);\n\n    // Generate ai's\n    if (ai_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n    } else if (ai_type == \"same\") {\n        int value = rnd.next(1, max_ai);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (ai_type == \"small\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (ai_type == \"large\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(max_ai - 10, max_ai);\n        }\n    } else if (ai_type == \"powers\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1 << rnd.next(0, 30);\n        }\n    }\n\n    // Generate ki's\n    if (k_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            k[i] = rnd.next(1, max_k);\n        }\n    } else if (k_type == \"repeated\") {\n        int value = rnd.next(1, max_k);\n        for (int i = 0; i < q; ++i) {\n            k[i] = value;\n        }\n    } else if (k_type == \"small\") {\n        int max_k_small = min(10, max_k);\n        for (int i = 0; i < q; ++i) {\n            k[i] = rnd.next(1, max_k_small);\n        }\n    } else if (k_type == \"large\") {\n        for (int i = 0; i < q; ++i) {\n            k[i] = rnd.next(max(1, max_k - 10), max_k);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d%c\", k[i], i == q-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    string k_type = opt<string>(\"k_type\", \"random\");\n\n    int max_ai = opt<int>(\"max_ai\", 1000000000);\n    int max_k = opt<int>(\"max_k\", n);\n\n    vector<int> a(n);\n    vector<int> k(q);\n\n    // Generate ai's\n    if (ai_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n    } else if (ai_type == \"same\") {\n        int value = rnd.next(1, max_ai);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (ai_type == \"small\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (ai_type == \"large\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(max_ai - 10, max_ai);\n        }\n    } else if (ai_type == \"powers\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1 << rnd.next(0, 30);\n        }\n    }\n\n    // Generate ki's\n    if (k_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            k[i] = rnd.next(1, max_k);\n        }\n    } else if (k_type == \"repeated\") {\n        int value = rnd.next(1, max_k);\n        for (int i = 0; i < q; ++i) {\n            k[i] = value;\n        }\n    } else if (k_type == \"small\") {\n        int max_k_small = min(10, max_k);\n        for (int i = 0; i < q; ++i) {\n            k[i] = rnd.next(1, max_k_small);\n        }\n    } else if (k_type == \"large\") {\n        for (int i = 0; i < q; ++i) {\n            k[i] = rnd.next(max(1, max_k - 10), max_k);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d%c\", k[i], i == q-1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -ai_type small -k_type small\n./gen -n 1 -q 1 -ai_type large -k_type large\n\n./gen -n 10 -q 10 -ai_type random -k_type random\n./gen -n 10 -q 10 -ai_type same -k_type repeated\n\n./gen -n 100 -q 100 -ai_type small -k_type small\n./gen -n 100 -q 100 -ai_type large -k_type large\n./gen -n 100 -q 100 -ai_type powers -k_type random\n\n./gen -n 1000 -q 1000 -ai_type random -k_type small\n./gen -n 1000 -q 1000 -ai_type small -k_type large\n\n./gen -n 10000 -q 10000 -ai_type random -k_type random\n./gen -n 10000 -q 10000 -ai_type same -k_type repeated\n\n./gen -n 100000 -q 100000 -ai_type random -k_type random\n./gen -n 100000 -q 100000 -ai_type large -k_type small\n./gen -n 100000 -q 100000 -ai_type small -k_type large\n\n./gen -n 100000 -q 100000 -ai_type random -k_type random -max_ai 1000000000 -max_k 100000\n\n./gen -n 100000 -q 100000 -ai_type same -max_ai 1 -k_type random\n\n./gen -n 100000 -q 100000 -ai_type same -max_ai 1000000000 -k_type large\n\n./gen -n 100000 -q 100000 -ai_type small -k_type small\n\n./gen -n 100000 -q 100000 -ai_type large -max_ai 1000000000 -k_type small\n\n./gen -n 100000 -q 100000 -ai_type random -k_type repeated -max_k 1\n\n./gen -n 100000 -q 100000 -ai_type random -k_type repeated -max_k 100000\n\n./gen -n 100000 -q 100000 -ai_type random -k_type repeated\n\n./gen -n 100000 -q 100000 -ai_type random -k_type small\n\n./gen -n 100000 -q 100000 -ai_type random -k_type large -max_k 100000\n\n./gen -n 100000 -q 100000 -ai_type powers -k_type random\n\n./gen -n 1 -q 100000 -ai_type small -k_type random\n\n./gen -n 100000 -q 1 -ai_type random -k_type random\n\n./gen -n 100000 -q 100000 -ai_type random -k_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:07.292136",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "227/E",
      "title": "E. Anniversary",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four space-separated integers m, l, r and k (1 ≤ m ≤ 109; 1 ≤ l < r ≤ 1012; 2 ≤ k ≤ r - l + 1).Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint a single integer — the residue from dividing the sought greatest common divisor by m.",
      "sample_tests": "ExamplesInputCopy10 1 8 2OutputCopy3InputCopy10 1 8 3OutputCopy1",
      "description": "E. Anniversary\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four space-separated integers m, l, r and k (1 ≤ m ≤ 109; 1 ≤ l < r ≤ 1012; 2 ≤ k ≤ r - l + 1).Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nOutputPrint a single integer — the residue from dividing the sought greatest common divisor by m.\n\nInputCopy10 1 8 2OutputCopy3InputCopy10 1 8 3OutputCopy1\n\nInputCopy10 1 8 2\n\nOutputCopy3\n\nInputCopy10 1 8 3\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Round #140 - Codeforces",
          "content": "Hello everyone!Today, at 19:30 MSK Codeforces Round #140 will take place. The competition will be held in both divisions.I'am the author of today's competition. My name is Ilya Malinovsky, I'm student of Saint-Petersburg State University. This is my first Codeforces round.I want to express my gratitude to Gerald Agapov (Gerald) for his help during the work on the round, Maria Belova (Delinur) for statements' translation from Russian into English, Mikhail Mirzayanov (MikeMirzayanov) for the possibility to prerare contests (and, of course, to compete in them) here, on Codeforces. As usual, in most of the problems participants will help different characters to cope with their troubles and misfortunes. You will have only two hours to help epical hero, an alien, noble knight and other characters. Also, insidious stone heaps will resist you in one of the problems...I hope, most of participants will enjoy the tasks.Good luck!P.S. Information about score distribution will appear not long before the round starts.upd. Score distribution is stadart (500-1000-1500-2000-2500) in both divisions.upd 2 Round is over! Congratulations for winners!div1: peter50216 Dmitry_Egorov Egor RAVEman bmerry Winners have from 3 to 4 solved problems. Noone managed to solve E.div2: Velicue (he is the only div2-participant, who got 5 \"OK\"s) Frommi Aerolight Shahriar_sust bzdbz Thanks to everyone for participating! I hope, you've enjoeyd the round. Full editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5357",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1454
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces",
          "content": "A div2. Where do I Turn?Let's consider cross product of vectors and , which is equal to . Sign of cross product defines sign of a sine of oriented angle between vectors (because cross product is also equal to ), and that sign leads us to the correct answer.If cross product is equal to zero, then A, B and C lay on the same straight line. So the answer is <>.If cross product is more than zero, then answer is <>.And, at last, if it's less than zero, the answer is <>.Also you should notice that the value of cross product doesn't fit 32-bit type, so you have to use 64-bit type in order to avoid integer overflow.ImplementationB div2. Effective ApproachLet's assume that number t is on the indtth position in the original permutation. Then, obviously, during iterating from left to right this number will be found in indt comparisons, and during iterating from right to left — in n - indt + 1 comparisons. Let's declare additional array, in ith element of each there will be such number j, that aj = i. This array allows to process each query in O(1) using formulas referred above. Additional array is built in O(n) during iterating array a. So, the final complexity is O(n + m).ImplementationC div2 — A div1. Flying Saucer Segments.Let Fn be the answer for the task, where n is equal to the amount of aliens. Let's assume, that we've solved problem for n - 1 aliens, i.e. we know the value of Fn - 1. Let's try to find value of Fn. Notice, that the most junior alien in rank will be able to leave the 3rd section, if and only if all other aliens are in the 1st section. So, now we know first Fn - 1 actions. Then the most junior alien may go to the 2nd section. To make for him entrance to the 1st section possible, it's necessary for all other aliens to return to the first one. So, Fn - 1 more actions are necessary. At last, after the most junior alien will go to the 1st section, Fn - 1 more actions are required for n - 1 other aliens to return to the 1st section from the 3rd. So, Fn = Fn - 1 + 1 + Fn - 1 + 1 + Fn - 1. It allows to count Fn using matrix exponentiation in O(log n), but we'll improve current solution. Let's add 1 to both parts of the equality and after elementary operations we'll have Fn = 3·(Fn - 1 + 1) - 1. Now it's easy to solve this reccurence: Fn = 3n - 1. To count Fn quickly you should use binary power method. Solution's complexity — O(log n).Don't forget that if 3n mod m = 0, answer is equal to m - 1, but not  - 1.And, in conclusion, notice that the task is equal to Hanoi Towers problem with a slight modification (it's impossible to move disks between one pair of rods).ImplementationD div2 — B div1. Naughty Stone PilesConsider the following interpretation of the problem: stone piles are graph vertices. Operation \"add pile a to pile b\" changes to operation of suspencion of subtree of vertice b to vertice a. Numbers, written on vertices, — piles' sizes. Your task is to get such tree configuration, that each vertice has no more than k subtrees suspended to it, and sum of the products of numbers, written on vertices, and vertices' depth (where root's depth is 0) is minimal. In order to minimize the sum, at first, vertice with a larger number must be not deeply than vertice with smaller number (otherwise it's possible to change them and to get less sum), at second, each inner vertice, besides, maybe, one, has exactly k successors (the second condition is also proved using proof by contradiction). Now you are to learn how to calculate sum (described above) for this configuration quickly. In order do to it, let's sort piles' size array, and then let's do the following: at first, let's add to answer sum of sizes of piles from 1st to kth (in 0-indexed array, sorted in non-increasing order), multiplied by 1; then sum of sizes of next k2 piles, multiplied by 2; and so on till the end of array. In order to answer for the query about the sum of segment, precalculate sums of prefixes immediately after array sorting. Now in the case k > 1 we can find answer in O(log n). If you follow the same considerations for k = 1, answer for query will get O(n) operations that's why solution will get TL, if k is equal to 1 in most of the queries. So you should calculate the answer for k = 1 beforehand and memorize it, in order to response such queries in O(1).Complexity — O(n · log n  +  q · log n).ImplementationE div2 — C div1. AnniversaryAt first, let's prove the statement: GCD(Fn, Fm) = FGCD(n, m).Let's express Fn + k using Fn and Fk. We'll get the formula: Fn + k = Fk·Fn + 1 + Fk - 1·Fn, which is easy to prove by induction.Then use the derived formula and notice, that GCD(Fn + k, Fn) = GCD(Fk, Fn). Now you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.So, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD. Let the answer be equal to q. Then  -  ⌉ + 1 ≥ k (1) must be true.Notice, that for each summand from left part of inequality O( ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q - 1 value of at least one summand changes (obviously, increases). There are also such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q = 1 is true for any input.So, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.ImplementationComplexity — .D div1. The table.Let's get the required table. Act in the following way: find any row or column with negative sum and invert it. Notice, that sum of numbers in the entire table will always increase (at least, by 2). It can't increase permanently, because its maximal possible summary change is 200·n·m. So we'll get the required table anyway. It takes us not more than 100·n·m operations (applying of the spell), each of those is performed in O(n) or O(m). So, we've learned how to get required table in not more than ~ 1004 operations.Now let's restore the answer. It's easy to understand that it will contain those rows and columns, which we've inverted odd times.ImplementationE div1. Noble Knight's PathSolution 1It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.Each knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y + 1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.If the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down).ImplementationSolution 2Let's go round the tree using dfs. When we enter the vertex and when we leave it let's put down vertex's number in the additional array (you can find out that this list has something same with regular brackets sequence). Assign 0 as the second number to all elements of the array. Then build persistent segment tree on the described array.Now, when the first event happens, we'll assign  + 1 to the second number in position of the first occurence of a castle's number, and  - 1 to a position of the last one.In order to answer for the second query, just notice, that we should count sum of the second numbers assigned to positions between first occurences of the vertices a and b in the array described above for finding the amount of visited vertices in the path connecting them. Now on each of the paths separately start binary search for an answer — position of required castle. For the answer's check use the idea from the previous paragraph.Complexity: O(m·log2 n) — in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) iterations of binary search on answer, each of iterations takes O(log n) operations.ImplementationQuestions?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5378?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9545
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #140 - Codeforces - Code 1",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 2",
          "code": "def d_down( r,l,k ):\n  d = (r-l)/(k-1)                                    ### 1 below\n  while d > 1:                                       ### 4 below\n    if (1+(r/d)-((l+d-1)/d))>=k: return d            ### 2 below\n    N = 1 + (r/d)                                    ### 3.2 below\n    d -= ( ((N*d)-r) + (N-1) ) / N                   ### 3.4 below\n  return 1\n\n\"\"\"\nbasically` \n1) (r-l)/(k-1) is the maximum possible d, given r, l and k\n2) the if...return tests if k d's fit between l and r\n3) if not, then d must decrease; can't loop decrement (d-=1) with 1E12 ranges, so\n3.1) R = d * (1 + r/d) is a multiple of d greater than r, and\n3.2) N = (1 + r/d) is the multiplier of d that gets to that R = N*d, so\n3.3) (N*d - r) is how far R has to drop to be <= r, so\n3.4) ((N*d-r) + (N-1)) / N is the minimum decrease in d which will drop R to <= r\n4) go back to 2) above, with decreased, new d\n\ne.g. input m,101,200,2  (answer is 66: *2=132; *3=198)\n\nInitial d = 200 - 101 = 99\nbut only one multiple of 99 between 101 and 200 inclusive, i.e. 198\n\n       101                       200                    ## boundaries r and l\n     99                       198              297      ## multiples of max possible d; R=297; N=3\n\nand if you start decreasing d from 99, then\n\n  98                      196              294           ## multiples of d-1\n97                    194               291              ## multiples of d-2\n...",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 3",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 4",
          "code": "import sys\ndef recfib(n,m):\n  if n==0: return (0,1,)\n  a, b = recfib(n / 2,m)\n  return ( [ a*(((2*b)-a)%m), ((b*b)%m)+((a*a)%m)][n%2], [ ((b*b)%m)+((a*a)%m), b*((2*a+b)%m)][n%2], )\nm,l,r,k = map( int, sys.stdin.readline().strip().split()[:4] )\nD = (r-l)/(k-1)\nwhile D > 1 and (1+(r/D)-((l+D-1)/D))<k:\n  N = 1 + (r/D)\n  D -= ( ((N*D)-r) + (N-1) ) / N\nprint( recfib( D, m)[0] )",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 5",
          "code": "V1 if C else V2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 6",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 7",
          "code": "return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 8",
          "code": "((VALUE%m)+m)%m)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 9",
          "code": "-1 % 5 == 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 10",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 11",
          "code": "def recfib(n,m):\n    if n == 0: return (0, 1)\n    a, b = recfib(n / 2,m)\n    return ((b*b+a*a)%m, b*(2*a+b)%m) if n%2 else (a*((2*b)-a)%m, ((b*b+a*a))%m)\ndef next_d(D): return D if 1+r/D-(l+D-1)/D>=k else next_d(D-(D-r%D+r/D)/(1+r/D))\nm, l, r, k = map(long, raw_input().split())\nprint recfib(next_d((r-l)/(k-1)), m)[0]\n\n# Trick to remove N from the code: N = 1 + r / D\n# D -= (N*D-r + N - 1)/N\n#   N*D - r = (D + r - r % D - r) = (D - r % D)\n#   N*D - r + N - 1 = D - r % D + r / D",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 12",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 - Codeforces - Code 13",
          "code": "F(N) = 3*F(N-1) + 2\n\nF(1) = 2\nF(2) = 3*F(1) + 2\nF(2) = 3*2 + 2\nF(2) = 3*2 + 3 - 1\nF(2) = 3 (2+1) - 1\nF(2) = 3^2 - 1\n...\nF(N) = 3^N - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5357",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #140 Editorial - Codeforces - Code 1",
          "code": "turn Right if unit_dir = -1j\nturn Left  if unit_dir = 1j\ngo Towards if unit_dir = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5378?locale=en",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000LL - 1LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l + 1LL, 1000000000000LL, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(2LL, r - l + 1LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000LL - 1LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l + 1LL, 1000000000000LL, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(2LL, r - l + 1LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000LL - 1LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l + 1LL, 1000000000000LL, \"r\");\n    inf.readSpace();\n    long long k = inf.readLong(2LL, r - l + 1LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    \n    long long m;\n    long long l;\n    long long r;\n    long long k;\n\n    if (type == \"min\") {\n        m = 1;\n        l = 1;\n        r = 2;\n        k = 2;\n    } else if (type == \"max\") {\n        m = 1000000000;\n        l = (long long)(1e12) - (long long)(1e6);\n        r = (long long)(1e12);\n        k = r - l + 1;\n    } else if (type == \"small_m\") {\n        m = 1;\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = rnd.next(l + 1, min(l + 1000LL, (long long)(1e12)));\n        k = rnd.next(2LL, r - l + 1);\n    } else if (type == \"large_m\") {\n        m = 1000000000;\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = rnd.next(l + 1, (long long)(1e12));\n        k = rnd.next(2LL, r - l + 1);\n    } else if (type == \"small_k\") {\n        m = rnd.next(1LL, 1000000000LL);\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = rnd.next(l + 1, (long long)(1e12));\n        k = 2;\n    } else if (type == \"large_k\") {\n        m = rnd.next(1LL, 1000000000LL);\n        l = rnd.next(1LL, (long long)(1e12) - 1000000LL);\n        r = min(l + 999999LL, (long long)(1e12));\n        k = r - l + 1;\n    } else if (type == \"edge_l\") {\n        m = rnd.next(1LL, 1000000000LL);\n        l = 1;\n        r = rnd.next(l + 1, (long long)(1e12));\n        k = rnd.next(2LL, r - l + 1);\n    } else if (type == \"edge_r\") {\n        m = rnd.next(1LL, 1000000000LL);\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = (long long)(1e12);\n        k = rnd.next(2LL, r - l + 1);\n    } else if (type == \"sample1\") {\n        m = 10;\n        l = 1;\n        r = 8;\n        k = 2;\n    } else if (type == \"sample2\") {\n        m = 10;\n        l = 1;\n        r = 8;\n        k = 3;\n    } else if (type == \"random\") {\n        m = rnd.next(1LL, 1000000000LL);\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = rnd.next(l + 1, (long long)(1e12));\n        k = rnd.next(2LL, r - l + 1);\n    } else {\n        // Default to random\n        m = rnd.next(1LL, 1000000000LL);\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = rnd.next(l + 1, (long long)(1e12));\n        k = rnd.next(2LL, r - l + 1);\n    }\n\n    printf(\"%lld %lld %lld %lld\\n\", m, l, r, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    \n    long long m;\n    long long l;\n    long long r;\n    long long k;\n\n    if (type == \"min\") {\n        m = 1;\n        l = 1;\n        r = 2;\n        k = 2;\n    } else if (type == \"max\") {\n        m = 1000000000;\n        l = (long long)(1e12) - (long long)(1e6);\n        r = (long long)(1e12);\n        k = r - l + 1;\n    } else if (type == \"small_m\") {\n        m = 1;\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = rnd.next(l + 1, min(l + 1000LL, (long long)(1e12)));\n        k = rnd.next(2LL, r - l + 1);\n    } else if (type == \"large_m\") {\n        m = 1000000000;\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = rnd.next(l + 1, (long long)(1e12));\n        k = rnd.next(2LL, r - l + 1);\n    } else if (type == \"small_k\") {\n        m = rnd.next(1LL, 1000000000LL);\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = rnd.next(l + 1, (long long)(1e12));\n        k = 2;\n    } else if (type == \"large_k\") {\n        m = rnd.next(1LL, 1000000000LL);\n        l = rnd.next(1LL, (long long)(1e12) - 1000000LL);\n        r = min(l + 999999LL, (long long)(1e12));\n        k = r - l + 1;\n    } else if (type == \"edge_l\") {\n        m = rnd.next(1LL, 1000000000LL);\n        l = 1;\n        r = rnd.next(l + 1, (long long)(1e12));\n        k = rnd.next(2LL, r - l + 1);\n    } else if (type == \"edge_r\") {\n        m = rnd.next(1LL, 1000000000LL);\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = (long long)(1e12);\n        k = rnd.next(2LL, r - l + 1);\n    } else if (type == \"sample1\") {\n        m = 10;\n        l = 1;\n        r = 8;\n        k = 2;\n    } else if (type == \"sample2\") {\n        m = 10;\n        l = 1;\n        r = 8;\n        k = 3;\n    } else if (type == \"random\") {\n        m = rnd.next(1LL, 1000000000LL);\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = rnd.next(l + 1, (long long)(1e12));\n        k = rnd.next(2LL, r - l + 1);\n    } else {\n        // Default to random\n        m = rnd.next(1LL, 1000000000LL);\n        l = rnd.next(1LL, (long long)(1e12) - 1);\n        r = rnd.next(l + 1, (long long)(1e12));\n        k = rnd.next(2LL, r - l + 1);\n    }\n\n    printf(\"%lld %lld %lld %lld\\n\", m, l, r, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type sample1\n./gen -type sample2\n\n./gen -type min\n./gen -type max\n\n./gen -type small_m\n./gen -type large_m\n\n./gen -type small_k\n./gen -type large_k\n\n./gen -type edge_l\n./gen -type edge_r\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Random test cases with small k\n./gen -type small_k\n./gen -type small_k\n./gen -type small_k\n\n# Random test cases with large k\n./gen -type large_k\n./gen -type large_k\n./gen -type large_k\n\n# Random test cases with small m\n./gen -type small_m\n./gen -type small_m\n./gen -type small_m\n\n# Random test cases with large m\n./gen -type large_m\n./gen -type large_m\n./gen -type large_m\n\n# Edge l and random\n./gen -type edge_l\n./gen -type edge_l\n\n# Edge r and random\n./gen -type edge_r\n./gen -type edge_r\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:08.901509",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "228/A",
      "title": "A. Is your horseshoe on the other hoof?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four space-separated integers s1, s2, s3, s4 (1 ≤ s1, s2, s3, s4 ≤ 109) — the colors of horseshoes Valera has.Consider all possible colors indexed with integers.",
      "output_spec": "OutputPrint a single integer — the minimum number of horseshoes Valera needs to buy.",
      "sample_tests": "ExamplesInputCopy1 7 3 3OutputCopy1InputCopy7 7 7 7OutputCopy3",
      "description": "A. Is your horseshoe on the other hoof?\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four space-separated integers s1, s2, s3, s4 (1 ≤ s1, s2, s3, s4 ≤ 109) — the colors of horseshoes Valera has.Consider all possible colors indexed with integers.\n\nOutputPrint a single integer — the minimum number of horseshoes Valera needs to buy.\n\nInputCopy1 7 3 3OutputCopy1InputCopy7 7 7 7OutputCopy3\n\nInputCopy1 7 3 3\n\nOutputCopy1\n\nInputCopy7 7 7 7\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Codeforces Round #141 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #141 for Div.2 participants. But traditionally the others can take part out of the competition.Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Ivan Fefer (Fefer_Ivan), Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Mary Belova (Delinur) for translating problems.Score distribution is standard.We wish you good luck, successful hacks and high rating!UPD: the contest is over, hope you enjoy it) Congratulations to winners: 1) AntiFate 2) alicechennan 3) honeyofsistercha 4) Fride 5) bla_bla_bla UPD2: the editorial was already published, you can find it here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5396",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 760
        },
        {
          "title": "Codeforces Round #141 (Div. 2) Tutorial - Codeforces",
          "content": "228A - Is your horseshoe on the other hoof?In this problem you should count different numbers from input cnt and print 4–cnt. You could do it in different ways. For example, you could use set. 228B - Two TablesIn this problem you should carefully consider every shift  - N <  = x, y <  = N, count the answer and find the maximum value. The complexity of solution is O(N4).228C - Fractal DetectorThis problem could be solved using dynamic programming. State z[x][y][st][mask] means if the square with upper left corner (x, y) is fractal with nesting level st and colors mask. The value z[x][y][st][mask] is 0 or 1. There are O(N2·Log(N)·24) states in this dynamic programming. The transitions from state to state are rather simple. If st = 1 you should fairly check that the square 2*2 with upper left corner (x, y) matches colors of mask. If st > 1 you should divide the square into four parts and check them separately. If the value in mask in one quarter means black color, you should check that the whole quarter is black. It could be done using partial sums on rectangles using O(1) of time. If the quarter is white, you should check that it is a fractal with nesting level st - 1 with the same mask. So, there are less than 4 transitions from every state. To get the answer to the problem you should consider every upper left corner of squares, every mask and every nesting level of fractal and check this square. It is done using your dynamic. 228D - ZigzagIn this problem we will use that sequence s is cyclic because of its structure. Also, it is important that 2 <  = z <  = 6. For every z we will write the sequence s and note that its period is 2 * (z–1). So, for every z and modulo 0 <  = mod < 2 * (z–1) we will build separate segment tree or Fenwick tree. You should be careful with memory, it needs O(Z·(2·Z)·N) of memory. So, if the query is to update some value, we should update z values of trees with correct modules. If the query is to find sum, we should consider every 2·(z–1) modules, count the sum and multiply by correct coefficient from sequence s. The complexity is O(Z·N·Log(N)).228E - The Road to Berland is Paved With Good IntentionsThis problem can be solved in different ways. It was expected the solution that solved the system of modular equations using Gauss algorithm. Here is another simple solution. The vertices from the result call switched-on. Firstly, note that every vertex should be switched-on no more than once. Then, consider every edge (x, y) of color c. We want to make its color 1. So, if c = 1 we should switch on vertices x and y or don’t switch them on simultaneously. If c = 0 we should switch on x or y. So, consider some vertex v and try to switch it on or not. Thus, we can uniquely determine the state of every vertex of the same connected component as v. If we face some collision, we can’t get the solution, you should print Impossible. The solution can be realized using bfs with complexity O(N + M).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5404",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 228\\s*A"
          },
          "content_length": 2961
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #141 (Div. 2) - Codeforces - Code 1",
          "code": "x.cpp: In function 'int main()':\nx.cpp:83:93: warning: format '%c' expects argument of type 'char*', but argument 2 has type 'int*' [-Wformat]\nx.cpp:88:93: warning: format '%c' expects argument of type 'char*', but argument 2 has type 'int*' [-Wformat]\nx.cpp:90:13: warning: declaration of 'x' shadows a global declaration [-Wshadow]\nx.cpp:55:5: warning: shadowed declaration is here [-Wshadow]\nx.cpp:91:17: warning: declaration of 'y' shadows a global declaration [-Wshadow]\nx.cpp:55:8: warning: shadowed declaration is here [-Wshadow]",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5396",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int s1 = inf.readInt(1, 1000000000, \"s1\");\n    inf.readSpace();\n    int s2 = inf.readInt(1, 1000000000, \"s2\");\n    inf.readSpace();\n    int s3 = inf.readInt(1, 1000000000, \"s3\");\n    inf.readSpace();\n    int s4 = inf.readInt(1, 1000000000, \"s4\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int s1 = inf.readInt(1, 1000000000, \"s1\");\n    inf.readSpace();\n    int s2 = inf.readInt(1, 1000000000, \"s2\");\n    inf.readSpace();\n    int s3 = inf.readInt(1, 1000000000, \"s3\");\n    inf.readSpace();\n    int s4 = inf.readInt(1, 1000000000, \"s4\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int s1 = inf.readInt(1, 1000000000, \"s1\");\n    inf.readSpace();\n    int s2 = inf.readInt(1, 1000000000, \"s2\");\n    inf.readSpace();\n    int s3 = inf.readInt(1, 1000000000, \"s3\");\n    inf.readSpace();\n    int s4 = inf.readInt(1, 1000000000, \"s4\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int K = opt<int>(\"K\", -1);\n\n    int s1, s2, s3, s4;\n    const int min_value = 1;\n    const int max_value = 1000000000; // 1e9\n\n    if(type == \"min_all_same\") {\n        s1 = s2 = s3 = s4 = min_value;\n    } else if(type == \"max_all_same\") {\n        s1 = s2 = s3 = s4 = max_value;\n    } else if(type == \"all_same\") {\n        if(K == -1) K = rnd.next(min_value, max_value);\n        s1 = s2 = s3 = s4 = K;\n    } else if(type == \"all_different\") {\n        set<int> colors;\n        while(colors.size() < 4) {\n            int color = rnd.next(min_value, max_value);\n            colors.insert(color);\n        }\n        auto it = colors.begin();\n        s1 = *it++; s2 = *it++; s3 = *it++; s4 = *it++;\n    } else if(type == \"one_duplicate\") {\n        int dup_color = rnd.next(min_value, max_value);\n        s1 = s2 = dup_color;\n        // Now generate two different colors not equal to dup_color\n        do { s3 = rnd.next(min_value, max_value); } while(s3 == dup_color);\n        do { s4 = rnd.next(min_value, max_value); } while(s4 == dup_color || s4 == s3);\n    } else if(type == \"one_duplicate_with_low_values\") {\n        s1 = 1;\n        s2 = 2;\n        s3 = 3;\n        s4 = 1;\n    } else if(type == \"two_duplicates\") {\n        int dup_color1 = rnd.next(min_value, max_value);\n        int dup_color2;\n        do { dup_color2 = rnd.next(min_value, max_value); } while(dup_color2 == dup_color1);\n        s1 = s2 = dup_color1;\n        s3 = s4 = dup_color2;\n    } else if(type == \"two_pairs_min_max\") {\n        s1 = min_value;\n        s2 = min_value;\n        s3 = max_value;\n        s4 = max_value;\n    } else if(type == \"two_pairs_low_values\") {\n        s1 = 1;\n        s2 = 2;\n        s3 = 1;\n        s4 = 2;\n    } else if(type == \"three_same\") {\n        int trip_color = rnd.next(min_value, max_value);\n        s1 = s2 = s3 = trip_color;\n        do { s4 = rnd.next(min_value, max_value); } while(s4 == trip_color);\n    } else if(type == \"alternating_min_max\") {\n        s1 = min_value;\n        s2 = max_value;\n        s3 = min_value;\n        s4 = max_value;\n    } else if(type == \"random\") {\n        s1 = rnd.next(min_value, max_value);\n        s2 = rnd.next(min_value, max_value);\n        s3 = rnd.next(min_value, max_value);\n        s4 = rnd.next(min_value, max_value);\n    } else {\n        // default to random\n        s1 = rnd.next(min_value, max_value);\n        s2 = rnd.next(min_value, max_value);\n        s3 = rnd.next(min_value, max_value);\n        s4 = rnd.next(min_value, max_value);\n    }\n\n    // Output: four space-separated integers\n    printf(\"%d %d %d %d\\n\", s1, s2, s3, s4);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int K = opt<int>(\"K\", -1);\n\n    int s1, s2, s3, s4;\n    const int min_value = 1;\n    const int max_value = 1000000000; // 1e9\n\n    if(type == \"min_all_same\") {\n        s1 = s2 = s3 = s4 = min_value;\n    } else if(type == \"max_all_same\") {\n        s1 = s2 = s3 = s4 = max_value;\n    } else if(type == \"all_same\") {\n        if(K == -1) K = rnd.next(min_value, max_value);\n        s1 = s2 = s3 = s4 = K;\n    } else if(type == \"all_different\") {\n        set<int> colors;\n        while(colors.size() < 4) {\n            int color = rnd.next(min_value, max_value);\n            colors.insert(color);\n        }\n        auto it = colors.begin();\n        s1 = *it++; s2 = *it++; s3 = *it++; s4 = *it++;\n    } else if(type == \"one_duplicate\") {\n        int dup_color = rnd.next(min_value, max_value);\n        s1 = s2 = dup_color;\n        // Now generate two different colors not equal to dup_color\n        do { s3 = rnd.next(min_value, max_value); } while(s3 == dup_color);\n        do { s4 = rnd.next(min_value, max_value); } while(s4 == dup_color || s4 == s3);\n    } else if(type == \"one_duplicate_with_low_values\") {\n        s1 = 1;\n        s2 = 2;\n        s3 = 3;\n        s4 = 1;\n    } else if(type == \"two_duplicates\") {\n        int dup_color1 = rnd.next(min_value, max_value);\n        int dup_color2;\n        do { dup_color2 = rnd.next(min_value, max_value); } while(dup_color2 == dup_color1);\n        s1 = s2 = dup_color1;\n        s3 = s4 = dup_color2;\n    } else if(type == \"two_pairs_min_max\") {\n        s1 = min_value;\n        s2 = min_value;\n        s3 = max_value;\n        s4 = max_value;\n    } else if(type == \"two_pairs_low_values\") {\n        s1 = 1;\n        s2 = 2;\n        s3 = 1;\n        s4 = 2;\n    } else if(type == \"three_same\") {\n        int trip_color = rnd.next(min_value, max_value);\n        s1 = s2 = s3 = trip_color;\n        do { s4 = rnd.next(min_value, max_value); } while(s4 == trip_color);\n    } else if(type == \"alternating_min_max\") {\n        s1 = min_value;\n        s2 = max_value;\n        s3 = min_value;\n        s4 = max_value;\n    } else if(type == \"random\") {\n        s1 = rnd.next(min_value, max_value);\n        s2 = rnd.next(min_value, max_value);\n        s3 = rnd.next(min_value, max_value);\n        s4 = rnd.next(min_value, max_value);\n    } else {\n        // default to random\n        s1 = rnd.next(min_value, max_value);\n        s2 = rnd.next(min_value, max_value);\n        s3 = rnd.next(min_value, max_value);\n        s4 = rnd.next(min_value, max_value);\n    }\n\n    // Output: four space-separated integers\n    printf(\"%d %d %d %d\\n\", s1, s2, s3, s4);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# All colors are the same, minimal value\n./gen -type min_all_same\n\n# All colors are the same, maximal value\n./gen -type max_all_same\n\n# All colors are the same, K is specified\n./gen -type all_same -K 42\n./gen -type all_same -K 1000000000\n./gen -type all_same -K 1\n\n# All colors are different\n./gen -type all_different\n./gen -type all_different\n./gen -type all_different\n\n# One duplicate color\n./gen -type one_duplicate\n./gen -type one_duplicate\n./gen -type one_duplicate\n\n# Two duplicates\n./gen -type two_duplicates\n./gen -type two_duplicates\n./gen -type two_duplicates\n\n# Three colors the same\n./gen -type three_same\n./gen -type three_same\n./gen -type three_same\n\n# Random cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Edge cases with combinations of min and max values\n./gen -type alternating_min_max\n\n# Edge case: s1=1, s2=1, s3=1000000000, s4=1000000000\n./gen -type two_pairs_min_max\n\n# Edge case: s1=1, s2=2, s3=1, s4=2\n./gen -type two_pairs_low_values\n\n# Edge case: s1=1, s2=2, s3=3, s4=1\n./gen -type one_duplicate_with_low_values\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:10.579957",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "228/B",
      "title": "B. Two Tables",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers na, ma (1 ≤ na, ma ≤ 50) — the number of rows and columns in the first table. Then na lines contain ma characters each — the elements of the first table. Each character is either a \"0\", or a \"1\".The next line contains two space-separated integers nb, mb (1 ≤ nb, mb ≤ 50) — the number of rows and columns in the second table. Then follow the elements of the second table in the format, similar to the first table.It is guaranteed that the first table has at least one number \"1\". It is guaranteed that the second table has at least one number \"1\".",
      "output_spec": "OutputPrint two space-separated integers x, y (|x|, |y| ≤ 109) — a shift with maximum overlap factor. If there are multiple solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy3 20110002 3001111OutputCopy0 1InputCopy3 30000100001 11OutputCopy-1 -1",
      "description": "B. Two Tables\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers na, ma (1 ≤ na, ma ≤ 50) — the number of rows and columns in the first table. Then na lines contain ma characters each — the elements of the first table. Each character is either a \"0\", or a \"1\".The next line contains two space-separated integers nb, mb (1 ≤ nb, mb ≤ 50) — the number of rows and columns in the second table. Then follow the elements of the second table in the format, similar to the first table.It is guaranteed that the first table has at least one number \"1\". It is guaranteed that the second table has at least one number \"1\".\n\nOutputPrint two space-separated integers x, y (|x|, |y| ≤ 109) — a shift with maximum overlap factor. If there are multiple solutions, print any of them.\n\nInputCopy3 20110002 3001111OutputCopy0 1InputCopy3 30000100001 11OutputCopy-1 -1\n\nInputCopy3 20110002 3001111\n\nOutputCopy0 1\n\nInputCopy3 30000100001 11\n\nOutputCopy-1 -1",
      "solutions": [
        {
          "title": "Codeforces Round #141 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #141 for Div.2 participants. But traditionally the others can take part out of the competition.Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Ivan Fefer (Fefer_Ivan), Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Mary Belova (Delinur) for translating problems.Score distribution is standard.We wish you good luck, successful hacks and high rating!UPD: the contest is over, hope you enjoy it) Congratulations to winners: 1) AntiFate 2) alicechennan 3) honeyofsistercha 4) Fride 5) bla_bla_bla UPD2: the editorial was already published, you can find it here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5396",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 760
        },
        {
          "title": "Codeforces Round #141 (Div. 2) Tutorial - Codeforces",
          "content": "228A - Is your horseshoe on the other hoof?In this problem you should count different numbers from input cnt and print 4–cnt. You could do it in different ways. For example, you could use set. 228B - Two TablesIn this problem you should carefully consider every shift  - N <  = x, y <  = N, count the answer and find the maximum value. The complexity of solution is O(N4).228C - Fractal DetectorThis problem could be solved using dynamic programming. State z[x][y][st][mask] means if the square with upper left corner (x, y) is fractal with nesting level st and colors mask. The value z[x][y][st][mask] is 0 or 1. There are O(N2·Log(N)·24) states in this dynamic programming. The transitions from state to state are rather simple. If st = 1 you should fairly check that the square 2*2 with upper left corner (x, y) matches colors of mask. If st > 1 you should divide the square into four parts and check them separately. If the value in mask in one quarter means black color, you should check that the whole quarter is black. It could be done using partial sums on rectangles using O(1) of time. If the quarter is white, you should check that it is a fractal with nesting level st - 1 with the same mask. So, there are less than 4 transitions from every state. To get the answer to the problem you should consider every upper left corner of squares, every mask and every nesting level of fractal and check this square. It is done using your dynamic. 228D - ZigzagIn this problem we will use that sequence s is cyclic because of its structure. Also, it is important that 2 <  = z <  = 6. For every z we will write the sequence s and note that its period is 2 * (z–1). So, for every z and modulo 0 <  = mod < 2 * (z–1) we will build separate segment tree or Fenwick tree. You should be careful with memory, it needs O(Z·(2·Z)·N) of memory. So, if the query is to update some value, we should update z values of trees with correct modules. If the query is to find sum, we should consider every 2·(z–1) modules, count the sum and multiply by correct coefficient from sequence s. The complexity is O(Z·N·Log(N)).228E - The Road to Berland is Paved With Good IntentionsThis problem can be solved in different ways. It was expected the solution that solved the system of modular equations using Gauss algorithm. Here is another simple solution. The vertices from the result call switched-on. Firstly, note that every vertex should be switched-on no more than once. Then, consider every edge (x, y) of color c. We want to make its color 1. So, if c = 1 we should switch on vertices x and y or don’t switch them on simultaneously. If c = 0 we should switch on x or y. So, consider some vertex v and try to switch it on or not. Thus, we can uniquely determine the state of every vertex of the same connected component as v. If we face some collision, we can’t get the solution, you should print Impossible. The solution can be realized using bfs with complexity O(N + M).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5404",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 228\\s*B"
          },
          "content_length": 2961
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #141 (Div. 2) - Codeforces - Code 1",
          "code": "x.cpp: In function 'int main()':\nx.cpp:83:93: warning: format '%c' expects argument of type 'char*', but argument 2 has type 'int*' [-Wformat]\nx.cpp:88:93: warning: format '%c' expects argument of type 'char*', but argument 2 has type 'int*' [-Wformat]\nx.cpp:90:13: warning: declaration of 'x' shadows a global declaration [-Wshadow]\nx.cpp:55:5: warning: shadowed declaration is here [-Wshadow]\nx.cpp:91:17: warning: declaration of 'y' shadows a global declaration [-Wshadow]\nx.cpp:55:8: warning: shadowed declaration is here [-Wshadow]",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5396",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int na = inf.readInt(1, 50, \"na\");\n    inf.readSpace();\n    int ma = inf.readInt(1, 50, \"ma\");\n    inf.readEoln();\n\n    bool has_one_first = false;\n    for (int i = 0; i < na; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == ma, \"Line %d of first table should have length %d\", i+1, ma);\n        for (char c : s) {\n            ensuref(c == '0' || c == '1', \"Invalid character '%c' in line %d of first table\", c, i+1);\n            if (c == '1') has_one_first = true;\n        }\n    }\n    ensuref(has_one_first, \"First table must contain at least one '1'\");\n\n    int nb = inf.readInt(1, 50, \"nb\");\n    inf.readSpace();\n    int mb = inf.readInt(1, 50, \"mb\");\n    inf.readEoln();\n\n    bool has_one_second = false;\n    for (int i = 0; i < nb; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == mb, \"Line %d of second table should have length %d\", i+1, mb);\n        for (char c : s) {\n            ensuref(c == '0' || c == '1', \"Invalid character '%c' in line %d of second table\", c, i+1);\n            if (c == '1') has_one_second = true;\n        }\n    }\n    ensuref(has_one_second, \"Second table must contain at least one '1'\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int na = inf.readInt(1, 50, \"na\");\n    inf.readSpace();\n    int ma = inf.readInt(1, 50, \"ma\");\n    inf.readEoln();\n\n    bool has_one_first = false;\n    for (int i = 0; i < na; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == ma, \"Line %d of first table should have length %d\", i+1, ma);\n        for (char c : s) {\n            ensuref(c == '0' || c == '1', \"Invalid character '%c' in line %d of first table\", c, i+1);\n            if (c == '1') has_one_first = true;\n        }\n    }\n    ensuref(has_one_first, \"First table must contain at least one '1'\");\n\n    int nb = inf.readInt(1, 50, \"nb\");\n    inf.readSpace();\n    int mb = inf.readInt(1, 50, \"mb\");\n    inf.readEoln();\n\n    bool has_one_second = false;\n    for (int i = 0; i < nb; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == mb, \"Line %d of second table should have length %d\", i+1, mb);\n        for (char c : s) {\n            ensuref(c == '0' || c == '1', \"Invalid character '%c' in line %d of second table\", c, i+1);\n            if (c == '1') has_one_second = true;\n        }\n    }\n    ensuref(has_one_second, \"Second table must contain at least one '1'\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int na = inf.readInt(1, 50, \"na\");\n    inf.readSpace();\n    int ma = inf.readInt(1, 50, \"ma\");\n    inf.readEoln();\n\n    bool has_one_first = false;\n    for (int i = 0; i < na; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == ma, \"Line %d of first table should have length %d\", i+1, ma);\n        for (char c : s) {\n            ensuref(c == '0' || c == '1', \"Invalid character '%c' in line %d of first table\", c, i+1);\n            if (c == '1') has_one_first = true;\n        }\n    }\n    ensuref(has_one_first, \"First table must contain at least one '1'\");\n\n    int nb = inf.readInt(1, 50, \"nb\");\n    inf.readSpace();\n    int mb = inf.readInt(1, 50, \"mb\");\n    inf.readEoln();\n\n    bool has_one_second = false;\n    for (int i = 0; i < nb; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == mb, \"Line %d of second table should have length %d\", i+1, mb);\n        for (char c : s) {\n            ensuref(c == '0' || c == '1', \"Invalid character '%c' in line %d of second table\", c, i+1);\n            if (c == '1') has_one_second = true;\n        }\n    }\n    ensuref(has_one_second, \"Second table must contain at least one '1'\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> A, B;\nint na, ma, nb, mb;\n\nint computeOverlap(int x, int y) {\n    int sum = 0;\n    for (int i = 0; i < na; ++i) {\n        int ib = i + x;\n        if (ib >= 0 && ib < nb) {\n            for (int j = 0; j < ma; ++j) {\n                int jb = j + y;\n                if (jb >= 0 && jb < mb) {\n                    sum += A[i][j] * B[ib][jb];\n                }\n            }\n        }\n    }\n    return sum;\n}\n\nint readAns(InStream& stream) {\n    int x = stream.readInt(-1000000000, 1000000000, \"x\");\n    int y = stream.readInt(-1000000000, 1000000000, \"y\");\n    int overlap = computeOverlap(x, y);\n    return overlap;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read input\n    na = inf.readInt(1, 50, \"na\");\n    ma = inf.readInt(1, 50, \"ma\");\n    A.resize(na, vector<int>(ma));\n    for (int i = 0; i < na; ++i) {\n        string row = inf.readToken(\"[01]{1,50}\");\n        if ((int)row.size() != ma)\n            inf.quitf(_fail, \"Incorrect row length in the first table\");\n        for (int j = 0; j < ma; ++j)\n            A[i][j] = row[j] - '0';\n    }\n    nb = inf.readInt(1, 50, \"nb\");\n    mb = inf.readInt(1, 50, \"mb\");\n    B.resize(nb, vector<int>(mb));\n    for (int i = 0; i < nb; ++i) {\n        string row = inf.readToken(\"[01]{1,50}\");\n        if ((int)row.size() != mb)\n            inf.quitf(_fail, \"Incorrect row length in the second table\");\n        for (int j = 0; j < mb; ++j)\n            B[i][j] = row[j] - '0';\n    }\n    // Read jury's answer\n    int jOverlap = readAns(ans);\n    // Read participant's answer\n    int pOverlap = readAns(ouf);\n    if (pOverlap < jOverlap) {\n        quitf(_wa, \"Participant's overlap factor %d is less than jury's %d\", pOverlap, jOverlap);\n    } else if (pOverlap == jOverlap) {\n        quitf(_ok, \"Overlap factor %d\", pOverlap);\n    } else {\n        quitf(_fail, \"Participant's overlap factor %d is greater than jury's %d\", pOverlap, jOverlap);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int na = opt<int>(\"na\");\n    int ma = opt<int>(\"ma\");\n    int nb = opt<int>(\"nb\");\n    int mb = opt<int>(\"mb\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Variables to hold the tables\n    vector<string> tableA(na);\n    vector<string> tableB(nb);\n\n    if (type == \"random\") {\n        // Randomly fill tables with '0's and '1's\n        for (int i = 0; i < na; ++i) {\n            tableA[i].resize(ma);\n            for (int j = 0; j < ma; ++j) {\n                tableA[i][j] = (rnd.next(2) == 1) ? '1' : '0';\n            }\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i].resize(mb);\n            for (int j = 0; j < mb; ++j) {\n                tableB[i][j] = (rnd.next(2) == 1) ? '1' : '0';\n            }\n        }\n    } else if (type == \"all_ones\") {\n        // Fill tables with '1's\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '1');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '1');\n        }\n    } else if (type == \"single_one\") {\n        // Make all zeros and put a single '1' at a specific location\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '0');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '0');\n        }\n\n        // Put a '1' at random location in tableA\n        int ia = rnd.next(na);\n        int ja = rnd.next(ma);\n        tableA[ia][ja] = '1';\n\n        // Put a '1' at random location in tableB\n        int ib = rnd.next(nb);\n        int jb = rnd.next(mb);\n        tableB[ib][jb] = '1';\n    } else if (type == \"corner_overlap\") {\n        // Place a '1' at the corner of each table\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '0');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '0');\n        }\n        tableA[0][0] = '1';\n        tableB[0][0] = '1';\n    } else if (type == \"edge_case\") {\n        // Edge case where shift is maximally negative\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '0');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '0');\n        }\n        // Put '1's in tableA at bottom-right corner\n        tableA[na-1][ma-1] = '1';\n        // Put '1's in tableB at top-left corner\n        tableB[0][0] = '1';\n    } else if (type == \"max_overlap\") {\n        // Create tables where maximum overlap can be achieved with full overlap\n        // and shifts are (0,0)\n        int min_n = min(na, nb);\n        int min_m = min(ma, mb);\n        // Fill overlapping area with '1's\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '0');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '0');\n        }\n        for (int i = 0; i < min_n; ++i) {\n            for (int j = 0; j < min_m; ++j) {\n                tableA[i][j] = tableB[i][j] = '1';\n            }\n        }\n    } else if (type == \"no_overlap\") {\n        // Tables with '1's in positions that will never overlap\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '0');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '0');\n        }\n        // Put '1's in tableA at top-left\n        tableA[0][0] = '1';\n        // Put '1's in tableB at bottom-right\n        tableB[nb-1][mb-1] = '1';\n    } else if (type == \"full_random\") {\n        // Random sizes, random content\n        na = rnd.next(1, 50);\n        ma = rnd.next(1, 50);\n        nb = rnd.next(1, 50);\n        mb = rnd.next(1, 50);\n        tableA.resize(na);\n        tableB.resize(nb);\n        for (int i = 0; i < na; ++i) {\n            tableA[i].resize(ma);\n            for (int j = 0; j < ma; ++j) {\n                tableA[i][j] = (rnd.next(2) == 1) ? '1' : '0';\n            }\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i].resize(mb);\n            for (int j = 0; j < mb; ++j) {\n                tableB[i][j] = (rnd.next(2) == 1) ? '1' : '0';\n            }\n        }\n    } else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Ensure that tables have at least one '1'\n    bool has_one_a = false;\n    for (int i = 0; i < na; ++i) {\n        if (tableA[i].find('1') != string::npos) {\n            has_one_a = true;\n            break;\n        }\n    }\n    if (!has_one_a) {\n        // Add a '1' at random position\n        int ia = rnd.next(na);\n        int ja = rnd.next(ma);\n        tableA[ia][ja] = '1';\n    }\n\n    bool has_one_b = false;\n    for (int i = 0; i < nb; ++i) {\n        if (tableB[i].find('1') != string::npos) {\n            has_one_b = true;\n            break;\n        }\n    }\n    if (!has_one_b) {\n        // Add a '1' at random position\n        int ib = rnd.next(nb);\n        int jb = rnd.next(mb);\n        tableB[ib][jb] = '1';\n    }\n\n    // Output tableA\n    printf(\"%d %d\\n\", na, ma);\n    for (int i = 0; i < na; ++i) {\n        printf(\"%s\\n\", tableA[i].c_str());\n    }\n\n    // Output tableB\n    printf(\"%d %d\\n\", nb, mb);\n    for (int i = 0; i < nb; ++i) {\n        printf(\"%s\\n\", tableB[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int na = opt<int>(\"na\");\n    int ma = opt<int>(\"ma\");\n    int nb = opt<int>(\"nb\");\n    int mb = opt<int>(\"mb\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Variables to hold the tables\n    vector<string> tableA(na);\n    vector<string> tableB(nb);\n\n    if (type == \"random\") {\n        // Randomly fill tables with '0's and '1's\n        for (int i = 0; i < na; ++i) {\n            tableA[i].resize(ma);\n            for (int j = 0; j < ma; ++j) {\n                tableA[i][j] = (rnd.next(2) == 1) ? '1' : '0';\n            }\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i].resize(mb);\n            for (int j = 0; j < mb; ++j) {\n                tableB[i][j] = (rnd.next(2) == 1) ? '1' : '0';\n            }\n        }\n    } else if (type == \"all_ones\") {\n        // Fill tables with '1's\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '1');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '1');\n        }\n    } else if (type == \"single_one\") {\n        // Make all zeros and put a single '1' at a specific location\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '0');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '0');\n        }\n\n        // Put a '1' at random location in tableA\n        int ia = rnd.next(na);\n        int ja = rnd.next(ma);\n        tableA[ia][ja] = '1';\n\n        // Put a '1' at random location in tableB\n        int ib = rnd.next(nb);\n        int jb = rnd.next(mb);\n        tableB[ib][jb] = '1';\n    } else if (type == \"corner_overlap\") {\n        // Place a '1' at the corner of each table\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '0');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '0');\n        }\n        tableA[0][0] = '1';\n        tableB[0][0] = '1';\n    } else if (type == \"edge_case\") {\n        // Edge case where shift is maximally negative\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '0');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '0');\n        }\n        // Put '1's in tableA at bottom-right corner\n        tableA[na-1][ma-1] = '1';\n        // Put '1's in tableB at top-left corner\n        tableB[0][0] = '1';\n    } else if (type == \"max_overlap\") {\n        // Create tables where maximum overlap can be achieved with full overlap\n        // and shifts are (0,0)\n        int min_n = min(na, nb);\n        int min_m = min(ma, mb);\n        // Fill overlapping area with '1's\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '0');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '0');\n        }\n        for (int i = 0; i < min_n; ++i) {\n            for (int j = 0; j < min_m; ++j) {\n                tableA[i][j] = tableB[i][j] = '1';\n            }\n        }\n    } else if (type == \"no_overlap\") {\n        // Tables with '1's in positions that will never overlap\n        for (int i = 0; i < na; ++i) {\n            tableA[i] = string(ma, '0');\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i] = string(mb, '0');\n        }\n        // Put '1's in tableA at top-left\n        tableA[0][0] = '1';\n        // Put '1's in tableB at bottom-right\n        tableB[nb-1][mb-1] = '1';\n    } else if (type == \"full_random\") {\n        // Random sizes, random content\n        na = rnd.next(1, 50);\n        ma = rnd.next(1, 50);\n        nb = rnd.next(1, 50);\n        mb = rnd.next(1, 50);\n        tableA.resize(na);\n        tableB.resize(nb);\n        for (int i = 0; i < na; ++i) {\n            tableA[i].resize(ma);\n            for (int j = 0; j < ma; ++j) {\n                tableA[i][j] = (rnd.next(2) == 1) ? '1' : '0';\n            }\n        }\n        for (int i = 0; i < nb; ++i) {\n            tableB[i].resize(mb);\n            for (int j = 0; j < mb; ++j) {\n                tableB[i][j] = (rnd.next(2) == 1) ? '1' : '0';\n            }\n        }\n    } else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Ensure that tables have at least one '1'\n    bool has_one_a = false;\n    for (int i = 0; i < na; ++i) {\n        if (tableA[i].find('1') != string::npos) {\n            has_one_a = true;\n            break;\n        }\n    }\n    if (!has_one_a) {\n        // Add a '1' at random position\n        int ia = rnd.next(na);\n        int ja = rnd.next(ma);\n        tableA[ia][ja] = '1';\n    }\n\n    bool has_one_b = false;\n    for (int i = 0; i < nb; ++i) {\n        if (tableB[i].find('1') != string::npos) {\n            has_one_b = true;\n            break;\n        }\n    }\n    if (!has_one_b) {\n        // Add a '1' at random position\n        int ib = rnd.next(nb);\n        int jb = rnd.next(mb);\n        tableB[ib][jb] = '1';\n    }\n\n    // Output tableA\n    printf(\"%d %d\\n\", na, ma);\n    for (int i = 0; i < na; ++i) {\n        printf(\"%s\\n\", tableA[i].c_str());\n    }\n\n    // Output tableB\n    printf(\"%d %d\\n\", nb, mb);\n    for (int i = 0; i < nb; ++i) {\n        printf(\"%s\\n\", tableB[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -na 5 -ma 5 -nb 5 -mb 5 -type random\n./gen -na 1 -ma 1 -nb 1 -mb 1 -type random\n./gen -na 50 -ma 50 -nb 50 -mb 50 -type random\n./gen -na 50 -ma 50 -nb 50 -mb 50 -type all_ones\n./gen -na 50 -ma 50 -nb 1 -mb 1 -type single_one\n./gen -na 1 -ma 1 -nb 50 -mb 50 -type single_one\n./gen -na 3 -ma 3 -nb 3 -mb 3 -type corner_overlap\n./gen -na 50 -ma 50 -nb 50 -mb 50 -type corner_overlap\n./gen -na 50 -ma 50 -nb 50 -mb 50 -type edge_case\n./gen -na 5 -ma 5 -nb 5 -mb 5 -type max_overlap\n./gen -na 50 -ma 50 -nb 50 -mb 50 -type max_overlap\n./gen -na 50 -ma 50 -nb 50 -mb 50 -type no_overlap\n./gen -na 30 -ma 40 -nb 35 -mb 45 -type random\n./gen -na 20 -ma 20 -nb 20 -mb 20 -type random\n./gen -na 1 -ma 50 -nb 50 -mb 1 -type random\n./gen -na 50 -ma 1 -nb 1 -mb 50 -type random\n./gen -na 25 -ma 25 -nb 25 -mb 25 -type full_random\n./gen -na 50 -ma 50 -nb 50 -mb 50 -type full_random\n./gen -na 10 -ma 10 -nb 10 -mb 10 -type full_random\n./gen -na 2 -ma 2 -nb 2 -mb 2 -type random\n./gen -na 1 -ma 1 -nb 1 -mb 1 -type single_one\n./gen -na 7 -ma 8 -nb 9 -mb 6 -type max_overlap\n./gen -na 6 -ma 7 -nb 8 -mb 9 -type edge_case\n./gen -na 50 -ma 50 -nb 1 -mb 1 -type edge_case\n./gen -na 1 -ma 1 -nb 50 -mb 50 -type edge_case\n./gen -na 1 -ma 1 -nb 1 -mb 1 -type all_ones\n./gen -na 50 -ma 50 -nb 50 -mb 50 -type no_overlap\n./gen -na 30 -ma 30 -nb 30 -mb 30 -type full_random\n./gen -na 25 -ma 25 -nb 25 -mb 25 -type full_random\n./gen -na 25 -ma 25 -nb 25 -mb 25 -type random\n./gen -na 1 -ma 50 -nb 1 -mb 50 -type single_one\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:12.701164",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "228/C",
      "title": "C. Fractal Detector",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n, m (2 ≤ n, m ≤ 500) — the number of rows and columns of the field, correspondingly. Next n lines contain m characters each — the description of the field, painted by Vasya. Character \".\" represents a white cell, character \"*\" represents a black cell.It is guaranteed that the field description doesn't contain other characters than \".\" and \"*\".",
      "output_spec": "OutputOn a single line print a single integer — the number of squares on the field, such that these squares contain a drawn fractal, which can be obtained as described above.",
      "sample_tests": "ExamplesInputCopy6 11......*.****.*.*....**.***....*.*..***.*.....*.*.....**......*.*..OutputCopy3InputCopy4 4..**..**........OutputCopy0",
      "description": "C. Fractal Detector\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n, m (2 ≤ n, m ≤ 500) — the number of rows and columns of the field, correspondingly. Next n lines contain m characters each — the description of the field, painted by Vasya. Character \".\" represents a white cell, character \"*\" represents a black cell.It is guaranteed that the field description doesn't contain other characters than \".\" and \"*\".\n\nOutputOn a single line print a single integer — the number of squares on the field, such that these squares contain a drawn fractal, which can be obtained as described above.\n\nInputCopy6 11......*.****.*.*....**.***....*.*..***.*.....*.*.....**......*.*..OutputCopy3InputCopy4 4..**..**........OutputCopy0\n\nInputCopy6 11......*.****.*.*....**.***....*.*..***.*.....*.*.....**......*.*..\n\nOutputCopy3\n\nInputCopy4 4..**..**........\n\nOutputCopy0\n\nNoteThe answer for the first sample is shown on the picture below. Fractals are outlined by red, blue and green squares.  The answer for the second sample is 0. There is no fractal, equal to the given picture.",
      "solutions": [
        {
          "title": "Codeforces Round #141 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #141 for Div.2 participants. But traditionally the others can take part out of the competition.Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Ivan Fefer (Fefer_Ivan), Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Mary Belova (Delinur) for translating problems.Score distribution is standard.We wish you good luck, successful hacks and high rating!UPD: the contest is over, hope you enjoy it) Congratulations to winners: 1) AntiFate 2) alicechennan 3) honeyofsistercha 4) Fride 5) bla_bla_bla UPD2: the editorial was already published, you can find it here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5396",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 760
        },
        {
          "title": "Codeforces Round #141 (Div. 2) Tutorial - Codeforces",
          "content": "228A - Is your horseshoe on the other hoof?In this problem you should count different numbers from input cnt and print 4–cnt. You could do it in different ways. For example, you could use set. 228B - Two TablesIn this problem you should carefully consider every shift  - N <  = x, y <  = N, count the answer and find the maximum value. The complexity of solution is O(N4).228C - Fractal DetectorThis problem could be solved using dynamic programming. State z[x][y][st][mask] means if the square with upper left corner (x, y) is fractal with nesting level st and colors mask. The value z[x][y][st][mask] is 0 or 1. There are O(N2·Log(N)·24) states in this dynamic programming. The transitions from state to state are rather simple. If st = 1 you should fairly check that the square 2*2 with upper left corner (x, y) matches colors of mask. If st > 1 you should divide the square into four parts and check them separately. If the value in mask in one quarter means black color, you should check that the whole quarter is black. It could be done using partial sums on rectangles using O(1) of time. If the quarter is white, you should check that it is a fractal with nesting level st - 1 with the same mask. So, there are less than 4 transitions from every state. To get the answer to the problem you should consider every upper left corner of squares, every mask and every nesting level of fractal and check this square. It is done using your dynamic. 228D - ZigzagIn this problem we will use that sequence s is cyclic because of its structure. Also, it is important that 2 <  = z <  = 6. For every z we will write the sequence s and note that its period is 2 * (z–1). So, for every z and modulo 0 <  = mod < 2 * (z–1) we will build separate segment tree or Fenwick tree. You should be careful with memory, it needs O(Z·(2·Z)·N) of memory. So, if the query is to update some value, we should update z values of trees with correct modules. If the query is to find sum, we should consider every 2·(z–1) modules, count the sum and multiply by correct coefficient from sequence s. The complexity is O(Z·N·Log(N)).228E - The Road to Berland is Paved With Good IntentionsThis problem can be solved in different ways. It was expected the solution that solved the system of modular equations using Gauss algorithm. Here is another simple solution. The vertices from the result call switched-on. Firstly, note that every vertex should be switched-on no more than once. Then, consider every edge (x, y) of color c. We want to make its color 1. So, if c = 1 we should switch on vertices x and y or don’t switch them on simultaneously. If c = 0 we should switch on x or y. So, consider some vertex v and try to switch it on or not. Thus, we can uniquely determine the state of every vertex of the same connected component as v. If we face some collision, we can’t get the solution, you should print Impossible. The solution can be realized using bfs with complexity O(N + M).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5404",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 228\\s*C"
          },
          "content_length": 2961
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #141 (Div. 2) - Codeforces - Code 1",
          "code": "x.cpp: In function 'int main()':\nx.cpp:83:93: warning: format '%c' expects argument of type 'char*', but argument 2 has type 'int*' [-Wformat]\nx.cpp:88:93: warning: format '%c' expects argument of type 'char*', but argument 2 has type 'int*' [-Wformat]\nx.cpp:90:13: warning: declaration of 'x' shadows a global declaration [-Wshadow]\nx.cpp:55:5: warning: shadowed declaration is here [-Wshadow]\nx.cpp:91:17: warning: declaration of 'y' shadows a global declaration [-Wshadow]\nx.cpp:55:8: warning: shadowed declaration is here [-Wshadow]",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5396",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 500, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d should have exactly m=%d characters, but has length %d\", i + 1, m, (int)s.length());\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Character at line %d position %d is '%c', should be '.' or '*'\", i + 1, j + 1, s[j]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 500, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d should have exactly m=%d characters, but has length %d\", i + 1, m, (int)s.length());\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Character at line %d position %d is '%c', should be '.' or '*'\", i + 1, j + 1, s[j]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 500, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d should have exactly m=%d characters, but has length %d\", i + 1, m, (int)s.length());\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Character at line %d position %d is '%c', should be '.' or '*'\", i + 1, j + 1, s[j]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nstring type;\n\nvector<string> grid;\n\nvoid generateRandomGrid() {\n    grid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i].resize(m);\n        for (int j = 0; j < m; ++j) {\n            grid[i][j] = (rnd.next(2) == 0) ? '.' : '*';\n        }\n    }\n}\n\nvoid generateFullGrid() {\n    grid.assign(n, string(m, '*'));\n}\n\nvoid generateEmptyGrid() {\n    grid.assign(n, string(m, '.'));\n}\n\nvoid generateFractalPattern(vector<vector<char>>& pattern) {\n    pattern.resize(2, vector<char>(2));\n    for (int i = 0; i < 2; ++i)\n        for (int j = 0; j < 2; ++j)\n            pattern[i][j] = (rnd.next(2) == 0) ? '.' : '*';\n}\n\nvoid drawFractal(int x, int y, int size, vector<vector<char>>& pattern, int depth) {\n    if (size <= 0 || x >= n || y >= m) return;\n    if (size == 2) {\n        for (int i = 0; i < 2 && x + i < n; ++i)\n            for (int j = 0; j < 2 && y + j < m; ++j)\n                grid[x + i][y + j] = pattern[i][j];\n        return;\n    }\n\n    int newSize = size / 2;\n    for (int i = 0; i < 2; ++i)\n        for (int j = 0; j < 2; ++j) {\n            int nx = x + i * newSize;\n            int ny = y + j * newSize;\n            if (nx < n && ny < m) {\n                if (pattern[i][j] == '*') {\n                    for (int a = 0; a < newSize && nx + a < n; ++a)\n                        for (int b = 0; b < newSize && ny + b < m; ++b)\n                            grid[nx + a][ny + b] = '*';\n                } else {\n                    if (depth > 0) {\n                        drawFractal(nx, ny, newSize, pattern, depth - 1);\n                    } else {\n                        for (int a = 0; a < newSize && nx + a < n; ++a)\n                            for (int b = 0; b < newSize && ny + b < m; ++b)\n                                grid[nx + a][ny + b] = '.';\n                    }\n                }\n            }\n        }\n}\n\nvoid generateSingleFractalGrid() {\n    grid.assign(n, string(m, '.'));\n    vector<vector<char>> pattern;\n    generateFractalPattern(pattern);\n    int minSize = 1 << rnd.next(1, 5);\n    while (minSize * 2 > min(n, m)) minSize /= 2;\n    if (minSize < 2) minSize = 2;\n    int x = rnd.next(0, n - minSize);\n    int y = rnd.next(0, m - minSize);\n    int depth = rnd.next(1, 5);\n    drawFractal(x, y, minSize, pattern, depth);\n}\n\nvoid generateMultipleFractalsGrid() {\n    grid.assign(n, string(m, '.'));\n    vector<vector<char>> pattern;\n    generateFractalPattern(pattern);\n    int numFractals = rnd.next(2, 10);\n    for (int k = 0; k < numFractals; ++k) {\n        int minSize = 1 << rnd.next(1, 5);\n        while (minSize * 2 > min(n, m)) minSize /= 2;\n        if (minSize < 2) minSize = 2;\n        int x = rnd.next(0, n - minSize);\n        int y = rnd.next(0, m - minSize);\n        int depth = rnd.next(1, 5);\n        drawFractal(x, y, minSize, pattern, depth);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\");\n    type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        generateRandomGrid();\n    } else if (type == \"full\") {\n        generateFullGrid();\n    } else if (type == \"empty\") {\n        generateEmptyGrid();\n    } else if (type == \"single-fractal\") {\n        generateSingleFractalGrid();\n    } else if (type == \"multiple-fractals\") {\n        generateMultipleFractalsGrid();\n    } else {\n        generateRandomGrid();\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nstring type;\n\nvector<string> grid;\n\nvoid generateRandomGrid() {\n    grid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i].resize(m);\n        for (int j = 0; j < m; ++j) {\n            grid[i][j] = (rnd.next(2) == 0) ? '.' : '*';\n        }\n    }\n}\n\nvoid generateFullGrid() {\n    grid.assign(n, string(m, '*'));\n}\n\nvoid generateEmptyGrid() {\n    grid.assign(n, string(m, '.'));\n}\n\nvoid generateFractalPattern(vector<vector<char>>& pattern) {\n    pattern.resize(2, vector<char>(2));\n    for (int i = 0; i < 2; ++i)\n        for (int j = 0; j < 2; ++j)\n            pattern[i][j] = (rnd.next(2) == 0) ? '.' : '*';\n}\n\nvoid drawFractal(int x, int y, int size, vector<vector<char>>& pattern, int depth) {\n    if (size <= 0 || x >= n || y >= m) return;\n    if (size == 2) {\n        for (int i = 0; i < 2 && x + i < n; ++i)\n            for (int j = 0; j < 2 && y + j < m; ++j)\n                grid[x + i][y + j] = pattern[i][j];\n        return;\n    }\n\n    int newSize = size / 2;\n    for (int i = 0; i < 2; ++i)\n        for (int j = 0; j < 2; ++j) {\n            int nx = x + i * newSize;\n            int ny = y + j * newSize;\n            if (nx < n && ny < m) {\n                if (pattern[i][j] == '*') {\n                    for (int a = 0; a < newSize && nx + a < n; ++a)\n                        for (int b = 0; b < newSize && ny + b < m; ++b)\n                            grid[nx + a][ny + b] = '*';\n                } else {\n                    if (depth > 0) {\n                        drawFractal(nx, ny, newSize, pattern, depth - 1);\n                    } else {\n                        for (int a = 0; a < newSize && nx + a < n; ++a)\n                            for (int b = 0; b < newSize && ny + b < m; ++b)\n                                grid[nx + a][ny + b] = '.';\n                    }\n                }\n            }\n        }\n}\n\nvoid generateSingleFractalGrid() {\n    grid.assign(n, string(m, '.'));\n    vector<vector<char>> pattern;\n    generateFractalPattern(pattern);\n    int minSize = 1 << rnd.next(1, 5);\n    while (minSize * 2 > min(n, m)) minSize /= 2;\n    if (minSize < 2) minSize = 2;\n    int x = rnd.next(0, n - minSize);\n    int y = rnd.next(0, m - minSize);\n    int depth = rnd.next(1, 5);\n    drawFractal(x, y, minSize, pattern, depth);\n}\n\nvoid generateMultipleFractalsGrid() {\n    grid.assign(n, string(m, '.'));\n    vector<vector<char>> pattern;\n    generateFractalPattern(pattern);\n    int numFractals = rnd.next(2, 10);\n    for (int k = 0; k < numFractals; ++k) {\n        int minSize = 1 << rnd.next(1, 5);\n        while (minSize * 2 > min(n, m)) minSize /= 2;\n        if (minSize < 2) minSize = 2;\n        int x = rnd.next(0, n - minSize);\n        int y = rnd.next(0, m - minSize);\n        int depth = rnd.next(1, 5);\n        drawFractal(x, y, minSize, pattern, depth);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\");\n    type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        generateRandomGrid();\n    } else if (type == \"full\") {\n        generateFullGrid();\n    } else if (type == \"empty\") {\n        generateEmptyGrid();\n    } else if (type == \"single-fractal\") {\n        generateSingleFractalGrid();\n    } else if (type == \"multiple-fractals\") {\n        generateMultipleFractalsGrid();\n    } else {\n        generateRandomGrid();\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type random\n./gen -n 2 -m 2 -type full\n./gen -n 2 -m 2 -type empty\n./gen -n 2 -m 2 -type single-fractal\n./gen -n 2 -m 2 -type multiple-fractals\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type full\n./gen -n 10 -m 10 -type empty\n./gen -n 10 -m 10 -type single-fractal\n./gen -n 10 -m 10 -type multiple-fractals\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type full\n./gen -n 100 -m 100 -type empty\n./gen -n 100 -m 100 -type single-fractal\n./gen -n 100 -m 100 -type multiple-fractals\n\n./gen -n 250 -m 250 -type random\n./gen -n 250 -m 250 -type full\n./gen -n 250 -m 250 -type empty\n./gen -n 250 -m 250 -type single-fractal\n./gen -n 250 -m 250 -type multiple-fractals\n\n./gen -n 500 -m 500 -type random\n./gen -n 500 -m 500 -type full\n./gen -n 500 -m 500 -type empty\n./gen -n 500 -m 500 -type single-fractal\n./gen -n 500 -m 500 -type multiple-fractals\n\n./gen -n 499 -m 499 -type random\n./gen -n 499 -m 499 -type single-fractal\n./gen -n 499 -m 499 -type multiple-fractals\n\n./gen -n 2 -m 500 -type random\n./gen -n 2 -m 500 -type full\n./gen -n 2 -m 500 -type empty\n./gen -n 2 -m 500 -type single-fractal\n./gen -n 2 -m 500 -type multiple-fractals\n\n./gen -n 500 -m 2 -type random\n./gen -n 500 -m 2 -type full\n./gen -n 500 -m 2 -type empty\n./gen -n 500 -m 2 -type single-fractal\n./gen -n 500 -m 2 -type multiple-fractals\n\n./gen -n 400 -m 300 -type random\n./gen -n 400 -m 300 -type full\n./gen -n 400 -m 300 -type empty\n./gen -n 400 -m 300 -type single-fractal\n./gen -n 400 -m 300 -type multiple-fractals\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:14.346926",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "228/D",
      "title": "D. Zigzag",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — The number of elements in array a. The second line contains n space-separated integers: a1, a2, ..., an (1 ≤ ai ≤ 109) — the elements of the array. The third line contains integer m (1 ≤ m ≤ 105) — the number of operations. Next m lines contain the operations' descriptions. An operation's description starts with integer ti (1 ≤ ti ≤ 2) — the operation type.   If ti = 1 (assignment operation), then on the line follow two space-separated integers: pi, vi (1 ≤ pi ≤ n; 1 ≤ vi ≤ 109) — the parameters of the assigning operation.  If ti = 2 (Zigzag operation), then on the line follow three space-separated integers: li, ri, zi (1 ≤ li ≤ ri ≤ n; 2 ≤ zi ≤ 6) — the parameters of the Zigzag operation. You should execute the operations in the order, in which they are given in the input.",
      "output_spec": "OutputFor each Zigzag operation print the calculated value of the Zigzag function on a single line. Print the values for Zigzag functions in the order, in which they are given in the input.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy52 3 1 5 542 2 3 22 1 5 31 3 52 1 5 3OutputCopy52638",
      "description": "time limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — The number of elements in array a. The second line contains n space-separated integers: a1, a2, ..., an (1 ≤ ai ≤ 109) — the elements of the array. The third line contains integer m (1 ≤ m ≤ 105) — the number of operations. Next m lines contain the operations' descriptions. An operation's description starts with integer ti (1 ≤ ti ≤ 2) — the operation type.   If ti = 1 (assignment operation), then on the line follow two space-separated integers: pi, vi (1 ≤ pi ≤ n; 1 ≤ vi ≤ 109) — the parameters of the assigning operation.  If ti = 2 (Zigzag operation), then on the line follow three space-separated integers: li, ri, zi (1 ≤ li ≤ ri ≤ n; 2 ≤ zi ≤ 6) — the parameters of the Zigzag operation. You should execute the operations in the order, in which they are given in the input.\n\nOutputFor each Zigzag operation print the calculated value of the Zigzag function on a single line. Print the values for Zigzag functions in the order, in which they are given in the input.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nInputCopy52 3 1 5 542 2 3 22 1 5 31 3 52 1 5 3OutputCopy52638\n\nInputCopy52 3 1 5 542 2 3 22 1 5 31 3 52 1 5 3\n\nOutputCopy52638\n\nNoteExplanation of the sample test:   Result of the first operation is Z(2, 3, 2) = 3·1 + 1·2 = 5.  Result of the second operation is Z(1, 5, 3) = 2·1 + 3·2 + 1·3 + 5·2 + 5·1 = 26.  After the third operation array a is equal to 2, 3, 5, 5, 5.  Result of the forth operation is Z(1, 5, 3) = 2·1 + 3·2 + 5·3 + 5·2 + 5·1 = 38.",
      "solutions": [
        {
          "title": "Codeforces Round #141 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #141 for Div.2 participants. But traditionally the others can take part out of the competition.Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Ivan Fefer (Fefer_Ivan), Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Mary Belova (Delinur) for translating problems.Score distribution is standard.We wish you good luck, successful hacks and high rating!UPD: the contest is over, hope you enjoy it) Congratulations to winners: 1) AntiFate 2) alicechennan 3) honeyofsistercha 4) Fride 5) bla_bla_bla UPD2: the editorial was already published, you can find it here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5396",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 760
        },
        {
          "title": "Codeforces Round #141 (Div. 2) Tutorial - Codeforces",
          "content": "228A - Is your horseshoe on the other hoof?In this problem you should count different numbers from input cnt and print 4–cnt. You could do it in different ways. For example, you could use set. 228B - Two TablesIn this problem you should carefully consider every shift  - N <  = x, y <  = N, count the answer and find the maximum value. The complexity of solution is O(N4).228C - Fractal DetectorThis problem could be solved using dynamic programming. State z[x][y][st][mask] means if the square with upper left corner (x, y) is fractal with nesting level st and colors mask. The value z[x][y][st][mask] is 0 or 1. There are O(N2·Log(N)·24) states in this dynamic programming. The transitions from state to state are rather simple. If st = 1 you should fairly check that the square 2*2 with upper left corner (x, y) matches colors of mask. If st > 1 you should divide the square into four parts and check them separately. If the value in mask in one quarter means black color, you should check that the whole quarter is black. It could be done using partial sums on rectangles using O(1) of time. If the quarter is white, you should check that it is a fractal with nesting level st - 1 with the same mask. So, there are less than 4 transitions from every state. To get the answer to the problem you should consider every upper left corner of squares, every mask and every nesting level of fractal and check this square. It is done using your dynamic. 228D - ZigzagIn this problem we will use that sequence s is cyclic because of its structure. Also, it is important that 2 <  = z <  = 6. For every z we will write the sequence s and note that its period is 2 * (z–1). So, for every z and modulo 0 <  = mod < 2 * (z–1) we will build separate segment tree or Fenwick tree. You should be careful with memory, it needs O(Z·(2·Z)·N) of memory. So, if the query is to update some value, we should update z values of trees with correct modules. If the query is to find sum, we should consider every 2·(z–1) modules, count the sum and multiply by correct coefficient from sequence s. The complexity is O(Z·N·Log(N)).228E - The Road to Berland is Paved With Good IntentionsThis problem can be solved in different ways. It was expected the solution that solved the system of modular equations using Gauss algorithm. Here is another simple solution. The vertices from the result call switched-on. Firstly, note that every vertex should be switched-on no more than once. Then, consider every edge (x, y) of color c. We want to make its color 1. So, if c = 1 we should switch on vertices x and y or don’t switch them on simultaneously. If c = 0 we should switch on x or y. So, consider some vertex v and try to switch it on or not. Thus, we can uniquely determine the state of every vertex of the same connected component as v. If we face some collision, we can’t get the solution, you should print Impossible. The solution can be realized using bfs with complexity O(N + M).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5404",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 228\\s*D"
          },
          "content_length": 2961
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #141 (Div. 2) - Codeforces - Code 1",
          "code": "x.cpp: In function 'int main()':\nx.cpp:83:93: warning: format '%c' expects argument of type 'char*', but argument 2 has type 'int*' [-Wformat]\nx.cpp:88:93: warning: format '%c' expects argument of type 'char*', but argument 2 has type 'int*' [-Wformat]\nx.cpp:90:13: warning: declaration of 'x' shadows a global declaration [-Wshadow]\nx.cpp:55:5: warning: shadowed declaration is here [-Wshadow]\nx.cpp:91:17: warning: declaration of 'y' shadows a global declaration [-Wshadow]\nx.cpp:55:8: warning: shadowed declaration is here [-Wshadow]",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5396",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int t = inf.readInt(1, 2, \"t_i\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int p_i = inf.readInt(1, n, \"p_i\");\n            inf.readSpace();\n            int v_i = inf.readInt(1, 1000000000, \"v_i\");\n            inf.readEoln();\n        } else {\n            // t == 2\n            inf.readSpace();\n            int l_i = inf.readInt(1, n, \"l_i\");\n            inf.readSpace();\n            int r_i = inf.readInt(l_i, n, \"r_i\");\n            inf.readSpace();\n            int z_i = inf.readInt(2, 6, \"z_i\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int t = inf.readInt(1, 2, \"t_i\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int p_i = inf.readInt(1, n, \"p_i\");\n            inf.readSpace();\n            int v_i = inf.readInt(1, 1000000000, \"v_i\");\n            inf.readEoln();\n        } else {\n            // t == 2\n            inf.readSpace();\n            int l_i = inf.readInt(1, n, \"l_i\");\n            inf.readSpace();\n            int r_i = inf.readInt(l_i, n, \"r_i\");\n            inf.readSpace();\n            int z_i = inf.readInt(2, 6, \"z_i\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int t = inf.readInt(1, 2, \"t_i\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int p_i = inf.readInt(1, n, \"p_i\");\n            inf.readSpace();\n            int v_i = inf.readInt(1, 1000000000, \"v_i\");\n            inf.readEoln();\n        } else {\n            // t == 2\n            inf.readSpace();\n            int l_i = inf.readInt(1, n, \"l_i\");\n            inf.readSpace();\n            int r_i = inf.readInt(l_i, n, \"r_i\");\n            inf.readSpace();\n            int z_i = inf.readInt(2, 6, \"z_i\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate the array a\n    vector<int> a(n);\n\n    if (type == \"max\") {\n        // All elements are maxAi\n        for (int i = 0; i < n; ++i)\n            a[i] = maxAi;\n    }\n    else if (type == \"min\") {\n        // Minimal input\n        n = max(1, n); m = max(1, m);\n        a[0] = 1;\n        for (int i = 1; i < n; ++i)\n            a[i] = 1;\n    }\n    else if (type == \"same\") {\n        // All elements are the same random value\n        int val = rnd.next(1, maxAi);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    }\n    else if (type == \"inc\") {\n        // Elements are increasing\n        int startVal = rnd.next(1, maxAi / 2);\n        int step = max(1, (maxAi - startVal) / n);\n        for (int i = 0; i < n; ++i)\n            a[i] = min(maxAi, startVal + step * i);\n    }\n    else if (type == \"dec\") {\n        // Elements are decreasing\n        int startVal = rnd.next(maxAi / 2, maxAi);\n        int step = max(1, startVal / n);\n        for (int i = 0; i < n; ++i)\n            a[i] = max(1, startVal - step * i);\n    }\n    else {\n        // Random elements between 1 and maxAi\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxAi);\n    }\n\n    // Adjust n and m for 'min' type\n    if (type == \"min\") {\n        n = max(1, n);\n        m = max(1, m);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a1, a2, ..., an\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Generate m operations\n    printf(\"%d\\n\", m);\n\n    if (type == \"min\") {\n        // Single operation, can be assignment or zigzag\n        int opType = rnd.next(1, 2);\n        if (opType == 1) {\n            // Assignment\n            int p = 1;\n            int v = rnd.next(1, maxAi);\n            printf(\"1 %d %d\\n\", p, v);\n        } else {\n            // Zigzag\n            int l = 1, r = 1, z = rnd.next(2, 6);\n            printf(\"2 %d %d %d\\n\", l, r, z);\n        }\n    }\n    else if (type == \"zigzag_only\") {\n        // All operations are zigzag over full array\n        for (int i = 0; i < m; ++i) {\n            int l = 1, r = n;\n            int z = rnd.next(2,6);\n            printf(\"2 %d %d %d\\n\", l, r, z);\n        }\n    }\n    else if (type == \"assign_only\") {\n        // All operations are assignments\n        for (int i = 0; i < m; ++i) {\n            int p = rnd.next(1, n);\n            int v = rnd.next(1, maxAi);\n            printf(\"1 %d %d\\n\", p, v);\n        }\n    }\n    else if (type == \"alternating\") {\n        // Alternate between assignment and zigzag\n        for (int i = 0; i < m; ++i) {\n            int opType = (i % 2) + 1;\n            if (opType == 1) {\n                // Assignment\n                int p = rnd.next(1, n);\n                int v = rnd.next(1, maxAi);\n                printf(\"1 %d %d\\n\", p, v);\n            } else {\n                // Zigzag\n                int l = rnd.next(1, n);\n                int r = rnd.next(l, n);\n                int z = rnd.next(2, 6);\n                printf(\"2 %d %d %d\\n\", l, r, z);\n            }\n        }\n    }\n    else if (type == \"worst\") {\n        // Operations designed to cause worst-case time complexity\n        for (int i = 0; i < m; ++i) {\n            // Zigzag over the entire array\n            int l = 1, r = n, z = rnd.next(2, 6);\n            printf(\"2 %d %d %d\\n\", l, r, z);\n        }\n    }\n    else {\n        // Random operations\n        for (int i = 0; i < m; ++i) {\n            int opType = rnd.next(1, 2);\n            if (opType == 1) {\n                // Assignment\n                int p = rnd.next(1, n);\n                int v = rnd.next(1, maxAi);\n                printf(\"1 %d %d\\n\", p, v);\n            } else {\n                // Zigzag\n                int l = rnd.next(1, n);\n                int r = rnd.next(l, n);\n                int z = rnd.next(2, 6);\n                printf(\"2 %d %d %d\\n\", l, r, z);\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate the array a\n    vector<int> a(n);\n\n    if (type == \"max\") {\n        // All elements are maxAi\n        for (int i = 0; i < n; ++i)\n            a[i] = maxAi;\n    }\n    else if (type == \"min\") {\n        // Minimal input\n        n = max(1, n); m = max(1, m);\n        a[0] = 1;\n        for (int i = 1; i < n; ++i)\n            a[i] = 1;\n    }\n    else if (type == \"same\") {\n        // All elements are the same random value\n        int val = rnd.next(1, maxAi);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    }\n    else if (type == \"inc\") {\n        // Elements are increasing\n        int startVal = rnd.next(1, maxAi / 2);\n        int step = max(1, (maxAi - startVal) / n);\n        for (int i = 0; i < n; ++i)\n            a[i] = min(maxAi, startVal + step * i);\n    }\n    else if (type == \"dec\") {\n        // Elements are decreasing\n        int startVal = rnd.next(maxAi / 2, maxAi);\n        int step = max(1, startVal / n);\n        for (int i = 0; i < n; ++i)\n            a[i] = max(1, startVal - step * i);\n    }\n    else {\n        // Random elements between 1 and maxAi\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxAi);\n    }\n\n    // Adjust n and m for 'min' type\n    if (type == \"min\") {\n        n = max(1, n);\n        m = max(1, m);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a1, a2, ..., an\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Generate m operations\n    printf(\"%d\\n\", m);\n\n    if (type == \"min\") {\n        // Single operation, can be assignment or zigzag\n        int opType = rnd.next(1, 2);\n        if (opType == 1) {\n            // Assignment\n            int p = 1;\n            int v = rnd.next(1, maxAi);\n            printf(\"1 %d %d\\n\", p, v);\n        } else {\n            // Zigzag\n            int l = 1, r = 1, z = rnd.next(2, 6);\n            printf(\"2 %d %d %d\\n\", l, r, z);\n        }\n    }\n    else if (type == \"zigzag_only\") {\n        // All operations are zigzag over full array\n        for (int i = 0; i < m; ++i) {\n            int l = 1, r = n;\n            int z = rnd.next(2,6);\n            printf(\"2 %d %d %d\\n\", l, r, z);\n        }\n    }\n    else if (type == \"assign_only\") {\n        // All operations are assignments\n        for (int i = 0; i < m; ++i) {\n            int p = rnd.next(1, n);\n            int v = rnd.next(1, maxAi);\n            printf(\"1 %d %d\\n\", p, v);\n        }\n    }\n    else if (type == \"alternating\") {\n        // Alternate between assignment and zigzag\n        for (int i = 0; i < m; ++i) {\n            int opType = (i % 2) + 1;\n            if (opType == 1) {\n                // Assignment\n                int p = rnd.next(1, n);\n                int v = rnd.next(1, maxAi);\n                printf(\"1 %d %d\\n\", p, v);\n            } else {\n                // Zigzag\n                int l = rnd.next(1, n);\n                int r = rnd.next(l, n);\n                int z = rnd.next(2, 6);\n                printf(\"2 %d %d %d\\n\", l, r, z);\n            }\n        }\n    }\n    else if (type == \"worst\") {\n        // Operations designed to cause worst-case time complexity\n        for (int i = 0; i < m; ++i) {\n            // Zigzag over the entire array\n            int l = 1, r = n, z = rnd.next(2, 6);\n            printf(\"2 %d %d %d\\n\", l, r, z);\n        }\n    }\n    else {\n        // Random operations\n        for (int i = 0; i < m; ++i) {\n            int opType = rnd.next(1, 2);\n            if (opType == 1) {\n                // Assignment\n                int p = rnd.next(1, n);\n                int v = rnd.next(1, maxAi);\n                printf(\"1 %d %d\\n\", p, v);\n            } else {\n                // Zigzag\n                int l = rnd.next(1, n);\n                int r = rnd.next(l, n);\n                int z = rnd.next(2, 6);\n                printf(\"2 %d %d %d\\n\", l, r, z);\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type min\n\n./gen -n 100000 -m 100000 -type max\n\n./gen -n 100000 -m 100000 -type zigzag_only\n\n./gen -n 100000 -m 100000 -type assign_only\n\n./gen -n 100000 -m 100000 -type alternating\n\n./gen -n 100000 -m 100000 -type same\n\n./gen -n 100000 -m 100000 -type inc\n\n./gen -n 100000 -m 100000 -type dec\n\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 100000 -m 100000 -type worst\n\n./gen -n 99999 -m 100000 -type random\n\n./gen -n 99999 -m 50000 -type random\n\n./gen -n 50000 -m 100000 -type random\n\n./gen -n 50000 -m 50000 -type random\n\n./gen -n 1 -m 100000 -type zigzag_only\n\n./gen -n 100000 -m 1 -type assign_only\n\n./gen -n 100000 -m 1 -type random\n\n./gen -n 2 -m 2 -type random\n\n./gen -n 10 -m 10 -type random\n\n./gen -n 100 -m 100 -type random\n\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 10000 -m 10000 -type random\n\n./gen -n 50000 -m 50000 -type same\n\n./gen -n 100000 -m 100000 -type same\n\n./gen -n 100000 -m 100000 -type dec\n\n./gen -n 100000 -m 100000 -type inc\n\n./gen -n 100000 -m 100000 -type worst\n\n./gen -n 100000 -m 100000 -type alternating\n\n./gen -n 100000 -m 100000 -type assign_only\n\n./gen -n 100000 -m 100000 -type zigzag_only\n\n./gen -n 100000 -m 100000 -type random -maxAi 1\n\n./gen -n 100000 -m 100000 -type random -maxAi 1000000000\n\n./gen -n 100000 -m 100000 -type random -maxAi 999999999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:16.454294",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "228/E",
      "title": "E. The Road to Berland is Paved With Good Intentions",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n, m  — the number of cities and roads in Berland, correspondingly. Next m lines contain the descriptions of roads in Berland: the i-th line contains three space-separated integers ai, bi, ci (1 ≤ ai, bi ≤ n; ai ≠ bi; 0 ≤ ci ≤ 1). The first two integers (ai, bi) are indexes of the cities that are connected by the i-th road, the third integer (ci) equals 1, if the road was initially asphalted, and 0 otherwise. Consider the cities in Berland indexed from 1 to n, and the roads indexed from 1 to m. It is guaranteed that between two Berlandian cities there is not more than one road.",
      "output_spec": "OutputIn the first line print a single integer x (0 ≤ x ≤ n) — the number of days needed to asphalt all roads. In the second line print x space-separated integers — the indexes of the cities to send the workers to. Print the cities in the order, in which Valera send the workers to asphalt roads. If there are multiple solutions, print any of them. If there's no way to asphalt all roads, print \"Impossible\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy4 41 2 12 4 04 3 13 2 0OutputCopy43 2 1 3InputCopy3 31 2 02 3 03 1 0OutputCopyImpossible",
      "description": "E. The Road to Berland is Paved With Good Intentions\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n, m  — the number of cities and roads in Berland, correspondingly. Next m lines contain the descriptions of roads in Berland: the i-th line contains three space-separated integers ai, bi, ci (1 ≤ ai, bi ≤ n; ai ≠ bi; 0 ≤ ci ≤ 1). The first two integers (ai, bi) are indexes of the cities that are connected by the i-th road, the third integer (ci) equals 1, if the road was initially asphalted, and 0 otherwise. Consider the cities in Berland indexed from 1 to n, and the roads indexed from 1 to m. It is guaranteed that between two Berlandian cities there is not more than one road.\n\nOutputIn the first line print a single integer x (0 ≤ x ≤ n) — the number of days needed to asphalt all roads. In the second line print x space-separated integers — the indexes of the cities to send the workers to. Print the cities in the order, in which Valera send the workers to asphalt roads. If there are multiple solutions, print any of them. If there's no way to asphalt all roads, print \"Impossible\" (without the quotes).\n\nInputCopy4 41 2 12 4 04 3 13 2 0OutputCopy43 2 1 3InputCopy3 31 2 02 3 03 1 0OutputCopyImpossible\n\nInputCopy4 41 2 12 4 04 3 13 2 0\n\nOutputCopy43 2 1 3\n\nInputCopy3 31 2 02 3 03 1 0\n\nOutputCopyImpossible",
      "solutions": [
        {
          "title": "Codeforces Round #141 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #141 for Div.2 participants. But traditionally the others can take part out of the competition.Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Ivan Fefer (Fefer_Ivan), Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Mary Belova (Delinur) for translating problems.Score distribution is standard.We wish you good luck, successful hacks and high rating!UPD: the contest is over, hope you enjoy it) Congratulations to winners: 1) AntiFate 2) alicechennan 3) honeyofsistercha 4) Fride 5) bla_bla_bla UPD2: the editorial was already published, you can find it here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5396",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 760
        },
        {
          "title": "Codeforces Round #141 (Div. 2) Tutorial - Codeforces",
          "content": "228A - Is your horseshoe on the other hoof?In this problem you should count different numbers from input cnt and print 4–cnt. You could do it in different ways. For example, you could use set. 228B - Two TablesIn this problem you should carefully consider every shift  - N <  = x, y <  = N, count the answer and find the maximum value. The complexity of solution is O(N4).228C - Fractal DetectorThis problem could be solved using dynamic programming. State z[x][y][st][mask] means if the square with upper left corner (x, y) is fractal with nesting level st and colors mask. The value z[x][y][st][mask] is 0 or 1. There are O(N2·Log(N)·24) states in this dynamic programming. The transitions from state to state are rather simple. If st = 1 you should fairly check that the square 2*2 with upper left corner (x, y) matches colors of mask. If st > 1 you should divide the square into four parts and check them separately. If the value in mask in one quarter means black color, you should check that the whole quarter is black. It could be done using partial sums on rectangles using O(1) of time. If the quarter is white, you should check that it is a fractal with nesting level st - 1 with the same mask. So, there are less than 4 transitions from every state. To get the answer to the problem you should consider every upper left corner of squares, every mask and every nesting level of fractal and check this square. It is done using your dynamic. 228D - ZigzagIn this problem we will use that sequence s is cyclic because of its structure. Also, it is important that 2 <  = z <  = 6. For every z we will write the sequence s and note that its period is 2 * (z–1). So, for every z and modulo 0 <  = mod < 2 * (z–1) we will build separate segment tree or Fenwick tree. You should be careful with memory, it needs O(Z·(2·Z)·N) of memory. So, if the query is to update some value, we should update z values of trees with correct modules. If the query is to find sum, we should consider every 2·(z–1) modules, count the sum and multiply by correct coefficient from sequence s. The complexity is O(Z·N·Log(N)).228E - The Road to Berland is Paved With Good IntentionsThis problem can be solved in different ways. It was expected the solution that solved the system of modular equations using Gauss algorithm. Here is another simple solution. The vertices from the result call switched-on. Firstly, note that every vertex should be switched-on no more than once. Then, consider every edge (x, y) of color c. We want to make its color 1. So, if c = 1 we should switch on vertices x and y or don’t switch them on simultaneously. If c = 0 we should switch on x or y. So, consider some vertex v and try to switch it on or not. Thus, we can uniquely determine the state of every vertex of the same connected component as v. If we face some collision, we can’t get the solution, you should print Impossible. The solution can be realized using bfs with complexity O(N + M).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5404",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 228\\s*E"
          },
          "content_length": 2961
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #141 (Div. 2) - Codeforces - Code 1",
          "code": "x.cpp: In function 'int main()':\nx.cpp:83:93: warning: format '%c' expects argument of type 'char*', but argument 2 has type 'int*' [-Wformat]\nx.cpp:88:93: warning: format '%c' expects argument of type 'char*', but argument 2 has type 'int*' [-Wformat]\nx.cpp:90:13: warning: declaration of 'x' shadows a global declaration [-Wshadow]\nx.cpp:55:5: warning: shadowed declaration is here [-Wshadow]\nx.cpp:91:17: warning: declaration of 'y' shadows a global declaration [-Wshadow]\nx.cpp:55:8: warning: shadowed declaration is here [-Wshadow]",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5396",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main (int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int maxM = min(100000, n * (n - 1) / 2);\n    int m = inf.readInt(0, maxM, \"m\");\n    inf.readEoln();\n\n    set< pair<int, int> > edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge between city %d and itself\", ai);\n        inf.readSpace();\n        int ci = inf.readInt(0, 1, \"ci\");\n        inf.readEoln();\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between cities %d and %d\", u, v);\n        edges.insert({u, v});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main (int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int maxM = min(100000, n * (n - 1) / 2);\n    int m = inf.readInt(0, maxM, \"m\");\n    inf.readEoln();\n\n    set< pair<int, int> > edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge between city %d and itself\", ai);\n        inf.readSpace();\n        int ci = inf.readInt(0, 1, \"ci\");\n        inf.readEoln();\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between cities %d and %d\", u, v);\n        edges.insert({u, v});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main (int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int maxM = min(100000, n * (n - 1) / 2);\n    int m = inf.readInt(0, maxM, \"m\");\n    inf.readEoln();\n\n    set< pair<int, int> > edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge between city %d and itself\", ai);\n        inf.readSpace();\n        int ci = inf.readInt(0, 1, \"ci\");\n        inf.readEoln();\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between cities %d and %d\", u, v);\n        edges.insert({u, v});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\nWe'll read the jury's (correct) solution from ans and the participant's\nsolution from ouf, and check whether the participant's solution is valid.\n\nProblem summary:\nWe have n cities and m roads (a_i, b_i, c_i), where c_i in {0,1} indicates\nwhether the road is initially asphalted. The participant can output either\n\"Impossible\" (if there is no way to make all roads asphalted within at most\nn toggles) or two lines:\n\n  x                  (0 <= x <= n) -- number of days (toggles)\n  c1 c2 ... c_x      -- the list of cities chosen for toggling\n\nEach time we pick a city c, for every road touching city c, we flip its\nstate: if it was asphalted, it becomes not asphalted; if it was not\nasphalted, it becomes asphalted.\n\nA participant's answer is correct if, after applying these toggles in order,\nall roads end up asphalted. If multiple solutions exist, any one is fine.\n\nThe jury solution (ans) either states \"Impossible\" (meaning no solution exists)\nor else provides one valid solution. If the jury's solution is \"Impossible\",\nthen no valid solution should exist.\n*/\n\nstruct Road {\n    int a, b;\n    bool asphalted;\n};\n\nstatic const string IMPOSSIBLE = \"Impossible\";\n\n/*\nreadAndCheckSolution(...) attempts to parse exactly one solution from 'stream'.\n\nReturn true if the solution is literally \"Impossible\".\nOtherwise, read up to n toggles and verify the result. If the solution\nis invalid, we call stream.quitf(...) with the appropriate verdict. \n*/\nbool readAndCheckSolution(InStream &stream,\n                          int n,\n                          int m,\n                          vector<Road> roads,\n                          const vector<vector<int>> &adj) \n{\n    // If there's no output, automatically invalid.\n    if (stream.eof()) {\n        stream.quitf(_wa, \"No output at all\");\n    }\n\n    // Read the first token; it might be \"Impossible\" or a number.\n    string firstToken = stream.readToken();\n    \n    // If the solution is \"Impossible\", ensure no extra tokens beyond whitespace\n    if (firstToken == IMPOSSIBLE) {\n        // We check if there's anything else beyond possible whitespace.\n        if (!stream.seekEof()) {\n            stream.quitf(_wa, \"Unexpected token(s) after 'Impossible'\");\n        }\n        return true;\n    }\n\n    // Otherwise, parse the token as x, the number of toggles, must be in [0..n].\n    long long val;\n    {\n        std::istringstream iss(firstToken);\n        iss >> val;\n        if (!iss || !iss.eof()) {\n            stream.quitf(_wa, \"Expected an integer x or '%s', got '%s'\",\n                         IMPOSSIBLE.c_str(), firstToken.c_str());\n        }\n        if (val < 0 || val > n) {\n            stream.quitf(_wa, \"Number of toggles x=%lld is not in [0, %d]\", val, n);\n        }\n    }\n    int x = (int)val;\n\n    // Now read x more integers for the cities.\n    vector<int> toggles(x);\n    for (int i = 0; i < x; i++) {\n        toggles[i] = stream.readInt(1, n, format(\"toggleCity[%d]\", i + 1).c_str());\n    }\n\n    // Ensure there's no extra tokens besides possible whitespace/newlines.\n    if (!stream.seekEof()) {\n        stream.quitf(_wa, \"Unexpected extra token(s) after reading the toggles\");\n    }\n\n    // Apply the toggles to the roads data.\n    for (int city : toggles) {\n        for (int idx : adj[city]) {\n            roads[idx].asphalted = !roads[idx].asphalted;\n        }\n    }\n\n    // Check if all roads are finally asphalted.\n    for (int i = 0; i < m; i++) {\n        if (!roads[i].asphalted) {\n            stream.quitf(_wa, \"Not all roads are asphalted after applying toggles\");\n        }\n    }\n\n    // If we get here, the solution is valid.\n    return false;\n}\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    // Read n, m from the input.\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    // Read roads, store them, and build adjacency: adj[i] => indices of roads touching city i.\n    vector<Road> roads(m);\n    vector<vector<int>> adj(n + 1);\n\n    for (int i = 0; i < m; i++){\n        int a = inf.readInt();\n        int b = inf.readInt();\n        int c = inf.readInt();\n        roads[i] = {a, b, (c == 1)};\n        adj[a].push_back(i);\n        adj[b].push_back(i);\n    }\n\n    // Read jury's solution from ans.\n    bool juryImpossible = readAndCheckSolution(ans, n, m, roads, adj);\n\n    // Read participant's solution from ouf.\n    bool userImpossible = false;\n    try {\n        userImpossible = readAndCheckSolution(ouf, n, m, roads, adj);\n    } \n    catch (...) {\n        quitf(_fail, \"Exception in checker while reading participant's output\");\n    }\n\n    // Compare verdicts.\n    // If jury says no solution while participant claims to have one => WA.\n    if (juryImpossible && !userImpossible) {\n        quitf(_wa, \"Jury says no solution, but participant claims one\");\n    }\n    // If jury has a solution but participant says \"Impossible\" => WA.\n    if (!juryImpossible && userImpossible) {\n        quitf(_wa, \"Jury has a solution, but participant says 'Impossible'\");\n    }\n\n    // Otherwise, consistent results => OK.\n    quitf(_ok, \"All seems correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1); // default m = n-1\n    string type = opt<string>(\"type\", \"random\");\n    string solvable = opt<string>(\"solvable\", \"yes\"); // default solvable\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edgeSet;\n    vector<int> ci; // asphalt statuses\n    \n    if (type == \"chain\") {\n        // Chain from 1 to n\n        if (m != n - 1) {\n            fprintf(stderr, \"For chain type, m must be n - 1.\\n\");\n            exit(1);\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Star centered at 1\n        if (m != n - 1) {\n            fprintf(stderr, \"For star type, m must be n - 1.\\n\");\n            exit(1);\n        }\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"complete\") {\n        if (m != n * (n - 1) / 2) {\n            fprintf(stderr, \"For complete type, m must be n * (n - 1) / 2.\\n\");\n            exit(1);\n        }\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                edges.push_back({i, j});\n            }\n        }\n    } else if (type == \"cycle\") {\n        // Cycle of length n\n        if (m != n) {\n            fprintf(stderr, \"For cycle type, m must be n.\\n\");\n            exit(1);\n        }\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n    } else if (type == \"random\") {\n        // Random edges\n        if (m > n * (n - 1) / 2) {\n            fprintf(stderr, \"Too many edges.\\n\");\n            exit(1);\n        }\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edgeSet.count({u, v})) continue;\n            edgeSet.insert({u, v});\n            edges.push_back({u, v});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type.\\n\");\n        exit(1);\n    }\n\n    // Now, set ci according to solvable\n    if (solvable == \"yes\") {\n        // Random ci\n        for (int i = 0; i < (int)edges.size(); ++i) {\n            ci.push_back(rnd.next(0,1));\n        }\n    } else if (solvable == \"no\") {\n        // For cycles of odd length with all ci = 0\n        if (type == \"cycle\" && (n % 2 == 1)) {\n            // All ci = 0\n            for (int i = 0; i < (int)edges.size(); ++i) {\n                ci.push_back(0);\n            }\n        } else if (type == \"complete\" && n >= 3) {\n            // For complete graph, setting ci to 0 may produce impossible case\n            for (int i = 0; i < (int)edges.size(); ++i) {\n                ci.push_back(0);\n            }\n        } else {\n            // Try to produce an impossible case, but it's not guaranteed\n            for (int i = 0; i < (int)edges.size(); ++i) {\n                ci.push_back(0);\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown solvable value. Use yes or no.\\n\");\n        exit(1);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int c = ci[i];\n        printf(\"%d %d %d\\n\", u, v, c);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1); // default m = n-1\n    string type = opt<string>(\"type\", \"random\");\n    string solvable = opt<string>(\"solvable\", \"yes\"); // default solvable\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edgeSet;\n    vector<int> ci; // asphalt statuses\n    \n    if (type == \"chain\") {\n        // Chain from 1 to n\n        if (m != n - 1) {\n            fprintf(stderr, \"For chain type, m must be n - 1.\\n\");\n            exit(1);\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Star centered at 1\n        if (m != n - 1) {\n            fprintf(stderr, \"For star type, m must be n - 1.\\n\");\n            exit(1);\n        }\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"complete\") {\n        if (m != n * (n - 1) / 2) {\n            fprintf(stderr, \"For complete type, m must be n * (n - 1) / 2.\\n\");\n            exit(1);\n        }\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                edges.push_back({i, j});\n            }\n        }\n    } else if (type == \"cycle\") {\n        // Cycle of length n\n        if (m != n) {\n            fprintf(stderr, \"For cycle type, m must be n.\\n\");\n            exit(1);\n        }\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n    } else if (type == \"random\") {\n        // Random edges\n        if (m > n * (n - 1) / 2) {\n            fprintf(stderr, \"Too many edges.\\n\");\n            exit(1);\n        }\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edgeSet.count({u, v})) continue;\n            edgeSet.insert({u, v});\n            edges.push_back({u, v});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type.\\n\");\n        exit(1);\n    }\n\n    // Now, set ci according to solvable\n    if (solvable == \"yes\") {\n        // Random ci\n        for (int i = 0; i < (int)edges.size(); ++i) {\n            ci.push_back(rnd.next(0,1));\n        }\n    } else if (solvable == \"no\") {\n        // For cycles of odd length with all ci = 0\n        if (type == \"cycle\" && (n % 2 == 1)) {\n            // All ci = 0\n            for (int i = 0; i < (int)edges.size(); ++i) {\n                ci.push_back(0);\n            }\n        } else if (type == \"complete\" && n >= 3) {\n            // For complete graph, setting ci to 0 may produce impossible case\n            for (int i = 0; i < (int)edges.size(); ++i) {\n                ci.push_back(0);\n            }\n        } else {\n            // Try to produce an impossible case, but it's not guaranteed\n            for (int i = 0; i < (int)edges.size(); ++i) {\n                ci.push_back(0);\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown solvable value. Use yes or no.\\n\");\n        exit(1);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int c = ci[i];\n        printf(\"%d %d %d\\n\", u, v, c);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small tests\n./gen -n 3 -m 2 -type chain -solvable yes\n./gen -n 3 -m 3 -type cycle -solvable no\n./gen -n 5 -m 5 -type cycle -solvable yes\n./gen -n 5 -m 5 -type cycle -solvable no\n./gen -n 5 -m 10 -type complete -solvable yes\n./gen -n 5 -m 10 -type complete -solvable no\n\n# Medium tests\n./gen -n 1000 -m 999 -type chain -solvable yes\n./gen -n 1000 -m 1000 -type cycle -solvable no\n./gen -n 1000 -m 2000 -type random -solvable yes\n./gen -n 1000 -m 2000 -type random -solvable no\n\n# Large tests\n./gen -n 100000 -m 99999 -type chain -solvable yes\n./gen -n 100000 -m 100000 -type cycle -solvable no\n./gen -n 100000 -m 200000 -type random -solvable yes\n./gen -n 100000 -m 200000 -type random -solvable no\n\n# Random tests with maximum m\n./gen -n 100000 -m 300000 -type random -solvable yes\n./gen -n 100000 -m 300000 -type random -solvable no\n\n# Test with star graph\n./gen -n 100000 -m 99999 -type star -solvable yes\n./gen -n 100000 -m 99999 -type star -solvable no\n\n# Tests with varying m and random type\n./gen -n 100000 -m 100000 -type random -solvable yes\n./gen -n 100000 -m 100000 -type random -solvable no\n./gen -n 100000 -m 150000 -type random -solvable yes\n./gen -n 100000 -m 150000 -type random -solvable no\n\n# Tests with small n and large m\n./gen -n 1000 -m 100000 -type random -solvable yes\n./gen -n 1000 -m 100000 -type random -solvable no\n\n# Test with cycle of odd length to produce impossible case\n./gen -n 99999 -m 99999 -type cycle -solvable no\n\n# Test with even length cycle to produce solvable case\n./gen -n 100000 -m 100000 -type cycle -solvable yes\n\n# Include the sample inputs\n./gen -n 4 -m 4 -type random -solvable yes\n./gen -n 3 -m 3 -type random -solvable no\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:18.671989",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "229/A",
      "title": "A. Shifts",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers: n (1 ≤ n ≤ 100) — the number of rows in the table and m (1 ≤ m ≤ 104) — the number of columns in the table. Then n lines follow, each of them contains m characters \"0\" or \"1\": the j-th character of the i-th line describes the contents of the cell in the i-th row and in the j-th column of the table.It is guaranteed that the description of the table contains no other characters besides \"0\" and \"1\".",
      "output_spec": "OutputPrint a single number: the minimum number of moves needed to get only numbers 1 in some column of the table. If this is impossible, print -1.",
      "sample_tests": "ExamplesInputCopy3 6101010000100100000OutputCopy3InputCopy2 3111000OutputCopy-1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers: n (1 ≤ n ≤ 100) — the number of rows in the table and m (1 ≤ m ≤ 104) — the number of columns in the table. Then n lines follow, each of them contains m characters \"0\" or \"1\": the j-th character of the i-th line describes the contents of the cell in the i-th row and in the j-th column of the table.It is guaranteed that the description of the table contains no other characters besides \"0\" and \"1\".\n\nOutputPrint a single number: the minimum number of moves needed to get only numbers 1 in some column of the table. If this is impossible, print -1.\n\nInputCopy3 6101010000100100000OutputCopy3InputCopy2 3111000OutputCopy-1\n\nInputCopy3 6101010000100100000\n\nOutputCopy3\n\nInputCopy2 3111000\n\nOutputCopy-1\n\nNoteIn the first sample one way to achieve the goal with the least number of moves is as follows: cyclically shift the second row to the right once, then shift the third row to the left twice. Then the table column before the last one will contain only 1s.In the second sample one can't shift the rows to get a column containing only 1s.",
      "solutions": [
        {
          "title": "Codeforces Round #142 - Codeforces",
          "content": "Hello everyone!Codeforces Round #142 will be held today at 19:30 in Moscow time, and it will take place in both divisions.The authors of the problems are me, Evgeny Vihrov (gen), and Andrey Vihrov (andreyv). Both of us are students of the Faculty of Computing in the University of Latvia. This is our very first contest on Codeforces!Big thanks for the help in preparing the contest go to Gerald Agapov (Gerald), and to Maria Belova (Delinur) — for translating the problem statements in English. Also thanks to Mikhail Mirzayanov (MikeMirzayanov) for the Polygon system, which we found to be great for preparing contest problems.We hope that each participant will be able find a problem to match his taste. Please, consider reading all the problems!We wish you an exciting round!UPD1: The score distribution will be dynamic. The problems will be sorted in order of expected increasing difficulty.UPD2: Due to the technical problems the contest was extended by 5 minutes. We are sorry for the inconvinience.UPD3: The analysis of the contest is available. Enjoy!The round is over! 5 contestants solved all the problems in division 1, and in division 2 only the top four contestants solved all the tasks. Congratulations to the winners!Div I YuukaKazami peter50216 kelvin takaramono Martin Div II coquelicot llj_bash kb. niukuo Petar",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5432",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1330
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces",
          "content": "Div. 2 A — DragonsObserve that if Kirito fights a dragon whose strength is less than Kirito's strength, then Kirito does not lose anything — in fact, he even gains a nonnegative strength increase. Taking note of this, let's for each step choose some dragon whose strength is less than Kirito's current strength, and fight it. After performing some amount of these steps we'll eventually end up in one of these two situations: either all dragons are slain (then the answer is \"YES\"), or only dragons whose strength is not less than Kirito's strength remain (then the answer is \"NO\"). On each step we can choose a suitable dragon to fight either by searching through all dragons or by sorting the dragons by strength in non-descending order in advance.The complexity of the solution is O(n2) or . Sample solution: http://pastie.org/4897164 (archived copy)  Div. 2 B — T-primesIt can be shown that only squares of prime numbers are T-primes, and that there are not too many of them — as many as there are prime numbers not greater than . Precompute these numbers (using, for example, the sieve of Eratosthenes) and store them in an array or an std::set, then we can answer each query by simply checking whether the number in question is amongst the precomputed numbers.The complexity of the solution is linear in relation to n — or , where d = 1012 (one can also get a tighter bound). Sample solution: http://pastie.org/4897166 (archived copy)Div. 1 A — ShiftsLet's compute the minimum number of operations needed to get all 1s in each of the m columns. For this, traverse each row twice — one time to the left and one time to the right, recording the index of the nearest cell with 1 (in corresponding direction) for each column in this row. Then the number of operations for any particular column is the sum of the computed values over all rows. In turn, the answer to the problem is the minimal value of these sums.The complexity of the solution is O(nm). Sample solution: http://pastie.org/4897169 (archived copy)Div. 1 B — PlanetsObserve that when we visit some planet, the best strategy is to arrive as early as we can and then wait for the nearest free moment of time to move further. Hence this problem can be solved with the Dijkstra's algorithm by slightly altering the definition of a shortest distance. When we process a planet (meaning that we already know the minimum time needed to reach it), we need to check the array of arrival times for this planet and find the first moment of time in which we can leave this planet — this will be the distance that we will be adding to outgoing paths from this planet. It's clear that we will traverse each array of arrival times no more than once. Additionally, one must pay attention to these cases: when a traveller arrives to planet 1 at time 0 (then Jack has to wait) and when a traveller arrives to planet n at the same time as Jack (then Jack needs not to wait).The complexity of the solution — . Sample solution: http://pastie.org/4897171 (archived copy)Div. 1 C — TrianglesLet's call Alice's edges simply edges, and Bob's edges the antiedges. For each edge pair of the initial complete graph that pass through the same vertices, assign a weight: for each pair of edges the weight +2, for each pair of edge and antiedge −1 and for each pair of antiedges +2. Now calculate the sum of all the weights. Observe that each Alice's or Bob's triangle adds exactly +6 to the sum, and each combination of three vertices that do not form the triangle in any of the two graphs adds exactly 0 to the sum. The sum itself is calculated by iterating over all vertices and adding the total weight of all the edge pairs that pass through this vertex. If the degree of the vertex is d, then we should add d(d - 1) - d(n - d - 1) + (n - d - 1)(n - d - 2) to the final sum. Since each triangle adds +6 to the sum, then the answer is equal to the sum divided by 6.The complexity of the solution is O(n + m). Sample solution: http://pastie.org/4897512 (archived copy)Div. 1 D — TowersLet's calculate the dynamics d[i][k] — the minimal possible height of the last tower that we can obtain by merging the first i left towers into at least k towers. Assume we already have calculated the dynamics' values for the first i towers. Now we iterate over the all possible tower intervals [i + 1;j]; say the sum in the pending interval is equal to s. Now we find the greatest k such that d[i][k] is not greater than s. Then we update the value of d[j][k+1] to the minimum of s and d[j][k+1]. Notice that when k increases the values d[i][k] do not decrease. Because of that we can iterate over intervals in the decreasing value of j, and corresponding k can be found using a single pointer over values of d[i][k].When we arrive in the position j during the dynamics, some of the d[j][k] values are updated, but some are still not. Using the same observation that along with the increasing of k the values d[j][k] do not decrease as well, we can make a single run over the values of k in the decreasing order and update the dynamics' values as follows: d[j][k] := min(d[j][k], d[j][k+1]). This is done in the beginning of the dynamics' iteration.In the end we can find the greatest k for which there exists an answer among the values of d[n][k]. The answer to the problem then is n - k.The complexity of the solution is O(n2). Sample solution: http://pastie.org/4897515 (archived copy)Div. 1 E — GiftsFirst let's establish some facts that we will use in the solution. With how much probability can the fisherman get a particular set of gifts, among which there are ai gifts of i-th name? In total there are such sets, since there are exactly subsets of gifts with i-th name of size ai, and two different names are independent during the gold fish's choice. Then the described particular set of gifts we can get with the probability of , by asking ai gifts of i-th name.Now we know the probability p of obtaining one particular gift set A. Now observe that from p we can calculate the probabiltity p' of obtaining the set A along with some one other gift of x-th name in constant time. Say there are already ax elements of x-th name in A. Using the formula from the first paragraph, we can deduce that: Let's solve the main problem now. We sort all the gifts in descending order of their prices. It is clear that the fisherman will definitely ask the names of all the gifts among the first n ones whose prices are not equal to the price of the n-th gift in the list. Let's say that this set of gifts is the base, and it has b elements. Then there is still n - b unchosen gifts, and we know that all of them will have the price equal to the price of the n-th gift in the list. Say the price of the n-th gift is d, and there are exactly s gifts with the price d (keep in mind that each of them has a different name); also call these gifts dubious. We can also deduce that the fisherman can make different decisions, where l = n - b.So now we have some s dubious gifts with the price of d; let's enumerate them in any order. We calculate the dynamics f(x, y) — the cumulative probability of obtaining n most valuable gifts, if there are x chosen from the first y in the list. It is clear that f(0, 0) = p, and f(l, s) contains the answer to the problem. Using the coefficients we have deduced earlier, we get two transitions in the dynamics: , if we add y + 1-th dubious gift to the set of x chosen among the first y dubious gifts; , otherwise, if do not put the y + 1-th dubious gift. This dynamics can be computed in O(t2) time, where t is the total number of gifts. The complexity of the solution is . Sample solution: http://pastie.org/4897519 (archived copy)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7684
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #142 - Codeforces - Code 1",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 2",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 3",
          "code": "\\_dangerous\\_",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 4",
          "code": "double temp = pow((double)n, 0.5);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 5",
          "code": "long long square_root = (long long)(temp);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces - Code 1",
          "code": "d[j][k] := min(d[j][k], d[j][k+1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[01]{\" + to_string(m) + \"}\", \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[01]{\" + to_string(m) + \"}\", \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[01]{\" + to_string(m) + \"}\", \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= m && m <= 10000);\n\n    vector<string> table(n, string(m, '0'));\n\n    if (type == \"all_ones\") {\n        for (int i = 0; i < n; ++i) {\n            table[i] = string(m, '1');\n        }\n    } else if (type == \"all_zeros\") {\n        // table is already initialized to zeros\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                table[i][j] = rnd.next(2) ? '1' : '0';\n            }\n        }\n    } else if (type == \"zero_moves\") {\n        int col = rnd.next(0, m - 1);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                table[i][j] = rnd.next(2) ? '1' : '0';\n            }\n            table[i][col] = '1';\n        }\n    } else if (type == \"impossible\") {\n        for (int i = 0; i < n; ++i) {\n            int pos = i % m;\n            table[i][pos] = '1';\n        }\n    } else if (type == \"max_moves\") {\n        int k = m / n;\n        if (k == 0) k = 1;\n        for (int i = 0; i < n; ++i) {\n            int pos = (i * k) % m;\n            table[i][pos] = '1';\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                table[i][j] = rnd.next(2) ? '1' : '0';\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", table[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= m && m <= 10000);\n\n    vector<string> table(n, string(m, '0'));\n\n    if (type == \"all_ones\") {\n        for (int i = 0; i < n; ++i) {\n            table[i] = string(m, '1');\n        }\n    } else if (type == \"all_zeros\") {\n        // table is already initialized to zeros\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                table[i][j] = rnd.next(2) ? '1' : '0';\n            }\n        }\n    } else if (type == \"zero_moves\") {\n        int col = rnd.next(0, m - 1);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                table[i][j] = rnd.next(2) ? '1' : '0';\n            }\n            table[i][col] = '1';\n        }\n    } else if (type == \"impossible\") {\n        for (int i = 0; i < n; ++i) {\n            int pos = i % m;\n            table[i][pos] = '1';\n        }\n    } else if (type == \"max_moves\") {\n        int k = m / n;\n        if (k == 0) k = 1;\n        for (int i = 0; i < n; ++i) {\n            int pos = (i * k) % m;\n            table[i][pos] = '1';\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                table[i][j] = rnd.next(2) ? '1' : '0';\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", table[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type all_ones\n./gen -n 1 -m 1 -type all_zeros\n./gen -n 2 -m 2 -type impossible\n./gen -n 10 -m 10 -type random\n./gen -n 100 -m 1000 -type random\n./gen -n 100 -m 10000 -type random\n./gen -n 100 -m 10000 -type impossible\n./gen -n 100 -m 10000 -type zero_moves\n./gen -n 1 -m 10000 -type max_moves\n./gen -n 50 -m 10000 -type max_moves\n./gen -n 100 -m 5000 -type max_moves\n./gen -n 100 -m 10000 -type max_moves\n./gen -n 100 -m 10 -type zero_moves\n./gen -n 50 -m 1000 -type impossible\n./gen -n 100 -m 10000 -type all_ones\n./gen -n 100 -m 10000 -type all_zeros\n./gen -n 100 -m 10000 -type random\n./gen -n 100 -m 9999 -type random\n./gen -n 50 -m 5000 -type random\n./gen -n 75 -m 7500 -type random\n./gen -n 1 -m 10000 -type impossible\n./gen -n 1 -m 10000 -type zero_moves\n./gen -n 1 -m 10000 -type all_zeros\n./gen -n 1 -m 10000 -type all_ones\n./gen -n 2 -m 2 -type impossible\n./gen -n 2 -m 10000 -type impossible\n./gen -n 100 -m 10000 -type random\n./gen -n 100 -m 10000 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:20.335177",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "229/B",
      "title": "B. Planets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers: n (2 ≤ n ≤ 105), the number of planets in the galaxy, and m (0 ≤ m ≤ 105) — the number of pairs of planets between which Jack can travel using stargates. Then m lines follow, containing three integers each: the i-th line contains numbers of planets ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), which are connected through stargates, and the integer transfer time (in seconds) ci (1 ≤ ci ≤ 104) between these planets. It is guaranteed that between any pair of planets there is at most one stargate connection.Then n lines follow: the i-th line contains an integer ki (0 ≤ ki ≤ 105) that denotes the number of moments of time when other travellers arrive to the planet with index i. Then ki distinct space-separated integers tij (0 ≤ tij < 109) follow, sorted in ascending order. An integer tij means that at time tij (in seconds) another traveller arrives to the planet i. It is guaranteed that the sum of all ki does not exceed 105.",
      "output_spec": "OutputPrint a single number — the least amount of time Jack needs to get from planet 1 to planet n. If Jack can't get to planet n in any amount of time, print number -1.",
      "sample_tests": "ExamplesInputCopy4 61 2 21 3 31 4 82 3 42 4 53 4 301 32 3 40OutputCopy7InputCopy3 11 2 301 30OutputCopy-1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers: n (2 ≤ n ≤ 105), the number of planets in the galaxy, and m (0 ≤ m ≤ 105) — the number of pairs of planets between which Jack can travel using stargates. Then m lines follow, containing three integers each: the i-th line contains numbers of planets ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), which are connected through stargates, and the integer transfer time (in seconds) ci (1 ≤ ci ≤ 104) between these planets. It is guaranteed that between any pair of planets there is at most one stargate connection.Then n lines follow: the i-th line contains an integer ki (0 ≤ ki ≤ 105) that denotes the number of moments of time when other travellers arrive to the planet with index i. Then ki distinct space-separated integers tij (0 ≤ tij < 109) follow, sorted in ascending order. An integer tij means that at time tij (in seconds) another traveller arrives to the planet i. It is guaranteed that the sum of all ki does not exceed 105.\n\nOutputPrint a single number — the least amount of time Jack needs to get from planet 1 to planet n. If Jack can't get to planet n in any amount of time, print number -1.\n\nInputCopy4 61 2 21 3 31 4 82 3 42 4 53 4 301 32 3 40OutputCopy7InputCopy3 11 2 301 30OutputCopy-1\n\nInputCopy4 61 2 21 3 31 4 82 3 42 4 53 4 301 32 3 40\n\nOutputCopy7\n\nInputCopy3 11 2 301 30\n\nOutputCopy-1\n\nNoteIn the first sample Jack has three ways to go from planet 1. If he moves to planet 4 at once, he spends 8 seconds. If he transfers to planet 3, he spends 3 seconds, but as other travellers arrive to planet 3 at time 3 and 4, he can travel to planet 4 only at time 5, thus spending 8 seconds in total. But if Jack moves to planet 2, and then — to planet 4, then he spends a total of only 2 + 5 = 7 seconds.In the second sample one can't get from planet 1 to planet 3 by moving through stargates.",
      "solutions": [
        {
          "title": "Codeforces Round #142 - Codeforces",
          "content": "Hello everyone!Codeforces Round #142 will be held today at 19:30 in Moscow time, and it will take place in both divisions.The authors of the problems are me, Evgeny Vihrov (gen), and Andrey Vihrov (andreyv). Both of us are students of the Faculty of Computing in the University of Latvia. This is our very first contest on Codeforces!Big thanks for the help in preparing the contest go to Gerald Agapov (Gerald), and to Maria Belova (Delinur) — for translating the problem statements in English. Also thanks to Mikhail Mirzayanov (MikeMirzayanov) for the Polygon system, which we found to be great for preparing contest problems.We hope that each participant will be able find a problem to match his taste. Please, consider reading all the problems!We wish you an exciting round!UPD1: The score distribution will be dynamic. The problems will be sorted in order of expected increasing difficulty.UPD2: Due to the technical problems the contest was extended by 5 minutes. We are sorry for the inconvinience.UPD3: The analysis of the contest is available. Enjoy!The round is over! 5 contestants solved all the problems in division 1, and in division 2 only the top four contestants solved all the tasks. Congratulations to the winners!Div I YuukaKazami peter50216 kelvin takaramono Martin Div II coquelicot llj_bash kb. niukuo Petar",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5432",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1330
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces",
          "content": "Div. 2 A — DragonsObserve that if Kirito fights a dragon whose strength is less than Kirito's strength, then Kirito does not lose anything — in fact, he even gains a nonnegative strength increase. Taking note of this, let's for each step choose some dragon whose strength is less than Kirito's current strength, and fight it. After performing some amount of these steps we'll eventually end up in one of these two situations: either all dragons are slain (then the answer is \"YES\"), or only dragons whose strength is not less than Kirito's strength remain (then the answer is \"NO\"). On each step we can choose a suitable dragon to fight either by searching through all dragons or by sorting the dragons by strength in non-descending order in advance.The complexity of the solution is O(n2) or . Sample solution: http://pastie.org/4897164 (archived copy)  Div. 2 B — T-primesIt can be shown that only squares of prime numbers are T-primes, and that there are not too many of them — as many as there are prime numbers not greater than . Precompute these numbers (using, for example, the sieve of Eratosthenes) and store them in an array or an std::set, then we can answer each query by simply checking whether the number in question is amongst the precomputed numbers.The complexity of the solution is linear in relation to n — or , where d = 1012 (one can also get a tighter bound). Sample solution: http://pastie.org/4897166 (archived copy)Div. 1 A — ShiftsLet's compute the minimum number of operations needed to get all 1s in each of the m columns. For this, traverse each row twice — one time to the left and one time to the right, recording the index of the nearest cell with 1 (in corresponding direction) for each column in this row. Then the number of operations for any particular column is the sum of the computed values over all rows. In turn, the answer to the problem is the minimal value of these sums.The complexity of the solution is O(nm). Sample solution: http://pastie.org/4897169 (archived copy)Div. 1 B — PlanetsObserve that when we visit some planet, the best strategy is to arrive as early as we can and then wait for the nearest free moment of time to move further. Hence this problem can be solved with the Dijkstra's algorithm by slightly altering the definition of a shortest distance. When we process a planet (meaning that we already know the minimum time needed to reach it), we need to check the array of arrival times for this planet and find the first moment of time in which we can leave this planet — this will be the distance that we will be adding to outgoing paths from this planet. It's clear that we will traverse each array of arrival times no more than once. Additionally, one must pay attention to these cases: when a traveller arrives to planet 1 at time 0 (then Jack has to wait) and when a traveller arrives to planet n at the same time as Jack (then Jack needs not to wait).The complexity of the solution — . Sample solution: http://pastie.org/4897171 (archived copy)Div. 1 C — TrianglesLet's call Alice's edges simply edges, and Bob's edges the antiedges. For each edge pair of the initial complete graph that pass through the same vertices, assign a weight: for each pair of edges the weight +2, for each pair of edge and antiedge −1 and for each pair of antiedges +2. Now calculate the sum of all the weights. Observe that each Alice's or Bob's triangle adds exactly +6 to the sum, and each combination of three vertices that do not form the triangle in any of the two graphs adds exactly 0 to the sum. The sum itself is calculated by iterating over all vertices and adding the total weight of all the edge pairs that pass through this vertex. If the degree of the vertex is d, then we should add d(d - 1) - d(n - d - 1) + (n - d - 1)(n - d - 2) to the final sum. Since each triangle adds +6 to the sum, then the answer is equal to the sum divided by 6.The complexity of the solution is O(n + m). Sample solution: http://pastie.org/4897512 (archived copy)Div. 1 D — TowersLet's calculate the dynamics d[i][k] — the minimal possible height of the last tower that we can obtain by merging the first i left towers into at least k towers. Assume we already have calculated the dynamics' values for the first i towers. Now we iterate over the all possible tower intervals [i + 1;j]; say the sum in the pending interval is equal to s. Now we find the greatest k such that d[i][k] is not greater than s. Then we update the value of d[j][k+1] to the minimum of s and d[j][k+1]. Notice that when k increases the values d[i][k] do not decrease. Because of that we can iterate over intervals in the decreasing value of j, and corresponding k can be found using a single pointer over values of d[i][k].When we arrive in the position j during the dynamics, some of the d[j][k] values are updated, but some are still not. Using the same observation that along with the increasing of k the values d[j][k] do not decrease as well, we can make a single run over the values of k in the decreasing order and update the dynamics' values as follows: d[j][k] := min(d[j][k], d[j][k+1]). This is done in the beginning of the dynamics' iteration.In the end we can find the greatest k for which there exists an answer among the values of d[n][k]. The answer to the problem then is n - k.The complexity of the solution is O(n2). Sample solution: http://pastie.org/4897515 (archived copy)Div. 1 E — GiftsFirst let's establish some facts that we will use in the solution. With how much probability can the fisherman get a particular set of gifts, among which there are ai gifts of i-th name? In total there are such sets, since there are exactly subsets of gifts with i-th name of size ai, and two different names are independent during the gold fish's choice. Then the described particular set of gifts we can get with the probability of , by asking ai gifts of i-th name.Now we know the probability p of obtaining one particular gift set A. Now observe that from p we can calculate the probabiltity p' of obtaining the set A along with some one other gift of x-th name in constant time. Say there are already ax elements of x-th name in A. Using the formula from the first paragraph, we can deduce that: Let's solve the main problem now. We sort all the gifts in descending order of their prices. It is clear that the fisherman will definitely ask the names of all the gifts among the first n ones whose prices are not equal to the price of the n-th gift in the list. Let's say that this set of gifts is the base, and it has b elements. Then there is still n - b unchosen gifts, and we know that all of them will have the price equal to the price of the n-th gift in the list. Say the price of the n-th gift is d, and there are exactly s gifts with the price d (keep in mind that each of them has a different name); also call these gifts dubious. We can also deduce that the fisherman can make different decisions, where l = n - b.So now we have some s dubious gifts with the price of d; let's enumerate them in any order. We calculate the dynamics f(x, y) — the cumulative probability of obtaining n most valuable gifts, if there are x chosen from the first y in the list. It is clear that f(0, 0) = p, and f(l, s) contains the answer to the problem. Using the coefficients we have deduced earlier, we get two transitions in the dynamics: , if we add y + 1-th dubious gift to the set of x chosen among the first y dubious gifts; , otherwise, if do not put the y + 1-th dubious gift. This dynamics can be computed in O(t2) time, where t is the total number of gifts. The complexity of the solution is . Sample solution: http://pastie.org/4897519 (archived copy)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7684
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #142 - Codeforces - Code 1",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 2",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 3",
          "code": "\\_dangerous\\_",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 4",
          "code": "double temp = pow((double)n, 0.5);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 5",
          "code": "long long square_root = (long long)(temp);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces - Code 1",
          "code": "d[j][k] := min(d[j][k], d[j][k+1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        ensuref(a != b, \"Edge cannot connect a planet to itself\");\n        inf.readSpace();\n        int c = inf.readInt(1, 10000, \"ci\");\n        inf.readEoln();\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple stargates between planets %d and %d\", u, v);\n        edges.insert(edge);\n    }\n\n    long long sum_k = 0;\n    for (int i = 1; i <= n; i++) {\n        int ki = inf.readInt(0, 100000, \"ki\");\n        sum_k += ki;\n\n        if (ki > 0) {\n            inf.readSpace();\n            vector<int> tij = inf.readInts(ki, 0, 999999999, \"tij\");\n            for (int j = 1; j < ki; ++j) {\n                ensuref(tij[j - 1] < tij[j], \"Values of tij must be sorted in ascending order and distinct\");\n            }\n        }\n        inf.readEoln();\n    }\n\n    ensuref(sum_k <= 100000, \"Sum of ki exceeds 1e5\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        ensuref(a != b, \"Edge cannot connect a planet to itself\");\n        inf.readSpace();\n        int c = inf.readInt(1, 10000, \"ci\");\n        inf.readEoln();\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple stargates between planets %d and %d\", u, v);\n        edges.insert(edge);\n    }\n\n    long long sum_k = 0;\n    for (int i = 1; i <= n; i++) {\n        int ki = inf.readInt(0, 100000, \"ki\");\n        sum_k += ki;\n\n        if (ki > 0) {\n            inf.readSpace();\n            vector<int> tij = inf.readInts(ki, 0, 999999999, \"tij\");\n            for (int j = 1; j < ki; ++j) {\n                ensuref(tij[j - 1] < tij[j], \"Values of tij must be sorted in ascending order and distinct\");\n            }\n        }\n        inf.readEoln();\n    }\n\n    ensuref(sum_k <= 100000, \"Sum of ki exceeds 1e5\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        ensuref(a != b, \"Edge cannot connect a planet to itself\");\n        inf.readSpace();\n        int c = inf.readInt(1, 10000, \"ci\");\n        inf.readEoln();\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple stargates between planets %d and %d\", u, v);\n        edges.insert(edge);\n    }\n\n    long long sum_k = 0;\n    for (int i = 1; i <= n; i++) {\n        int ki = inf.readInt(0, 100000, \"ki\");\n        sum_k += ki;\n\n        if (ki > 0) {\n            inf.readSpace();\n            vector<int> tij = inf.readInts(ki, 0, 999999999, \"tij\");\n            for (int j = 1; j < ki; ++j) {\n                ensuref(tij[j - 1] < tij[j], \"Values of tij must be sorted in ascending order and distinct\");\n            }\n        }\n        inf.readEoln();\n    }\n\n    ensuref(sum_k <= 100000, \"Sum of ki exceeds 1e5\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // number of planets\n    int m = opt<int>(\"m\", n - 1); // number of edges\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n    string arrival_type = opt<string>(\"arrival_type\", \"none\");\n\n    // Adjust m to be at least n - 1 unless disconnected\n    if (graph_type != \"disconnected\" && m < n - 1) m = n - 1;\n    if (m > 100000) m = 100000;\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edge_set;\n\n    if (graph_type == \"chain\") {\n        // Create a chain from node 1 to node n\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else if (graph_type == \"star\") {\n        // Create a star graph centered at node 1\n        for (int i = 2; i <= n; ++i) {\n            int u = 1;\n            int v = i;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else if (graph_type == \"disconnected\") {\n        // Create two separate components, one containing node 1, one containing node n\n        // First component includes node 1 to mid\n        // Second component includes mid+1 to n\n        int mid = n / 2;\n        for (int i = 1; i < mid; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n        for (int i = mid + 1; i < n; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else { // \"random\"\n        // Create a random connected graph\n        // Start with a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n        // Add extra edges up to m\n        int max_edges = n * (n - 1) / 2;\n        int total_edges = min(m, max_edges);\n        while ((int)edges.size() < total_edges) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (edge_set.count({u, v})) continue;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    }\n\n    // Assign weights ci to edges, between 1 and 1e4\n    vector<int> ci(edges.size());\n    for (size_t i = 0; i < edges.size(); ++i) {\n        ci[i] = rnd.next(1, 10000);\n    }\n\n    // Arrival times\n    vector<vector<int>> arrivals(n + 1);\n    int total_ki = 0;\n    if (arrival_type == \"none\") {\n        // No arrival times\n    } else if (arrival_type == \"random\") {\n        // Randomly distribute arrival_times up to total sum of 1e5\n        int arrival_times = min(100000, n * 10); // Adjust as needed\n        total_ki = arrival_times;\n        for (int i = 1; i <= n; ++i) {\n            arrivals[i].clear();\n        }\n        for (int i = 0; i < arrival_times; ++i) {\n            int planet = rnd.next(1, n);\n            int time = rnd.next(0, (int)1e9 - 1);\n            arrivals[planet].push_back(time);\n        }\n        // Ensure the total ki does not exceed 1e5\n        total_ki = 0;\n        for (int i = 1; i <= n; ++i) {\n            sort(arrivals[i].begin(), arrivals[i].end());\n            arrivals[i].erase(unique(arrivals[i].begin(), arrivals[i].end()), arrivals[i].end());\n            total_ki += arrivals[i].size();\n        }\n    } else if (arrival_type == \"max_arrivals\") {\n        // Maximize total ki up to 1e5\n        total_ki = 100000;\n        int ki_per_planet = total_ki / n;\n        int remaining = total_ki % n;\n        for (int i = 1; i <= n; ++i) {\n            int ki = ki_per_planet + (i <= remaining ? 1 : 0);\n            arrivals[i].clear();\n            for (int j = 0; j < ki; ++j) {\n                int time = rnd.next(0, (int)1e9 - 1);\n                arrivals[i].push_back(time);\n            }\n            sort(arrivals[i].begin(), arrivals[i].end());\n            arrivals[i].erase(unique(arrivals[i].begin(), arrivals[i].end()), arrivals[i].end());\n        }\n    } else if (arrival_type == \"busy\") {\n        // Make arrival times at every time step, making Jack wait\n        arrivals[1].clear();\n        int ki = min(100000, (int)1e9);\n        for (int t = 0; t < ki; ++t) {\n            arrivals[1].push_back(t);\n        }\n    } else if (arrival_type == \"impossible\") {\n        // Block Jack's movement\n        // For example, have arrivals at planet 1 at every time step\n        arrivals[1].clear();\n        int ki = min(100000, (int)1e9);\n        for (int t = 0; t < ki; ++t) {\n            arrivals[1].push_back(t);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Output edges\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        printf(\"%d %d %d\\n\", u, v, ci[i]);\n    }\n\n    // Output arrivals\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", (int)arrivals[i].size());\n        for (size_t j = 0; j < arrivals[i].size(); ++j) {\n            printf(\" %d\", arrivals[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // number of planets\n    int m = opt<int>(\"m\", n - 1); // number of edges\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n    string arrival_type = opt<string>(\"arrival_type\", \"none\");\n\n    // Adjust m to be at least n - 1 unless disconnected\n    if (graph_type != \"disconnected\" && m < n - 1) m = n - 1;\n    if (m > 100000) m = 100000;\n\n    vector<pair<int, int>> edges;\n    set<pair<int, int>> edge_set;\n\n    if (graph_type == \"chain\") {\n        // Create a chain from node 1 to node n\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else if (graph_type == \"star\") {\n        // Create a star graph centered at node 1\n        for (int i = 2; i <= n; ++i) {\n            int u = 1;\n            int v = i;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else if (graph_type == \"disconnected\") {\n        // Create two separate components, one containing node 1, one containing node n\n        // First component includes node 1 to mid\n        // Second component includes mid+1 to n\n        int mid = n / 2;\n        for (int i = 1; i < mid; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n        for (int i = mid + 1; i < n; ++i) {\n            int u = i;\n            int v = i + 1;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    } else { // \"random\"\n        // Create a random connected graph\n        // Start with a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n        // Add extra edges up to m\n        int max_edges = n * (n - 1) / 2;\n        int total_edges = min(m, max_edges);\n        while ((int)edges.size() < total_edges) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (edge_set.count({u, v})) continue;\n            edges.push_back({u, v});\n            edge_set.insert({u, v});\n            edge_set.insert({v, u});\n        }\n    }\n\n    // Assign weights ci to edges, between 1 and 1e4\n    vector<int> ci(edges.size());\n    for (size_t i = 0; i < edges.size(); ++i) {\n        ci[i] = rnd.next(1, 10000);\n    }\n\n    // Arrival times\n    vector<vector<int>> arrivals(n + 1);\n    int total_ki = 0;\n    if (arrival_type == \"none\") {\n        // No arrival times\n    } else if (arrival_type == \"random\") {\n        // Randomly distribute arrival_times up to total sum of 1e5\n        int arrival_times = min(100000, n * 10); // Adjust as needed\n        total_ki = arrival_times;\n        for (int i = 1; i <= n; ++i) {\n            arrivals[i].clear();\n        }\n        for (int i = 0; i < arrival_times; ++i) {\n            int planet = rnd.next(1, n);\n            int time = rnd.next(0, (int)1e9 - 1);\n            arrivals[planet].push_back(time);\n        }\n        // Ensure the total ki does not exceed 1e5\n        total_ki = 0;\n        for (int i = 1; i <= n; ++i) {\n            sort(arrivals[i].begin(), arrivals[i].end());\n            arrivals[i].erase(unique(arrivals[i].begin(), arrivals[i].end()), arrivals[i].end());\n            total_ki += arrivals[i].size();\n        }\n    } else if (arrival_type == \"max_arrivals\") {\n        // Maximize total ki up to 1e5\n        total_ki = 100000;\n        int ki_per_planet = total_ki / n;\n        int remaining = total_ki % n;\n        for (int i = 1; i <= n; ++i) {\n            int ki = ki_per_planet + (i <= remaining ? 1 : 0);\n            arrivals[i].clear();\n            for (int j = 0; j < ki; ++j) {\n                int time = rnd.next(0, (int)1e9 - 1);\n                arrivals[i].push_back(time);\n            }\n            sort(arrivals[i].begin(), arrivals[i].end());\n            arrivals[i].erase(unique(arrivals[i].begin(), arrivals[i].end()), arrivals[i].end());\n        }\n    } else if (arrival_type == \"busy\") {\n        // Make arrival times at every time step, making Jack wait\n        arrivals[1].clear();\n        int ki = min(100000, (int)1e9);\n        for (int t = 0; t < ki; ++t) {\n            arrivals[1].push_back(t);\n        }\n    } else if (arrival_type == \"impossible\") {\n        // Block Jack's movement\n        // For example, have arrivals at planet 1 at every time step\n        arrivals[1].clear();\n        int ki = min(100000, (int)1e9);\n        for (int t = 0; t < ki; ++t) {\n            arrivals[1].push_back(t);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Output edges\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        printf(\"%d %d %d\\n\", u, v, ci[i]);\n    }\n\n    // Output arrivals\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", (int)arrivals[i].size());\n        for (size_t j = 0; j < arrivals[i].size(); ++j) {\n            printf(\" %d\", arrivals[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 15 -graph_type random -arrival_type none\n./gen -n 10 -m 15 -graph_type random -arrival_type random\n./gen -n 10 -m 15 -graph_type random -arrival_type max_arrivals\n./gen -n 10 -m 9 -graph_type chain -arrival_type none\n./gen -n 1000 -m 999 -graph_type chain -arrival_type random\n./gen -n 1000 -m 5000 -graph_type random -arrival_type random\n./gen -n 100000 -m 99999 -graph_type chain -arrival_type none\n./gen -n 100000 -m 100000 -graph_type random -arrival_type max_arrivals\n./gen -n 100000 -m 100000 -graph_type random -arrival_type busy\n./gen -n 100000 -m 100000 -graph_type random -arrival_type impossible\n./gen -n 100000 -m 100000 -graph_type star -arrival_type none\n./gen -n 100 -m 50 -graph_type star -arrival_type random\n./gen -n 100 -m 50 -graph_type star -arrival_type max_arrivals\n./gen -n 50000 -m 50000 -graph_type random -arrival_type none\n./gen -n 50000 -m 100000 -graph_type random -arrival_type random\n./gen -n 50000 -m 50000 -graph_type random -arrival_type busy\n./gen -n 1000 -m 0 -graph_type disconnected -arrival_type none\n./gen -n 1000 -m 500 -graph_type disconnected -arrival_type random\n./gen -n 2 -m 1 -graph_type chain -arrival_type none\n./gen -n 2 -m 1 -graph_type chain -arrival_type busy\n./gen -n 3 -m 2 -graph_type chain -arrival_type impossible\n./gen -n 100000 -m 100000 -graph_type random -arrival_type none\n./gen -n 100000 -m 99999 -graph_type chain -arrival_type random\n./gen -n 100000 -m 100000 -graph_type random -arrival_type busy\n./gen -n 100000 -m 100000 -graph_type random -arrival_type impossible\n./gen -n 100000 -m 50000 -graph_type disconnected -arrival_type none\n./gen -n 2 -m 0 -graph_type disconnected -arrival_type none\n./gen -n 100000 -m 0 -graph_type disconnected -arrival_type max_arrivals\n./gen -n 100000 -m 100000 -graph_type star -arrival_type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:22.627671",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "229/C",
      "title": "C. Треугольники",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа n и m (1 ≤ n ≤ 106, 0 ≤ m ≤ 106), разделенные пробелом — количество вершин в изначальном полном графе, а также количество ребер в графе Алисы, соответственно. Далее следуют m строк: i-тая строка содержит два целых числа ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), разделенные пробелом — номера двух вершин, соединенных i-тым ребром графа Алисы. Гарантируется, что граф Алисы не содержит кратных ребер и петель. Изначальный полный граф также не содержит кратных ребер и петель.Считайте, что вершины графа пронумерованы некоторым образом от 1 до n.",
      "output_spec": "Выходные данныеВыведите единственное число — суммарное количество циклов длины 3 в графах Алисы и Боба.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 51 21 32 32 43 4Выходные данныеСкопировать3Входные данныеСкопировать5 31 22 31 3Выходные данныеСкопировать4",
      "description": "C. Треугольники\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит два целых числа n и m (1 ≤ n ≤ 106, 0 ≤ m ≤ 106), разделенные пробелом — количество вершин в изначальном полном графе, а также количество ребер в графе Алисы, соответственно. Далее следуют m строк: i-тая строка содержит два целых числа ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), разделенные пробелом — номера двух вершин, соединенных i-тым ребром графа Алисы. Гарантируется, что граф Алисы не содержит кратных ребер и петель. Изначальный полный граф также не содержит кратных ребер и петель.Считайте, что вершины графа пронумерованы некоторым образом от 1 до n.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — суммарное количество циклов длины 3 в графах Алисы и Боба.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать5 51 21 32 32 43 4Выходные данныеСкопировать3Входные данныеСкопировать5 31 22 31 3Выходные данныеСкопировать4\n\nВходные данныеСкопировать5 51 21 32 32 43 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 31 22 31 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере в графе Алисы есть 2 треугольника: (1, 2, 3) и (2, 3, 4). В графе Боба всего 1 треугольник: (1, 4, 5). Поэтому в двух графах всего 3 треугольника.Во втором примере в графе Алисы всего 1 треугольник: (1, 2, 3). В графе Боба находится 3 треугольника: (1, 4, 5), (2, 4, 5) и (3, 4, 5). В данном случае ответ на задачу — 4.",
      "solutions": [
        {
          "title": "Codeforces Round #142 - Codeforces",
          "content": "Привет всем!Сегодня в 19:30 по московскому времени состоится Codeforces раунд #142, который пройдёт в обоих дивизионах.Задачи составляли я, Евгений Вихров (gen), и Андрей Вихров (andreyv). Мы оба — студенты Факультета компьютерных наук Латвийского университета. Это наш самый первый раунд на Codeforces!Раунд нам помогал готовить Геральд Агапов (Gerald), а условия на английский язык по традиции перевела Мария Белова (Delinur). Большое спасибо! Отдельно хочется поблагодарить также Михаила Мирзаянова (MikeMirzayanov) за отличную систему подготовки задач Polygon.Мы надеемся, что каждый сможет найти себе задачу по вкусу. Постарайтесь прочесть условия всех задач!Желаем интересного раунда!UPD1: Разбалловка задач динамическая, однако задачи будут упорядочены в порядке возрастания предполагаемой сложности.UPD2: По техническим причинам продолжительность контеста увеличена на 5 минут. Приносим извинения за неудобства.UPD3: Разбор опубликован здесь.Раунд завершён! В первом дивизионе все задачи покорились 5 участникам, во втором — первой 4-ке. Поздравляем победителей!Div I YuukaKazami peter50216 kelvin takaramono Martin Div II coquelicot llj_bash kb. niukuo Petar",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5432",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1167
        },
        {
          "title": "Разбор задач Codeforces Round #142 - Codeforces",
          "content": "Div. 2 A — ДраконыЗаметим, что если Кирито сражается с драконом, сила которого меньше силы Кирито, то Кирито ничего не теряет — наоборот, его сила увеличивается на целое неотрицательное число. Поэтому будем всё время выбирать какого-либо дракона с меньшей силой, чем у Кирито в данный момент, и сражаться с ним. Так будем продолжать до тех пор, пока не победим всех драконов (тогда ответ — «YES»), или пока не останутся только драконы, которых Кирито не может победить (тогда ответ — «NO»). Дракона на каждом шаге можно искать по-разному — как проходиться по всем драконам, так и сначала отсортировать драконов по возрастанию силы.Сложность решения — O(n2) или . Пример решения: http://pastie.org/4897164 (сохранённая копия)  Div. 2 B — Т-простые числаМожно показать, что Т-простыми являются только квадраты простых чисел, и их не так и много — столько, сколько есть простых чисел, не больших . Вычислим все эти числа (например, с помощью решета Эратосфена) и запишем в массив или std::set, тогда на каждый запрос можно отвечать, просто проверяя (двоичным поиском для версии с массивом), есть ли данное число среди заранее вычисленных.Сложность решения линейная от n — или , где d = 1012 (можно вывести и более точную оценку). Пример решения: http://pastie.org/4897166 (сохранённая копия)Div. 1 A — СдвигиПосчитаем для каждого столбика, каким минимальным количеством операций в этом столбике можно получить все единицы. Для этого для каждой строки сделаем два прохода, один слева, а другой справа, поддерживая номер ближайшей с соответствующей стороны единицы. Таким образом для всех позиций мы узнаем расстояние до ближайшей единицы. Тогда для одного столбика ответом является сумма этих значений. В свою очередь, ответом на задачу является наименьшая из этих сумм.Сложность решения — O(nm). Пример решения: http://pastie.org/4897169 (сохранённая копия)Div. 1 B — ПланетыМожно заметить, что если мы посещаем конкретную планету, то выгоднее всего как можно раньше прибыть на неё, а потом подождать ближайшего свободного момента, и тогда отправиться дальше. Поэтому задачу можно решать с помощью алгоритма Дейкстры, немного поменяв определение кратчайшего пути. Когда мы рассматриваем очередную планету (то есть, мы уже знаем минимальное расстояние до неё), надо пройтись по соответственному списку моментов времени и найти первый момент, когда из этой планеты можно отправляться снова — этот момент и будет расстоянием, которое мы будем добавлять к путям, исходящим из этой планеты. Понятно, что по каждому списку мы пройдёмся не более одного раза. Ещё надо обратить внимание на случаи, когда путешественник прибывает на планету 1 в момент времени 0 (тогда Джек должен ждать), и когда путешественник прибывает на планету n одновременно с Джеком (тогда Джек не должен ждать).Сложность решения — . Пример решения: http://pastie.org/4897171 (сохранённая копия)Div. 1 C — ТреугольникиНазовём рёбра Боба антирёбрами. Для каждой пары рёбер полного графа, которые проходят через одну вершину, присвоим вес: каждой паре рёбер значение +2, каждой паре ребро и антиребро — значение −1, и каждой паре антирёбер +2. Посчитаем сумму всех значений. Можно заметить, что каждый треугольник даёт в сумме вес +6, а все остальные комбинации из трёх вершин дают вес 0. Саму сумму считаем, для каждой вершины считая вес каждой пары рёбер, которые проходят через эту вершину. Если степень вершины d, то к сумме нужно прибавить d(d - 1) - d(n - d - 1) + (n - d - 1)(n - d - 2). В конце остаётся разделить сумму на 6, и получаем ответ.Сложность решения — O(m + n). Пример решения: http://pastie.org/4897512 (сохранённая копия)Div. 1 D — БашниПосчитаем динамику d[i][k] — минимальная высота последней башни, которую мы можем получить, соединив первые слева i башен в не менее чем k башен. Допустим, посчитали динамику для первых i башен. Переберём отрезки башен [i + 1;j], пусть сумма высот на этом отрезке s. Найдём наибольшее k такое, что d[i][k] не больше s. Тогда обновим ответ для d[j][k+1]. Заметим, что при увеличении k увеличиваются и значения d[i][k]. Поэтому сами отрезки можно перебирать по уменьшению j, а подходящее k находить указателем по порядку.Когда приходим на позицию j, какие-то значения d[j][k] обновлены, а какие-то — нет. Используя то же наблюдение, что при возрастании k возрастает и d[j][k], пройдём по этим значениям в порядке уменьшения k, и будем обновлять минимум для d[j][k]. Это делаем в начале итерации динамики.В конце найдём максимальный k, для которого существует ответ среди значений d[n][k]. Ответом на задачу является n - k.Сложность решения — O(n2). Пример решения: http://pastie.org/4897515 (сохранённая копия)Div. 1 E — ДарыСперва установим пару фактов, которые будем использовать в решении. Узнаем, с какой вероятностью мы можем получить одно множество из даров, среди которых i-того названия ровно ai даров. Всего таких множеств , т.к. множеств элементов i-того названия счётом ai есть ровно , а два разных названия при выборе ответа независимы. Одно конкретное множество мы тогда можем получить с вероятностью , попросив i-того названия ровно ai штук.Теперь мы знаем вероятность p получения одного множества элементов A. Заметим, что за константное время мы можем из p узнать вероятность p' получения множества A, к которому добавлен другой элемент x-того названия. Допустим, что в A есть ровно ax даров x-того названия. Используя ранее полученную формулу, можно вывести: То есть, p' мы можем вычислить за константное время, зная p.Используя это, решим собственно задачу. Отсортируем все дары в порядке убывания ценностей. Ясно, что названия всех тех даров, ценности которых не равны n-той ценности в этом массиве (обозначим эту ценность как d), нам однозначно надо назвать, чтобы получить n самых ценных даров. Назовём это множество даров базой и посчитаем с помощью формулы вероятность получения базы p. Неопределёнными остаются только те дары, ценность которых равняется d. Потому что, если всего таких даров s, а количество недостающих даров (кроме базы) l, то всего возможно вариантов, как мы можем вместе с названиями даров базы назвать множество остальных l названий, у которого будет шанс получить n самых ценных даров.Теперь у нас есть s «неопределённых» даров с ценностью d, пронумеруем их в каком-то порядке, и назовём их спорными. Будем считать динамику f(x, y) — суммарная вероятность получить n самых ценных даров, если взяли x спорных из первых y спорных. Ясно, что f(0, 0) = p, а f(l, s) — ответ на задачу. Используя ранее найденные коэффициенты, получаем в самой динамике два перехода: , если к комплекту из x спорных среди первых y спорных добавим y + 1-ое спорное; , если, наоборот, не добавляем. Данную динамику можно посчитать за время O(t2), где t — суммарное количество даров.Сложность решения — . Пример решения: http://pastie.org/4897519 (сохранённая копия)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6802
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #142 - Codeforces - Code 1",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 2",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 3",
          "code": "\\_dangerous\\_",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 4",
          "code": "2 1\n1 2 10000\n100000 0 1 2 3 4 ... 99998 99999\n0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 5",
          "code": "2 1\n1 2 10000\n100000 0 1 2 3 4 ... 99998 99999\n0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 6",
          "code": "* --(1)-- * --(1)-- * --(1)-- * --(1)-- * ...\n          |         |         |         |\n       (99998)   (99996)   (99994)   (99992)\n          |         |         |         |\n          +---------+---------+---------+ ... ----- *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 7",
          "code": "* --(1)-- * --(1)-- * --(1)-- * --(1)-- * ...\n          |         |         |         |\n       (99998)   (99996)   (99994)   (99992)\n          |         |         |         |\n          +---------+---------+---------+ ... ----- *",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 8",
          "code": "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.7.1/../../../../include/c++/4.7.1/debug/vector:336:\n    error: attempt to subscript container with out-of-bounds index 1000000,     \n    but container only holds 1000000 elements.\n\nObjects involved in the operation:\nsequence \"this\" @ 0x0xffeafc54 {\n  type = NSt7__debug6vectorIbSaIbEEE;\n}\nАварийный останов",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 9",
          "code": "double temp = pow((double)n, 0.5);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 10",
          "code": "long long square_root = (long long)(temp);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #142 - Codeforces - Code 1",
          "code": "for (int i = 0; i < n; i++) {\n\tint column = rand.nextInt(2) * m / 2;\n\tfor (int j = 0; j < m; j++) {\n\t\tif (i < n / 2 ||  j == column)\n\t\t\tout.print(\"1\");\n\t\telse\n\t\t\tout.print(\"0\");\n\t}\n\tout.println();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #142 - Codeforces - Code 2",
          "code": "for (int i = 0; i < n; i++) {\n\tint column = rand.nextInt(2) * m / 2;\n\tfor (int j = 0; j < m; j++) {\n\t\tif (i < n / 2 ||  j == column)\n\t\t\tout.print(\"1\");\n\t\telse\n\t\t\tout.print(\"0\");\n\t}\n\tout.println();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #142 - Codeforces - Code 3",
          "code": "inline int nxt() {in(ret); return ret;}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #142 - Codeforces - Code 4",
          "code": "inline int nxt() {in(ret); return ret;}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #142 - Codeforces - Code 5",
          "code": "3 5\n00001\n11000\n00001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edge_set;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loops are not allowed: ai (%d) == bi (%d)\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        auto edge = make_pair(u, v);\n\n        ensuref(edge_set.find(edge) == edge_set.end(),\n            \"Multiple edges are not allowed between vertices %d and %d\", u, v);\n\n        edge_set.insert(edge);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edge_set;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loops are not allowed: ai (%d) == bi (%d)\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        auto edge = make_pair(u, v);\n\n        ensuref(edge_set.find(edge) == edge_set.end(),\n            \"Multiple edges are not allowed between vertices %d and %d\", u, v);\n\n        edge_set.insert(edge);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edge_set;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loops are not allowed: ai (%d) == bi (%d)\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        auto edge = make_pair(u, v);\n\n        ensuref(edge_set.find(edge) == edge_set.end(),\n            \"Multiple edges are not allowed between vertices %d and %d\", u, v);\n\n        edge_set.insert(edge);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"empty\") {\n        m = 0;\n        // No edges to add\n    } else if (type == \"full\") {\n        m = n * (n - 1) / 2;\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u + 1; v <= n; ++v) {\n                edges.push_back({u, v});\n            }\n        }\n    } else if (type == \"triangle\") {\n        if (n < 3) {\n            fprintf(stderr, \"n must be at least 3 for triangle type\\n\");\n            exit(1);\n        }\n        m = 3;\n        edges.push_back({1, 2});\n        edges.push_back({2, 3});\n        edges.push_back({1, 3});\n    } else if (type == \"star\") {\n        if (n < 2) {\n            fprintf(stderr, \"n must be at least 2 for star type\\n\");\n            exit(1);\n        }\n        m = n - 1;\n        for (int v = 2; v <= n; ++v) {\n            edges.push_back({1, v});\n        }\n    } else if (type == \"clique\") {\n        int k = opt<int>(\"k\", -1);\n        if (k == -1 || k > n) {\n            fprintf(stderr, \"For clique type, k must be provided and k ≤ n\\n\");\n            exit(1);\n        }\n        m = k * (k - 1) / 2;\n        for (int u = 1; u <= k; ++u) {\n            for (int v = u + 1; v <= k; ++v) {\n                edges.push_back({u, v});\n            }\n        }\n    } else if (type == \"random\") {\n        long long max_edges = 1LL * n * (n - 1) / 2;\n        if (m == -1) {\n            m = rnd.next(0LL, max_edges);\n        }\n        if (m < 0 || m > max_edges) {\n            fprintf(stderr, \"Invalid m: %d\\n\", m);\n            exit(1);\n        }\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"empty\") {\n        m = 0;\n        // No edges to add\n    } else if (type == \"full\") {\n        m = n * (n - 1) / 2;\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u + 1; v <= n; ++v) {\n                edges.push_back({u, v});\n            }\n        }\n    } else if (type == \"triangle\") {\n        if (n < 3) {\n            fprintf(stderr, \"n must be at least 3 for triangle type\\n\");\n            exit(1);\n        }\n        m = 3;\n        edges.push_back({1, 2});\n        edges.push_back({2, 3});\n        edges.push_back({1, 3});\n    } else if (type == \"star\") {\n        if (n < 2) {\n            fprintf(stderr, \"n must be at least 2 for star type\\n\");\n            exit(1);\n        }\n        m = n - 1;\n        for (int v = 2; v <= n; ++v) {\n            edges.push_back({1, v});\n        }\n    } else if (type == \"clique\") {\n        int k = opt<int>(\"k\", -1);\n        if (k == -1 || k > n) {\n            fprintf(stderr, \"For clique type, k must be provided and k ≤ n\\n\");\n            exit(1);\n        }\n        m = k * (k - 1) / 2;\n        for (int u = 1; u <= k; ++u) {\n            for (int v = u + 1; v <= k; ++v) {\n                edges.push_back({u, v});\n            }\n        }\n    } else if (type == \"random\") {\n        long long max_edges = 1LL * n * (n - 1) / 2;\n        if (m == -1) {\n            m = rnd.next(0LL, max_edges);\n        }\n        if (m < 0 || m > max_edges) {\n            fprintf(stderr, \"Invalid m: %d\\n\", m);\n            exit(1);\n        }\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type empty\n./gen -n 5 -type full\n./gen -n 5 -type triangle\n./gen -n 5 -type star\n./gen -n 5 -type random -m 7\n./gen -n 5 -type clique -k 3\n./gen -n 10 -type empty\n./gen -n 10 -type full\n./gen -n 10 -type triangle\n./gen -n 10 -type star\n./gen -n 10 -type random -m 15\n./gen -n 10 -type clique -k 4\n./gen -n 100 -type empty\n./gen -n 100 -type random -m 0\n./gen -n 100 -type random -m 1000\n./gen -n 1000 -type empty\n./gen -n 1000 -type random -m 50000\n./gen -n 10000 -type random -m 100000\n./gen -n 100000 -type empty\n./gen -n 100000 -type random -m 500000\n./gen -n 1000000 -type empty\n./gen -n 1000000 -type random -m 1000000\n./gen -n 1000000 -type random -m 0\n./gen -n 1000000 -type random -m 500000\n./gen -n 1000000 -type triangle\n./gen -n 5000 -type clique -k 5000\n./gen -n 10000 -type clique -k 10000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:24.388732",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "229/D",
      "title": "D. Towers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 5000) — the number of towers in the city. The next line contains n space-separated integers: the i-th number hi (1 ≤ hi ≤ 105) determines the height of the tower that is i-th (from left to right) in the initial tower sequence.",
      "output_spec": "OutputPrint a single integer — the minimum number of operations needed to make the city beautiful.",
      "sample_tests": "ExamplesInputCopy58 2 7 3 1OutputCopy3InputCopy35 2 1OutputCopy2",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 5000) — the number of towers in the city. The next line contains n space-separated integers: the i-th number hi (1 ≤ hi ≤ 105) determines the height of the tower that is i-th (from left to right) in the initial tower sequence.\n\nOutputPrint a single integer — the minimum number of operations needed to make the city beautiful.\n\nInputCopy58 2 7 3 1OutputCopy3InputCopy35 2 1OutputCopy2\n\nInputCopy58 2 7 3 1\n\nOutputCopy3\n\nInputCopy35 2 1\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #142 - Codeforces",
          "content": "Hello everyone!Codeforces Round #142 will be held today at 19:30 in Moscow time, and it will take place in both divisions.The authors of the problems are me, Evgeny Vihrov (gen), and Andrey Vihrov (andreyv). Both of us are students of the Faculty of Computing in the University of Latvia. This is our very first contest on Codeforces!Big thanks for the help in preparing the contest go to Gerald Agapov (Gerald), and to Maria Belova (Delinur) — for translating the problem statements in English. Also thanks to Mikhail Mirzayanov (MikeMirzayanov) for the Polygon system, which we found to be great for preparing contest problems.We hope that each participant will be able find a problem to match his taste. Please, consider reading all the problems!We wish you an exciting round!UPD1: The score distribution will be dynamic. The problems will be sorted in order of expected increasing difficulty.UPD2: Due to the technical problems the contest was extended by 5 minutes. We are sorry for the inconvinience.UPD3: The analysis of the contest is available. Enjoy!The round is over! 5 contestants solved all the problems in division 1, and in division 2 only the top four contestants solved all the tasks. Congratulations to the winners!Div I YuukaKazami peter50216 kelvin takaramono Martin Div II coquelicot llj_bash kb. niukuo Petar",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5432",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1330
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces",
          "content": "Div. 2 A — DragonsObserve that if Kirito fights a dragon whose strength is less than Kirito's strength, then Kirito does not lose anything — in fact, he even gains a nonnegative strength increase. Taking note of this, let's for each step choose some dragon whose strength is less than Kirito's current strength, and fight it. After performing some amount of these steps we'll eventually end up in one of these two situations: either all dragons are slain (then the answer is \"YES\"), or only dragons whose strength is not less than Kirito's strength remain (then the answer is \"NO\"). On each step we can choose a suitable dragon to fight either by searching through all dragons or by sorting the dragons by strength in non-descending order in advance.The complexity of the solution is O(n2) or . Sample solution: http://pastie.org/4897164 (archived copy)  Div. 2 B — T-primesIt can be shown that only squares of prime numbers are T-primes, and that there are not too many of them — as many as there are prime numbers not greater than . Precompute these numbers (using, for example, the sieve of Eratosthenes) and store them in an array or an std::set, then we can answer each query by simply checking whether the number in question is amongst the precomputed numbers.The complexity of the solution is linear in relation to n — or , where d = 1012 (one can also get a tighter bound). Sample solution: http://pastie.org/4897166 (archived copy)Div. 1 A — ShiftsLet's compute the minimum number of operations needed to get all 1s in each of the m columns. For this, traverse each row twice — one time to the left and one time to the right, recording the index of the nearest cell with 1 (in corresponding direction) for each column in this row. Then the number of operations for any particular column is the sum of the computed values over all rows. In turn, the answer to the problem is the minimal value of these sums.The complexity of the solution is O(nm). Sample solution: http://pastie.org/4897169 (archived copy)Div. 1 B — PlanetsObserve that when we visit some planet, the best strategy is to arrive as early as we can and then wait for the nearest free moment of time to move further. Hence this problem can be solved with the Dijkstra's algorithm by slightly altering the definition of a shortest distance. When we process a planet (meaning that we already know the minimum time needed to reach it), we need to check the array of arrival times for this planet and find the first moment of time in which we can leave this planet — this will be the distance that we will be adding to outgoing paths from this planet. It's clear that we will traverse each array of arrival times no more than once. Additionally, one must pay attention to these cases: when a traveller arrives to planet 1 at time 0 (then Jack has to wait) and when a traveller arrives to planet n at the same time as Jack (then Jack needs not to wait).The complexity of the solution — . Sample solution: http://pastie.org/4897171 (archived copy)Div. 1 C — TrianglesLet's call Alice's edges simply edges, and Bob's edges the antiedges. For each edge pair of the initial complete graph that pass through the same vertices, assign a weight: for each pair of edges the weight +2, for each pair of edge and antiedge −1 and for each pair of antiedges +2. Now calculate the sum of all the weights. Observe that each Alice's or Bob's triangle adds exactly +6 to the sum, and each combination of three vertices that do not form the triangle in any of the two graphs adds exactly 0 to the sum. The sum itself is calculated by iterating over all vertices and adding the total weight of all the edge pairs that pass through this vertex. If the degree of the vertex is d, then we should add d(d - 1) - d(n - d - 1) + (n - d - 1)(n - d - 2) to the final sum. Since each triangle adds +6 to the sum, then the answer is equal to the sum divided by 6.The complexity of the solution is O(n + m). Sample solution: http://pastie.org/4897512 (archived copy)Div. 1 D — TowersLet's calculate the dynamics d[i][k] — the minimal possible height of the last tower that we can obtain by merging the first i left towers into at least k towers. Assume we already have calculated the dynamics' values for the first i towers. Now we iterate over the all possible tower intervals [i + 1;j]; say the sum in the pending interval is equal to s. Now we find the greatest k such that d[i][k] is not greater than s. Then we update the value of d[j][k+1] to the minimum of s and d[j][k+1]. Notice that when k increases the values d[i][k] do not decrease. Because of that we can iterate over intervals in the decreasing value of j, and corresponding k can be found using a single pointer over values of d[i][k].When we arrive in the position j during the dynamics, some of the d[j][k] values are updated, but some are still not. Using the same observation that along with the increasing of k the values d[j][k] do not decrease as well, we can make a single run over the values of k in the decreasing order and update the dynamics' values as follows: d[j][k] := min(d[j][k], d[j][k+1]). This is done in the beginning of the dynamics' iteration.In the end we can find the greatest k for which there exists an answer among the values of d[n][k]. The answer to the problem then is n - k.The complexity of the solution is O(n2). Sample solution: http://pastie.org/4897515 (archived copy)Div. 1 E — GiftsFirst let's establish some facts that we will use in the solution. With how much probability can the fisherman get a particular set of gifts, among which there are ai gifts of i-th name? In total there are such sets, since there are exactly subsets of gifts with i-th name of size ai, and two different names are independent during the gold fish's choice. Then the described particular set of gifts we can get with the probability of , by asking ai gifts of i-th name.Now we know the probability p of obtaining one particular gift set A. Now observe that from p we can calculate the probabiltity p' of obtaining the set A along with some one other gift of x-th name in constant time. Say there are already ax elements of x-th name in A. Using the formula from the first paragraph, we can deduce that: Let's solve the main problem now. We sort all the gifts in descending order of their prices. It is clear that the fisherman will definitely ask the names of all the gifts among the first n ones whose prices are not equal to the price of the n-th gift in the list. Let's say that this set of gifts is the base, and it has b elements. Then there is still n - b unchosen gifts, and we know that all of them will have the price equal to the price of the n-th gift in the list. Say the price of the n-th gift is d, and there are exactly s gifts with the price d (keep in mind that each of them has a different name); also call these gifts dubious. We can also deduce that the fisherman can make different decisions, where l = n - b.So now we have some s dubious gifts with the price of d; let's enumerate them in any order. We calculate the dynamics f(x, y) — the cumulative probability of obtaining n most valuable gifts, if there are x chosen from the first y in the list. It is clear that f(0, 0) = p, and f(l, s) contains the answer to the problem. Using the coefficients we have deduced earlier, we get two transitions in the dynamics: , if we add y + 1-th dubious gift to the set of x chosen among the first y dubious gifts; , otherwise, if do not put the y + 1-th dubious gift. This dynamics can be computed in O(t2) time, where t is the total number of gifts. The complexity of the solution is . Sample solution: http://pastie.org/4897519 (archived copy)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7684
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #142 - Codeforces - Code 1",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 2",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 3",
          "code": "\\_dangerous\\_",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 4",
          "code": "double temp = pow((double)n, 0.5);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 5",
          "code": "long long square_root = (long long)(temp);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces - Code 1",
          "code": "d[j][k] := min(d[j][k], d[j][k+1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 100000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 100000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 100000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxh = opt<int>(\"maxh\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        // Random heights between 1 and maxh\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, maxh);\n        }\n    } else if (type == \"sorted\") {\n        // Non-decreasing sequence\n        int curr = 1;\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(curr, maxh);\n            curr = h[i]; // Ensure non-decreasing\n        }\n    } else if (type == \"reverse\") {\n        // Non-increasing sequence\n        int curr = maxh;\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, curr);\n            curr = h[i]; // Ensure non-increasing\n        }\n    } else if (type == \"equal\") {\n        // All heights are equal\n        int value = rnd.next(1, maxh);\n        for (int i = 0; i < n; ++i) {\n            h[i] = value;\n        }\n    } else if (type == \"onePeak\") {\n        // Heights increase to a peak and then decrease\n        int peakPos = rnd.next(1, n - 2); // Peak cannot be first or last\n        int curr = 1;\n        for (int i = 0; i <= peakPos; ++i) {\n            h[i] = rnd.next(curr, maxh);\n            curr = h[i];\n        }\n        curr = h[peakPos];\n        for (int i = peakPos + 1; i < n; ++i) {\n            h[i] = rnd.next(1, curr);\n            curr = h[i];\n        }\n    } else if (type == \"valleys\") {\n        // Heights decrease to a minimum and then increase\n        int minPos = rnd.next(1, n - 2); // Minimum cannot be first or last\n        int curr = maxh;\n        for (int i = 0; i <= minPos; ++i) {\n            h[i] = rnd.next(1, curr);\n            curr = h[i];\n        }\n        curr = h[minPos];\n        for (int i = minPos + 1; i < n; ++i) {\n            h[i] = rnd.next(curr, maxh);\n            curr = h[i];\n        }\n    } else if (type == \"zigzag\") {\n        // Heights alternate between high and low\n        int low = 1;\n        int high = maxh;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                h[i] = rnd.next(low, high / 2);\n            } else {\n                h[i] = rnd.next(high / 2 + 1, high);\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, maxh);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output h_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", h[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxh = opt<int>(\"maxh\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        // Random heights between 1 and maxh\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, maxh);\n        }\n    } else if (type == \"sorted\") {\n        // Non-decreasing sequence\n        int curr = 1;\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(curr, maxh);\n            curr = h[i]; // Ensure non-decreasing\n        }\n    } else if (type == \"reverse\") {\n        // Non-increasing sequence\n        int curr = maxh;\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, curr);\n            curr = h[i]; // Ensure non-increasing\n        }\n    } else if (type == \"equal\") {\n        // All heights are equal\n        int value = rnd.next(1, maxh);\n        for (int i = 0; i < n; ++i) {\n            h[i] = value;\n        }\n    } else if (type == \"onePeak\") {\n        // Heights increase to a peak and then decrease\n        int peakPos = rnd.next(1, n - 2); // Peak cannot be first or last\n        int curr = 1;\n        for (int i = 0; i <= peakPos; ++i) {\n            h[i] = rnd.next(curr, maxh);\n            curr = h[i];\n        }\n        curr = h[peakPos];\n        for (int i = peakPos + 1; i < n; ++i) {\n            h[i] = rnd.next(1, curr);\n            curr = h[i];\n        }\n    } else if (type == \"valleys\") {\n        // Heights decrease to a minimum and then increase\n        int minPos = rnd.next(1, n - 2); // Minimum cannot be first or last\n        int curr = maxh;\n        for (int i = 0; i <= minPos; ++i) {\n            h[i] = rnd.next(1, curr);\n            curr = h[i];\n        }\n        curr = h[minPos];\n        for (int i = minPos + 1; i < n; ++i) {\n            h[i] = rnd.next(curr, maxh);\n            curr = h[i];\n        }\n    } else if (type == \"zigzag\") {\n        // Heights alternate between high and low\n        int low = 1;\n        int high = maxh;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                h[i] = rnd.next(low, high / 2);\n            } else {\n                h[i] = rnd.next(high / 2 + 1, high);\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, maxh);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output h_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", h[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type equal\n./gen -n 2 -type sorted\n./gen -n 2 -type reverse\n./gen -n 2 -type equal\n\n./gen -n 5 -type random\n./gen -n 5 -type sorted\n./gen -n 5 -type reverse\n./gen -n 5 -type equal\n./gen -n 5 -type onePeak\n./gen -n 5 -type valleys\n./gen -n 5 -type zigzag\n\n./gen -n 10 -type random\n./gen -n 10 -type sorted\n./gen -n 10 -type reverse\n./gen -n 10 -type onePeak\n./gen -n 10 -type valleys\n./gen -n 10 -type zigzag\n\n./gen -n 1000 -type random\n./gen -n 1000 -type sorted\n./gen -n 1000 -type reverse\n./gen -n 1000 -type equal\n\n./gen -n 4999 -type random\n./gen -n 5000 -type random\n./gen -n 5000 -type sorted\n./gen -n 5000 -type reverse\n./gen -n 5000 -type equal\n\n./gen -n 5000 -maxh 1 -type equal\n./gen -n 5000 -maxh 100000 -type equal\n./gen -n 5000 -maxh 1 -type random\n./gen -n 5000 -maxh 100000 -type random\n\n./gen -n 5000 -maxh 1 -type sorted\n./gen -n 5000 -maxh 1 -type reverse\n\n./gen -n 5000 -type zigzag\n./gen -n 5000 -type onePeak\n./gen -n 5000 -type valleys\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:26.104300",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "229/E",
      "title": "E. Gifts",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 1000) — the number of the old man's wishes and the number of distinct names in the goldfish's list, correspondingly. Then m lines follow: the i-th line first contains integer ki (ki > 0) — the number of distinct prices of gifts with the i-th name, then ki distinct space-separated integers cij (1 ≤ cij ≤ 109), the gifts' prices. It is guaranteed that the sum of all ki doesn't exceed 1000. It is guaranteed that n is not greater than the total number of the gifts.",
      "output_spec": "OutputOn a single line print one real number — the probability of getting n most valuable gifts. The answer will be considered correct if its absolute or relative error does not exceed 10 - 9.",
      "sample_tests": "ExamplesInputCopy3 13 10 20 30OutputCopy1.000000000InputCopy3 21 404 10 20 30 40OutputCopy0.166666667",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 1000) — the number of the old man's wishes and the number of distinct names in the goldfish's list, correspondingly. Then m lines follow: the i-th line first contains integer ki (ki > 0) — the number of distinct prices of gifts with the i-th name, then ki distinct space-separated integers cij (1 ≤ cij ≤ 109), the gifts' prices. It is guaranteed that the sum of all ki doesn't exceed 1000. It is guaranteed that n is not greater than the total number of the gifts.\n\nOutputOn a single line print one real number — the probability of getting n most valuable gifts. The answer will be considered correct if its absolute or relative error does not exceed 10 - 9.\n\nInputCopy3 13 10 20 30OutputCopy1.000000000InputCopy3 21 404 10 20 30 40OutputCopy0.166666667\n\nInputCopy3 13 10 20 30\n\nOutputCopy1.000000000\n\nInputCopy3 21 404 10 20 30 40\n\nOutputCopy0.166666667",
      "solutions": [
        {
          "title": "Codeforces Round #142 - Codeforces",
          "content": "Hello everyone!Codeforces Round #142 will be held today at 19:30 in Moscow time, and it will take place in both divisions.The authors of the problems are me, Evgeny Vihrov (gen), and Andrey Vihrov (andreyv). Both of us are students of the Faculty of Computing in the University of Latvia. This is our very first contest on Codeforces!Big thanks for the help in preparing the contest go to Gerald Agapov (Gerald), and to Maria Belova (Delinur) — for translating the problem statements in English. Also thanks to Mikhail Mirzayanov (MikeMirzayanov) for the Polygon system, which we found to be great for preparing contest problems.We hope that each participant will be able find a problem to match his taste. Please, consider reading all the problems!We wish you an exciting round!UPD1: The score distribution will be dynamic. The problems will be sorted in order of expected increasing difficulty.UPD2: Due to the technical problems the contest was extended by 5 minutes. We are sorry for the inconvinience.UPD3: The analysis of the contest is available. Enjoy!The round is over! 5 contestants solved all the problems in division 1, and in division 2 only the top four contestants solved all the tasks. Congratulations to the winners!Div I YuukaKazami peter50216 kelvin takaramono Martin Div II coquelicot llj_bash kb. niukuo Petar",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5432",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1330
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces",
          "content": "Div. 2 A — DragonsObserve that if Kirito fights a dragon whose strength is less than Kirito's strength, then Kirito does not lose anything — in fact, he even gains a nonnegative strength increase. Taking note of this, let's for each step choose some dragon whose strength is less than Kirito's current strength, and fight it. After performing some amount of these steps we'll eventually end up in one of these two situations: either all dragons are slain (then the answer is \"YES\"), or only dragons whose strength is not less than Kirito's strength remain (then the answer is \"NO\"). On each step we can choose a suitable dragon to fight either by searching through all dragons or by sorting the dragons by strength in non-descending order in advance.The complexity of the solution is O(n2) or . Sample solution: http://pastie.org/4897164 (archived copy)  Div. 2 B — T-primesIt can be shown that only squares of prime numbers are T-primes, and that there are not too many of them — as many as there are prime numbers not greater than . Precompute these numbers (using, for example, the sieve of Eratosthenes) and store them in an array or an std::set, then we can answer each query by simply checking whether the number in question is amongst the precomputed numbers.The complexity of the solution is linear in relation to n — or , where d = 1012 (one can also get a tighter bound). Sample solution: http://pastie.org/4897166 (archived copy)Div. 1 A — ShiftsLet's compute the minimum number of operations needed to get all 1s in each of the m columns. For this, traverse each row twice — one time to the left and one time to the right, recording the index of the nearest cell with 1 (in corresponding direction) for each column in this row. Then the number of operations for any particular column is the sum of the computed values over all rows. In turn, the answer to the problem is the minimal value of these sums.The complexity of the solution is O(nm). Sample solution: http://pastie.org/4897169 (archived copy)Div. 1 B — PlanetsObserve that when we visit some planet, the best strategy is to arrive as early as we can and then wait for the nearest free moment of time to move further. Hence this problem can be solved with the Dijkstra's algorithm by slightly altering the definition of a shortest distance. When we process a planet (meaning that we already know the minimum time needed to reach it), we need to check the array of arrival times for this planet and find the first moment of time in which we can leave this planet — this will be the distance that we will be adding to outgoing paths from this planet. It's clear that we will traverse each array of arrival times no more than once. Additionally, one must pay attention to these cases: when a traveller arrives to planet 1 at time 0 (then Jack has to wait) and when a traveller arrives to planet n at the same time as Jack (then Jack needs not to wait).The complexity of the solution — . Sample solution: http://pastie.org/4897171 (archived copy)Div. 1 C — TrianglesLet's call Alice's edges simply edges, and Bob's edges the antiedges. For each edge pair of the initial complete graph that pass through the same vertices, assign a weight: for each pair of edges the weight +2, for each pair of edge and antiedge −1 and for each pair of antiedges +2. Now calculate the sum of all the weights. Observe that each Alice's or Bob's triangle adds exactly +6 to the sum, and each combination of three vertices that do not form the triangle in any of the two graphs adds exactly 0 to the sum. The sum itself is calculated by iterating over all vertices and adding the total weight of all the edge pairs that pass through this vertex. If the degree of the vertex is d, then we should add d(d - 1) - d(n - d - 1) + (n - d - 1)(n - d - 2) to the final sum. Since each triangle adds +6 to the sum, then the answer is equal to the sum divided by 6.The complexity of the solution is O(n + m). Sample solution: http://pastie.org/4897512 (archived copy)Div. 1 D — TowersLet's calculate the dynamics d[i][k] — the minimal possible height of the last tower that we can obtain by merging the first i left towers into at least k towers. Assume we already have calculated the dynamics' values for the first i towers. Now we iterate over the all possible tower intervals [i + 1;j]; say the sum in the pending interval is equal to s. Now we find the greatest k such that d[i][k] is not greater than s. Then we update the value of d[j][k+1] to the minimum of s and d[j][k+1]. Notice that when k increases the values d[i][k] do not decrease. Because of that we can iterate over intervals in the decreasing value of j, and corresponding k can be found using a single pointer over values of d[i][k].When we arrive in the position j during the dynamics, some of the d[j][k] values are updated, but some are still not. Using the same observation that along with the increasing of k the values d[j][k] do not decrease as well, we can make a single run over the values of k in the decreasing order and update the dynamics' values as follows: d[j][k] := min(d[j][k], d[j][k+1]). This is done in the beginning of the dynamics' iteration.In the end we can find the greatest k for which there exists an answer among the values of d[n][k]. The answer to the problem then is n - k.The complexity of the solution is O(n2). Sample solution: http://pastie.org/4897515 (archived copy)Div. 1 E — GiftsFirst let's establish some facts that we will use in the solution. With how much probability can the fisherman get a particular set of gifts, among which there are ai gifts of i-th name? In total there are such sets, since there are exactly subsets of gifts with i-th name of size ai, and two different names are independent during the gold fish's choice. Then the described particular set of gifts we can get with the probability of , by asking ai gifts of i-th name.Now we know the probability p of obtaining one particular gift set A. Now observe that from p we can calculate the probabiltity p' of obtaining the set A along with some one other gift of x-th name in constant time. Say there are already ax elements of x-th name in A. Using the formula from the first paragraph, we can deduce that: Let's solve the main problem now. We sort all the gifts in descending order of their prices. It is clear that the fisherman will definitely ask the names of all the gifts among the first n ones whose prices are not equal to the price of the n-th gift in the list. Let's say that this set of gifts is the base, and it has b elements. Then there is still n - b unchosen gifts, and we know that all of them will have the price equal to the price of the n-th gift in the list. Say the price of the n-th gift is d, and there are exactly s gifts with the price d (keep in mind that each of them has a different name); also call these gifts dubious. We can also deduce that the fisherman can make different decisions, where l = n - b.So now we have some s dubious gifts with the price of d; let's enumerate them in any order. We calculate the dynamics f(x, y) — the cumulative probability of obtaining n most valuable gifts, if there are x chosen from the first y in the list. It is clear that f(0, 0) = p, and f(l, s) contains the answer to the problem. Using the coefficients we have deduced earlier, we get two transitions in the dynamics: , if we add y + 1-th dubious gift to the set of x chosen among the first y dubious gifts; , otherwise, if do not put the y + 1-th dubious gift. This dynamics can be computed in O(t2) time, where t is the total number of gifts. The complexity of the solution is . Sample solution: http://pastie.org/4897519 (archived copy)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7684
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #142 - Codeforces - Code 1",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 2",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 3",
          "code": "\\_dangerous\\_",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 4",
          "code": "double temp = pow((double)n, 0.5);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 5",
          "code": "long long square_root = (long long)(temp);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces - Code 1",
          "code": "d[j][k] := min(d[j][k], d[j][k+1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    int total_k = 0;\n    for (int i = 0; i < m; ++i) {\n        int ki = inf.readInt(1, 1000, \"ki\");\n        total_k += ki;\n        ensuref(total_k <= 1000, \"Sum of all ki must not exceed 1000\");\n        inf.readSpace();\n        vector<int> c = inf.readInts(ki, 1, 1000000000, \"cij\");\n        inf.readEoln();\n        set<int> c_set(c.begin(), c.end());\n        ensuref((int)c_set.size() == ki, \"Prices cij must be distinct within the same name\");\n    }\n    ensuref(n <= total_k, \"n must not be greater than total number of gifts\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    int total_k = 0;\n    for (int i = 0; i < m; ++i) {\n        int ki = inf.readInt(1, 1000, \"ki\");\n        total_k += ki;\n        ensuref(total_k <= 1000, \"Sum of all ki must not exceed 1000\");\n        inf.readSpace();\n        vector<int> c = inf.readInts(ki, 1, 1000000000, \"cij\");\n        inf.readEoln();\n        set<int> c_set(c.begin(), c.end());\n        ensuref((int)c_set.size() == ki, \"Prices cij must be distinct within the same name\");\n    }\n    ensuref(n <= total_k, \"n must not be greater than total number of gifts\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    int total_k = 0;\n    for (int i = 0; i < m; ++i) {\n        int ki = inf.readInt(1, 1000, \"ki\");\n        total_k += ki;\n        ensuref(total_k <= 1000, \"Sum of all ki must not exceed 1000\");\n        inf.readSpace();\n        vector<int> c = inf.readInts(ki, 1, 1000000000, \"cij\");\n        inf.readEoln();\n        set<int> c_set(c.begin(), c.end());\n        ensuref((int)c_set.size() == ki, \"Prices cij must be distinct within the same name\");\n    }\n    ensuref(n <= total_k, \"n must not be greater than total number of gifts\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    int sum_k_max = 1000;\n    int c_max = int(1e9);\n    \n    if (type == \"random\") {\n        // Generate random ki such that sum of ki ≤ sum_k_max\n        vector<int> ki(m);\n        int remaining = min(sum_k_max, sum_k_max);\n        for (int i = 0; i < m; ++i) {\n            ki[i] = rnd.next(1, min(remaining - (m - i - 1), 1000));\n            remaining -= ki[i];\n        }\n        // Adjust n if necessary\n        int total_ki = accumulate(ki.begin(), ki.end(), 0);\n        n = min(n, total_ki);\n        \n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            set<int> prices;\n            while (int(prices.size()) < ki[i]) {\n                int price = rnd.next(1, c_max);\n                // Ensure no duplicates in prices for this name\n                prices.insert(price);\n            }\n            for (int price : prices) {\n                printf(\" %d\", price);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"max_prices_same\") {\n        // All gifts have the same maximum price\n        int price = c_max;\n        vector<int> ki(m, 1);\n        int total_ki = m;\n        if (total_ki > sum_k_max) {\n            fprintf(stderr, \"Error: sum of ki exceeds maximum allowed (%d)\\n\", sum_k_max);\n            return 1;\n        }\n        n = min(n, total_ki);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d\\n\", ki[i], price);\n        }\n    }\n    else if (type == \"min_prices_same\") {\n        // All gifts have the same minimum price\n        int price = 1;\n        vector<int> ki(m, 1);\n        int total_ki = m;\n        if (total_ki > sum_k_max) {\n            fprintf(stderr, \"Error: sum of ki exceeds maximum allowed (%d)\\n\", sum_k_max);\n            return 1;\n        }\n        n = min(n, total_ki);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d\\n\", ki[i], price);\n        }\n    }\n    else if (type == \"max_ki\") {\n        // Each ki is maximum possible to reach sum_k_max\n        int ki_val = sum_k_max / m;\n        vector<int> ki(m, ki_val);\n        int total_ki = ki_val * m;\n        int remainder = sum_k_max - total_ki;\n        for (int i = 0; i < remainder; ++i) {\n            ki[i]++;\n        }\n        total_ki = accumulate(ki.begin(), ki.end(), 0);\n        n = min(n, total_ki);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            set<int> prices;\n            while (int(prices.size()) < ki[i]) {\n                int price = rnd.next(1, c_max);\n                prices.insert(price);\n            }\n            for (int price : prices) {\n                printf(\" %d\", price);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"n_equals_total\") {\n        // n equals total number of gifts\n        vector<int> ki(m);\n        int remaining = sum_k_max;\n        for (int i = 0; i < m; ++i) {\n            ki[i] = rnd.next(1, min(remaining - (m - i - 1), 1000));\n            remaining -= ki[i];\n        }\n        int total_ki = accumulate(ki.begin(), ki.end(), 0);\n        n = total_ki;\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            set<int> prices;\n            while (int(prices.size()) < ki[i]) {\n                int price = rnd.next(1, c_max);\n                prices.insert(price);\n            }\n            for (int price : prices) {\n                printf(\" %d\", price);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"n_is_one\") {\n        // n is 1\n        n = 1;\n        vector<int> ki(m, 1);\n        int total_ki = m;\n        if (total_ki > sum_k_max) {\n            fprintf(stderr, \"Error: sum of ki exceeds maximum allowed (%d)\\n\", sum_k_max);\n            return 1;\n        }\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            int price = rnd.next(1, c_max);\n            printf(\" %d\\n\", price);\n        }\n    }\n    else if (type == \"all_cij_same\") {\n        // All prices are the same\n        int price = rnd.next(1, c_max);\n        vector<int> ki(m);\n        int remaining = sum_k_max;\n        for (int i = 0; i < m; ++i) {\n            ki[i] = rnd.next(1, min(remaining - (m - i - 1), 1000));\n            remaining -= ki[i];\n        }\n        int total_ki = accumulate(ki.begin(), ki.end(), 0);\n        n = min(n, total_ki);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            for (int j = 0; j < ki[i]; ++j) {\n                printf(\" %d\", price);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"max_price_range\") {\n        // Prices range from c_max - 1000 to c_max\n        vector<int> ki(m);\n        int remaining = sum_k_max;\n        for (int i = 0; i < m; ++i) {\n            ki[i] = rnd.next(1, min(remaining - (m - i - 1), 1000));\n            remaining -= ki[i];\n        }\n        int total_ki = accumulate(ki.begin(), ki.end(), 0);\n        n = min(n, total_ki);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            set<int> prices;\n            while (int(prices.size()) < ki[i]) {\n                int price = rnd.next(c_max - 1000, c_max);\n                prices.insert(price);\n            }\n            for (int price : prices) {\n                printf(\" %d\", price);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else {\n        fprintf(stderr, \"Error: Unknown type \\\"%s\\\"\\n\", type.c_str());\n        return 1;\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    int sum_k_max = 1000;\n    int c_max = int(1e9);\n    \n    if (type == \"random\") {\n        // Generate random ki such that sum of ki ≤ sum_k_max\n        vector<int> ki(m);\n        int remaining = min(sum_k_max, sum_k_max);\n        for (int i = 0; i < m; ++i) {\n            ki[i] = rnd.next(1, min(remaining - (m - i - 1), 1000));\n            remaining -= ki[i];\n        }\n        // Adjust n if necessary\n        int total_ki = accumulate(ki.begin(), ki.end(), 0);\n        n = min(n, total_ki);\n        \n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            set<int> prices;\n            while (int(prices.size()) < ki[i]) {\n                int price = rnd.next(1, c_max);\n                // Ensure no duplicates in prices for this name\n                prices.insert(price);\n            }\n            for (int price : prices) {\n                printf(\" %d\", price);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"max_prices_same\") {\n        // All gifts have the same maximum price\n        int price = c_max;\n        vector<int> ki(m, 1);\n        int total_ki = m;\n        if (total_ki > sum_k_max) {\n            fprintf(stderr, \"Error: sum of ki exceeds maximum allowed (%d)\\n\", sum_k_max);\n            return 1;\n        }\n        n = min(n, total_ki);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d\\n\", ki[i], price);\n        }\n    }\n    else if (type == \"min_prices_same\") {\n        // All gifts have the same minimum price\n        int price = 1;\n        vector<int> ki(m, 1);\n        int total_ki = m;\n        if (total_ki > sum_k_max) {\n            fprintf(stderr, \"Error: sum of ki exceeds maximum allowed (%d)\\n\", sum_k_max);\n            return 1;\n        }\n        n = min(n, total_ki);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d %d\\n\", ki[i], price);\n        }\n    }\n    else if (type == \"max_ki\") {\n        // Each ki is maximum possible to reach sum_k_max\n        int ki_val = sum_k_max / m;\n        vector<int> ki(m, ki_val);\n        int total_ki = ki_val * m;\n        int remainder = sum_k_max - total_ki;\n        for (int i = 0; i < remainder; ++i) {\n            ki[i]++;\n        }\n        total_ki = accumulate(ki.begin(), ki.end(), 0);\n        n = min(n, total_ki);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            set<int> prices;\n            while (int(prices.size()) < ki[i]) {\n                int price = rnd.next(1, c_max);\n                prices.insert(price);\n            }\n            for (int price : prices) {\n                printf(\" %d\", price);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"n_equals_total\") {\n        // n equals total number of gifts\n        vector<int> ki(m);\n        int remaining = sum_k_max;\n        for (int i = 0; i < m; ++i) {\n            ki[i] = rnd.next(1, min(remaining - (m - i - 1), 1000));\n            remaining -= ki[i];\n        }\n        int total_ki = accumulate(ki.begin(), ki.end(), 0);\n        n = total_ki;\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            set<int> prices;\n            while (int(prices.size()) < ki[i]) {\n                int price = rnd.next(1, c_max);\n                prices.insert(price);\n            }\n            for (int price : prices) {\n                printf(\" %d\", price);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"n_is_one\") {\n        // n is 1\n        n = 1;\n        vector<int> ki(m, 1);\n        int total_ki = m;\n        if (total_ki > sum_k_max) {\n            fprintf(stderr, \"Error: sum of ki exceeds maximum allowed (%d)\\n\", sum_k_max);\n            return 1;\n        }\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            int price = rnd.next(1, c_max);\n            printf(\" %d\\n\", price);\n        }\n    }\n    else if (type == \"all_cij_same\") {\n        // All prices are the same\n        int price = rnd.next(1, c_max);\n        vector<int> ki(m);\n        int remaining = sum_k_max;\n        for (int i = 0; i < m; ++i) {\n            ki[i] = rnd.next(1, min(remaining - (m - i - 1), 1000));\n            remaining -= ki[i];\n        }\n        int total_ki = accumulate(ki.begin(), ki.end(), 0);\n        n = min(n, total_ki);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            for (int j = 0; j < ki[i]; ++j) {\n                printf(\" %d\", price);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"max_price_range\") {\n        // Prices range from c_max - 1000 to c_max\n        vector<int> ki(m);\n        int remaining = sum_k_max;\n        for (int i = 0; i < m; ++i) {\n            ki[i] = rnd.next(1, min(remaining - (m - i - 1), 1000));\n            remaining -= ki[i];\n        }\n        int total_ki = accumulate(ki.begin(), ki.end(), 0);\n        n = min(n, total_ki);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            printf(\"%d\", ki[i]);\n            set<int> prices;\n            while (int(prices.size()) < ki[i]) {\n                int price = rnd.next(c_max - 1000, c_max);\n                prices.insert(price);\n            }\n            for (int price : prices) {\n                printf(\" %d\", price);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else {\n        fprintf(stderr, \"Error: Unknown type \\\"%s\\\"\\n\", type.c_str());\n        return 1;\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type n_is_one\n./gen -n 1 -m 1000 -type n_is_one\n./gen -n 2 -m 2 -type random\n./gen -n 1000 -m 1 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type max_ki\n./gen -n 500 -m 500 -type max_ki\n./gen -n 500 -m 1000 -type max_ki\n./gen -n 1000 -m 100 -type max_prices_same\n./gen -n 1000 -m 100 -type min_prices_same\n./gen -n 1000 -m 100 -type all_cij_same\n./gen -n 1000 -m 50 -type max_price_range\n./gen -n 1000 -m 1 -type all_cij_same\n./gen -n 1000 -m 500 -type n_equals_total\n./gen -n 1000 -m 1000 -type n_equals_total\n./gen -n 999 -m 1000 -type random\n./gen -n 1000 -m 2 -type random\n./gen -n 1000 -m 2 -type all_cij_same\n./gen -n 1000 -m 1 -type random\n./gen -n 999 -m 1 -type random\n./gen -n 1 -m 1000 -type random\n./gen -n 1000 -m 1000 -type all_cij_same\n./gen -n 1000 -m 1000 -type max_prices_same\n./gen -n 1000 -m 1000 -type min_prices_same\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 3 -m 3 -type random\n./gen -n 10 -m 5 -type random\n./gen -n 100 -m 10 -type random\n./gen -n 500 -m 50 -type random\n./gen -n 1000 -m 500 -type random\n./gen -n 1000 -m 1000 -type all_cij_same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:27.715730",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "23/A",
      "title": "A. You're Given a String...",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.",
      "output_spec": "OutputOutput one number — length of the longest substring that can be met in the string at least twice.",
      "sample_tests": "ExamplesInputCopyabcdOutputCopy0InputCopyababaOutputCopy3InputCopyzzzOutputCopy2",
      "description": "A. You're Given a String...\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.\n\nOutputOutput one number — length of the longest substring that can be met in the string at least twice.\n\nInputCopyabcdOutputCopy0InputCopyababaOutputCopy3InputCopyzzzOutputCopy2\n\nInputCopyabcd\n\nOutputCopy0\n\nInputCopyababa\n\nOutputCopy3\n\nInputCopyzzz\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #23 - Codeforces",
          "content": "Hi everybodyToday the author of the majority of problems is Dmitry Zhukov, many thanks to him for this. Also I want to thank Mike Mirzayanov for choosing problems for the contest and organizing it and Julia Satushina for the translation of the statements.Good luck! UPD: ProblemsFinal standingsWinner: saeedreza.seddighin",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/528",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 321
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces",
          "content": "A. You're given a string...Iterate over all substrings, starting with the longest ones, and for each one count the number of appearances. The complexity is O(L4) with a small multiplicative constant. B. PartyIt's clear that at least one person (the one with the least number of friends) will have to leave. We claim that at least two persons will leave. Indeed, suppose that only one person left, and he had d friends. Then all other people had more than d friends before he left, and after that they had less than d + 1 friends, i.e. not more than d. So, his leaving influenced the number of friends for every other person, which means that he was friends with everyone: d = N - 1. But he has fewer friends than everyone — a contradiction.So, the answer is not more than N - 2. We'll prove that it's possible for N - 2 people to stay (of course, if N > 1). The graph of friendship will be the following: take a complete graph on N vertices and delete one edge. Then the degrees of two vertices equal N - 2, and other degrees equal N - 1. After the first two vertices are removed, we have a complete graph on N - 2 vertices, and all degrees equal N - 3, which means that no one else will leave.C. Oranges and ApplesSort the boxes in increasing number of oranges. Count the total number of apples in boxes with odd and even numbers. If the boxes with odd numbers contain at least half of all apples, choose them (there are exactly N boxes with odd numbers). If the boxes with even numbers contain at least half of all apples, take them and the last box (which contains the largest number of oranges). It's easy to see that in both cases the conditions of the task are fulfilled.D. TetragonLet ABCD be the quadrangle that we're looking for, and K, L, and M be the middle points of equal sides AB, BC and CD, correspondingly. Let M' be the point symmetric to M with respect to L. Triangles BLM' and CLM are equal by two sides and angle, so BM' = CM = BL = BK, i. e. B is the circumcenter of the triangle KLM'. Knowing B, we can reconstruct the whole quadrangle, using the symmetries with respect to the points K, L, and M, and then check whether it satisfies all conditions.Note that we don't know which of the given points is L, so we need to check all 3 cases.E. TreeLemma. In one of optimal solutions there are no simple paths of length 3.Proof. We can remove the middle edge from such a path. The connected component will split into two components of sizes a and b, where a ≥ 2, b ≥ 2, and therefore ab ≥ a + b.We'll root the tree and calculate recursively the numbers hv = the solution of the problem for the subtree with the root v, and fv = the product of hu for all children of v. If v is a leaf, then hv = fv = 1.We show how to calculate hv, given the solution for all subtrees of v. Consider the connected component of v in an optimal solution. It follows from the lemma that the component has one of the following types:1. The single vertex v.2. The vertex v and several children of v.3. The vertex v, one child of v — w, and several children of w.In the first case the result of the game is fv.In the second case it equals Πfi · Πhj · k = Π(fi / hi) · fv · k, where i iterates over children belonging to the connected component, j iterates over the rest children, and k is the size of the component. Since we want to maximize the result, we're interested in children with the largest value of fi / hi. Therefore, the largest possible result in this case equals the maximum value of Πi ≤ s  (fi / hi) · fv · (s + 1), where it's supposed that the children are sorted in descending order of fi / hi.In the third case we can use a similar reasoning for every child w. The best result will be the maximum of the expression fv · (fw / hw) · Πi ≤ s (fi / hi) · (s + 2) as w iterates over children of v, and s iterates from 1 to the number of children of w; note that the children of w have already been sorted in the previous step.Therefore, the number of operations necessary to calculate fv is proportional to the total number of children and grandchildren of v, which is less than n. The complexity of the algorithm, then, is O(n2) (ignoring operations with long numbers).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/530",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4177
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 1",
          "code": "0:  []          leaf\n  1:  [[]]        two-chain\n  2:  [[][]]      1-fork-2\n  3:  [[][][]]    1-fork-3\n  k:  [[]...[]]   1-fork-k\n  -1: [[[]]]      three-chain\n  -2: [[[][]]]    1-1-fork-2\n  -3: [[[][][]]]  1-1-fork-3\n  -k: [[[]...[]]] 1-1-fork-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 2",
          "code": "0:  []          leaf\n  1:  [[]]        two-chain\n  2:  [[][]]      1-fork-2\n  3:  [[][][]]    1-fork-3\n  k:  [[]...[]]   1-fork-k\n  -1: [[[]]]      three-chain\n  -2: [[[][]]]    1-1-fork-2\n  -3: [[[][][]]]  1-1-fork-3\n  -k: [[[]...[]]] 1-1-fork-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 3",
          "code": "c0: number of 0s (leaves).\ncp: list of all positive cases (1-fork-k).\ncn: list of all negative cases (1-1-fork-k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 4",
          "code": "c0: number of 0s (leaves).\ncp: list of all positive cases (1-fork-k).\ncn: list of all negative cases (1-1-fork-k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 5",
          "code": "[[]] means a two-chain.\n[[[]]] means a three chain.\n[[][]] means a parent with two children.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 6",
          "code": "[[]] means a two-chain.\n[[[]]] means a three chain.\n[[][]] means a parent with two children.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,100}\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,100}\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,100}\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 0);\n\n    string s;\n\n    if (n < 1 || n > 100) {\n        fprintf(stderr, \"n must be between 1 and 100\\n\");\n        return 1;\n    }\n\n    if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"same_char\") {\n        char c = (char)('a' + rnd.next(26));\n        s = string(n, c);\n    } else if (type == \"non_repeated\") {\n        if (n > 26) {\n            fprintf(stderr, \"Cannot generate non-repeated string longer than 26\\n\");\n            return 1;\n        }\n        vector<char> letters(26);\n        for (int i = 0; i < 26; ++i)\n            letters[i] = 'a' + i;\n        shuffle(letters.begin(), letters.end());\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += letters[i];\n    } else if (type == \"repeated_substring\") {\n        if (k <= 0 || k > n/2) {\n            fprintf(stderr, \"Invalid value of k for repeated_substring type. Must be k > 0 and k <= n/2\\n\");\n            return 1;\n        }\n        string sub;\n        sub.resize(k);\n        for (int i = 0; i < k; ++i)\n            sub[i] = (char)('a' + rnd.next(26));\n        int remaining = n - 2*k;\n        if (remaining < 0)\n            remaining = 0;\n        s = sub;\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n        s += sub;\n    } else if (type == \"overlapping_substring\") {\n        if (k <= 1 || k > n) {\n            fprintf(stderr, \"Invalid value of k for overlapping_substring type. Must be k > 1 and k <= n\\n\");\n            return 1;\n        }\n        string sub;\n        sub.resize(k);\n        for (int i = 0; i < k; ++i)\n            sub[i] = (char)('a' + rnd.next(26));\n        int overlap = k - 1; // Overlap size\n        s = sub;\n        while ((int)s.size() < n) {\n            s += sub.substr(overlap);\n        }\n        s = s.substr(0, n);\n    } else if (type == \"palindromic\") {\n        s.resize(n);\n        for (int i = 0; i < n/2; ++i) {\n            char c = (char)('a' + rnd.next(26));\n            s[i] = c;\n            s[n - i - 1] = c;\n        }\n        if (n % 2 == 1)\n            s[n/2] = (char)('a' + rnd.next(26));\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the string s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 0);\n\n    string s;\n\n    if (n < 1 || n > 100) {\n        fprintf(stderr, \"n must be between 1 and 100\\n\");\n        return 1;\n    }\n\n    if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"same_char\") {\n        char c = (char)('a' + rnd.next(26));\n        s = string(n, c);\n    } else if (type == \"non_repeated\") {\n        if (n > 26) {\n            fprintf(stderr, \"Cannot generate non-repeated string longer than 26\\n\");\n            return 1;\n        }\n        vector<char> letters(26);\n        for (int i = 0; i < 26; ++i)\n            letters[i] = 'a' + i;\n        shuffle(letters.begin(), letters.end());\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += letters[i];\n    } else if (type == \"repeated_substring\") {\n        if (k <= 0 || k > n/2) {\n            fprintf(stderr, \"Invalid value of k for repeated_substring type. Must be k > 0 and k <= n/2\\n\");\n            return 1;\n        }\n        string sub;\n        sub.resize(k);\n        for (int i = 0; i < k; ++i)\n            sub[i] = (char)('a' + rnd.next(26));\n        int remaining = n - 2*k;\n        if (remaining < 0)\n            remaining = 0;\n        s = sub;\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n        s += sub;\n    } else if (type == \"overlapping_substring\") {\n        if (k <= 1 || k > n) {\n            fprintf(stderr, \"Invalid value of k for overlapping_substring type. Must be k > 1 and k <= n\\n\");\n            return 1;\n        }\n        string sub;\n        sub.resize(k);\n        for (int i = 0; i < k; ++i)\n            sub[i] = (char)('a' + rnd.next(26));\n        int overlap = k - 1; // Overlap size\n        s = sub;\n        while ((int)s.size() < n) {\n            s += sub.substr(overlap);\n        }\n        s = s.substr(0, n);\n    } else if (type == \"palindromic\") {\n        s.resize(n);\n        for (int i = 0; i < n/2; ++i) {\n            char c = (char)('a' + rnd.next(26));\n            s[i] = c;\n            s[n - i - 1] = c;\n        }\n        if (n % 2 == 1)\n            s[n/2] = (char)('a' + rnd.next(26));\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the string s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n\n./gen -n 1 -type same_char\n./gen -n 10 -type same_char\n./gen -n 100 -type same_char\n\n./gen -n 1 -type non_repeated\n./gen -n 10 -type non_repeated\n./gen -n 26 -type non_repeated\n\n./gen -n 2 -type repeated_substring -k 1\n./gen -n 10 -type repeated_substring -k 2\n./gen -n 100 -type repeated_substring -k 10\n\n./gen -n 3 -type overlapping_substring -k 2\n./gen -n 10 -type overlapping_substring -k 3\n./gen -n 100 -type overlapping_substring -k 20\n\n./gen -n 5 -type palindromic\n./gen -n 10 -type palindromic\n./gen -n 100 -type palindromic\n\n./gen -n 25 -type repeated_substring -k 12\n./gen -n 50 -type repeated_substring -k 25\n./gen -n 75 -type repeated_substring -k 37\n\n./gen -n 50 -type overlapping_substring -k 25\n./gen -n 99 -type overlapping_substring -k 50\n\n./gen -n 26 -type non_repeated\n./gen -n 26 -type random\n\n./gen -n 1 -type random\n./gen -n 100 -type palindromic\n\n./gen -n 40 -type overlapping_substring -k 20\n./gen -n 40 -type repeated_substring -k 20\n\n./gen -n 100 -type same_char\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:29.750774",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "23/B",
      "title": "B. Party",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains one number t — amount of tests (1 ≤ t ≤ 105). Each of the following t lines contains one integer number n (1 ≤ n ≤ 105).",
      "output_spec": "OutputFor each test output in a separate line one number — the maximum amount of people that could stay in the end.",
      "sample_tests": "ExamplesInputCopy13OutputCopy1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains one number t — amount of tests (1 ≤ t ≤ 105). Each of the following t lines contains one integer number n (1 ≤ n ≤ 105).\n\nOutputFor each test output in a separate line one number — the maximum amount of people that could stay in the end.\n\nInputCopy13OutputCopy1\n\nInputCopy13\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #23 - Codeforces",
          "content": "Hi everybodyToday the author of the majority of problems is Dmitry Zhukov, many thanks to him for this. Also I want to thank Mike Mirzayanov for choosing problems for the contest and organizing it and Julia Satushina for the translation of the statements.Good luck! UPD: ProblemsFinal standingsWinner: saeedreza.seddighin",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/528",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 321
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces",
          "content": "A. You're given a string...Iterate over all substrings, starting with the longest ones, and for each one count the number of appearances. The complexity is O(L4) with a small multiplicative constant. B. PartyIt's clear that at least one person (the one with the least number of friends) will have to leave. We claim that at least two persons will leave. Indeed, suppose that only one person left, and he had d friends. Then all other people had more than d friends before he left, and after that they had less than d + 1 friends, i.e. not more than d. So, his leaving influenced the number of friends for every other person, which means that he was friends with everyone: d = N - 1. But he has fewer friends than everyone — a contradiction.So, the answer is not more than N - 2. We'll prove that it's possible for N - 2 people to stay (of course, if N > 1). The graph of friendship will be the following: take a complete graph on N vertices and delete one edge. Then the degrees of two vertices equal N - 2, and other degrees equal N - 1. After the first two vertices are removed, we have a complete graph on N - 2 vertices, and all degrees equal N - 3, which means that no one else will leave.C. Oranges and ApplesSort the boxes in increasing number of oranges. Count the total number of apples in boxes with odd and even numbers. If the boxes with odd numbers contain at least half of all apples, choose them (there are exactly N boxes with odd numbers). If the boxes with even numbers contain at least half of all apples, take them and the last box (which contains the largest number of oranges). It's easy to see that in both cases the conditions of the task are fulfilled.D. TetragonLet ABCD be the quadrangle that we're looking for, and K, L, and M be the middle points of equal sides AB, BC and CD, correspondingly. Let M' be the point symmetric to M with respect to L. Triangles BLM' and CLM are equal by two sides and angle, so BM' = CM = BL = BK, i. e. B is the circumcenter of the triangle KLM'. Knowing B, we can reconstruct the whole quadrangle, using the symmetries with respect to the points K, L, and M, and then check whether it satisfies all conditions.Note that we don't know which of the given points is L, so we need to check all 3 cases.E. TreeLemma. In one of optimal solutions there are no simple paths of length 3.Proof. We can remove the middle edge from such a path. The connected component will split into two components of sizes a and b, where a ≥ 2, b ≥ 2, and therefore ab ≥ a + b.We'll root the tree and calculate recursively the numbers hv = the solution of the problem for the subtree with the root v, and fv = the product of hu for all children of v. If v is a leaf, then hv = fv = 1.We show how to calculate hv, given the solution for all subtrees of v. Consider the connected component of v in an optimal solution. It follows from the lemma that the component has one of the following types:1. The single vertex v.2. The vertex v and several children of v.3. The vertex v, one child of v — w, and several children of w.In the first case the result of the game is fv.In the second case it equals Πfi · Πhj · k = Π(fi / hi) · fv · k, where i iterates over children belonging to the connected component, j iterates over the rest children, and k is the size of the component. Since we want to maximize the result, we're interested in children with the largest value of fi / hi. Therefore, the largest possible result in this case equals the maximum value of Πi ≤ s  (fi / hi) · fv · (s + 1), where it's supposed that the children are sorted in descending order of fi / hi.In the third case we can use a similar reasoning for every child w. The best result will be the maximum of the expression fv · (fw / hw) · Πi ≤ s (fi / hi) · (s + 2) as w iterates over children of v, and s iterates from 1 to the number of children of w; note that the children of w have already been sorted in the previous step.Therefore, the number of operations necessary to calculate fv is proportional to the total number of children and grandchildren of v, which is less than n. The complexity of the algorithm, then, is O(n2) (ignoring operations with long numbers).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/530",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4177
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 1",
          "code": "0:  []          leaf\n  1:  [[]]        two-chain\n  2:  [[][]]      1-fork-2\n  3:  [[][][]]    1-fork-3\n  k:  [[]...[]]   1-fork-k\n  -1: [[[]]]      three-chain\n  -2: [[[][]]]    1-1-fork-2\n  -3: [[[][][]]]  1-1-fork-3\n  -k: [[[]...[]]] 1-1-fork-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 2",
          "code": "0:  []          leaf\n  1:  [[]]        two-chain\n  2:  [[][]]      1-fork-2\n  3:  [[][][]]    1-fork-3\n  k:  [[]...[]]   1-fork-k\n  -1: [[[]]]      three-chain\n  -2: [[[][]]]    1-1-fork-2\n  -3: [[[][][]]]  1-1-fork-3\n  -k: [[[]...[]]] 1-1-fork-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 3",
          "code": "c0: number of 0s (leaves).\ncp: list of all positive cases (1-fork-k).\ncn: list of all negative cases (1-1-fork-k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 4",
          "code": "c0: number of 0s (leaves).\ncp: list of all positive cases (1-fork-k).\ncn: list of all negative cases (1-1-fork-k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 5",
          "code": "[[]] means a two-chain.\n[[[]]] means a three chain.\n[[][]] means a parent with two children.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 6",
          "code": "[[]] means a two-chain.\n[[[]]] means a three chain.\n[[][]] means a parent with two children.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(1, 100000, \"n\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(1, 100000, \"n\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(1, 100000, \"n\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 100000); // Default t = 100000\n    ensure(1 <= t && t <= 100000);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> n_values(t);\n\n    if (type == \"min\") {\n        /* Generate t test cases with n = 1 */\n        fill(n_values.begin(), n_values.end(), 1);\n    } else if (type == \"max\") {\n        /* Generate t test cases with n = 100000 */\n        fill(n_values.begin(), n_values.end(), 100000);\n    } else if (type == \"small\") {\n        /* Generate small n's (1 <= n <= 10) */\n        for (int i = 0; i < t; ++i)\n            n_values[i] = rnd.next(1, 10);\n    } else if (type == \"even\") {\n        /* Generate even n's between 2 and 100000 */\n        for (int i = 0; i < t; ++i)\n            n_values[i] = rnd.next(1, 50000) * 2;\n    } else if (type == \"odd\") {\n        /* Generate odd n's between 1 and 99999 */\n        for (int i = 0; i < t; ++i)\n            n_values[i] = rnd.next(1, 50000) * 2 - 1;\n    } else if (type == \"random\") {\n        /* Generate random n between 1 and 100000 */\n        for (int i = 0; i < t; ++i)\n            n_values[i] = rnd.next(1, 100000);\n    } else if (type == \"tmax_nmax\") {\n        /* t = 100000, n = 100000 for all */\n        t = 100000;\n        n_values.assign(t, 100000);\n    } else if (type == \"t1_n1\") {\n        /* t = 1, n = 1 */\n        t = 1;\n        n_values[0] = 1;\n    } else if (type == \"mixed\") {\n        /* Generate t test cases mixing various n's */\n        for (int i = 0; i < t; ++i) {\n            int choice = rnd.next(1, 4);\n            if (choice == 1) {\n                n_values[i] = 1;\n            } else if (choice == 2) {\n                n_values[i] = 2;\n            } else if (choice == 3) {\n                n_values[i] = 100000;\n            } else {\n                n_values[i] = rnd.next(1, 100000);\n            }\n        }\n    } else {\n        /* Default random */\n        for (int i = 0; i < t; ++i)\n            n_values[i] = rnd.next(1, 100000);\n    }\n\n    /* Output t */\n    printf(\"%d\\n\", t);\n\n    /* Output n's */\n    for (int i = 0; i < t; ++i)\n        printf(\"%d\\n\", n_values[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 100000); // Default t = 100000\n    ensure(1 <= t && t <= 100000);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> n_values(t);\n\n    if (type == \"min\") {\n        /* Generate t test cases with n = 1 */\n        fill(n_values.begin(), n_values.end(), 1);\n    } else if (type == \"max\") {\n        /* Generate t test cases with n = 100000 */\n        fill(n_values.begin(), n_values.end(), 100000);\n    } else if (type == \"small\") {\n        /* Generate small n's (1 <= n <= 10) */\n        for (int i = 0; i < t; ++i)\n            n_values[i] = rnd.next(1, 10);\n    } else if (type == \"even\") {\n        /* Generate even n's between 2 and 100000 */\n        for (int i = 0; i < t; ++i)\n            n_values[i] = rnd.next(1, 50000) * 2;\n    } else if (type == \"odd\") {\n        /* Generate odd n's between 1 and 99999 */\n        for (int i = 0; i < t; ++i)\n            n_values[i] = rnd.next(1, 50000) * 2 - 1;\n    } else if (type == \"random\") {\n        /* Generate random n between 1 and 100000 */\n        for (int i = 0; i < t; ++i)\n            n_values[i] = rnd.next(1, 100000);\n    } else if (type == \"tmax_nmax\") {\n        /* t = 100000, n = 100000 for all */\n        t = 100000;\n        n_values.assign(t, 100000);\n    } else if (type == \"t1_n1\") {\n        /* t = 1, n = 1 */\n        t = 1;\n        n_values[0] = 1;\n    } else if (type == \"mixed\") {\n        /* Generate t test cases mixing various n's */\n        for (int i = 0; i < t; ++i) {\n            int choice = rnd.next(1, 4);\n            if (choice == 1) {\n                n_values[i] = 1;\n            } else if (choice == 2) {\n                n_values[i] = 2;\n            } else if (choice == 3) {\n                n_values[i] = 100000;\n            } else {\n                n_values[i] = rnd.next(1, 100000);\n            }\n        }\n    } else {\n        /* Default random */\n        for (int i = 0; i < t; ++i)\n            n_values[i] = rnd.next(1, 100000);\n    }\n\n    /* Output t */\n    printf(\"%d\\n\", t);\n\n    /* Output n's */\n    for (int i = 0; i < t; ++i)\n        printf(\"%d\\n\", n_values[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type min\n./gen -t 1 -type max\n./gen -t 5 -type small\n./gen -t 100000 -type even\n./gen -t 100000 -type odd\n./gen -t 50000 -type random\n./gen -type tmax_nmax\n./gen -type t1_n1\n./gen -t 1000 -type mixed\n./gen -t 2 -type min\n./gen -t 2 -type max\n./gen -t 10 -type min\n./gen -t 10 -type max\n./gen -t 100 -type min\n./gen -t 100 -type max\n./gen -t 1000 -type min\n./gen -t 1000 -type max\n./gen -t 50000 -type small\n./gen -t 50000 -type random\n./gen -t 1 -type random\n./gen -t 1\n./gen -t 2\n./gen -t 3 -type small\n./gen -t 3 -type min\n./gen -t 3 -type max\n./gen -t 100 -type even\n./gen -t 100 -type odd\n./gen -t 10000 -type small\n./gen -t 99999 -type random\n./gen -t 100000 -type random\n./gen -t 100000 -type min\n./gen -t 100000 -type max\n./gen -t 99999 -type min\n./gen -t 2 -type small\n./gen -t 5 -type even\n./gen -t 5 -type odd\n./gen -t 5 -type random\n./gen -t 5000 -type mixed\n./gen -t 10000 -type mixed\n./gen -t 100000 -type mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:31.851626",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "23/C",
      "title": "C. Oranges and Apples",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains one number T — amount of tests. The description of each test starts with a natural number N — amount of boxes. Each of the following 2N - 1 lines contains numbers ai and oi — amount of apples and oranges in the i-th box (0 ≤ ai, oi ≤ 109). The sum of N in all the tests in the input doesn't exceed 105. All the input numbers are integer.",
      "output_spec": "OutputFor each test output two lines. In the first line output YES, if it's possible to choose N boxes, or NO otherwise. If the answer is positive output in the second line N numbers — indexes of the chosen boxes. Boxes are numbered from 1 in the input order. Otherwise leave the second line empty. Separate the numbers with one space.",
      "sample_tests": "ExamplesInputCopy2210 155 720 1810 0OutputCopyYES1 3YES1",
      "description": "C. Oranges and Apples\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains one number T — amount of tests. The description of each test starts with a natural number N — amount of boxes. Each of the following 2N - 1 lines contains numbers ai and oi — amount of apples and oranges in the i-th box (0 ≤ ai, oi ≤ 109). The sum of N in all the tests in the input doesn't exceed 105. All the input numbers are integer.\n\nOutputFor each test output two lines. In the first line output YES, if it's possible to choose N boxes, or NO otherwise. If the answer is positive output in the second line N numbers — indexes of the chosen boxes. Boxes are numbered from 1 in the input order. Otherwise leave the second line empty. Separate the numbers with one space.\n\nInputCopy2210 155 720 1810 0OutputCopyYES1 3YES1\n\nInputCopy2210 155 720 1810 0\n\nOutputCopyYES1 3YES1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #23 - Codeforces",
          "content": "Hi everybodyToday the author of the majority of problems is Dmitry Zhukov, many thanks to him for this. Also I want to thank Mike Mirzayanov for choosing problems for the contest and organizing it and Julia Satushina for the translation of the statements.Good luck! UPD: ProblemsFinal standingsWinner: saeedreza.seddighin",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/528",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 321
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces",
          "content": "A. You're given a string...Iterate over all substrings, starting with the longest ones, and for each one count the number of appearances. The complexity is O(L4) with a small multiplicative constant. B. PartyIt's clear that at least one person (the one with the least number of friends) will have to leave. We claim that at least two persons will leave. Indeed, suppose that only one person left, and he had d friends. Then all other people had more than d friends before he left, and after that they had less than d + 1 friends, i.e. not more than d. So, his leaving influenced the number of friends for every other person, which means that he was friends with everyone: d = N - 1. But he has fewer friends than everyone — a contradiction.So, the answer is not more than N - 2. We'll prove that it's possible for N - 2 people to stay (of course, if N > 1). The graph of friendship will be the following: take a complete graph on N vertices and delete one edge. Then the degrees of two vertices equal N - 2, and other degrees equal N - 1. After the first two vertices are removed, we have a complete graph on N - 2 vertices, and all degrees equal N - 3, which means that no one else will leave.C. Oranges and ApplesSort the boxes in increasing number of oranges. Count the total number of apples in boxes with odd and even numbers. If the boxes with odd numbers contain at least half of all apples, choose them (there are exactly N boxes with odd numbers). If the boxes with even numbers contain at least half of all apples, take them and the last box (which contains the largest number of oranges). It's easy to see that in both cases the conditions of the task are fulfilled.D. TetragonLet ABCD be the quadrangle that we're looking for, and K, L, and M be the middle points of equal sides AB, BC and CD, correspondingly. Let M' be the point symmetric to M with respect to L. Triangles BLM' and CLM are equal by two sides and angle, so BM' = CM = BL = BK, i. e. B is the circumcenter of the triangle KLM'. Knowing B, we can reconstruct the whole quadrangle, using the symmetries with respect to the points K, L, and M, and then check whether it satisfies all conditions.Note that we don't know which of the given points is L, so we need to check all 3 cases.E. TreeLemma. In one of optimal solutions there are no simple paths of length 3.Proof. We can remove the middle edge from such a path. The connected component will split into two components of sizes a and b, where a ≥ 2, b ≥ 2, and therefore ab ≥ a + b.We'll root the tree and calculate recursively the numbers hv = the solution of the problem for the subtree with the root v, and fv = the product of hu for all children of v. If v is a leaf, then hv = fv = 1.We show how to calculate hv, given the solution for all subtrees of v. Consider the connected component of v in an optimal solution. It follows from the lemma that the component has one of the following types:1. The single vertex v.2. The vertex v and several children of v.3. The vertex v, one child of v — w, and several children of w.In the first case the result of the game is fv.In the second case it equals Πfi · Πhj · k = Π(fi / hi) · fv · k, where i iterates over children belonging to the connected component, j iterates over the rest children, and k is the size of the component. Since we want to maximize the result, we're interested in children with the largest value of fi / hi. Therefore, the largest possible result in this case equals the maximum value of Πi ≤ s  (fi / hi) · fv · (s + 1), where it's supposed that the children are sorted in descending order of fi / hi.In the third case we can use a similar reasoning for every child w. The best result will be the maximum of the expression fv · (fw / hw) · Πi ≤ s (fi / hi) · (s + 2) as w iterates over children of v, and s iterates from 1 to the number of children of w; note that the children of w have already been sorted in the previous step.Therefore, the number of operations necessary to calculate fv is proportional to the total number of children and grandchildren of v, which is less than n. The complexity of the algorithm, then, is O(n2) (ignoring operations with long numbers).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/530",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4177
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 1",
          "code": "0:  []          leaf\n  1:  [[]]        two-chain\n  2:  [[][]]      1-fork-2\n  3:  [[][][]]    1-fork-3\n  k:  [[]...[]]   1-fork-k\n  -1: [[[]]]      three-chain\n  -2: [[[][]]]    1-1-fork-2\n  -3: [[[][][]]]  1-1-fork-3\n  -k: [[[]...[]]] 1-1-fork-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 2",
          "code": "0:  []          leaf\n  1:  [[]]        two-chain\n  2:  [[][]]      1-fork-2\n  3:  [[][][]]    1-fork-3\n  k:  [[]...[]]   1-fork-k\n  -1: [[[]]]      three-chain\n  -2: [[[][]]]    1-1-fork-2\n  -3: [[[][][]]]  1-1-fork-3\n  -k: [[[]...[]]] 1-1-fork-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 3",
          "code": "c0: number of 0s (leaves).\ncp: list of all positive cases (1-fork-k).\ncn: list of all negative cases (1-1-fork-k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 4",
          "code": "c0: number of 0s (leaves).\ncp: list of all positive cases (1-fork-k).\ncn: list of all negative cases (1-1-fork-k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 5",
          "code": "[[]] means a two-chain.\n[[[]]] means a three chain.\n[[][]] means a parent with two children.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 6",
          "code": "[[]] means a two-chain.\n[[[]]] means a three chain.\n[[][]] means a parent with two children.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int T = inf.readInt(1, 100000, \"T\"); // T is the number of tests, must be between 1 and 1e5\n    inf.readEoln();\n    long long total_N = 0; // To keep track of the sum of N over all tests\n    for (int t = 1; t <= T; t++) {\n        int N = inf.readInt(1, 100000, \"N\"); // N is the number of boxes in test t, must be between 1 and 1e5\n        total_N += N;\n        ensuref(total_N <= 100000, \"Sum of N over all tests should not exceed 100000, but got %lld after test %d\", total_N, t);\n        inf.readEoln();\n        for (int i = 0; i < 2 * N - 1; i++) {\n            int ai = inf.readInt(0, 1000000000, \"ai\"); // ai is the number of apples in the i-th box, between 0 and 1e9\n            inf.readSpace();\n            int oi = inf.readInt(0, 1000000000, \"oi\"); // oi is the number of oranges in the i-th box, between 0 and 1e9\n            inf.readEoln();\n        }\n    }\n    inf.readEof(); // Ensure there is no extra data at the end of the file\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int T = inf.readInt(1, 100000, \"T\"); // T is the number of tests, must be between 1 and 1e5\n    inf.readEoln();\n    long long total_N = 0; // To keep track of the sum of N over all tests\n    for (int t = 1; t <= T; t++) {\n        int N = inf.readInt(1, 100000, \"N\"); // N is the number of boxes in test t, must be between 1 and 1e5\n        total_N += N;\n        ensuref(total_N <= 100000, \"Sum of N over all tests should not exceed 100000, but got %lld after test %d\", total_N, t);\n        inf.readEoln();\n        for (int i = 0; i < 2 * N - 1; i++) {\n            int ai = inf.readInt(0, 1000000000, \"ai\"); // ai is the number of apples in the i-th box, between 0 and 1e9\n            inf.readSpace();\n            int oi = inf.readInt(0, 1000000000, \"oi\"); // oi is the number of oranges in the i-th box, between 0 and 1e9\n            inf.readEoln();\n        }\n    }\n    inf.readEof(); // Ensure there is no extra data at the end of the file\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int T = inf.readInt(1, 100000, \"T\"); // T is the number of tests, must be between 1 and 1e5\n    inf.readEoln();\n    long long total_N = 0; // To keep track of the sum of N over all tests\n    for (int t = 1; t <= T; t++) {\n        int N = inf.readInt(1, 100000, \"N\"); // N is the number of boxes in test t, must be between 1 and 1e5\n        total_N += N;\n        ensuref(total_N <= 100000, \"Sum of N over all tests should not exceed 100000, but got %lld after test %d\", total_N, t);\n        inf.readEoln();\n        for (int i = 0; i < 2 * N - 1; i++) {\n            int ai = inf.readInt(0, 1000000000, \"ai\"); // ai is the number of apples in the i-th box, between 0 and 1e9\n            inf.readSpace();\n            int oi = inf.readInt(0, 1000000000, \"oi\"); // oi is the number of oranges in the i-th box, between 0 and 1e9\n            inf.readEoln();\n        }\n    }\n    inf.readEof(); // Ensure there is no extra data at the end of the file\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid readAndCheckSelection(InStream& stream, const string& verdict, int N, int total_boxes, const vector<long long>& apples, \n                           const vector<long long>& oranges, long long required_apples, long long required_oranges, const string& who) {\n    if (verdict == \"YES\") {\n        vector<int> indices = stream.readInts(N, 1, total_boxes, format(\"%s's selected boxes\", who).c_str());\n        set<int> indices_set(indices.begin(), indices.end());\n        if ((int)indices_set.size() != N) {\n            stream.quitf(_wa, \"%s has duplicate indices in selected boxes\", who.c_str());\n        }\n        long long sum_apples = 0;\n        long long sum_oranges = 0;\n        for (int idx : indices) {\n            idx--; // Convert to 0-based index\n            sum_apples += apples[idx];\n            sum_oranges += oranges[idx];\n        }\n        if (sum_apples < required_apples) {\n            stream.quitf(_wa, \"%s's selection does not have enough apples: required at least %lld, but got %lld\", \n                         who.c_str(), required_apples, sum_apples);\n        }\n        if (sum_oranges < required_oranges) {\n            stream.quitf(_wa, \"%s's selection does not have enough oranges: required at least %lld, but got %lld\", \n                         who.c_str(), required_oranges, sum_oranges);\n        }\n    } else if (verdict == \"NO\") {\n        // For NO verdict, no further action is needed\n    } else {\n        stream.quitf(_fail, \"%s outputted invalid verdict: %s\", who.c_str(), verdict.c_str());\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int T = inf.readInt();\n    for (int test = 1; test <= T; ++test) {\n        int N = inf.readInt(1, 100000);\n        int total_boxes = 2 * N - 1;\n        vector<long long> apples(total_boxes);\n        vector<long long> oranges(total_boxes);\n        long long total_apples = 0;\n        long long total_oranges = 0;\n        for (int i = 0; i < total_boxes; ++i) {\n            long long ai = inf.readLong(0, 1000000000LL, format(\"apples in box %d\", i + 1).c_str());\n            long long oi = inf.readLong(0, 1000000000LL, format(\"oranges in box %d\", i + 1).c_str());\n            apples[i] = ai;\n            oranges[i] = oi;\n            total_apples += ai;\n            total_oranges += oi;\n        }\n        long long required_apples = (total_apples + 1) / 2;\n        long long required_oranges = (total_oranges + 1) / 2;\n\n        string ans_verdict = upperCase(ans.readToken());\n        string ouf_verdict = upperCase(ouf.readToken());\n        if (ans_verdict != \"YES\" && ans_verdict != \"NO\") {\n            ans.quitf(_fail, \"Invalid verdict in judge's output on test %d: %s\", test, ans_verdict.c_str());\n        }\n        if (ouf_verdict != \"YES\" && ouf_verdict != \"NO\") {\n            quitf(_pe, \"Invalid verdict in participant's output on test %d: %s\", test, ouf_verdict.c_str());\n        }\n        // Read and validate judge's answer\n        readAndCheckSelection(ans, ans_verdict, N, total_boxes, apples, oranges, required_apples, required_oranges, \"Jury\");\n        // Compare the verdicts\n        if (ans_verdict != ouf_verdict) {\n            quitf(_wa, \"Wrong verdict on test %d: expected %s, found %s\", test, ans_verdict.c_str(), ouf_verdict.c_str());\n        }\n        if (ans_verdict == \"YES\") {\n            // Read and validate participant's selection\n            readAndCheckSelection(ouf, ouf_verdict, N, total_boxes, apples, oranges, required_apples, required_oranges, \"Participant\");\n        }\n    }\n    quitf(_ok, \"All test cases passed\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_possible_case(int N) {\n    // Generate a test case where it's possible to pick N boxes that meet the requirement\n    int totalBoxes = 2 * N - 1;\n    vector<pair<int, int>> boxes(totalBoxes);\n\n    // Generate random values for boxes\n    long long total_apples = 0;\n    long long total_oranges = 0;\n\n    for (int i = 0; i < totalBoxes; ++i) {\n        boxes[i].first = rnd.next(0, int(1e9));\n        boxes[i].second = rnd.next(0, int(1e9));\n        total_apples += boxes[i].first;\n        total_oranges += boxes[i].second;\n    }\n\n    // Sort boxes by sum of apples and oranges in decreasing order\n    vector<int> indices(totalBoxes);\n    iota(indices.begin(), indices.end(), 0);\n    sort(indices.begin(), indices.end(), [&](int a, int b) {\n        return boxes[a].first + boxes[a].second > boxes[b].first + boxes[b].second;\n    });\n\n    // Sum of apples and oranges in top N boxes\n    long long selected_apples = 0;\n    long long selected_oranges = 0;\n    for (int i = 0; i < N; ++i) {\n        selected_apples += boxes[indices[i]].first;\n        selected_oranges += boxes[indices[i]].second;\n    }\n\n    // Ensure selected boxes meet the requirement\n    long long half_apples = (total_apples + 1) / 2;\n    long long half_oranges = (total_oranges + 1) / 2;\n\n    if (selected_apples < half_apples || selected_oranges < half_oranges) {\n        long long needed_apples = half_apples - selected_apples;\n        long long needed_oranges = half_oranges - selected_oranges;\n\n        for (int i = 0; i < N; ++i) {\n            if (needed_apples > 0) {\n                int add = min(needed_apples, (long long)1e9 - boxes[indices[i]].first);\n                boxes[indices[i]].first += add;\n                needed_apples -= add;\n            }\n            if (needed_oranges > 0) {\n                int add = min(needed_oranges, (long long)1e9 - boxes[indices[i]].second);\n                boxes[indices[i]].second += add;\n                needed_oranges -= add;\n            }\n        }\n    }\n\n    // Output N and the boxes\n    printf(\"%d\\n\", N);\n    for (int i = 0; i < totalBoxes; ++i) {\n        printf(\"%d %d\\n\", boxes[i].first, boxes[i].second);\n    }\n}\n\nvoid generate_impossible_case(int N) {\n    // Generate a test case where it's impossible to meet the requirement\n    int totalBoxes = 2 * N - 1;\n    vector<pair<int, int>> boxes(totalBoxes);\n\n    // Create only two boxes with significant values\n    boxes[0] = {int(1e9), 0}; // Box with max apples\n    boxes[1] = {0, int(1e9)}; // Box with max oranges\n    for (int i = 2; i < totalBoxes; ++i) {\n        boxes[i] = {0, 0};\n    }\n\n    printf(\"%d\\n\", N);\n    for (int i = 0; i < totalBoxes; ++i) {\n        printf(\"%d %d\\n\", boxes[i].first, boxes[i].second);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int T = opt<int>(\"T\", 1);\n    int maxN = opt<int>(\"maxN\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate Ns so that their sum doesn't exceed 1e5\n    vector<int> Ns(T);\n    int totalN = 0;\n    for (int i = 0; i < T; ++i) {\n        Ns[i] = rnd.next(1, min(maxN - totalN - (T - i - 1), maxN));\n        totalN += Ns[i];\n    }\n\n    printf(\"%d\\n\", T);\n    for (int t = 0; t < T; ++t) {\n        int N = Ns[t];\n\n        if (type == \"zeros\") {\n            printf(\"%d\\n\", N);\n            int totalBoxes = 2 * N - 1;\n            for (int i = 0; i < totalBoxes; ++i) {\n                printf(\"0 0\\n\");\n            }\n        } else if (type == \"max\") {\n            printf(\"%d\\n\", N);\n            int totalBoxes = 2 * N - 1;\n            for (int i = 0; i < totalBoxes; ++i) {\n                printf(\"1000000000 1000000000\\n\");\n            }\n        } else if (type == \"min\") {\n            printf(\"%d\\n\", N);\n            int totalBoxes = 2 * N - 1;\n            for (int i = 0; i < totalBoxes; ++i) {\n                printf(\"0 0\\n\");\n            }\n        } else if (type == \"impossible\") {\n            generate_impossible_case(N);\n        } else if (type == \"possible\") {\n            generate_possible_case(N);\n        } else { // random case\n            printf(\"%d\\n\", N);\n            int totalBoxes = 2 * N - 1;\n            for (int i = 0; i < totalBoxes; ++i) {\n                int a = rnd.next(0, int(1e9));\n                int o = rnd.next(0, int(1e9));\n                printf(\"%d %d\\n\", a, o);\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_possible_case(int N) {\n    // Generate a test case where it's possible to pick N boxes that meet the requirement\n    int totalBoxes = 2 * N - 1;\n    vector<pair<int, int>> boxes(totalBoxes);\n\n    // Generate random values for boxes\n    long long total_apples = 0;\n    long long total_oranges = 0;\n\n    for (int i = 0; i < totalBoxes; ++i) {\n        boxes[i].first = rnd.next(0, int(1e9));\n        boxes[i].second = rnd.next(0, int(1e9));\n        total_apples += boxes[i].first;\n        total_oranges += boxes[i].second;\n    }\n\n    // Sort boxes by sum of apples and oranges in decreasing order\n    vector<int> indices(totalBoxes);\n    iota(indices.begin(), indices.end(), 0);\n    sort(indices.begin(), indices.end(), [&](int a, int b) {\n        return boxes[a].first + boxes[a].second > boxes[b].first + boxes[b].second;\n    });\n\n    // Sum of apples and oranges in top N boxes\n    long long selected_apples = 0;\n    long long selected_oranges = 0;\n    for (int i = 0; i < N; ++i) {\n        selected_apples += boxes[indices[i]].first;\n        selected_oranges += boxes[indices[i]].second;\n    }\n\n    // Ensure selected boxes meet the requirement\n    long long half_apples = (total_apples + 1) / 2;\n    long long half_oranges = (total_oranges + 1) / 2;\n\n    if (selected_apples < half_apples || selected_oranges < half_oranges) {\n        long long needed_apples = half_apples - selected_apples;\n        long long needed_oranges = half_oranges - selected_oranges;\n\n        for (int i = 0; i < N; ++i) {\n            if (needed_apples > 0) {\n                int add = min(needed_apples, (long long)1e9 - boxes[indices[i]].first);\n                boxes[indices[i]].first += add;\n                needed_apples -= add;\n            }\n            if (needed_oranges > 0) {\n                int add = min(needed_oranges, (long long)1e9 - boxes[indices[i]].second);\n                boxes[indices[i]].second += add;\n                needed_oranges -= add;\n            }\n        }\n    }\n\n    // Output N and the boxes\n    printf(\"%d\\n\", N);\n    for (int i = 0; i < totalBoxes; ++i) {\n        printf(\"%d %d\\n\", boxes[i].first, boxes[i].second);\n    }\n}\n\nvoid generate_impossible_case(int N) {\n    // Generate a test case where it's impossible to meet the requirement\n    int totalBoxes = 2 * N - 1;\n    vector<pair<int, int>> boxes(totalBoxes);\n\n    // Create only two boxes with significant values\n    boxes[0] = {int(1e9), 0}; // Box with max apples\n    boxes[1] = {0, int(1e9)}; // Box with max oranges\n    for (int i = 2; i < totalBoxes; ++i) {\n        boxes[i] = {0, 0};\n    }\n\n    printf(\"%d\\n\", N);\n    for (int i = 0; i < totalBoxes; ++i) {\n        printf(\"%d %d\\n\", boxes[i].first, boxes[i].second);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int T = opt<int>(\"T\", 1);\n    int maxN = opt<int>(\"maxN\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate Ns so that their sum doesn't exceed 1e5\n    vector<int> Ns(T);\n    int totalN = 0;\n    for (int i = 0; i < T; ++i) {\n        Ns[i] = rnd.next(1, min(maxN - totalN - (T - i - 1), maxN));\n        totalN += Ns[i];\n    }\n\n    printf(\"%d\\n\", T);\n    for (int t = 0; t < T; ++t) {\n        int N = Ns[t];\n\n        if (type == \"zeros\") {\n            printf(\"%d\\n\", N);\n            int totalBoxes = 2 * N - 1;\n            for (int i = 0; i < totalBoxes; ++i) {\n                printf(\"0 0\\n\");\n            }\n        } else if (type == \"max\") {\n            printf(\"%d\\n\", N);\n            int totalBoxes = 2 * N - 1;\n            for (int i = 0; i < totalBoxes; ++i) {\n                printf(\"1000000000 1000000000\\n\");\n            }\n        } else if (type == \"min\") {\n            printf(\"%d\\n\", N);\n            int totalBoxes = 2 * N - 1;\n            for (int i = 0; i < totalBoxes; ++i) {\n                printf(\"0 0\\n\");\n            }\n        } else if (type == \"impossible\") {\n            generate_impossible_case(N);\n        } else if (type == \"possible\") {\n            generate_possible_case(N);\n        } else { // random case\n            printf(\"%d\\n\", N);\n            int totalBoxes = 2 * N - 1;\n            for (int i = 0; i < totalBoxes; ++i) {\n                int a = rnd.next(0, int(1e9));\n                int o = rnd.next(0, int(1e9));\n                printf(\"%d %d\\n\", a, o);\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test 1: Minimum input\n./gen -T 1 -maxN 1 -type zeros\n\n# Test 2: Small N, zeros\n./gen -T 1 -maxN 5 -type zeros\n\n# Test 3: Small N, min\n./gen -T 1 -maxN 5 -type min\n\n# Test 4: Small N, max\n./gen -T 1 -maxN 5 -type max\n\n# Test 5: Small N, possible\n./gen -T 1 -maxN 5 -type possible\n\n# Test 6: Small N, impossible\n./gen -T 1 -maxN 5 -type impossible\n\n# Test 7: Medium N, random\n./gen -T 5 -maxN 1000 -type random\n\n# Test 8: Medium N, possible\n./gen -T 5 -maxN 1000 -type possible\n\n# Test 9: Medium N, impossible\n./gen -T 5 -maxN 1000 -type impossible\n\n# Test 10: Large N, random\n./gen -T 10 -maxN 100000 -type random\n\n# Test 11: Large N, possible\n./gen -T 10 -maxN 100000 -type possible\n\n# Test 12: Large N, impossible\n./gen -T 10 -maxN 100000 -type impossible\n\n# Test 13: Max N, zeros\n./gen -T 1 -maxN 100000 -type zeros\n\n# Test 14: Max N, min\n./gen -T 1 -maxN 100000 -type min\n\n# Test 15: Max N, max\n./gen -T 1 -maxN 100000 -type max\n\n# Test 16: Max N, possible\n./gen -T 1 -maxN 100000 -type possible\n\n# Test 17: Max N, impossible\n./gen -T 1 -maxN 100000 -type impossible\n\n# Test 18: Several tests, random\n./gen -T 20 -maxN 100000 -type random\n\n# Test 19: Several tests, possible\n./gen -T 20 -maxN 100000 -type possible\n\n# Test 20: Several tests, impossible\n./gen -T 20 -maxN 100000 -type impossible\n\n# Test 21: Edge case N=1, possible\n./gen -T 1 -maxN 1 -type possible\n\n# Test 22: Edge case N=1, impossible\n./gen -T 1 -maxN 1 -type impossible\n\n# Test 23: Edge case N=2, possible\n./gen -T 1 -maxN 2 -type possible\n\n# Test 24: Edge case N=2, impossible\n./gen -T 1 -maxN 2 -type impossible\n\n# Test 25: Various Ns, random\n./gen -T 50 -maxN 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:33.921496",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "23/D",
      "title": "D. Tetragon",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains one number T — amount of tests (1 ≤ T ≤ 5·104). Each of the following T lines contains numbers x1, y1, x2, y2, x3, y3 — coordinates of different points that are the centers of three equal sides (non-negative integer numbers, not exceeding 10).",
      "output_spec": "OutputFor each test output two lines. If the required tetragon exists, output in the first line YES, in the second line — four pairs of numbers — coordinates of the polygon's vertices in clockwise or counter-clockwise order. Don't forget, please, that the tetragon should be strictly convex, i.e. no 3 of its points lie on one line. Output numbers with 9 characters after a decimal point.If the required tetragon doen't exist, output NO in the first line, and leave the second line empty.",
      "sample_tests": "ExamplesInputCopy31 1 2 2 3 30 1 1 0 2 29 3 7 9 9 8OutputCopyNOYES3.5 1.5 0.5 2.5 -0.5 -0.5 2.5 0.5NO",
      "description": "D. Tetragon\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains one number T — amount of tests (1 ≤ T ≤ 5·104). Each of the following T lines contains numbers x1, y1, x2, y2, x3, y3 — coordinates of different points that are the centers of three equal sides (non-negative integer numbers, not exceeding 10).\n\nOutputFor each test output two lines. If the required tetragon exists, output in the first line YES, in the second line — four pairs of numbers — coordinates of the polygon's vertices in clockwise or counter-clockwise order. Don't forget, please, that the tetragon should be strictly convex, i.e. no 3 of its points lie on one line. Output numbers with 9 characters after a decimal point.If the required tetragon doen't exist, output NO in the first line, and leave the second line empty.\n\nInputCopy31 1 2 2 3 30 1 1 0 2 29 3 7 9 9 8OutputCopyNOYES3.5 1.5 0.5 2.5 -0.5 -0.5 2.5 0.5NO\n\nInputCopy31 1 2 2 3 30 1 1 0 2 29 3 7 9 9 8\n\nOutputCopyNOYES3.5 1.5 0.5 2.5 -0.5 -0.5 2.5 0.5NO",
      "solutions": [
        {
          "title": "Codeforces Beta Round #23 - Codeforces",
          "content": "Hi everybodyToday the author of the majority of problems is Dmitry Zhukov, many thanks to him for this. Also I want to thank Mike Mirzayanov for choosing problems for the contest and organizing it and Julia Satushina for the translation of the statements.Good luck! UPD: ProblemsFinal standingsWinner: saeedreza.seddighin",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/528",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 321
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces",
          "content": "A. You're given a string...Iterate over all substrings, starting with the longest ones, and for each one count the number of appearances. The complexity is O(L4) with a small multiplicative constant. B. PartyIt's clear that at least one person (the one with the least number of friends) will have to leave. We claim that at least two persons will leave. Indeed, suppose that only one person left, and he had d friends. Then all other people had more than d friends before he left, and after that they had less than d + 1 friends, i.e. not more than d. So, his leaving influenced the number of friends for every other person, which means that he was friends with everyone: d = N - 1. But he has fewer friends than everyone — a contradiction.So, the answer is not more than N - 2. We'll prove that it's possible for N - 2 people to stay (of course, if N > 1). The graph of friendship will be the following: take a complete graph on N vertices and delete one edge. Then the degrees of two vertices equal N - 2, and other degrees equal N - 1. After the first two vertices are removed, we have a complete graph on N - 2 vertices, and all degrees equal N - 3, which means that no one else will leave.C. Oranges and ApplesSort the boxes in increasing number of oranges. Count the total number of apples in boxes with odd and even numbers. If the boxes with odd numbers contain at least half of all apples, choose them (there are exactly N boxes with odd numbers). If the boxes with even numbers contain at least half of all apples, take them and the last box (which contains the largest number of oranges). It's easy to see that in both cases the conditions of the task are fulfilled.D. TetragonLet ABCD be the quadrangle that we're looking for, and K, L, and M be the middle points of equal sides AB, BC and CD, correspondingly. Let M' be the point symmetric to M with respect to L. Triangles BLM' and CLM are equal by two sides and angle, so BM' = CM = BL = BK, i. e. B is the circumcenter of the triangle KLM'. Knowing B, we can reconstruct the whole quadrangle, using the symmetries with respect to the points K, L, and M, and then check whether it satisfies all conditions.Note that we don't know which of the given points is L, so we need to check all 3 cases.E. TreeLemma. In one of optimal solutions there are no simple paths of length 3.Proof. We can remove the middle edge from such a path. The connected component will split into two components of sizes a and b, where a ≥ 2, b ≥ 2, and therefore ab ≥ a + b.We'll root the tree and calculate recursively the numbers hv = the solution of the problem for the subtree with the root v, and fv = the product of hu for all children of v. If v is a leaf, then hv = fv = 1.We show how to calculate hv, given the solution for all subtrees of v. Consider the connected component of v in an optimal solution. It follows from the lemma that the component has one of the following types:1. The single vertex v.2. The vertex v and several children of v.3. The vertex v, one child of v — w, and several children of w.In the first case the result of the game is fv.In the second case it equals Πfi · Πhj · k = Π(fi / hi) · fv · k, where i iterates over children belonging to the connected component, j iterates over the rest children, and k is the size of the component. Since we want to maximize the result, we're interested in children with the largest value of fi / hi. Therefore, the largest possible result in this case equals the maximum value of Πi ≤ s  (fi / hi) · fv · (s + 1), where it's supposed that the children are sorted in descending order of fi / hi.In the third case we can use a similar reasoning for every child w. The best result will be the maximum of the expression fv · (fw / hw) · Πi ≤ s (fi / hi) · (s + 2) as w iterates over children of v, and s iterates from 1 to the number of children of w; note that the children of w have already been sorted in the previous step.Therefore, the number of operations necessary to calculate fv is proportional to the total number of children and grandchildren of v, which is less than n. The complexity of the algorithm, then, is O(n2) (ignoring operations with long numbers).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/530",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4177
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 1",
          "code": "0:  []          leaf\n  1:  [[]]        two-chain\n  2:  [[][]]      1-fork-2\n  3:  [[][][]]    1-fork-3\n  k:  [[]...[]]   1-fork-k\n  -1: [[[]]]      three-chain\n  -2: [[[][]]]    1-1-fork-2\n  -3: [[[][][]]]  1-1-fork-3\n  -k: [[[]...[]]] 1-1-fork-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 2",
          "code": "0:  []          leaf\n  1:  [[]]        two-chain\n  2:  [[][]]      1-fork-2\n  3:  [[][][]]    1-fork-3\n  k:  [[]...[]]   1-fork-k\n  -1: [[[]]]      three-chain\n  -2: [[[][]]]    1-1-fork-2\n  -3: [[[][][]]]  1-1-fork-3\n  -k: [[[]...[]]] 1-1-fork-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 3",
          "code": "c0: number of 0s (leaves).\ncp: list of all positive cases (1-fork-k).\ncn: list of all negative cases (1-1-fork-k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 4",
          "code": "c0: number of 0s (leaves).\ncp: list of all positive cases (1-fork-k).\ncn: list of all negative cases (1-1-fork-k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 5",
          "code": "[[]] means a two-chain.\n[[[]]] means a three chain.\n[[][]] means a parent with two children.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 6",
          "code": "[[]] means a two-chain.\n[[[]]] means a three chain.\n[[][]] means a parent with two children.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int T = inf.readInt(1, 50000, \"T\");\n    inf.readEoln();\n    for (int test = 0; test < T; ++test) {\n        vector<int> coords = inf.readInts(6, 0, 10, \"coords\");\n        inf.readEoln();\n\n        int x1 = coords[0], y1 = coords[1];\n        int x2 = coords[2], y2 = coords[3];\n        int x3 = coords[4], y3 = coords[5];\n\n        ensuref(x1 != x2 || y1 != y2, \"Test %d: Point 1 equals point 2\", test + 1);\n        ensuref(x1 != x3 || y1 != y3, \"Test %d: Point 1 equals point 3\", test + 1);\n        ensuref(x2 != x3 || y2 != y3, \"Test %d: Point 2 equals point 3\", test + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int T = inf.readInt(1, 50000, \"T\");\n    inf.readEoln();\n    for (int test = 0; test < T; ++test) {\n        vector<int> coords = inf.readInts(6, 0, 10, \"coords\");\n        inf.readEoln();\n\n        int x1 = coords[0], y1 = coords[1];\n        int x2 = coords[2], y2 = coords[3];\n        int x3 = coords[4], y3 = coords[5];\n\n        ensuref(x1 != x2 || y1 != y2, \"Test %d: Point 1 equals point 2\", test + 1);\n        ensuref(x1 != x3 || y1 != y3, \"Test %d: Point 1 equals point 3\", test + 1);\n        ensuref(x2 != x3 || y2 != y3, \"Test %d: Point 2 equals point 3\", test + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int T = inf.readInt(1, 50000, \"T\");\n    inf.readEoln();\n    for (int test = 0; test < T; ++test) {\n        vector<int> coords = inf.readInts(6, 0, 10, \"coords\");\n        inf.readEoln();\n\n        int x1 = coords[0], y1 = coords[1];\n        int x2 = coords[2], y2 = coords[3];\n        int x3 = coords[4], y3 = coords[5];\n\n        ensuref(x1 != x2 || y1 != y2, \"Test %d: Point 1 equals point 2\", test + 1);\n        ensuref(x1 != x3 || y1 != y3, \"Test %d: Point 1 equals point 3\", test + 1);\n        ensuref(x2 != x3 || y2 != y3, \"Test %d: Point 2 equals point 3\", test + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-6;\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y): x(x), y(y) {}\n    Point operator - (const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator + (const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator / (double d) const { return Point(x / d, y / d); }\n    double cross(const Point& p) const { return x * p.y - y * p.x; }\n    double dot(const Point& p) const { return x * p.x + y * p.y; }\n    double length() const { return sqrt(x * x + y * y); }\n};\n\nbool equal(double a, double b) {\n    return fabs(a - b) < EPS;\n}\n\nbool pointEqual(const Point& a, const Point& b) {\n    return equal(a.x, b.x) && equal(a.y, b.y);\n}\n\nbool checkConvex(vector<Point>& pts) {\n    int n = pts.size();\n    double prev = 0;\n    for (int i = 0; i < n; i++) {\n        Point a = pts[i];\n        Point b = pts[(i + 1) % n];\n        Point c = pts[(i + 2) % n];\n        Point v1 = b - a;\n        Point v2 = c - b;\n        double cross = v1.cross(v2);\n        if (equal(cross, 0)) // Points are colinear\n            return false;\n        if (i == 0)\n            prev = cross;\n        else if (prev * cross < -EPS) // Sign change means not convex\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int T = inf.readInt(1, 50000, \"T\");\n    vector<vector<Point>> centers(T);\n    for (int test = 0; test < T; test++) {\n        vector<Point>& cs = centers[test];\n        for (int i = 0; i < 3; i++) {\n            int x = inf.readInt(0, 10, \"x\");\n            int y = inf.readInt(0, 10, \"y\");\n            cs.push_back(Point(x, y));\n        }\n    }\n\n    for (int test = 0; test < T; test++) {\n        // Read participant's output\n        string verdict = ouf.readToken();\n        if (verdict != \"YES\" && verdict != \"NO\")\n            quitf(_pe, \"Expected YES or NO, found '%s'\", verdict.c_str());\n\n        if (verdict == \"NO\") {\n            ouf.readLine(); // Skip the empty line\n            continue; // Cannot check further, accept NO\n        }\n\n        vector<Point> pts;\n        for (int i = 0; i < 4; i++) {\n            double x = ouf.readDouble(-1e9, 1e9, \"x\");\n            double y = ouf.readDouble(-1e9, 1e9, \"y\");\n            pts.push_back(Point(x, y));\n        }\n\n        // Check that the quadrilateral is strictly convex\n        if (!checkConvex(pts)) {\n            quitf(_wa, \"Quadrilateral is not strictly convex\");\n        }\n\n        // Compute side lengths and centers\n        vector<double> lengths;\n        vector<Point> sideCenters;\n        for (int i = 0; i < 4; i++) {\n            Point a = pts[i];\n            Point b = pts[(i + 1) % 4];\n            Point vec = b - a;\n            lengths.push_back(vec.length());\n            sideCenters.push_back((a + b) / 2);\n        }\n\n        // Find combinations of three equal sides\n        bool valid = false;\n        for (int mask = 1; mask < 16; mask++) {\n            if (__builtin_popcount(mask) != 3) continue;\n            vector<int> idx;\n            for (int i = 0; i < 4; i++) {\n                if (mask & (1 << i))\n                    idx.push_back(i);\n            }\n            double len = lengths[idx[0]];\n            if (!equal(lengths[idx[1]], len) || !equal(lengths[idx[2]], len))\n                continue;\n\n            // Check if the centers of these sides match the given centers\n            vector<Point> centersInAns = { sideCenters[idx[0]], sideCenters[idx[1]], sideCenters[idx[2]] };\n            vector<Point>& givenCenters = centers[test];\n            vector<int> perm = {0, 1, 2};\n            bool match = false;\n            do {\n                bool allMatch = true;\n                for (int i = 0; i < 3; i++) {\n                    if (!pointEqual(centersInAns[i], givenCenters[perm[i]])) {\n                        allMatch = false;\n                        break;\n                    }\n                }\n                if (allMatch) {\n                    match = true;\n                    break;\n                }\n            } while (next_permutation(perm.begin(), perm.end()));\n            if (match) {\n                valid = true;\n                break;\n            }\n        }\n        if (!valid) {\n            quitf(_wa, \"Quadrilateral does not satisfy the conditions in test %d\", test + 1);\n        }\n    }\n\n    quitf(_ok, \"All tests passed\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_COORD = 10;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command line arguments\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random_valid\");\n\n    // Output T\n    printf(\"%d\\n\", T);\n\n    for (int test = 0; test < T; ++test) {\n        if (type == \"random_valid\") {\n            // Generate a valid test case where centers correspond to three equal sides of a strictly convex tetragon\n            // Construct a rhombus (all sides equal)\n            int x0 = rnd.next(0, MAX_COORD / 2);\n            int y0 = rnd.next(0, MAX_COORD / 2);\n            int L = rnd.next(1, MAX_COORD / 2); // Side length\n\n            // Generate random angle between 0 and 90 degrees in radians\n            double angle = rnd.next(0.0, M_PI / 2);\n\n            // Vectors\n            double dx1 = L * cos(angle);\n            double dy1 = L * sin(angle);\n\n            // Rotate by 90 degrees to get perpendicular vector\n            double dx2 = -dy1;\n            double dy2 = dx1;\n\n            // Points A, B, C, D\n            double Ax = x0;\n            double Ay = y0;\n            double Bx = Ax + dx1;\n            double By = Ay + dy1;\n            double Cx = Bx + dx2;\n            double Cy = By + dy2;\n            double Dx = Ax + dx2;\n            double Dy = Ay + dy2;\n\n            // Ensure all coordinates are within [0, MAX_COORD]\n            if (min({Ax, Bx, Cx, Dx}) < 0 || max({Ax, Bx, Cx, Dx}) > MAX_COORD ||\n                min({Ay, By, Cy, Dy}) < 0 || max({Ay, By, Cy, Dy}) > MAX_COORD) {\n                // If out of bounds, adjust the origin\n                double minX = min({Ax, Bx, Cx, Dx});\n                double minY = min({Ay, By, Cy, Dy});\n                double maxX = max({Ax, Bx, Cx, Dx});\n                double maxY = max({Ay, By, Cy, Dy});\n\n                double shiftX = 0 - minX;\n                double shiftY = 0 - minY;\n\n                if (maxX + shiftX > MAX_COORD || maxY + shiftY > MAX_COORD) {\n                    // Can't adjust to fit within bounds, regenerate this test case\n                    --test;\n                    continue;\n                }\n\n                Ax += shiftX;\n                Ay += shiftY;\n                Bx += shiftX;\n                By += shiftY;\n                Cx += shiftX;\n                Cy += shiftY;\n                Dx += shiftX;\n                Dy += shiftY;\n            }\n\n            // Compute centers of three sides\n            vector<pair<double, double>> centers;\n            centers.push_back(make_pair((Ax + Bx) / 2.0, (Ay + By) / 2.0)); // Center of AB\n            centers.push_back(make_pair((Bx + Cx) / 2.0, (By + Cy) / 2.0)); // Center of BC\n            centers.push_back(make_pair((Cx + Dx) / 2.0, (Cy + Dy) / 2.0)); // Center of CD\n\n            // Since the problem expects integer centers in [0,10], we can round the centers\n            vector<int> outputs;\n            for (auto& center : centers) {\n                int x = int(round(center.first));\n                int y = int(round(center.second));\n                // Ensure coordinates are within bounds\n                x = max(0, min(MAX_COORD, x));\n                y = max(0, min(MAX_COORD, y));\n                outputs.push_back(x);\n                outputs.push_back(y);\n            }\n\n            // Output the six integers\n            printf(\"%d %d %d %d %d %d\\n\", outputs[0], outputs[1], outputs[2], outputs[3], outputs[4], outputs[5]);\n\n        } else if (type == \"random_invalid\") {\n            // Generate random points that may not correspond to valid tetragons\n            int x1 = rnd.next(0, MAX_COORD);\n            int y1 = rnd.next(0, MAX_COORD);\n            int x2 = rnd.next(0, MAX_COORD);\n            int y2 = rnd.next(0, MAX_COORD);\n            int x3 = rnd.next(0, MAX_COORD);\n            int y3 = rnd.next(0, MAX_COORD);\n\n            // Ensure points are different\n            set<pair<int, int>> points = {{x1, y1}, {x2, y2}, {x3, y3}};\n            if (points.size() < 3) {\n                --test; // Duplicate points, regenerate\n                continue;\n            }\n\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n        } else if (type == \"edge_cases\") {\n            // Generate points at the edges (0 or 10)\n            vector<int> coords = {0, MAX_COORD};\n            int x1 = coords[rnd.next(0, 1)];\n            int y1 = coords[rnd.next(0, 1)];\n            int x2 = coords[rnd.next(0, 1)];\n            int y2 = coords[rnd.next(0, 1)];\n            int x3 = coords[rnd.next(0, 1)];\n            int y3 = coords[rnd.next(0, 1)];\n\n            // Ensure points are different\n            set<pair<int, int>> points = {{x1, y1}, {x2, y2}, {x3, y3}};\n            if (points.size() < 3) {\n                --test; // Duplicate points, regenerate\n                continue;\n            }\n\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n        } else if (type == \"colinear_centers\") {\n            // Generate three colinear points\n            int x1 = rnd.next(0, MAX_COORD);\n            int y1 = rnd.next(0, MAX_COORD);\n\n            int x2 = rnd.next(0, MAX_COORD);\n            int y2 = rnd.next(0, MAX_COORD);\n\n            // Compute third point on the line between (x1,y1) and (x2,y2)\n            int x3 = (x1 + x2) / 2;\n            int y3 = (y1 + y2) / 2;\n\n            // Ensure points are different\n            set<pair<int, int>> points = {{x1, y1}, {x2, y2}, {x3, y3}};\n            if (points.size() < 3 || (x1 == x2 && y1 == y2)) {\n                --test; // Points not suitable, regenerate\n                continue;\n            }\n\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n        } else {\n            // Unsupported type\n            fprintf(stderr, \"Unsupported type: %s\\n\", type.c_str());\n            return 1;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_COORD = 10;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command line arguments\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random_valid\");\n\n    // Output T\n    printf(\"%d\\n\", T);\n\n    for (int test = 0; test < T; ++test) {\n        if (type == \"random_valid\") {\n            // Generate a valid test case where centers correspond to three equal sides of a strictly convex tetragon\n            // Construct a rhombus (all sides equal)\n            int x0 = rnd.next(0, MAX_COORD / 2);\n            int y0 = rnd.next(0, MAX_COORD / 2);\n            int L = rnd.next(1, MAX_COORD / 2); // Side length\n\n            // Generate random angle between 0 and 90 degrees in radians\n            double angle = rnd.next(0.0, M_PI / 2);\n\n            // Vectors\n            double dx1 = L * cos(angle);\n            double dy1 = L * sin(angle);\n\n            // Rotate by 90 degrees to get perpendicular vector\n            double dx2 = -dy1;\n            double dy2 = dx1;\n\n            // Points A, B, C, D\n            double Ax = x0;\n            double Ay = y0;\n            double Bx = Ax + dx1;\n            double By = Ay + dy1;\n            double Cx = Bx + dx2;\n            double Cy = By + dy2;\n            double Dx = Ax + dx2;\n            double Dy = Ay + dy2;\n\n            // Ensure all coordinates are within [0, MAX_COORD]\n            if (min({Ax, Bx, Cx, Dx}) < 0 || max({Ax, Bx, Cx, Dx}) > MAX_COORD ||\n                min({Ay, By, Cy, Dy}) < 0 || max({Ay, By, Cy, Dy}) > MAX_COORD) {\n                // If out of bounds, adjust the origin\n                double minX = min({Ax, Bx, Cx, Dx});\n                double minY = min({Ay, By, Cy, Dy});\n                double maxX = max({Ax, Bx, Cx, Dx});\n                double maxY = max({Ay, By, Cy, Dy});\n\n                double shiftX = 0 - minX;\n                double shiftY = 0 - minY;\n\n                if (maxX + shiftX > MAX_COORD || maxY + shiftY > MAX_COORD) {\n                    // Can't adjust to fit within bounds, regenerate this test case\n                    --test;\n                    continue;\n                }\n\n                Ax += shiftX;\n                Ay += shiftY;\n                Bx += shiftX;\n                By += shiftY;\n                Cx += shiftX;\n                Cy += shiftY;\n                Dx += shiftX;\n                Dy += shiftY;\n            }\n\n            // Compute centers of three sides\n            vector<pair<double, double>> centers;\n            centers.push_back(make_pair((Ax + Bx) / 2.0, (Ay + By) / 2.0)); // Center of AB\n            centers.push_back(make_pair((Bx + Cx) / 2.0, (By + Cy) / 2.0)); // Center of BC\n            centers.push_back(make_pair((Cx + Dx) / 2.0, (Cy + Dy) / 2.0)); // Center of CD\n\n            // Since the problem expects integer centers in [0,10], we can round the centers\n            vector<int> outputs;\n            for (auto& center : centers) {\n                int x = int(round(center.first));\n                int y = int(round(center.second));\n                // Ensure coordinates are within bounds\n                x = max(0, min(MAX_COORD, x));\n                y = max(0, min(MAX_COORD, y));\n                outputs.push_back(x);\n                outputs.push_back(y);\n            }\n\n            // Output the six integers\n            printf(\"%d %d %d %d %d %d\\n\", outputs[0], outputs[1], outputs[2], outputs[3], outputs[4], outputs[5]);\n\n        } else if (type == \"random_invalid\") {\n            // Generate random points that may not correspond to valid tetragons\n            int x1 = rnd.next(0, MAX_COORD);\n            int y1 = rnd.next(0, MAX_COORD);\n            int x2 = rnd.next(0, MAX_COORD);\n            int y2 = rnd.next(0, MAX_COORD);\n            int x3 = rnd.next(0, MAX_COORD);\n            int y3 = rnd.next(0, MAX_COORD);\n\n            // Ensure points are different\n            set<pair<int, int>> points = {{x1, y1}, {x2, y2}, {x3, y3}};\n            if (points.size() < 3) {\n                --test; // Duplicate points, regenerate\n                continue;\n            }\n\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n        } else if (type == \"edge_cases\") {\n            // Generate points at the edges (0 or 10)\n            vector<int> coords = {0, MAX_COORD};\n            int x1 = coords[rnd.next(0, 1)];\n            int y1 = coords[rnd.next(0, 1)];\n            int x2 = coords[rnd.next(0, 1)];\n            int y2 = coords[rnd.next(0, 1)];\n            int x3 = coords[rnd.next(0, 1)];\n            int y3 = coords[rnd.next(0, 1)];\n\n            // Ensure points are different\n            set<pair<int, int>> points = {{x1, y1}, {x2, y2}, {x3, y3}};\n            if (points.size() < 3) {\n                --test; // Duplicate points, regenerate\n                continue;\n            }\n\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n        } else if (type == \"colinear_centers\") {\n            // Generate three colinear points\n            int x1 = rnd.next(0, MAX_COORD);\n            int y1 = rnd.next(0, MAX_COORD);\n\n            int x2 = rnd.next(0, MAX_COORD);\n            int y2 = rnd.next(0, MAX_COORD);\n\n            // Compute third point on the line between (x1,y1) and (x2,y2)\n            int x3 = (x1 + x2) / 2;\n            int y3 = (y1 + y2) / 2;\n\n            // Ensure points are different\n            set<pair<int, int>> points = {{x1, y1}, {x2, y2}, {x3, y3}};\n            if (points.size() < 3 || (x1 == x2 && y1 == y2)) {\n                --test; // Points not suitable, regenerate\n                continue;\n            }\n\n            printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n        } else {\n            // Unsupported type\n            fprintf(stderr, \"Unsupported type: %s\\n\", type.c_str());\n            return 1;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small T with random valid test cases\n./gen -T 1 -type random_valid\n./gen -T 5 -type random_valid\n./gen -T 10 -type random_valid\n\n# Medium T with random valid test cases\n./gen -T 100 -type random_valid\n./gen -T 500 -type random_valid\n./gen -T 1000 -type random_valid\n\n# Large T with random valid test cases\n./gen -T 10000 -type random_valid\n./gen -T 50000 -type random_valid\n\n# Small T with random invalid test cases\n./gen -T 1 -type random_invalid\n./gen -T 5 -type random_invalid\n./gen -T 10 -type random_invalid\n\n# Medium T with random invalid test cases\n./gen -T 100 -type random_invalid\n./gen -T 500 -type random_invalid\n./gen -T 1000 -type random_invalid\n\n# Large T with random invalid test cases\n./gen -T 10000 -type random_invalid\n./gen -T 50000 -type random_invalid\n\n# Test cases with edge coordinates\n./gen -T 10 -type edge_cases\n./gen -T 100 -type edge_cases\n./gen -T 1000 -type edge_cases\n\n# Test cases with colinear centers\n./gen -T 10 -type colinear_centers\n./gen -T 100 -type colinear_centers\n./gen -T 1000 -type colinear_centers\n\n# Mixed types\n./gen -T 1000 -type random_valid\n./gen -T 1000 -type random_invalid\n./gen -T 1000 -type edge_cases\n./gen -T 1000 -type colinear_centers\n\n# Maximum T with a mix of test cases\n./gen -T 50000 -type random_valid\n./gen -T 50000 -type random_invalid\n\n# Minimal T\n./gen -T 1 -type random_valid\n./gen -T 1 -type random_invalid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:35.874264",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "23/E",
      "title": "E. Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains integer number n (1 ≤ n ≤ 700) — amount of vertices in the tree. The following n - 1 lines contain the description of the edges. Each line contains the pair of vertices' indexes, joined by an edge, ai, bi (1 ≤ ai, bi ≤ n). It's guaranteed that the graph described in the input is a tree.",
      "output_spec": "OutputOutput the only number — the maximum product of sizes of the connected components, that Bob can get after deleting some of the tree's edges.",
      "sample_tests": "ExamplesInputCopy51 22 33 44 5OutputCopy6InputCopy81 21 32 42 53 63 76 8OutputCopy18InputCopy31 21 3OutputCopy3",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains integer number n (1 ≤ n ≤ 700) — amount of vertices in the tree. The following n - 1 lines contain the description of the edges. Each line contains the pair of vertices' indexes, joined by an edge, ai, bi (1 ≤ ai, bi ≤ n). It's guaranteed that the graph described in the input is a tree.\n\nOutputOutput the only number — the maximum product of sizes of the connected components, that Bob can get after deleting some of the tree's edges.\n\nInputCopy51 22 33 44 5OutputCopy6InputCopy81 21 32 42 53 63 76 8OutputCopy18InputCopy31 21 3OutputCopy3\n\nInputCopy51 22 33 44 5\n\nOutputCopy6\n\nInputCopy81 21 32 42 53 63 76 8\n\nOutputCopy18\n\nInputCopy31 21 3\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Codeforces Beta Round #23 - Codeforces",
          "content": "Hi everybodyToday the author of the majority of problems is Dmitry Zhukov, many thanks to him for this. Also I want to thank Mike Mirzayanov for choosing problems for the contest and organizing it and Julia Satushina for the translation of the statements.Good luck! UPD: ProblemsFinal standingsWinner: saeedreza.seddighin",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/528",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 321
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces",
          "content": "A. You're given a string...Iterate over all substrings, starting with the longest ones, and for each one count the number of appearances. The complexity is O(L4) with a small multiplicative constant. B. PartyIt's clear that at least one person (the one with the least number of friends) will have to leave. We claim that at least two persons will leave. Indeed, suppose that only one person left, and he had d friends. Then all other people had more than d friends before he left, and after that they had less than d + 1 friends, i.e. not more than d. So, his leaving influenced the number of friends for every other person, which means that he was friends with everyone: d = N - 1. But he has fewer friends than everyone — a contradiction.So, the answer is not more than N - 2. We'll prove that it's possible for N - 2 people to stay (of course, if N > 1). The graph of friendship will be the following: take a complete graph on N vertices and delete one edge. Then the degrees of two vertices equal N - 2, and other degrees equal N - 1. After the first two vertices are removed, we have a complete graph on N - 2 vertices, and all degrees equal N - 3, which means that no one else will leave.C. Oranges and ApplesSort the boxes in increasing number of oranges. Count the total number of apples in boxes with odd and even numbers. If the boxes with odd numbers contain at least half of all apples, choose them (there are exactly N boxes with odd numbers). If the boxes with even numbers contain at least half of all apples, take them and the last box (which contains the largest number of oranges). It's easy to see that in both cases the conditions of the task are fulfilled.D. TetragonLet ABCD be the quadrangle that we're looking for, and K, L, and M be the middle points of equal sides AB, BC and CD, correspondingly. Let M' be the point symmetric to M with respect to L. Triangles BLM' and CLM are equal by two sides and angle, so BM' = CM = BL = BK, i. e. B is the circumcenter of the triangle KLM'. Knowing B, we can reconstruct the whole quadrangle, using the symmetries with respect to the points K, L, and M, and then check whether it satisfies all conditions.Note that we don't know which of the given points is L, so we need to check all 3 cases.E. TreeLemma. In one of optimal solutions there are no simple paths of length 3.Proof. We can remove the middle edge from such a path. The connected component will split into two components of sizes a and b, where a ≥ 2, b ≥ 2, and therefore ab ≥ a + b.We'll root the tree and calculate recursively the numbers hv = the solution of the problem for the subtree with the root v, and fv = the product of hu for all children of v. If v is a leaf, then hv = fv = 1.We show how to calculate hv, given the solution for all subtrees of v. Consider the connected component of v in an optimal solution. It follows from the lemma that the component has one of the following types:1. The single vertex v.2. The vertex v and several children of v.3. The vertex v, one child of v — w, and several children of w.In the first case the result of the game is fv.In the second case it equals Πfi · Πhj · k = Π(fi / hi) · fv · k, where i iterates over children belonging to the connected component, j iterates over the rest children, and k is the size of the component. Since we want to maximize the result, we're interested in children with the largest value of fi / hi. Therefore, the largest possible result in this case equals the maximum value of Πi ≤ s  (fi / hi) · fv · (s + 1), where it's supposed that the children are sorted in descending order of fi / hi.In the third case we can use a similar reasoning for every child w. The best result will be the maximum of the expression fv · (fw / hw) · Πi ≤ s (fi / hi) · (s + 2) as w iterates over children of v, and s iterates from 1 to the number of children of w; note that the children of w have already been sorted in the previous step.Therefore, the number of operations necessary to calculate fv is proportional to the total number of children and grandchildren of v, which is less than n. The complexity of the algorithm, then, is O(n2) (ignoring operations with long numbers).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/530",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4177
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 1",
          "code": "0:  []          leaf\n  1:  [[]]        two-chain\n  2:  [[][]]      1-fork-2\n  3:  [[][][]]    1-fork-3\n  k:  [[]...[]]   1-fork-k\n  -1: [[[]]]      three-chain\n  -2: [[[][]]]    1-1-fork-2\n  -3: [[[][][]]]  1-1-fork-3\n  -k: [[[]...[]]] 1-1-fork-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 2",
          "code": "0:  []          leaf\n  1:  [[]]        two-chain\n  2:  [[][]]      1-fork-2\n  3:  [[][][]]    1-fork-3\n  k:  [[]...[]]   1-fork-k\n  -1: [[[]]]      three-chain\n  -2: [[[][]]]    1-1-fork-2\n  -3: [[[][][]]]  1-1-fork-3\n  -k: [[[]...[]]] 1-1-fork-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 3",
          "code": "c0: number of 0s (leaves).\ncp: list of all positive cases (1-fork-k).\ncn: list of all negative cases (1-1-fork-k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 4",
          "code": "c0: number of 0s (leaves).\ncp: list of all positive cases (1-fork-k).\ncn: list of all negative cases (1-1-fork-k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 5",
          "code": "[[]] means a two-chain.\n[[[]]] means a three chain.\n[[][]] means a parent with two children.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #23 tutorial - Codeforces - Code 6",
          "code": "[[]] means a two-chain.\n[[[]]] means a three chain.\n[[][]] means a parent with two children.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/530",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 700;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n        return false;  // Cycle detected\n    parent[x] = y;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    parent.resize(n + 1); // 1-based indexing\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 1; i <= n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d is a loop: (%d, %d)\", i, a, b);\n\n        bool success = unite(a, b);\n        ensuref(success, \"Edge %d creates a cycle: (%d, %d)\", i, a, b);\n    }\n\n    // Check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"The graph is not connected; vertex %d is not connected to the rest\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 700;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n        return false;  // Cycle detected\n    parent[x] = y;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    parent.resize(n + 1); // 1-based indexing\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 1; i <= n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d is a loop: (%d, %d)\", i, a, b);\n\n        bool success = unite(a, b);\n        ensuref(success, \"Edge %d creates a cycle: (%d, %d)\", i, a, b);\n    }\n\n    // Check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"The graph is not connected; vertex %d is not connected to the rest\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 700;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n        return false;  // Cycle detected\n    parent[x] = y;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    parent.resize(n + 1); // 1-based indexing\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 1; i <= n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d is a loop: (%d, %d)\", i, a, b);\n\n        bool success = unite(a, b);\n        ensuref(success, \"Edge %d creates a cycle: (%d, %d)\", i, a, b);\n    }\n\n    // Check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"The graph is not connected; vertex %d is not connected to the rest\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case for the described tree problem.\n  Usage:\n    ./gen -n <number_of_vertices> -type <tree_shape>\n\n  The valid values for \"type\" are:\n    1) chain    -> a chain (path) of length n-1\n    2) star     -> a star (one central node connected to all others)\n    3) random   -> a random tree (parent of i is rnd.next(i))\n    4) binary   -> a \"complete\" binary-like tree\n    5) special  -> a \"special\" shaped tree, part chain and part star (for example)\n\n  The generator:\n    - prints one integer n in the first line,\n    - then prints n-1 lines describing edges (in 1-based indexing).\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Parent array: p[i] is the parent of node i, for i from 1..n-1\n    // (Node 0 has no parent.)\n    vector<int> p(n);\n\n    // Corner case: If n == 1, there are no edges. Just print \"1\" and exit.\n    if (n == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    if (type == \"chain\") {\n        // Create a chain 0 - 1 - 2 - ... - (n-1)\n        for (int i = 1; i < n; i++) {\n            p[i] = i - 1;\n        }\n    }\n    else if (type == \"star\") {\n        // Create a star: parent(i) = 0 for i >= 1\n        for (int i = 1; i < n; i++) {\n            p[i] = 0;\n        }\n    }\n    else if (type == \"binary\") {\n        // Create a \"complete\" binary-like tree\n        // For i >= 1, p[i] = floor((i-1)/2)\n        for (int i = 1; i < n; i++) {\n            p[i] = (i - 1) / 2;\n        }\n    }\n    else if (type == \"special\") {\n        // A \"special\" shape: half of the nodes form a chain, \n        // and the other half are attached directly to node 0 (star style).\n        // Just as an example of a special shape that could catch corner cases.\n        // Split point sp = n/2\n        int sp = n / 2;\n        for (int i = 1; i < sp; i++) {\n            // chain among the first sp nodes\n            p[i] = i - 1;\n        }\n        for (int i = sp; i < n; i++) {\n            // star for the remaining portion\n            p[i] = 0;\n        }\n    }\n    else {\n        // Default: random tree\n        // p[i] = rnd.next(i) for i in [1..n-1]\n        for (int i = 1; i < n; i++) {\n            p[i] = rnd.next(i);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // We'll shuffle the vertex labels (0..n-1) to avoid code that only passes in simple labeled structures.\n    vector<int> perm(n);\n    iota(perm.begin(), perm.end(), 0);\n    shuffle(perm.begin() + 1, perm.end());  // keep 0 in place or not, either is fine, but let's be consistent with example\n\n    // Build edge list\n    vector<pair<int,int>> edges;\n    edges.reserve(n - 1);\n\n    // Each i from 1..n-1 has an edge with p[i]\n    for (int i = 1; i < n; i++) {\n        int u = perm[i];\n        int v = perm[p[i]];\n        // random direction flip (not strictly necessary, but done to vary outputs)\n        if (rnd.next(2)) {\n            edges.push_back({u, v});\n        } else {\n            edges.push_back({v, u});\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Print edges in 1-based indexing\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case for the described tree problem.\n  Usage:\n    ./gen -n <number_of_vertices> -type <tree_shape>\n\n  The valid values for \"type\" are:\n    1) chain    -> a chain (path) of length n-1\n    2) star     -> a star (one central node connected to all others)\n    3) random   -> a random tree (parent of i is rnd.next(i))\n    4) binary   -> a \"complete\" binary-like tree\n    5) special  -> a \"special\" shaped tree, part chain and part star (for example)\n\n  The generator:\n    - prints one integer n in the first line,\n    - then prints n-1 lines describing edges (in 1-based indexing).\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Parent array: p[i] is the parent of node i, for i from 1..n-1\n    // (Node 0 has no parent.)\n    vector<int> p(n);\n\n    // Corner case: If n == 1, there are no edges. Just print \"1\" and exit.\n    if (n == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    if (type == \"chain\") {\n        // Create a chain 0 - 1 - 2 - ... - (n-1)\n        for (int i = 1; i < n; i++) {\n            p[i] = i - 1;\n        }\n    }\n    else if (type == \"star\") {\n        // Create a star: parent(i) = 0 for i >= 1\n        for (int i = 1; i < n; i++) {\n            p[i] = 0;\n        }\n    }\n    else if (type == \"binary\") {\n        // Create a \"complete\" binary-like tree\n        // For i >= 1, p[i] = floor((i-1)/2)\n        for (int i = 1; i < n; i++) {\n            p[i] = (i - 1) / 2;\n        }\n    }\n    else if (type == \"special\") {\n        // A \"special\" shape: half of the nodes form a chain, \n        // and the other half are attached directly to node 0 (star style).\n        // Just as an example of a special shape that could catch corner cases.\n        // Split point sp = n/2\n        int sp = n / 2;\n        for (int i = 1; i < sp; i++) {\n            // chain among the first sp nodes\n            p[i] = i - 1;\n        }\n        for (int i = sp; i < n; i++) {\n            // star for the remaining portion\n            p[i] = 0;\n        }\n    }\n    else {\n        // Default: random tree\n        // p[i] = rnd.next(i) for i in [1..n-1]\n        for (int i = 1; i < n; i++) {\n            p[i] = rnd.next(i);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // We'll shuffle the vertex labels (0..n-1) to avoid code that only passes in simple labeled structures.\n    vector<int> perm(n);\n    iota(perm.begin(), perm.end(), 0);\n    shuffle(perm.begin() + 1, perm.end());  // keep 0 in place or not, either is fine, but let's be consistent with example\n\n    // Build edge list\n    vector<pair<int,int>> edges;\n    edges.reserve(n - 1);\n\n    // Each i from 1..n-1 has an edge with p[i]\n    for (int i = 1; i < n; i++) {\n        int u = perm[i];\n        int v = perm[p[i]];\n        // random direction flip (not strictly necessary, but done to vary outputs)\n        if (rnd.next(2)) {\n            edges.push_back({u, v});\n        } else {\n            edges.push_back({v, u});\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Print edges in 1-based indexing\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Very small trees\n./gen -n 1 -type chain\n./gen -n 2 -type chain\n./gen -n 3 -type star\n./gen -n 5 -type random\n./gen -n 5 -type special\n\n# Moderate trees\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type random\n./gen -n 10 -type binary\n./gen -n 10 -type special\n\n# Larger trees\n./gen -n 20 -type special\n./gen -n 50 -type chain\n./gen -n 50 -type random\n./gen -n 50 -type binary\n./gen -n 100 -type special\n\n# Even larger\n./gen -n 200 -type random\n./gen -n 300 -type chain\n./gen -n 400 -type star\n./gen -n 700 -type random\n./gen -n 700 -type binary\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:38.149060",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "230/A",
      "title": "A. Dragons",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers s and n (1 ≤ s ≤ 104, 1 ≤ n ≤ 103). Then n lines follow: the i-th line contains space-separated integers xi and yi (1 ≤ xi ≤ 104, 0 ≤ yi ≤ 104) — the i-th dragon's strength and the bonus for defeating it.",
      "output_spec": "OutputOn a single line print \"YES\" (without the quotes), if Kirito can move on to the next level and print \"NO\" (without the quotes), if he can't.",
      "sample_tests": "ExamplesInputCopy2 21 99100 0OutputCopyYESInputCopy10 1100 100OutputCopyNO",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers s and n (1 ≤ s ≤ 104, 1 ≤ n ≤ 103). Then n lines follow: the i-th line contains space-separated integers xi and yi (1 ≤ xi ≤ 104, 0 ≤ yi ≤ 104) — the i-th dragon's strength and the bonus for defeating it.\n\nOutputOn a single line print \"YES\" (without the quotes), if Kirito can move on to the next level and print \"NO\" (without the quotes), if he can't.\n\nInputCopy2 21 99100 0OutputCopyYESInputCopy10 1100 100OutputCopyNO\n\nInputCopy2 21 99100 0\n\nOutputCopyYES\n\nInputCopy10 1100 100\n\nOutputCopyNO\n\nNoteIn the first sample Kirito's strength initially equals 2. As the first dragon's strength is less than 2, Kirito can fight it and defeat it. After that he gets the bonus and his strength increases to 2 + 99 = 101. Now he can defeat the second dragon and move on to the next level.In the second sample Kirito's strength is too small to defeat the only dragon and win.",
      "solutions": [
        {
          "title": "Codeforces Round #142 - Codeforces",
          "content": "Hello everyone!Codeforces Round #142 will be held today at 19:30 in Moscow time, and it will take place in both divisions.The authors of the problems are me, Evgeny Vihrov (gen), and Andrey Vihrov (andreyv). Both of us are students of the Faculty of Computing in the University of Latvia. This is our very first contest on Codeforces!Big thanks for the help in preparing the contest go to Gerald Agapov (Gerald), and to Maria Belova (Delinur) — for translating the problem statements in English. Also thanks to Mikhail Mirzayanov (MikeMirzayanov) for the Polygon system, which we found to be great for preparing contest problems.We hope that each participant will be able find a problem to match his taste. Please, consider reading all the problems!We wish you an exciting round!UPD1: The score distribution will be dynamic. The problems will be sorted in order of expected increasing difficulty.UPD2: Due to the technical problems the contest was extended by 5 minutes. We are sorry for the inconvinience.UPD3: The analysis of the contest is available. Enjoy!The round is over! 5 contestants solved all the problems in division 1, and in division 2 only the top four contestants solved all the tasks. Congratulations to the winners!Div I YuukaKazami peter50216 kelvin takaramono Martin Div II coquelicot llj_bash kb. niukuo Petar",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5432",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1330
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces",
          "content": "Div. 2 A — DragonsObserve that if Kirito fights a dragon whose strength is less than Kirito's strength, then Kirito does not lose anything — in fact, he even gains a nonnegative strength increase. Taking note of this, let's for each step choose some dragon whose strength is less than Kirito's current strength, and fight it. After performing some amount of these steps we'll eventually end up in one of these two situations: either all dragons are slain (then the answer is \"YES\"), or only dragons whose strength is not less than Kirito's strength remain (then the answer is \"NO\"). On each step we can choose a suitable dragon to fight either by searching through all dragons or by sorting the dragons by strength in non-descending order in advance.The complexity of the solution is O(n2) or . Sample solution: http://pastie.org/4897164 (archived copy)  Div. 2 B — T-primesIt can be shown that only squares of prime numbers are T-primes, and that there are not too many of them — as many as there are prime numbers not greater than . Precompute these numbers (using, for example, the sieve of Eratosthenes) and store them in an array or an std::set, then we can answer each query by simply checking whether the number in question is amongst the precomputed numbers.The complexity of the solution is linear in relation to n — or , where d = 1012 (one can also get a tighter bound). Sample solution: http://pastie.org/4897166 (archived copy)Div. 1 A — ShiftsLet's compute the minimum number of operations needed to get all 1s in each of the m columns. For this, traverse each row twice — one time to the left and one time to the right, recording the index of the nearest cell with 1 (in corresponding direction) for each column in this row. Then the number of operations for any particular column is the sum of the computed values over all rows. In turn, the answer to the problem is the minimal value of these sums.The complexity of the solution is O(nm). Sample solution: http://pastie.org/4897169 (archived copy)Div. 1 B — PlanetsObserve that when we visit some planet, the best strategy is to arrive as early as we can and then wait for the nearest free moment of time to move further. Hence this problem can be solved with the Dijkstra's algorithm by slightly altering the definition of a shortest distance. When we process a planet (meaning that we already know the minimum time needed to reach it), we need to check the array of arrival times for this planet and find the first moment of time in which we can leave this planet — this will be the distance that we will be adding to outgoing paths from this planet. It's clear that we will traverse each array of arrival times no more than once. Additionally, one must pay attention to these cases: when a traveller arrives to planet 1 at time 0 (then Jack has to wait) and when a traveller arrives to planet n at the same time as Jack (then Jack needs not to wait).The complexity of the solution — . Sample solution: http://pastie.org/4897171 (archived copy)Div. 1 C — TrianglesLet's call Alice's edges simply edges, and Bob's edges the antiedges. For each edge pair of the initial complete graph that pass through the same vertices, assign a weight: for each pair of edges the weight +2, for each pair of edge and antiedge −1 and for each pair of antiedges +2. Now calculate the sum of all the weights. Observe that each Alice's or Bob's triangle adds exactly +6 to the sum, and each combination of three vertices that do not form the triangle in any of the two graphs adds exactly 0 to the sum. The sum itself is calculated by iterating over all vertices and adding the total weight of all the edge pairs that pass through this vertex. If the degree of the vertex is d, then we should add d(d - 1) - d(n - d - 1) + (n - d - 1)(n - d - 2) to the final sum. Since each triangle adds +6 to the sum, then the answer is equal to the sum divided by 6.The complexity of the solution is O(n + m). Sample solution: http://pastie.org/4897512 (archived copy)Div. 1 D — TowersLet's calculate the dynamics d[i][k] — the minimal possible height of the last tower that we can obtain by merging the first i left towers into at least k towers. Assume we already have calculated the dynamics' values for the first i towers. Now we iterate over the all possible tower intervals [i + 1;j]; say the sum in the pending interval is equal to s. Now we find the greatest k such that d[i][k] is not greater than s. Then we update the value of d[j][k+1] to the minimum of s and d[j][k+1]. Notice that when k increases the values d[i][k] do not decrease. Because of that we can iterate over intervals in the decreasing value of j, and corresponding k can be found using a single pointer over values of d[i][k].When we arrive in the position j during the dynamics, some of the d[j][k] values are updated, but some are still not. Using the same observation that along with the increasing of k the values d[j][k] do not decrease as well, we can make a single run over the values of k in the decreasing order and update the dynamics' values as follows: d[j][k] := min(d[j][k], d[j][k+1]). This is done in the beginning of the dynamics' iteration.In the end we can find the greatest k for which there exists an answer among the values of d[n][k]. The answer to the problem then is n - k.The complexity of the solution is O(n2). Sample solution: http://pastie.org/4897515 (archived copy)Div. 1 E — GiftsFirst let's establish some facts that we will use in the solution. With how much probability can the fisherman get a particular set of gifts, among which there are ai gifts of i-th name? In total there are such sets, since there are exactly subsets of gifts with i-th name of size ai, and two different names are independent during the gold fish's choice. Then the described particular set of gifts we can get with the probability of , by asking ai gifts of i-th name.Now we know the probability p of obtaining one particular gift set A. Now observe that from p we can calculate the probabiltity p' of obtaining the set A along with some one other gift of x-th name in constant time. Say there are already ax elements of x-th name in A. Using the formula from the first paragraph, we can deduce that: Let's solve the main problem now. We sort all the gifts in descending order of their prices. It is clear that the fisherman will definitely ask the names of all the gifts among the first n ones whose prices are not equal to the price of the n-th gift in the list. Let's say that this set of gifts is the base, and it has b elements. Then there is still n - b unchosen gifts, and we know that all of them will have the price equal to the price of the n-th gift in the list. Say the price of the n-th gift is d, and there are exactly s gifts with the price d (keep in mind that each of them has a different name); also call these gifts dubious. We can also deduce that the fisherman can make different decisions, where l = n - b.So now we have some s dubious gifts with the price of d; let's enumerate them in any order. We calculate the dynamics f(x, y) — the cumulative probability of obtaining n most valuable gifts, if there are x chosen from the first y in the list. It is clear that f(0, 0) = p, and f(l, s) contains the answer to the problem. Using the coefficients we have deduced earlier, we get two transitions in the dynamics: , if we add y + 1-th dubious gift to the set of x chosen among the first y dubious gifts; , otherwise, if do not put the y + 1-th dubious gift. This dynamics can be computed in O(t2) time, where t is the total number of gifts. The complexity of the solution is . Sample solution: http://pastie.org/4897519 (archived copy)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7684
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #142 - Codeforces - Code 1",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 2",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 3",
          "code": "\\_dangerous\\_",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 4",
          "code": "double temp = pow((double)n, 0.5);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 5",
          "code": "long long square_root = (long long)(temp);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces - Code 1",
          "code": "d[j][k] := min(d[j][k], d[j][k+1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int s = inf.readInt(1, 10000, \"s\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 10000, \"xi[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 10000, \"yi[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();    \n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int s = inf.readInt(1, 10000, \"s\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 10000, \"xi[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 10000, \"yi[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();    \n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int s = inf.readInt(1, 10000, \"s\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 10000, \"xi[\" + to_string(i+1) + \"]\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 10000, \"yi[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();    \n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xs(n), ys(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            xs[i] = rnd.next(1, 10000);\n            ys[i] = rnd.next(0, 10000);\n        }\n    } else if (type == \"impossible\") {\n        for(int i = 0; i < n; ++i) {\n            xs[i] = rnd.next(s, 10000); // xi >= s, Kirito cannot defeat any dragon\n            ys[i] = rnd.next(0, 10000);\n        }\n    } else if (type == \"sorted_up\") {\n        int curr_s = s;\n        for(int i = 0; i < n; ++i) {\n            xs[i] = max(1, curr_s - 1);\n            ys[i] = rnd.next(1, 10000);\n            curr_s += ys[i];\n        }\n        sort(xs.begin(), xs.end());\n    } else if (type == \"sorted_down\") {\n        int curr_s = s;\n        for(int i = 0; i < n; ++i) {\n            xs[i] = max(1, curr_s - 1);\n            ys[i] = rnd.next(1, 10000);\n            curr_s += ys[i];\n        }\n        sort(xs.rbegin(), xs.rend());\n    } else if (type == \"same_strength\") {\n        int xi = rnd.next(1, 10000);\n        for(int i = 0; i < n; ++i) {\n            xs[i] = xi;\n            ys[i] = rnd.next(0, 10000);\n        }\n    } else if (type == \"optim_order_needed\") {\n        vector<pair<int, int>> dragons(n);\n        int curr_s = s;\n        for(int i = 0; i < n; ++i) {\n            int xi = curr_s + rnd.next(-5, 5);\n            xi = max(1, xi);\n            ys[i] = rnd.next(1, 10000);\n            dragons[i] = make_pair(xi, ys[i]);\n        }\n        shuffle(dragons.begin(), dragons.end());\n        for(int i = 0; i < n; ++i) {\n            xs[i] = dragons[i].first;\n            ys[i] = dragons[i].second;\n        }\n    } else {\n        // Default: generate random data\n        for(int i = 0; i < n; ++i) {\n            xs[i] = rnd.next(1, 10000);\n            ys[i] = rnd.next(0, 10000);\n        }\n    }\n\n    printf(\"%d %d\\n\", s, n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", xs[i], ys[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xs(n), ys(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            xs[i] = rnd.next(1, 10000);\n            ys[i] = rnd.next(0, 10000);\n        }\n    } else if (type == \"impossible\") {\n        for(int i = 0; i < n; ++i) {\n            xs[i] = rnd.next(s, 10000); // xi >= s, Kirito cannot defeat any dragon\n            ys[i] = rnd.next(0, 10000);\n        }\n    } else if (type == \"sorted_up\") {\n        int curr_s = s;\n        for(int i = 0; i < n; ++i) {\n            xs[i] = max(1, curr_s - 1);\n            ys[i] = rnd.next(1, 10000);\n            curr_s += ys[i];\n        }\n        sort(xs.begin(), xs.end());\n    } else if (type == \"sorted_down\") {\n        int curr_s = s;\n        for(int i = 0; i < n; ++i) {\n            xs[i] = max(1, curr_s - 1);\n            ys[i] = rnd.next(1, 10000);\n            curr_s += ys[i];\n        }\n        sort(xs.rbegin(), xs.rend());\n    } else if (type == \"same_strength\") {\n        int xi = rnd.next(1, 10000);\n        for(int i = 0; i < n; ++i) {\n            xs[i] = xi;\n            ys[i] = rnd.next(0, 10000);\n        }\n    } else if (type == \"optim_order_needed\") {\n        vector<pair<int, int>> dragons(n);\n        int curr_s = s;\n        for(int i = 0; i < n; ++i) {\n            int xi = curr_s + rnd.next(-5, 5);\n            xi = max(1, xi);\n            ys[i] = rnd.next(1, 10000);\n            dragons[i] = make_pair(xi, ys[i]);\n        }\n        shuffle(dragons.begin(), dragons.end());\n        for(int i = 0; i < n; ++i) {\n            xs[i] = dragons[i].first;\n            ys[i] = dragons[i].second;\n        }\n    } else {\n        // Default: generate random data\n        for(int i = 0; i < n; ++i) {\n            xs[i] = rnd.next(1, 10000);\n            ys[i] = rnd.next(0, 10000);\n        }\n    }\n\n    printf(\"%d %d\\n\", s, n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", xs[i], ys[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases where Kirito cannot defeat any dragon\n./gen -s 1 -n 1 -type impossible\n./gen -s 10000 -n 1000 -type impossible\n./gen -s 5000 -n 500 -type impossible\n\n# Random test cases of various sizes\n./gen -s 1 -n 1 -type random\n./gen -s 10 -n 10 -type random\n./gen -s 100 -n 100 -type random\n./gen -s 1000 -n 1000 -type random\n./gen -s 10000 -n 1000 -type random\n\n# Test cases with dragons sorted in ascending order of strength\n./gen -s 10 -n 10 -type sorted_up\n./gen -s 100 -n 100 -type sorted_up\n./gen -s 1000 -n 1000 -type sorted_up\n\n# Test cases with dragons sorted in descending order of strength\n./gen -s 10 -n 10 -type sorted_down\n./gen -s 100 -n 100 -type sorted_down\n./gen -s 1000 -n 1000 -type sorted_down\n\n# Test cases where all dragons have the same strength\n./gen -s 5000 -n 10 -type same_strength\n./gen -s 5000 -n 100 -type same_strength\n./gen -s 5000 -n 1000 -type same_strength\n\n# Test cases where Kirito needs to choose the optimal order to win\n./gen -s 5 -n 10 -type optim_order_needed\n./gen -s 50 -n 100 -type optim_order_needed\n./gen -s 500 -n 1000 -type optim_order_needed\n\n# Test cases with minimum initial strength\n./gen -s 1 -n 1000 -type random\n./gen -s 1 -n 500 -type random\n\n# Test cases with maximum initial strength\n./gen -s 10000 -n 1000 -type random\n./gen -s 10000 -n 500 -type random\n\n# Additional random test cases with mixed parameters\n./gen -s 1234 -n 987 -type random\n./gen -s 4321 -n 789 -type random\n./gen -s 2500 -n 750 -type random\n\n# Additional impossible cases\n./gen -s 1 -n 1000 -type impossible\n./gen -s 5000 -n 1000 -type impossible\n\n# Test cases to check edge conditions\n./gen -s 2 -n 2 -type random\n./gen -s 9999 -n 999 -type random\n./gen -s 1 -n 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:40.275586",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "230/B",
      "title": "B. T-primes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single positive integer, n (1 ≤ n ≤ 105), showing how many numbers are in the array. The next line contains n space-separated integers xi (1 ≤ xi ≤ 1012).Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint n lines: the i-th line should contain \"YES\" (without the quotes), if number xi is Т-prime, and \"NO\" (without the quotes), if it isn't.",
      "sample_tests": "ExamplesInputCopy34 5 6OutputCopyYESNONO",
      "description": "B. T-primes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single positive integer, n (1 ≤ n ≤ 105), showing how many numbers are in the array. The next line contains n space-separated integers xi (1 ≤ xi ≤ 1012).Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.\n\nOutputPrint n lines: the i-th line should contain \"YES\" (without the quotes), if number xi is Т-prime, and \"NO\" (without the quotes), if it isn't.\n\nInputCopy34 5 6OutputCopyYESNONO\n\nInputCopy34 5 6\n\nOutputCopyYESNONO\n\nNoteThe given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is \"YES\". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is \"NO\".",
      "solutions": [
        {
          "title": "Codeforces Round #142 - Codeforces",
          "content": "Hello everyone!Codeforces Round #142 will be held today at 19:30 in Moscow time, and it will take place in both divisions.The authors of the problems are me, Evgeny Vihrov (gen), and Andrey Vihrov (andreyv). Both of us are students of the Faculty of Computing in the University of Latvia. This is our very first contest on Codeforces!Big thanks for the help in preparing the contest go to Gerald Agapov (Gerald), and to Maria Belova (Delinur) — for translating the problem statements in English. Also thanks to Mikhail Mirzayanov (MikeMirzayanov) for the Polygon system, which we found to be great for preparing contest problems.We hope that each participant will be able find a problem to match his taste. Please, consider reading all the problems!We wish you an exciting round!UPD1: The score distribution will be dynamic. The problems will be sorted in order of expected increasing difficulty.UPD2: Due to the technical problems the contest was extended by 5 minutes. We are sorry for the inconvinience.UPD3: The analysis of the contest is available. Enjoy!The round is over! 5 contestants solved all the problems in division 1, and in division 2 only the top four contestants solved all the tasks. Congratulations to the winners!Div I YuukaKazami peter50216 kelvin takaramono Martin Div II coquelicot llj_bash kb. niukuo Petar",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5432",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1330
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces",
          "content": "Div. 2 A — DragonsObserve that if Kirito fights a dragon whose strength is less than Kirito's strength, then Kirito does not lose anything — in fact, he even gains a nonnegative strength increase. Taking note of this, let's for each step choose some dragon whose strength is less than Kirito's current strength, and fight it. After performing some amount of these steps we'll eventually end up in one of these two situations: either all dragons are slain (then the answer is \"YES\"), or only dragons whose strength is not less than Kirito's strength remain (then the answer is \"NO\"). On each step we can choose a suitable dragon to fight either by searching through all dragons or by sorting the dragons by strength in non-descending order in advance.The complexity of the solution is O(n2) or . Sample solution: http://pastie.org/4897164 (archived copy)  Div. 2 B — T-primesIt can be shown that only squares of prime numbers are T-primes, and that there are not too many of them — as many as there are prime numbers not greater than . Precompute these numbers (using, for example, the sieve of Eratosthenes) and store them in an array or an std::set, then we can answer each query by simply checking whether the number in question is amongst the precomputed numbers.The complexity of the solution is linear in relation to n — or , where d = 1012 (one can also get a tighter bound). Sample solution: http://pastie.org/4897166 (archived copy)Div. 1 A — ShiftsLet's compute the minimum number of operations needed to get all 1s in each of the m columns. For this, traverse each row twice — one time to the left and one time to the right, recording the index of the nearest cell with 1 (in corresponding direction) for each column in this row. Then the number of operations for any particular column is the sum of the computed values over all rows. In turn, the answer to the problem is the minimal value of these sums.The complexity of the solution is O(nm). Sample solution: http://pastie.org/4897169 (archived copy)Div. 1 B — PlanetsObserve that when we visit some planet, the best strategy is to arrive as early as we can and then wait for the nearest free moment of time to move further. Hence this problem can be solved with the Dijkstra's algorithm by slightly altering the definition of a shortest distance. When we process a planet (meaning that we already know the minimum time needed to reach it), we need to check the array of arrival times for this planet and find the first moment of time in which we can leave this planet — this will be the distance that we will be adding to outgoing paths from this planet. It's clear that we will traverse each array of arrival times no more than once. Additionally, one must pay attention to these cases: when a traveller arrives to planet 1 at time 0 (then Jack has to wait) and when a traveller arrives to planet n at the same time as Jack (then Jack needs not to wait).The complexity of the solution — . Sample solution: http://pastie.org/4897171 (archived copy)Div. 1 C — TrianglesLet's call Alice's edges simply edges, and Bob's edges the antiedges. For each edge pair of the initial complete graph that pass through the same vertices, assign a weight: for each pair of edges the weight +2, for each pair of edge and antiedge −1 and for each pair of antiedges +2. Now calculate the sum of all the weights. Observe that each Alice's or Bob's triangle adds exactly +6 to the sum, and each combination of three vertices that do not form the triangle in any of the two graphs adds exactly 0 to the sum. The sum itself is calculated by iterating over all vertices and adding the total weight of all the edge pairs that pass through this vertex. If the degree of the vertex is d, then we should add d(d - 1) - d(n - d - 1) + (n - d - 1)(n - d - 2) to the final sum. Since each triangle adds +6 to the sum, then the answer is equal to the sum divided by 6.The complexity of the solution is O(n + m). Sample solution: http://pastie.org/4897512 (archived copy)Div. 1 D — TowersLet's calculate the dynamics d[i][k] — the minimal possible height of the last tower that we can obtain by merging the first i left towers into at least k towers. Assume we already have calculated the dynamics' values for the first i towers. Now we iterate over the all possible tower intervals [i + 1;j]; say the sum in the pending interval is equal to s. Now we find the greatest k such that d[i][k] is not greater than s. Then we update the value of d[j][k+1] to the minimum of s and d[j][k+1]. Notice that when k increases the values d[i][k] do not decrease. Because of that we can iterate over intervals in the decreasing value of j, and corresponding k can be found using a single pointer over values of d[i][k].When we arrive in the position j during the dynamics, some of the d[j][k] values are updated, but some are still not. Using the same observation that along with the increasing of k the values d[j][k] do not decrease as well, we can make a single run over the values of k in the decreasing order and update the dynamics' values as follows: d[j][k] := min(d[j][k], d[j][k+1]). This is done in the beginning of the dynamics' iteration.In the end we can find the greatest k for which there exists an answer among the values of d[n][k]. The answer to the problem then is n - k.The complexity of the solution is O(n2). Sample solution: http://pastie.org/4897515 (archived copy)Div. 1 E — GiftsFirst let's establish some facts that we will use in the solution. With how much probability can the fisherman get a particular set of gifts, among which there are ai gifts of i-th name? In total there are such sets, since there are exactly subsets of gifts with i-th name of size ai, and two different names are independent during the gold fish's choice. Then the described particular set of gifts we can get with the probability of , by asking ai gifts of i-th name.Now we know the probability p of obtaining one particular gift set A. Now observe that from p we can calculate the probabiltity p' of obtaining the set A along with some one other gift of x-th name in constant time. Say there are already ax elements of x-th name in A. Using the formula from the first paragraph, we can deduce that: Let's solve the main problem now. We sort all the gifts in descending order of their prices. It is clear that the fisherman will definitely ask the names of all the gifts among the first n ones whose prices are not equal to the price of the n-th gift in the list. Let's say that this set of gifts is the base, and it has b elements. Then there is still n - b unchosen gifts, and we know that all of them will have the price equal to the price of the n-th gift in the list. Say the price of the n-th gift is d, and there are exactly s gifts with the price d (keep in mind that each of them has a different name); also call these gifts dubious. We can also deduce that the fisherman can make different decisions, where l = n - b.So now we have some s dubious gifts with the price of d; let's enumerate them in any order. We calculate the dynamics f(x, y) — the cumulative probability of obtaining n most valuable gifts, if there are x chosen from the first y in the list. It is clear that f(0, 0) = p, and f(l, s) contains the answer to the problem. Using the coefficients we have deduced earlier, we get two transitions in the dynamics: , if we add y + 1-th dubious gift to the set of x chosen among the first y dubious gifts; , otherwise, if do not put the y + 1-th dubious gift. This dynamics can be computed in O(t2) time, where t is the total number of gifts. The complexity of the solution is . Sample solution: http://pastie.org/4897519 (archived copy)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7684
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #142 - Codeforces - Code 1",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 2",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 3",
          "code": "\\_dangerous\\_",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 4",
          "code": "double temp = pow((double)n, 0.5);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 5",
          "code": "long long square_root = (long long)(temp);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces - Code 1",
          "code": "d[j][k] := min(d[j][k], d[j][k+1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<long long> xi = inf.readLongs(n, 1LL, 1000000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<long long> xi = inf.readLongs(n, 1LL, 1000000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<long long> xi = inf.readLongs(n, 1LL, 1000000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate primes up to 1e6\n    int MAX_N = 1000001;\n    vector<bool> is_prime(MAX_N, true);\n    vector<int> primes;\n    vector<int> composites;\n    is_prime[0] = is_prime[1] = false;\n    for(int i=2; i<MAX_N; i++) {\n        if(is_prime[i]) {\n            primes.push_back(i);\n            for(long long j=(long long)i*i; j<MAX_N; j+=i)\n                is_prime[j] = false;\n        } else {\n            composites.push_back(i);\n        }\n    }\n\n    // Precompute T-primes (squares of primes)\n    set<long long> tprimes;\n    for(int p : primes) {\n        tprimes.insert((long long)p * p);\n    }\n\n    vector<long long> xi(n);\n    if(type == \"random\") {\n        for(int i=0; i<n; i++) {\n            xi[i] = rnd.next(1LL, 1000000000000LL);\n        }\n    } else if(type == \"all_tprime\") {\n        for(int i=0; i<n; i++) {\n            int p = primes[rnd.next(0, (int)primes.size()-1)];\n            xi[i] = (long long)p * p;\n        }\n    } else if(type == \"all_nontprime\") {\n        for(int i=0; i<n; i++) {\n            long long num;\n            while(true) {\n                num = rnd.next(1LL, 1000000000000LL);\n                if(tprimes.count(num)==0)\n                    break;\n                // Else regenerate\n            }\n            xi[i] = num;\n        }\n    } else if(type == \"ones\") {\n        for(int i=0; i<n; i++) {\n            xi[i] = 1;\n        }\n    } else if(type == \"max\") {\n        for(int i=0; i<n; i++) {\n            xi[i] = 1000000000000LL;\n        }\n    } else if(type == \"composite_squares\") {\n        for(int i=0; i<n; i++) {\n            int c = composites[rnd.next(0, (int)composites.size()-1)];\n            xi[i] = (long long)c * c;\n        }\n    } else {\n        // If unknown type, default to random\n        for(int i=0; i<n; i++) {\n            xi[i] = rnd.next(1LL, 1000000000000LL);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output xi\n    for(int i=0; i<n; i++) {\n        printf(\"%lld\", xi[i]);\n        if(i+1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate primes up to 1e6\n    int MAX_N = 1000001;\n    vector<bool> is_prime(MAX_N, true);\n    vector<int> primes;\n    vector<int> composites;\n    is_prime[0] = is_prime[1] = false;\n    for(int i=2; i<MAX_N; i++) {\n        if(is_prime[i]) {\n            primes.push_back(i);\n            for(long long j=(long long)i*i; j<MAX_N; j+=i)\n                is_prime[j] = false;\n        } else {\n            composites.push_back(i);\n        }\n    }\n\n    // Precompute T-primes (squares of primes)\n    set<long long> tprimes;\n    for(int p : primes) {\n        tprimes.insert((long long)p * p);\n    }\n\n    vector<long long> xi(n);\n    if(type == \"random\") {\n        for(int i=0; i<n; i++) {\n            xi[i] = rnd.next(1LL, 1000000000000LL);\n        }\n    } else if(type == \"all_tprime\") {\n        for(int i=0; i<n; i++) {\n            int p = primes[rnd.next(0, (int)primes.size()-1)];\n            xi[i] = (long long)p * p;\n        }\n    } else if(type == \"all_nontprime\") {\n        for(int i=0; i<n; i++) {\n            long long num;\n            while(true) {\n                num = rnd.next(1LL, 1000000000000LL);\n                if(tprimes.count(num)==0)\n                    break;\n                // Else regenerate\n            }\n            xi[i] = num;\n        }\n    } else if(type == \"ones\") {\n        for(int i=0; i<n; i++) {\n            xi[i] = 1;\n        }\n    } else if(type == \"max\") {\n        for(int i=0; i<n; i++) {\n            xi[i] = 1000000000000LL;\n        }\n    } else if(type == \"composite_squares\") {\n        for(int i=0; i<n; i++) {\n            int c = composites[rnd.next(0, (int)composites.size()-1)];\n            xi[i] = (long long)c * c;\n        }\n    } else {\n        // If unknown type, default to random\n        for(int i=0; i<n; i++) {\n            xi[i] = rnd.next(1LL, 1000000000000LL);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output xi\n    for(int i=0; i<n; i++) {\n        printf(\"%lld\", xi[i]);\n        if(i+1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type ones\n./gen -n 1 -type all_tprime\n./gen -n 1 -type all_nontprime\n./gen -n 1 -type composite_squares\n\n./gen -n 2 -type random\n./gen -n 2 -type ones\n\n./gen -n 3 -type all_tprime\n./gen -n 3 -type composite_squares\n\n./gen -n 10 -type random\n./gen -n 10 -type all_tprime\n./gen -n 10 -type all_nontprime\n\n./gen -n 100 -type random\n./gen -n 100 -type all_tprime\n./gen -n 100 -type all_nontprime\n./gen -n 100 -type composite_squares\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_tprime\n./gen -n 1000 -type all_nontprime\n./gen -n 1000 -type ones\n./gen -n 1000 -type max\n\n./gen -n 10000 -type random\n./gen -n 10000 -type all_tprime\n./gen -n 10000 -type all_nontprime\n./gen -n 10000 -type composite_squares\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_tprime\n./gen -n 100000 -type all_nontprime\n./gen -n 100000 -type max\n./gen -n 100000 -type ones\n./gen -n 100000 -type composite_squares\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:42.187278",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "230/C",
      "title": "C. Shifts",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers: n (1 ≤ n ≤ 100) — the number of rows in the table and m (1 ≤ m ≤ 104) — the number of columns in the table. Then n lines follow, each of them contains m characters \"0\" or \"1\": the j-th character of the i-th line describes the contents of the cell in the i-th row and in the j-th column of the table.It is guaranteed that the description of the table contains no other characters besides \"0\" and \"1\".",
      "output_spec": "OutputPrint a single number: the minimum number of moves needed to get only numbers 1 in some column of the table. If this is impossible, print -1.",
      "sample_tests": "ExamplesInputCopy3 6101010000100100000OutputCopy3InputCopy2 3111000OutputCopy-1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers: n (1 ≤ n ≤ 100) — the number of rows in the table and m (1 ≤ m ≤ 104) — the number of columns in the table. Then n lines follow, each of them contains m characters \"0\" or \"1\": the j-th character of the i-th line describes the contents of the cell in the i-th row and in the j-th column of the table.It is guaranteed that the description of the table contains no other characters besides \"0\" and \"1\".\n\nOutputPrint a single number: the minimum number of moves needed to get only numbers 1 in some column of the table. If this is impossible, print -1.\n\nInputCopy3 6101010000100100000OutputCopy3InputCopy2 3111000OutputCopy-1\n\nInputCopy3 6101010000100100000\n\nOutputCopy3\n\nInputCopy2 3111000\n\nOutputCopy-1\n\nNoteIn the first sample one way to achieve the goal with the least number of moves is as follows: cyclically shift the second row to the right once, then shift the third row to the left twice. Then the table column before the last one will contain only 1s.In the second sample one can't shift the rows to get a column containing only 1s.",
      "solutions": [
        {
          "title": "Codeforces Round #142 - Codeforces",
          "content": "Hello everyone!Codeforces Round #142 will be held today at 19:30 in Moscow time, and it will take place in both divisions.The authors of the problems are me, Evgeny Vihrov (gen), and Andrey Vihrov (andreyv). Both of us are students of the Faculty of Computing in the University of Latvia. This is our very first contest on Codeforces!Big thanks for the help in preparing the contest go to Gerald Agapov (Gerald), and to Maria Belova (Delinur) — for translating the problem statements in English. Also thanks to Mikhail Mirzayanov (MikeMirzayanov) for the Polygon system, which we found to be great for preparing contest problems.We hope that each participant will be able find a problem to match his taste. Please, consider reading all the problems!We wish you an exciting round!UPD1: The score distribution will be dynamic. The problems will be sorted in order of expected increasing difficulty.UPD2: Due to the technical problems the contest was extended by 5 minutes. We are sorry for the inconvinience.UPD3: The analysis of the contest is available. Enjoy!The round is over! 5 contestants solved all the problems in division 1, and in division 2 only the top four contestants solved all the tasks. Congratulations to the winners!Div I YuukaKazami peter50216 kelvin takaramono Martin Div II coquelicot llj_bash kb. niukuo Petar",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5432",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1330
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces",
          "content": "Div. 2 A — DragonsObserve that if Kirito fights a dragon whose strength is less than Kirito's strength, then Kirito does not lose anything — in fact, he even gains a nonnegative strength increase. Taking note of this, let's for each step choose some dragon whose strength is less than Kirito's current strength, and fight it. After performing some amount of these steps we'll eventually end up in one of these two situations: either all dragons are slain (then the answer is \"YES\"), or only dragons whose strength is not less than Kirito's strength remain (then the answer is \"NO\"). On each step we can choose a suitable dragon to fight either by searching through all dragons or by sorting the dragons by strength in non-descending order in advance.The complexity of the solution is O(n2) or . Sample solution: http://pastie.org/4897164 (archived copy)  Div. 2 B — T-primesIt can be shown that only squares of prime numbers are T-primes, and that there are not too many of them — as many as there are prime numbers not greater than . Precompute these numbers (using, for example, the sieve of Eratosthenes) and store them in an array or an std::set, then we can answer each query by simply checking whether the number in question is amongst the precomputed numbers.The complexity of the solution is linear in relation to n — or , where d = 1012 (one can also get a tighter bound). Sample solution: http://pastie.org/4897166 (archived copy)Div. 1 A — ShiftsLet's compute the minimum number of operations needed to get all 1s in each of the m columns. For this, traverse each row twice — one time to the left and one time to the right, recording the index of the nearest cell with 1 (in corresponding direction) for each column in this row. Then the number of operations for any particular column is the sum of the computed values over all rows. In turn, the answer to the problem is the minimal value of these sums.The complexity of the solution is O(nm). Sample solution: http://pastie.org/4897169 (archived copy)Div. 1 B — PlanetsObserve that when we visit some planet, the best strategy is to arrive as early as we can and then wait for the nearest free moment of time to move further. Hence this problem can be solved with the Dijkstra's algorithm by slightly altering the definition of a shortest distance. When we process a planet (meaning that we already know the minimum time needed to reach it), we need to check the array of arrival times for this planet and find the first moment of time in which we can leave this planet — this will be the distance that we will be adding to outgoing paths from this planet. It's clear that we will traverse each array of arrival times no more than once. Additionally, one must pay attention to these cases: when a traveller arrives to planet 1 at time 0 (then Jack has to wait) and when a traveller arrives to planet n at the same time as Jack (then Jack needs not to wait).The complexity of the solution — . Sample solution: http://pastie.org/4897171 (archived copy)Div. 1 C — TrianglesLet's call Alice's edges simply edges, and Bob's edges the antiedges. For each edge pair of the initial complete graph that pass through the same vertices, assign a weight: for each pair of edges the weight +2, for each pair of edge and antiedge −1 and for each pair of antiedges +2. Now calculate the sum of all the weights. Observe that each Alice's or Bob's triangle adds exactly +6 to the sum, and each combination of three vertices that do not form the triangle in any of the two graphs adds exactly 0 to the sum. The sum itself is calculated by iterating over all vertices and adding the total weight of all the edge pairs that pass through this vertex. If the degree of the vertex is d, then we should add d(d - 1) - d(n - d - 1) + (n - d - 1)(n - d - 2) to the final sum. Since each triangle adds +6 to the sum, then the answer is equal to the sum divided by 6.The complexity of the solution is O(n + m). Sample solution: http://pastie.org/4897512 (archived copy)Div. 1 D — TowersLet's calculate the dynamics d[i][k] — the minimal possible height of the last tower that we can obtain by merging the first i left towers into at least k towers. Assume we already have calculated the dynamics' values for the first i towers. Now we iterate over the all possible tower intervals [i + 1;j]; say the sum in the pending interval is equal to s. Now we find the greatest k such that d[i][k] is not greater than s. Then we update the value of d[j][k+1] to the minimum of s and d[j][k+1]. Notice that when k increases the values d[i][k] do not decrease. Because of that we can iterate over intervals in the decreasing value of j, and corresponding k can be found using a single pointer over values of d[i][k].When we arrive in the position j during the dynamics, some of the d[j][k] values are updated, but some are still not. Using the same observation that along with the increasing of k the values d[j][k] do not decrease as well, we can make a single run over the values of k in the decreasing order and update the dynamics' values as follows: d[j][k] := min(d[j][k], d[j][k+1]). This is done in the beginning of the dynamics' iteration.In the end we can find the greatest k for which there exists an answer among the values of d[n][k]. The answer to the problem then is n - k.The complexity of the solution is O(n2). Sample solution: http://pastie.org/4897515 (archived copy)Div. 1 E — GiftsFirst let's establish some facts that we will use in the solution. With how much probability can the fisherman get a particular set of gifts, among which there are ai gifts of i-th name? In total there are such sets, since there are exactly subsets of gifts with i-th name of size ai, and two different names are independent during the gold fish's choice. Then the described particular set of gifts we can get with the probability of , by asking ai gifts of i-th name.Now we know the probability p of obtaining one particular gift set A. Now observe that from p we can calculate the probabiltity p' of obtaining the set A along with some one other gift of x-th name in constant time. Say there are already ax elements of x-th name in A. Using the formula from the first paragraph, we can deduce that: Let's solve the main problem now. We sort all the gifts in descending order of their prices. It is clear that the fisherman will definitely ask the names of all the gifts among the first n ones whose prices are not equal to the price of the n-th gift in the list. Let's say that this set of gifts is the base, and it has b elements. Then there is still n - b unchosen gifts, and we know that all of them will have the price equal to the price of the n-th gift in the list. Say the price of the n-th gift is d, and there are exactly s gifts with the price d (keep in mind that each of them has a different name); also call these gifts dubious. We can also deduce that the fisherman can make different decisions, where l = n - b.So now we have some s dubious gifts with the price of d; let's enumerate them in any order. We calculate the dynamics f(x, y) — the cumulative probability of obtaining n most valuable gifts, if there are x chosen from the first y in the list. It is clear that f(0, 0) = p, and f(l, s) contains the answer to the problem. Using the coefficients we have deduced earlier, we get two transitions in the dynamics: , if we add y + 1-th dubious gift to the set of x chosen among the first y dubious gifts; , otherwise, if do not put the y + 1-th dubious gift. This dynamics can be computed in O(t2) time, where t is the total number of gifts. The complexity of the solution is . Sample solution: http://pastie.org/4897519 (archived copy)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7684
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #142 - Codeforces - Code 1",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 2",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 3",
          "code": "\\_dangerous\\_",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 4",
          "code": "double temp = pow((double)n, 0.5);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 5",
          "code": "long long square_root = (long long)(temp);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces - Code 1",
          "code": "d[j][k] := min(d[j][k], d[j][k+1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n    \n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; i++) {\n        string varName = \"row[\" + to_string(i+1) + \"]\";\n        string s = inf.readLine(pattern, varName);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n    \n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; i++) {\n        string varName = \"row[\" + to_string(i+1) + \"]\";\n        string s = inf.readLine(pattern, varName);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n    \n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; i++) {\n        string varName = \"row[\" + to_string(i+1) + \"]\";\n        string s = inf.readLine(pattern, varName);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> table(n);\n\n    if (type == \"all_zeros\") {\n        // All zeros\n        for (int i = 0; i < n; ++i) {\n            table[i] = string(m, '0');\n        }\n    } else if (type == \"all_ones\") {\n        // All ones\n        for (int i = 0; i < n; ++i) {\n            table[i] = string(m, '1');\n        }\n    } else if (type == \"random\") {\n        // Random\n        for (int i = 0; i < n; ++i) {\n            table[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                table[i] += rnd.next(0,1) ? '1' : '0';\n            }\n        }\n    } else if (type == \"impossible\") {\n        // At least one row has only zeros, making it impossible\n        int zero_row = rnd.next(0, n-1);\n        for (int i = 0; i < n; ++i) {\n            if (i == zero_row) {\n                table[i] = string(m, '0');\n            } else {\n                table[i] = \"\";\n                for (int j = 0; j < m; ++j) {\n                    table[i] += rnd.next(0,1) ? '1' : '0';\n                }\n            }\n        }\n    } else if (type == \"single_one_per_row\") {\n        // Each row has a single '1' in random position\n        for (int i = 0; i < n; ++i) {\n            table[i] = string(m, '0');\n            int pos = rnd.next(0, m-1);\n            table[i][pos] = '1';\n        }\n    } else if (type == \"max_moves\") {\n        // Create a case where minimal total number of moves is large\n        // Each row has '1' in positions offset by (i * k) where k is a large number\n        for (int i = 0; i < n; ++i) {\n            table[i] = string(m, '0');\n            int pos = (i * (m / 2)) % m;\n            table[i][pos] = '1';\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            table[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                table[i] += rnd.next(0,1) ? '1' : '0';\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the table\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", table[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> table(n);\n\n    if (type == \"all_zeros\") {\n        // All zeros\n        for (int i = 0; i < n; ++i) {\n            table[i] = string(m, '0');\n        }\n    } else if (type == \"all_ones\") {\n        // All ones\n        for (int i = 0; i < n; ++i) {\n            table[i] = string(m, '1');\n        }\n    } else if (type == \"random\") {\n        // Random\n        for (int i = 0; i < n; ++i) {\n            table[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                table[i] += rnd.next(0,1) ? '1' : '0';\n            }\n        }\n    } else if (type == \"impossible\") {\n        // At least one row has only zeros, making it impossible\n        int zero_row = rnd.next(0, n-1);\n        for (int i = 0; i < n; ++i) {\n            if (i == zero_row) {\n                table[i] = string(m, '0');\n            } else {\n                table[i] = \"\";\n                for (int j = 0; j < m; ++j) {\n                    table[i] += rnd.next(0,1) ? '1' : '0';\n                }\n            }\n        }\n    } else if (type == \"single_one_per_row\") {\n        // Each row has a single '1' in random position\n        for (int i = 0; i < n; ++i) {\n            table[i] = string(m, '0');\n            int pos = rnd.next(0, m-1);\n            table[i][pos] = '1';\n        }\n    } else if (type == \"max_moves\") {\n        // Create a case where minimal total number of moves is large\n        // Each row has '1' in positions offset by (i * k) where k is a large number\n        for (int i = 0; i < n; ++i) {\n            table[i] = string(m, '0');\n            int pos = (i * (m / 2)) % m;\n            table[i][pos] = '1';\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            table[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                table[i] += rnd.next(0,1) ? '1' : '0';\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the table\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", table[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type all_zeros\n./gen -n 1 -m 1 -type all_ones\n./gen -n 1 -m 1 -type random\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type all_zeros\n./gen -n 10 -m 10 -type all_ones\n\n./gen -n 100 -m 100 -type random\n\n./gen -n 100 -m 1000 -type random\n\n./gen -n 100 -m 10000 -type random\n\n./gen -n 50 -m 5000 -type random\n\n./gen -n 10 -m 10000 -type random\n\n./gen -n 100 -m 10000 -type all_zeros\n./gen -n 100 -m 10000 -type all_ones\n./gen -n 100 -m 10000 -type impossible\n\n./gen -n 100 -m 10000 -type single_one_per_row\n./gen -n 100 -m 10000 -type max_moves\n\n./gen -n 1 -m 10000 -type all_zeros\n./gen -n 1 -m 10000 -type all_ones\n./gen -n 1 -m 10000 -type random\n\n./gen -n 100 -m 1 -type random\n./gen -n 100 -m 1 -type all_zeros\n./gen -n 100 -m 1 -type all_ones\n\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 10000 -type random\n\n./gen -n 100 -m 50 -type random\n\n./gen -n 99 -m 9999 -type random\n\n./gen -n 100 -m 9999 -type impossible\n\n./gen -n 100 -m 2 -type impossible\n\n./gen -n 100 -m 2 -type random\n\n./gen -n 50 -m 10000 -type max_moves\n\n./gen -n 100 -m 10000 -type single_one_per_row\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:43.836811",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "230/D",
      "title": "D. Planets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers: n (2 ≤ n ≤ 105), the number of planets in the galaxy, and m (0 ≤ m ≤ 105) — the number of pairs of planets between which Jack can travel using stargates. Then m lines follow, containing three integers each: the i-th line contains numbers of planets ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), which are connected through stargates, and the integer transfer time (in seconds) ci (1 ≤ ci ≤ 104) between these planets. It is guaranteed that between any pair of planets there is at most one stargate connection.Then n lines follow: the i-th line contains an integer ki (0 ≤ ki ≤ 105) that denotes the number of moments of time when other travellers arrive to the planet with index i. Then ki distinct space-separated integers tij (0 ≤ tij < 109) follow, sorted in ascending order. An integer tij means that at time tij (in seconds) another traveller arrives to the planet i. It is guaranteed that the sum of all ki does not exceed 105.",
      "output_spec": "OutputPrint a single number — the least amount of time Jack needs to get from planet 1 to planet n. If Jack can't get to planet n in any amount of time, print number -1.",
      "sample_tests": "ExamplesInputCopy4 61 2 21 3 31 4 82 3 42 4 53 4 301 32 3 40OutputCopy7InputCopy3 11 2 301 30OutputCopy-1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers: n (2 ≤ n ≤ 105), the number of planets in the galaxy, and m (0 ≤ m ≤ 105) — the number of pairs of planets between which Jack can travel using stargates. Then m lines follow, containing three integers each: the i-th line contains numbers of planets ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), which are connected through stargates, and the integer transfer time (in seconds) ci (1 ≤ ci ≤ 104) between these planets. It is guaranteed that between any pair of planets there is at most one stargate connection.Then n lines follow: the i-th line contains an integer ki (0 ≤ ki ≤ 105) that denotes the number of moments of time when other travellers arrive to the planet with index i. Then ki distinct space-separated integers tij (0 ≤ tij < 109) follow, sorted in ascending order. An integer tij means that at time tij (in seconds) another traveller arrives to the planet i. It is guaranteed that the sum of all ki does not exceed 105.\n\nOutputPrint a single number — the least amount of time Jack needs to get from planet 1 to planet n. If Jack can't get to planet n in any amount of time, print number -1.\n\nInputCopy4 61 2 21 3 31 4 82 3 42 4 53 4 301 32 3 40OutputCopy7InputCopy3 11 2 301 30OutputCopy-1\n\nInputCopy4 61 2 21 3 31 4 82 3 42 4 53 4 301 32 3 40\n\nOutputCopy7\n\nInputCopy3 11 2 301 30\n\nOutputCopy-1\n\nNoteIn the first sample Jack has three ways to go from planet 1. If he moves to planet 4 at once, he spends 8 seconds. If he transfers to planet 3, he spends 3 seconds, but as other travellers arrive to planet 3 at time 3 and 4, he can travel to planet 4 only at time 5, thus spending 8 seconds in total. But if Jack moves to planet 2, and then — to planet 4, then he spends a total of only 2 + 5 = 7 seconds.In the second sample one can't get from planet 1 to planet 3 by moving through stargates.",
      "solutions": [
        {
          "title": "Codeforces Round #142 - Codeforces",
          "content": "Hello everyone!Codeforces Round #142 will be held today at 19:30 in Moscow time, and it will take place in both divisions.The authors of the problems are me, Evgeny Vihrov (gen), and Andrey Vihrov (andreyv). Both of us are students of the Faculty of Computing in the University of Latvia. This is our very first contest on Codeforces!Big thanks for the help in preparing the contest go to Gerald Agapov (Gerald), and to Maria Belova (Delinur) — for translating the problem statements in English. Also thanks to Mikhail Mirzayanov (MikeMirzayanov) for the Polygon system, which we found to be great for preparing contest problems.We hope that each participant will be able find a problem to match his taste. Please, consider reading all the problems!We wish you an exciting round!UPD1: The score distribution will be dynamic. The problems will be sorted in order of expected increasing difficulty.UPD2: Due to the technical problems the contest was extended by 5 minutes. We are sorry for the inconvinience.UPD3: The analysis of the contest is available. Enjoy!The round is over! 5 contestants solved all the problems in division 1, and in division 2 only the top four contestants solved all the tasks. Congratulations to the winners!Div I YuukaKazami peter50216 kelvin takaramono Martin Div II coquelicot llj_bash kb. niukuo Petar",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5432",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1330
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces",
          "content": "Div. 2 A — DragonsObserve that if Kirito fights a dragon whose strength is less than Kirito's strength, then Kirito does not lose anything — in fact, he even gains a nonnegative strength increase. Taking note of this, let's for each step choose some dragon whose strength is less than Kirito's current strength, and fight it. After performing some amount of these steps we'll eventually end up in one of these two situations: either all dragons are slain (then the answer is \"YES\"), or only dragons whose strength is not less than Kirito's strength remain (then the answer is \"NO\"). On each step we can choose a suitable dragon to fight either by searching through all dragons or by sorting the dragons by strength in non-descending order in advance.The complexity of the solution is O(n2) or . Sample solution: http://pastie.org/4897164 (archived copy)  Div. 2 B — T-primesIt can be shown that only squares of prime numbers are T-primes, and that there are not too many of them — as many as there are prime numbers not greater than . Precompute these numbers (using, for example, the sieve of Eratosthenes) and store them in an array or an std::set, then we can answer each query by simply checking whether the number in question is amongst the precomputed numbers.The complexity of the solution is linear in relation to n — or , where d = 1012 (one can also get a tighter bound). Sample solution: http://pastie.org/4897166 (archived copy)Div. 1 A — ShiftsLet's compute the minimum number of operations needed to get all 1s in each of the m columns. For this, traverse each row twice — one time to the left and one time to the right, recording the index of the nearest cell with 1 (in corresponding direction) for each column in this row. Then the number of operations for any particular column is the sum of the computed values over all rows. In turn, the answer to the problem is the minimal value of these sums.The complexity of the solution is O(nm). Sample solution: http://pastie.org/4897169 (archived copy)Div. 1 B — PlanetsObserve that when we visit some planet, the best strategy is to arrive as early as we can and then wait for the nearest free moment of time to move further. Hence this problem can be solved with the Dijkstra's algorithm by slightly altering the definition of a shortest distance. When we process a planet (meaning that we already know the minimum time needed to reach it), we need to check the array of arrival times for this planet and find the first moment of time in which we can leave this planet — this will be the distance that we will be adding to outgoing paths from this planet. It's clear that we will traverse each array of arrival times no more than once. Additionally, one must pay attention to these cases: when a traveller arrives to planet 1 at time 0 (then Jack has to wait) and when a traveller arrives to planet n at the same time as Jack (then Jack needs not to wait).The complexity of the solution — . Sample solution: http://pastie.org/4897171 (archived copy)Div. 1 C — TrianglesLet's call Alice's edges simply edges, and Bob's edges the antiedges. For each edge pair of the initial complete graph that pass through the same vertices, assign a weight: for each pair of edges the weight +2, for each pair of edge and antiedge −1 and for each pair of antiedges +2. Now calculate the sum of all the weights. Observe that each Alice's or Bob's triangle adds exactly +6 to the sum, and each combination of three vertices that do not form the triangle in any of the two graphs adds exactly 0 to the sum. The sum itself is calculated by iterating over all vertices and adding the total weight of all the edge pairs that pass through this vertex. If the degree of the vertex is d, then we should add d(d - 1) - d(n - d - 1) + (n - d - 1)(n - d - 2) to the final sum. Since each triangle adds +6 to the sum, then the answer is equal to the sum divided by 6.The complexity of the solution is O(n + m). Sample solution: http://pastie.org/4897512 (archived copy)Div. 1 D — TowersLet's calculate the dynamics d[i][k] — the minimal possible height of the last tower that we can obtain by merging the first i left towers into at least k towers. Assume we already have calculated the dynamics' values for the first i towers. Now we iterate over the all possible tower intervals [i + 1;j]; say the sum in the pending interval is equal to s. Now we find the greatest k such that d[i][k] is not greater than s. Then we update the value of d[j][k+1] to the minimum of s and d[j][k+1]. Notice that when k increases the values d[i][k] do not decrease. Because of that we can iterate over intervals in the decreasing value of j, and corresponding k can be found using a single pointer over values of d[i][k].When we arrive in the position j during the dynamics, some of the d[j][k] values are updated, but some are still not. Using the same observation that along with the increasing of k the values d[j][k] do not decrease as well, we can make a single run over the values of k in the decreasing order and update the dynamics' values as follows: d[j][k] := min(d[j][k], d[j][k+1]). This is done in the beginning of the dynamics' iteration.In the end we can find the greatest k for which there exists an answer among the values of d[n][k]. The answer to the problem then is n - k.The complexity of the solution is O(n2). Sample solution: http://pastie.org/4897515 (archived copy)Div. 1 E — GiftsFirst let's establish some facts that we will use in the solution. With how much probability can the fisherman get a particular set of gifts, among which there are ai gifts of i-th name? In total there are such sets, since there are exactly subsets of gifts with i-th name of size ai, and two different names are independent during the gold fish's choice. Then the described particular set of gifts we can get with the probability of , by asking ai gifts of i-th name.Now we know the probability p of obtaining one particular gift set A. Now observe that from p we can calculate the probabiltity p' of obtaining the set A along with some one other gift of x-th name in constant time. Say there are already ax elements of x-th name in A. Using the formula from the first paragraph, we can deduce that: Let's solve the main problem now. We sort all the gifts in descending order of their prices. It is clear that the fisherman will definitely ask the names of all the gifts among the first n ones whose prices are not equal to the price of the n-th gift in the list. Let's say that this set of gifts is the base, and it has b elements. Then there is still n - b unchosen gifts, and we know that all of them will have the price equal to the price of the n-th gift in the list. Say the price of the n-th gift is d, and there are exactly s gifts with the price d (keep in mind that each of them has a different name); also call these gifts dubious. We can also deduce that the fisherman can make different decisions, where l = n - b.So now we have some s dubious gifts with the price of d; let's enumerate them in any order. We calculate the dynamics f(x, y) — the cumulative probability of obtaining n most valuable gifts, if there are x chosen from the first y in the list. It is clear that f(0, 0) = p, and f(l, s) contains the answer to the problem. Using the coefficients we have deduced earlier, we get two transitions in the dynamics: , if we add y + 1-th dubious gift to the set of x chosen among the first y dubious gifts; , otherwise, if do not put the y + 1-th dubious gift. This dynamics can be computed in O(t2) time, where t is the total number of gifts. The complexity of the solution is . Sample solution: http://pastie.org/4897519 (archived copy)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7684
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #142 - Codeforces - Code 1",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 2",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 3",
          "code": "\\_dangerous\\_",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 4",
          "code": "double temp = pow((double)n, 0.5);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 5",
          "code": "long long square_root = (long long)(temp);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces - Code 1",
          "code": "d[j][k] := min(d[j][k], d[j][k+1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge %d: ai (%d) should not equal bi (%d)\", i + 1, ai, bi);\n        inf.readSpace();\n        int ci = inf.readInt(1, 10000, \"ci\");\n        inf.readEoln();\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> p = make_pair(u, v);\n\n        ensuref(edgeSet.count(p) == 0, \"Edge between planets %d and %d appears multiple times\", u, v);\n        edgeSet.insert(p);\n    }\n\n    long long total_ki = 0;\n    for (int i = 1; i <= n; ++i) {\n        int ki = inf.readInt(0, 100000, \"ki\");\n        total_ki += ki;\n        ensuref(total_ki <= 100000, \"Sum of all ki exceeds 100000 after planet %d\", i);\n        if (ki == 0) {\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            vector<long long> t_i_j = inf.readLongs(ki, 0LL, 1000000000LL - 1LL);\n            inf.readEoln();\n\n            for (int j = 0; j < ki; ++j) {\n                if (j > 0) {\n                    ensuref(t_i_j[j - 1] < t_i_j[j],\n                        \"At planet %d, time moments are not strictly increasing at position %d: %lld >= %lld\",\n                        i, j, t_i_j[j - 1], t_i_j[j]);\n                }\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge %d: ai (%d) should not equal bi (%d)\", i + 1, ai, bi);\n        inf.readSpace();\n        int ci = inf.readInt(1, 10000, \"ci\");\n        inf.readEoln();\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> p = make_pair(u, v);\n\n        ensuref(edgeSet.count(p) == 0, \"Edge between planets %d and %d appears multiple times\", u, v);\n        edgeSet.insert(p);\n    }\n\n    long long total_ki = 0;\n    for (int i = 1; i <= n; ++i) {\n        int ki = inf.readInt(0, 100000, \"ki\");\n        total_ki += ki;\n        ensuref(total_ki <= 100000, \"Sum of all ki exceeds 100000 after planet %d\", i);\n        if (ki == 0) {\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            vector<long long> t_i_j = inf.readLongs(ki, 0LL, 1000000000LL - 1LL);\n            inf.readEoln();\n\n            for (int j = 0; j < ki; ++j) {\n                if (j > 0) {\n                    ensuref(t_i_j[j - 1] < t_i_j[j],\n                        \"At planet %d, time moments are not strictly increasing at position %d: %lld >= %lld\",\n                        i, j, t_i_j[j - 1], t_i_j[j]);\n                }\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge %d: ai (%d) should not equal bi (%d)\", i + 1, ai, bi);\n        inf.readSpace();\n        int ci = inf.readInt(1, 10000, \"ci\");\n        inf.readEoln();\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> p = make_pair(u, v);\n\n        ensuref(edgeSet.count(p) == 0, \"Edge between planets %d and %d appears multiple times\", u, v);\n        edgeSet.insert(p);\n    }\n\n    long long total_ki = 0;\n    for (int i = 1; i <= n; ++i) {\n        int ki = inf.readInt(0, 100000, \"ki\");\n        total_ki += ki;\n        ensuref(total_ki <= 100000, \"Sum of all ki exceeds 100000 after planet %d\", i);\n        if (ki == 0) {\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            vector<long long> t_i_j = inf.readLongs(ki, 0LL, 1000000000LL - 1LL);\n            inf.readEoln();\n\n            for (int j = 0; j < ki; ++j) {\n                if (j > 0) {\n                    ensuref(t_i_j[j - 1] < t_i_j[j],\n                        \"At planet %d, time moments are not strictly increasing at position %d: %lld >= %lld\",\n                        i, j, t_i_j[j - 1], t_i_j[j]);\n                }\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1); // default m = n - 1\n    int ksum = opt<int>(\"ksum\", 0); // total number of arrival times\n    int wtmax = opt<int>(\"wtmax\", 10000);\n    string arrival_type = opt<string>(\"arrival_type\", \"none\");\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n\n    if (m > 1LL * n * (n - 1) / 2)\n        m = 1LL * n * (n - 1) / 2;\n\n    vector<pair<int, int> > edges;\n    vector<int> ci;\n\n    if (graph_type == \"chain\") {\n        // Construct a chain\n        m = n - 1;\n        for (int i = 1; i <= n - 1; ++i) {\n            edges.push_back({i, i + 1});\n            ci.push_back(rnd.next(1, wtmax));\n        }\n    } else if (graph_type == \"star\") {\n        // Star centered at node 1\n        m = n - 1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n            ci.push_back(rnd.next(1, wtmax));\n        }\n    } else if (graph_type == \"nosolution\") {\n        // Ensure node 1 and node n are in different components\n        if (n <= 2) {\n            // No edges in this case\n            m = 0;\n        } else {\n            // Split nodes into two sets [1..n/2] and [n/2+1..n], no edges between them\n            int half = n / 2;\n            m = 0;\n            for (int i = 1; i < half; ++i) {\n                edges.push_back({i, i + 1});\n                ci.push_back(rnd.next(1, wtmax));\n                m++;\n            }\n            for (int i = half + 1; i < n; ++i) {\n                edges.push_back({i, i + 1});\n                ci.push_back(rnd.next(1, wtmax));\n                m++;\n            }\n        }\n    } else {\n        // Random graph\n        set<pair<int, int> > edgeSet;\n        if (graph_type == \"random\") {\n            while ((int)edgeSet.size() < m) {\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                if (u == v) continue;\n                if (u > v) swap(u, v);\n                if (edgeSet.count({u, v}) == 0) {\n                    edgeSet.insert({u, v});\n                    edges.push_back({u, v});\n                    ci.push_back(rnd.next(1, wtmax));\n                }\n            }\n        }\n    }\n\n    // Generate arrival times\n    vector<vector<int> > arrivals(n + 1); // 1-indexed planets\n\n    int total_ki = 0;\n    if (arrival_type == \"none\") {\n        // No arrivals\n    } else if (arrival_type == \"full\") {\n        // Full arrivals, distribute ksum equally\n        int per_planet = ksum / n;\n        int extra = ksum % n;\n        for (int i = 1; i <= n; ++i) {\n            int ki = per_planet + (i <= extra ? 1 : 0);\n            total_ki += ki;\n            for (int j = 0; j < ki; ++j) {\n                arrivals[i].push_back(j);\n            }\n        }\n    } else if (arrival_type == \"random\") {\n        // Distribute ksum randomly across planets\n        int remaining_ksum = ksum;\n        for (int i = 1; i <= n; ++i) {\n            int ki = 0;\n            if (remaining_ksum > 0)\n                ki = rnd.next(0, min(remaining_ksum, 100000));\n            total_ki += ki;\n            remaining_ksum -= ki;\n            set<int> times;\n            while ((int)times.size() < ki) {\n                times.insert(rnd.next(0, 1000000000 - 1));\n            }\n            arrivals[i] = vector<int>(times.begin(), times.end());\n            sort(arrivals[i].begin(), arrivals[i].end());\n        }\n    } else if (arrival_type == \"blocking\") {\n        // Arrivals that block Jack\n        arrivals[1].push_back(0);\n        total_ki += 1;\n        int remaining_ksum = ksum - 1;\n        for (int i = 2; i <= n; ++i) {\n            int ki = 0;\n            if (remaining_ksum > 0)\n                ki = rnd.next(0, min(remaining_ksum, 100000));\n            total_ki += ki;\n            remaining_ksum -= ki;\n            set<int> times;\n            while ((int)times.size() < ki) {\n                times.insert(rnd.next(0, 1000000000 - 1));\n            }\n            arrivals[i] = vector<int>(times.begin(), times.end());\n            sort(arrivals[i].begin(), arrivals[i].end());\n        }\n    }\n\n    // Ensure total ki does not exceed 1e5\n    if (total_ki > 100000) {\n        fprintf(stderr, \"Total number of arrivals exceeds 1e5\\n\");\n        return 1;\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", edges[i].first, edges[i].second, ci[i]);\n    }\n    for (int i = 1; i <= n; ++i) {\n        int ki = arrivals[i].size();\n        printf(\"%d\", ki);\n        for (int j = 0; j < ki; ++j) {\n            printf(\" %d\", arrivals[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1); // default m = n - 1\n    int ksum = opt<int>(\"ksum\", 0); // total number of arrival times\n    int wtmax = opt<int>(\"wtmax\", 10000);\n    string arrival_type = opt<string>(\"arrival_type\", \"none\");\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n\n    if (m > 1LL * n * (n - 1) / 2)\n        m = 1LL * n * (n - 1) / 2;\n\n    vector<pair<int, int> > edges;\n    vector<int> ci;\n\n    if (graph_type == \"chain\") {\n        // Construct a chain\n        m = n - 1;\n        for (int i = 1; i <= n - 1; ++i) {\n            edges.push_back({i, i + 1});\n            ci.push_back(rnd.next(1, wtmax));\n        }\n    } else if (graph_type == \"star\") {\n        // Star centered at node 1\n        m = n - 1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n            ci.push_back(rnd.next(1, wtmax));\n        }\n    } else if (graph_type == \"nosolution\") {\n        // Ensure node 1 and node n are in different components\n        if (n <= 2) {\n            // No edges in this case\n            m = 0;\n        } else {\n            // Split nodes into two sets [1..n/2] and [n/2+1..n], no edges between them\n            int half = n / 2;\n            m = 0;\n            for (int i = 1; i < half; ++i) {\n                edges.push_back({i, i + 1});\n                ci.push_back(rnd.next(1, wtmax));\n                m++;\n            }\n            for (int i = half + 1; i < n; ++i) {\n                edges.push_back({i, i + 1});\n                ci.push_back(rnd.next(1, wtmax));\n                m++;\n            }\n        }\n    } else {\n        // Random graph\n        set<pair<int, int> > edgeSet;\n        if (graph_type == \"random\") {\n            while ((int)edgeSet.size() < m) {\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                if (u == v) continue;\n                if (u > v) swap(u, v);\n                if (edgeSet.count({u, v}) == 0) {\n                    edgeSet.insert({u, v});\n                    edges.push_back({u, v});\n                    ci.push_back(rnd.next(1, wtmax));\n                }\n            }\n        }\n    }\n\n    // Generate arrival times\n    vector<vector<int> > arrivals(n + 1); // 1-indexed planets\n\n    int total_ki = 0;\n    if (arrival_type == \"none\") {\n        // No arrivals\n    } else if (arrival_type == \"full\") {\n        // Full arrivals, distribute ksum equally\n        int per_planet = ksum / n;\n        int extra = ksum % n;\n        for (int i = 1; i <= n; ++i) {\n            int ki = per_planet + (i <= extra ? 1 : 0);\n            total_ki += ki;\n            for (int j = 0; j < ki; ++j) {\n                arrivals[i].push_back(j);\n            }\n        }\n    } else if (arrival_type == \"random\") {\n        // Distribute ksum randomly across planets\n        int remaining_ksum = ksum;\n        for (int i = 1; i <= n; ++i) {\n            int ki = 0;\n            if (remaining_ksum > 0)\n                ki = rnd.next(0, min(remaining_ksum, 100000));\n            total_ki += ki;\n            remaining_ksum -= ki;\n            set<int> times;\n            while ((int)times.size() < ki) {\n                times.insert(rnd.next(0, 1000000000 - 1));\n            }\n            arrivals[i] = vector<int>(times.begin(), times.end());\n            sort(arrivals[i].begin(), arrivals[i].end());\n        }\n    } else if (arrival_type == \"blocking\") {\n        // Arrivals that block Jack\n        arrivals[1].push_back(0);\n        total_ki += 1;\n        int remaining_ksum = ksum - 1;\n        for (int i = 2; i <= n; ++i) {\n            int ki = 0;\n            if (remaining_ksum > 0)\n                ki = rnd.next(0, min(remaining_ksum, 100000));\n            total_ki += ki;\n            remaining_ksum -= ki;\n            set<int> times;\n            while ((int)times.size() < ki) {\n                times.insert(rnd.next(0, 1000000000 - 1));\n            }\n            arrivals[i] = vector<int>(times.begin(), times.end());\n            sort(arrivals[i].begin(), arrivals[i].end());\n        }\n    }\n\n    // Ensure total ki does not exceed 1e5\n    if (total_ki > 100000) {\n        fprintf(stderr, \"Total number of arrivals exceeds 1e5\\n\");\n        return 1;\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", edges[i].first, edges[i].second, ci[i]);\n    }\n    for (int i = 1; i <= n; ++i) {\n        int ki = arrivals[i].size();\n        printf(\"%d\", ki);\n        for (int j = 0; j < ki; ++j) {\n            printf(\" %d\", arrivals[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 0 -arrival_type none -graph_type nosolution\n\n./gen -n 10 -m 9 -arrival_type none -graph_type chain\n\n./gen -n 10 -m 9 -arrival_type full -ksum 20 -graph_type chain\n\n./gen -n 100 -m 99 -arrival_type none -graph_type chain\n\n./gen -n 1000 -m 999 -arrival_type full -ksum 5000 -graph_type chain\n\n./gen -n 1000 -m 999 -arrival_type random -ksum 5000 -graph_type chain\n\n./gen -n 100000 -m 99999 -arrival_type none -graph_type chain\n\n./gen -n 100000 -m 99999 -arrival_type full -ksum 100000 -graph_type chain\n\n./gen -n 100000 -m 99999 -arrival_type random -ksum 100000 -graph_type chain\n\n./gen -n 100000 -m 100000 -arrival_type none -graph_type random\n\n./gen -n 100000 -m 200000 -arrival_type none -graph_type random\n\n./gen -n 100000 -m 100000 -arrival_type full -ksum 100000 -graph_type random\n\n./gen -n 100000 -m 100000 -arrival_type random -ksum 100000 -graph_type random\n\n./gen -n 100000 -m 100000 -arrival_type blocking -ksum 100000 -graph_type random\n\n./gen -n 100000 -m 100000 -arrival_type none -wtmax 1 -graph_type random\n\n./gen -n 100000 -m 100000 -arrival_type none -wtmax 10000 -graph_type random\n\n./gen -n 100000 -m 99999 -arrival_type none -graph_type star\n\n./gen -n 100000 -m 99999 -arrival_type full -ksum 100000 -graph_type star\n\n./gen -n 100000 -m 0 -arrival_type none -graph_type nosolution\n\n./gen -n 100000 -m 50000 -arrival_type none -graph_type nosolution\n\n./gen -n 100000 -m 99999 -arrival_type none -graph_type nosolution\n\n./gen -n 1000 -m 0 -arrival_type blocking -ksum 100000 -graph_type nosolution\n\n./gen -n 3 -m 1 -arrival_type none -graph_type nosolution\n\n./gen -n 3 -m 2 -arrival_type none -graph_type nosolution\n\n./gen -n 3 -m 2 -arrival_type none -graph_type chain\n\n./gen -n 3 -m 2 -arrival_type none -graph_type star\n\n./gen -n 100000 -m 99999 -arrival_type random -ksum 100000 -wtmax 1 -graph_type chain\n\n./gen -n 100000 -m 100000 -arrival_type blocking -ksum 1 -graph_type random\n\n./gen -n 100000 -m 50000 -arrival_type random -ksum 50000 -graph_type random\n\n./gen -n 100000 -m 100000 -arrival_type none -wtmax 10000 -graph_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:46.116864",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "230/E",
      "title": "E. Triangles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n ≤ 106, 0 ≤ m ≤ 106) — the number of vertices in the initial complete graph and the number of edges in Alice's graph, correspondingly. Then m lines follow: the i-th line contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), — the numbers of the two vertices connected by the i-th edge in Alice's graph. It is guaranteed that Alice's graph contains no multiple edges and self-loops. It is guaranteed that the initial complete graph also contains no multiple edges and self-loops.Consider the graph vertices to be indexed in some way from 1 to n.",
      "output_spec": "OutputPrint a single number — the total number of cycles of length 3 in Alice and Bob's graphs together.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy5 51 21 32 32 43 4OutputCopy3InputCopy5 31 22 31 3OutputCopy4",
      "description": "E. Triangles\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n ≤ 106, 0 ≤ m ≤ 106) — the number of vertices in the initial complete graph and the number of edges in Alice's graph, correspondingly. Then m lines follow: the i-th line contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), — the numbers of the two vertices connected by the i-th edge in Alice's graph. It is guaranteed that Alice's graph contains no multiple edges and self-loops. It is guaranteed that the initial complete graph also contains no multiple edges and self-loops.Consider the graph vertices to be indexed in some way from 1 to n.\n\nOutputPrint a single number — the total number of cycles of length 3 in Alice and Bob's graphs together.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.\n\nInputCopy5 51 21 32 32 43 4OutputCopy3InputCopy5 31 22 31 3OutputCopy4\n\nInputCopy5 51 21 32 32 43 4\n\nOutputCopy3\n\nInputCopy5 31 22 31 3\n\nOutputCopy4\n\nNoteIn the first sample Alice has 2 triangles: (1, 2, 3) and (2, 3, 4). Bob's graph has only 1 triangle : (1, 4, 5). That's why the two graphs in total contain 3 triangles.In the second sample Alice's graph has only one triangle: (1, 2, 3). Bob's graph has three triangles: (1, 4, 5), (2, 4, 5) and (3, 4, 5). In this case the answer to the problem is 4.",
      "solutions": [
        {
          "title": "Codeforces Round #142 - Codeforces",
          "content": "Hello everyone!Codeforces Round #142 will be held today at 19:30 in Moscow time, and it will take place in both divisions.The authors of the problems are me, Evgeny Vihrov (gen), and Andrey Vihrov (andreyv). Both of us are students of the Faculty of Computing in the University of Latvia. This is our very first contest on Codeforces!Big thanks for the help in preparing the contest go to Gerald Agapov (Gerald), and to Maria Belova (Delinur) — for translating the problem statements in English. Also thanks to Mikhail Mirzayanov (MikeMirzayanov) for the Polygon system, which we found to be great for preparing contest problems.We hope that each participant will be able find a problem to match his taste. Please, consider reading all the problems!We wish you an exciting round!UPD1: The score distribution will be dynamic. The problems will be sorted in order of expected increasing difficulty.UPD2: Due to the technical problems the contest was extended by 5 minutes. We are sorry for the inconvinience.UPD3: The analysis of the contest is available. Enjoy!The round is over! 5 contestants solved all the problems in division 1, and in division 2 only the top four contestants solved all the tasks. Congratulations to the winners!Div I YuukaKazami peter50216 kelvin takaramono Martin Div II coquelicot llj_bash kb. niukuo Petar",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5432",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1330
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces",
          "content": "Div. 2 A — DragonsObserve that if Kirito fights a dragon whose strength is less than Kirito's strength, then Kirito does not lose anything — in fact, he even gains a nonnegative strength increase. Taking note of this, let's for each step choose some dragon whose strength is less than Kirito's current strength, and fight it. After performing some amount of these steps we'll eventually end up in one of these two situations: either all dragons are slain (then the answer is \"YES\"), or only dragons whose strength is not less than Kirito's strength remain (then the answer is \"NO\"). On each step we can choose a suitable dragon to fight either by searching through all dragons or by sorting the dragons by strength in non-descending order in advance.The complexity of the solution is O(n2) or . Sample solution: http://pastie.org/4897164 (archived copy)  Div. 2 B — T-primesIt can be shown that only squares of prime numbers are T-primes, and that there are not too many of them — as many as there are prime numbers not greater than . Precompute these numbers (using, for example, the sieve of Eratosthenes) and store them in an array or an std::set, then we can answer each query by simply checking whether the number in question is amongst the precomputed numbers.The complexity of the solution is linear in relation to n — or , where d = 1012 (one can also get a tighter bound). Sample solution: http://pastie.org/4897166 (archived copy)Div. 1 A — ShiftsLet's compute the minimum number of operations needed to get all 1s in each of the m columns. For this, traverse each row twice — one time to the left and one time to the right, recording the index of the nearest cell with 1 (in corresponding direction) for each column in this row. Then the number of operations for any particular column is the sum of the computed values over all rows. In turn, the answer to the problem is the minimal value of these sums.The complexity of the solution is O(nm). Sample solution: http://pastie.org/4897169 (archived copy)Div. 1 B — PlanetsObserve that when we visit some planet, the best strategy is to arrive as early as we can and then wait for the nearest free moment of time to move further. Hence this problem can be solved with the Dijkstra's algorithm by slightly altering the definition of a shortest distance. When we process a planet (meaning that we already know the minimum time needed to reach it), we need to check the array of arrival times for this planet and find the first moment of time in which we can leave this planet — this will be the distance that we will be adding to outgoing paths from this planet. It's clear that we will traverse each array of arrival times no more than once. Additionally, one must pay attention to these cases: when a traveller arrives to planet 1 at time 0 (then Jack has to wait) and when a traveller arrives to planet n at the same time as Jack (then Jack needs not to wait).The complexity of the solution — . Sample solution: http://pastie.org/4897171 (archived copy)Div. 1 C — TrianglesLet's call Alice's edges simply edges, and Bob's edges the antiedges. For each edge pair of the initial complete graph that pass through the same vertices, assign a weight: for each pair of edges the weight +2, for each pair of edge and antiedge −1 and for each pair of antiedges +2. Now calculate the sum of all the weights. Observe that each Alice's or Bob's triangle adds exactly +6 to the sum, and each combination of three vertices that do not form the triangle in any of the two graphs adds exactly 0 to the sum. The sum itself is calculated by iterating over all vertices and adding the total weight of all the edge pairs that pass through this vertex. If the degree of the vertex is d, then we should add d(d - 1) - d(n - d - 1) + (n - d - 1)(n - d - 2) to the final sum. Since each triangle adds +6 to the sum, then the answer is equal to the sum divided by 6.The complexity of the solution is O(n + m). Sample solution: http://pastie.org/4897512 (archived copy)Div. 1 D — TowersLet's calculate the dynamics d[i][k] — the minimal possible height of the last tower that we can obtain by merging the first i left towers into at least k towers. Assume we already have calculated the dynamics' values for the first i towers. Now we iterate over the all possible tower intervals [i + 1;j]; say the sum in the pending interval is equal to s. Now we find the greatest k such that d[i][k] is not greater than s. Then we update the value of d[j][k+1] to the minimum of s and d[j][k+1]. Notice that when k increases the values d[i][k] do not decrease. Because of that we can iterate over intervals in the decreasing value of j, and corresponding k can be found using a single pointer over values of d[i][k].When we arrive in the position j during the dynamics, some of the d[j][k] values are updated, but some are still not. Using the same observation that along with the increasing of k the values d[j][k] do not decrease as well, we can make a single run over the values of k in the decreasing order and update the dynamics' values as follows: d[j][k] := min(d[j][k], d[j][k+1]). This is done in the beginning of the dynamics' iteration.In the end we can find the greatest k for which there exists an answer among the values of d[n][k]. The answer to the problem then is n - k.The complexity of the solution is O(n2). Sample solution: http://pastie.org/4897515 (archived copy)Div. 1 E — GiftsFirst let's establish some facts that we will use in the solution. With how much probability can the fisherman get a particular set of gifts, among which there are ai gifts of i-th name? In total there are such sets, since there are exactly subsets of gifts with i-th name of size ai, and two different names are independent during the gold fish's choice. Then the described particular set of gifts we can get with the probability of , by asking ai gifts of i-th name.Now we know the probability p of obtaining one particular gift set A. Now observe that from p we can calculate the probabiltity p' of obtaining the set A along with some one other gift of x-th name in constant time. Say there are already ax elements of x-th name in A. Using the formula from the first paragraph, we can deduce that: Let's solve the main problem now. We sort all the gifts in descending order of their prices. It is clear that the fisherman will definitely ask the names of all the gifts among the first n ones whose prices are not equal to the price of the n-th gift in the list. Let's say that this set of gifts is the base, and it has b elements. Then there is still n - b unchosen gifts, and we know that all of them will have the price equal to the price of the n-th gift in the list. Say the price of the n-th gift is d, and there are exactly s gifts with the price d (keep in mind that each of them has a different name); also call these gifts dubious. We can also deduce that the fisherman can make different decisions, where l = n - b.So now we have some s dubious gifts with the price of d; let's enumerate them in any order. We calculate the dynamics f(x, y) — the cumulative probability of obtaining n most valuable gifts, if there are x chosen from the first y in the list. It is clear that f(0, 0) = p, and f(l, s) contains the answer to the problem. Using the coefficients we have deduced earlier, we get two transitions in the dynamics: , if we add y + 1-th dubious gift to the set of x chosen among the first y dubious gifts; , otherwise, if do not put the y + 1-th dubious gift. This dynamics can be computed in O(t2) time, where t is the total number of gifts. The complexity of the solution is . Sample solution: http://pastie.org/4897519 (archived copy)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7684
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #142 - Codeforces - Code 1",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 2",
          "code": "2 1\n1 2 1\n2 0 1\n4 0 1 2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 3",
          "code": "\\_dangerous\\_",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 4",
          "code": "double temp = pow((double)n, 0.5);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 - Codeforces - Code 5",
          "code": "long long square_root = (long long)(temp);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5432",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #142 Problem Analysis - Codeforces - Code 1",
          "code": "d[j][k] := min(d[j][k], d[j][k+1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5437",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"No self-loops allowed: ai (%d) != bi (%d)\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.find(edge) == edges.end(), \"No multiple edges allowed: edge between %d and %d appears multiple times\", u, v);\n\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"No self-loops allowed: ai (%d) != bi (%d)\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.find(edge) == edges.end(), \"No multiple edges allowed: edge between %d and %d appears multiple times\", u, v);\n\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"No self-loops allowed: ai (%d) != bi (%d)\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.find(edge) == edges.end(), \"No multiple edges allowed: edge between %d and %d appears multiple times\", u, v);\n\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m_input = opt<int>(\"m\", -1);\n    int k = opt<int>(\"k\", -1);\n\n    long long total_possible_edges = 1LL * n * (n - 1) / 2;\n    int max_m = min(total_possible_edges, 1000000LL);\n\n    vector<pair<int,int>> edges;\n\n    int m = 0; // Will be set accordingly\n\n    if (type == \"empty\") {\n        m = 0;\n    } else if (type == \"full\") {\n        m = max_m;\n        // Generate up to m edges\n        if (m > 0) {\n            for (int i = 1; i <= n; ++i) {\n                for (int j = i+1; j <= n; ++j) {\n                    edges.emplace_back(i, j);\n                    if ((int)edges.size() == m) break;\n                }\n                if ((int)edges.size() == m) break;\n            }\n        }\n    } else if (type == \"random\") {\n        if (m_input != -1) {\n            m = min(m_input, max_m);\n        } else {\n            m = max_m;\n        }\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edge_set.emplace(u, v);\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else if (type == \"chain\") {\n        m = n - 1;\n        m = min(m, 1000000);\n        for (int i = 1; i < n && (int)edges.size() < m; ++i)\n            edges.emplace_back(i, i+1);\n    } else if (type == \"star\") {\n        m = n - 1;\n        m = min(m, 1000000);\n        for (int i = 2; i <= n && (int)edges.size() < m; ++i)\n            edges.emplace_back(1, i);\n    } else if (type == \"clique\") {\n        if (k == -1) {\n            k = n;\n        }\n        m = k * (k -1) / 2;\n        m = min(m, 1000000);\n        for (int i = 1; i <= k && (int)edges.size() < m; ++i)\n            for (int j = i+1; j <= k && (int)edges.size() < m; ++j)\n                edges.emplace_back(i, j);\n    } else {\n        // default random\n        m = m_input != -1 ? min(m_input, max_m) : max_m;\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edge_set.emplace(u, v);\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n\n    // shuffle edges if necessary\n    if (type == \"full\" || type == \"random\" || type == \"clique\") {\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output n m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    // Output m edges\n    for (const auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m_input = opt<int>(\"m\", -1);\n    int k = opt<int>(\"k\", -1);\n\n    long long total_possible_edges = 1LL * n * (n - 1) / 2;\n    int max_m = min(total_possible_edges, 1000000LL);\n\n    vector<pair<int,int>> edges;\n\n    int m = 0; // Will be set accordingly\n\n    if (type == \"empty\") {\n        m = 0;\n    } else if (type == \"full\") {\n        m = max_m;\n        // Generate up to m edges\n        if (m > 0) {\n            for (int i = 1; i <= n; ++i) {\n                for (int j = i+1; j <= n; ++j) {\n                    edges.emplace_back(i, j);\n                    if ((int)edges.size() == m) break;\n                }\n                if ((int)edges.size() == m) break;\n            }\n        }\n    } else if (type == \"random\") {\n        if (m_input != -1) {\n            m = min(m_input, max_m);\n        } else {\n            m = max_m;\n        }\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edge_set.emplace(u, v);\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else if (type == \"chain\") {\n        m = n - 1;\n        m = min(m, 1000000);\n        for (int i = 1; i < n && (int)edges.size() < m; ++i)\n            edges.emplace_back(i, i+1);\n    } else if (type == \"star\") {\n        m = n - 1;\n        m = min(m, 1000000);\n        for (int i = 2; i <= n && (int)edges.size() < m; ++i)\n            edges.emplace_back(1, i);\n    } else if (type == \"clique\") {\n        if (k == -1) {\n            k = n;\n        }\n        m = k * (k -1) / 2;\n        m = min(m, 1000000);\n        for (int i = 1; i <= k && (int)edges.size() < m; ++i)\n            for (int j = i+1; j <= k && (int)edges.size() < m; ++j)\n                edges.emplace_back(i, j);\n    } else {\n        // default random\n        m = m_input != -1 ? min(m_input, max_m) : max_m;\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edge_set.emplace(u, v);\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n\n    // shuffle edges if necessary\n    if (type == \"full\" || type == \"random\" || type == \"clique\") {\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output n m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    // Output m edges\n    for (const auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type empty\n./gen -n 1 -type full\n./gen -n 2 -type empty\n./gen -n 2 -type full\n./gen -n 3 -type empty\n./gen -n 3 -type full\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type random -m 0\n./gen -n 3 -type random -m 3\n./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type clique -k 3\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type clique -k 5\n./gen -n 10 -type random -m 15\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type clique -k 20\n./gen -n 100 -type random -m 1000\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type clique -k 45\n./gen -n 1000 -type random -m 100000\n./gen -n 10000 -type chain\n./gen -n 10000 -type star\n./gen -n 10000 -type random -m 200000\n./gen -n 50000 -type chain\n./gen -n 50000 -type star\n./gen -n 50000 -type random -m 500000\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type random -m 1000000\n./gen -n 200000 -type random -m 1000000\n./gen -n 500000 -type random -m 1000000\n./gen -n 1000000 -type chain\n./gen -n 1000000 -type star\n./gen -n 1000000 -type random -m 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:47.753055",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "231/A",
      "title": "A. Team",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains a single integer n (1 ≤ n ≤ 1000) — the number of problems in the contest. Then n lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.",
      "output_spec": "OutputPrint a single integer — the number of problems the friends will implement on the contest.",
      "sample_tests": "ExamplesInputCopy31 1 01 1 11 0 0OutputCopy2InputCopy21 0 00 1 1OutputCopy1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains a single integer n (1 ≤ n ≤ 1000) — the number of problems in the contest. Then n lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.\n\nOutputPrint a single integer — the number of problems the friends will implement on the contest.\n\nInputCopy31 1 01 1 11 0 0OutputCopy2InputCopy21 0 00 1 1OutputCopy1\n\nInputCopy31 1 01 1 11 0 0\n\nOutputCopy2\n\nInputCopy21 0 00 1 1\n\nOutputCopy1\n\nNoteIn the first sample Petya and Vasya are sure that they know how to solve the first problem and all three of them know how to solve the second problem. That means that they will write solutions for these problems. Only Petya is sure about the solution for the third problem, but that isn't enough, so the friends won't take it. In the second sample the friends will only implement the second problem, as Vasya and Tonya are sure about the solution.",
      "solutions": [
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces",
          "content": "Hi to all!)Codeforces #143 for participants from second division is going to be today. I think, it is not necessary to remind, that coders with rating greater than 1699 will be able to take part out of the competition.Problems' autors for this event are Kholkin Pavel (HolkinPV) and Kuznetsov Nikolay (NALP). Kudryashov Igor Igor_Kudryashov and Agapov Gerald (Gerald) helped in contest's preparation too. Special thanks to creator great resource Codeforces Mike Mirzayanov (MikeMirzayanov) and our translator Maria Belova (Delinur).Score distribution will be determine later, monitor for changes).We wish you enjoy participating this competition and want you to get something new and useful.UPD: Score distribution will be standart 500-1000-1500-2000-2500.UPD2: Round is over. Thanks to all for participating. Six first coders solved all 5 problems, congratulations.1) teoy2) gomineral023) mrNobody4) Ryannnnnnn5) marschenly6) KuchumovIlyaEditorial will be published soon.UPD3: Editorial is published, you can find it here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5483",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1022
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces",
          "content": "Hi to all!)Codeforces #143 for participants from second division is going to be today. I think, it is not necessary to remind, that coders with rating greater than 1699 will be able to take part out of the competition.Problems' autors for this event are Kholkin Pavel (HolkinPV) and Kuznetsov Nikolay (NALP). Kudryashov Igor Igor_Kudryashov and Agapov Gerald (Gerald) helped in contest's preparation too. Special thanks to creator great resource Codeforces Mike Mirzayanov (MikeMirzayanov) and our translator Maria Belova (Delinur).Score distribution will be determine later, monitor for changes).We wish you enjoy participating this competition and want you to get something new and useful.UPD: Score distribution will be standart 500-1000-1500-2000-2500.UPD2: Round is over. Thanks to all for participating. Six first coders solved all 5 problems, congratulations.1) teoy2) gomineral023) mrNobody4) Ryannnnnnn5) marschenly6) KuchumovIlyaEditorial will be published soon.UPD3: Editorial is published, you can find it here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5483",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1022
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces",
          "content": "231A - TeamIt is needed just to implement actions described in statement. You had to read data and to calculate number of members of team, which were sure about the solution, for every task. If this number is greater than one, the answer must be increased by one.231B - Magic, Wizardry and WondersLet's see, what will be the last number of array after i iterations. After the first iteration it will be an - 1–an (and total number of elements will be decreased by one). After the second iteration the last number will be an - 2–an - 1 + an. It is not hard to see, that after n - 1 iterations remain a1–a2 + a3–a4 + ... + ( - 1)n + 1·an. In a such way, our task is to put numbers from 1 to l in array so, that sum of numbers in odd positions minus sum of numbers in even positions will equal to given d. This means sum of numbers in odd positions must be equal . But the minimal sum can be , and the maximal — .Because of this we should choose a2·k so, that s fits the boundaries. Constrains allow to do it in a such manner. Firstly, put ones on the even positions. If s > maxv after that, the answer is  - 1. Otherwise, let's increase each a2·k by one until s = minv. If we put l in all even positions and s < minv, than answer is  - 1 too. After we put numbers on even positions, let's write 1 in all odd positions, and while sum of this elements is less than s increase each one by fitting value.231C - To Add or Not to AddOne of the main observations, needed to solve this problem, is that the second number in answer always coincides with someone aj. Let's see why it is true. Suppose, the second number of the answer is aj + d for someone j and aj + d ≠ ai for all i. This means, we increased some numbers, which is less than aj, so that they became equal to aj, and then all this numbers and some numbers, which is equal to aj, we increased to aj + d. But if we didn't increase all this numbers to aj + d and remain they equal to aj, we'd perform less operations and the answer would be better.Due to this fact we can solve problem in a such manner. Sort array in non-decreasing order. Iterate over ai and calculate, what is the maximal number of ai we can obtain. For maximizing first number of answer, we must increase some lesser numbers to ai and perform not greater than k operations. It is obvious that firstly we should increase such aj that ai–aj is minimal. So, if we can solve problem in O(n2), we would iterate j from i to 0 and increase aj to ai, while we could. But the solution must be faster, and we will use binary search. We will brute the number of numbers, which we must do equal to ai. Suppose we fix cnt this value. Now we have to check if we can do cnt numbers equal to ai by not greater than k operations. For doing this, let’s calculate . If this value not greater than k, we can do it. For calculating sum quickly, we can save prefix sums and than si - cnt + 1, i = si–si–cnt. Finally we solved this problem in O(n·logn).231D - Magic BoxThe main subtask of this problem is to check whether we can observe the center of face of parallelepiped from point p = (x, y, z). Let’s see the case, when the face belongs to plane z = z1. For performing all calculations in integer numbers, multiply all coordinates x, y, z, x1, y1, z1 by 2. Take the point and normal to plane, containing the fixed face, which is directed out of interior of parallelepiped, that is . Also take vector . If undirected angle between this vectors is less than 90 degrees, we can observe a from p. For checking this we can use scalar product. If scalar product of and is strictly greater than zero, than that angle is fitting.231E - CactusIn this problem you should find the number of simple paths between some pair of vertices in vertex cactus. If you learn the structure of these graphs, it is not hard to see, that if we’ll squeeze each cycle in one vertex, we get a tree. So let’s squeeze all cycles in source graph and get this tree. Also every vertex of this tree we’ll mark, if it is squeezed cycle (let’s call this vertices 1-vertices) or single vertex in source graph (this vertices we’ll call 0-vertices).Then, we’ll do the following to find the number of paths between vertices a and b in source graph. Suppose c is a vertex, corresponding to a in obtained tree (it can be a single vertex or a vertex, corresponding to a squeezed cycle with a), and d is a vertex, corresponding to b. Let’s denote deg is the number of 1-vertices in path from c to d in tree. Than it is easy to understand, that the answer for query is , because every cycle (1-vertex) increase the number of possible ways twice (you can go from one vertex to other by two ways in cycle).It means that we need to count the number of 1-vertex on the path from one vertex to other in tree quickly to answer a query. We can do it in a following way. Hang our tree for one vertex, which we’ll call a root. Denote for every vertex cntv is the number of 1-vertex on the way to the root (including root and vertex itself). Suppose we want to find the number of 1-vertex on the path from a to b. Denote c is the least common ancestor of vertices a and b. Than number of 1-vertex on the way from a to b is equal to cnta + cntb–2·cntc, if c is 0-vertex and cnta + cntb–2·cntc + 1, if c is 1-vertex. The least common ancestor can be found by standard method — binary method recovery. Finally we have O(m + k·logn) solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5486",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 231\\s*A"
          },
          "content_length": 5387
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 1",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 2",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 1",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 2",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "stringstream",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "ONLINE_JUDGE",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "freopen(\"output.txt\", \"w\", stdout);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "while (cin >> first_variable_of_input)\n{\n    // Read remaining data for this test case\n    // Process data and print the answer\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "int n = in.nextInt(), k = in.nextInt();\nint[] a = new int[n];\nfor (int i = 0; i < n; i++) {\n\ta[i] = in.nextInt();\n}\nArrays.sort(a);\nint i = n - 1, j = n - 2;\nint mocc = 0;\nint mnum = 0;\nint num = a[n - 1];\nint tdiff = 0;\nint occ = 1;\nwhile (i >= 0 && j >= 0) {//0 2 3 4 6\n\tif (tdiff + num - a[j] <= k) {\n\t\ttdiff += num - a[j];\n\t\tocc++;\n\t\tj--;\n\t} else {\n\t\tif (occ >= mocc) {\n\t\t\tmocc = occ;\n\t\t\tmnum = num;\n\t\t}\n\t\tocc--;\n\t\ttdiff += (i - j - 1) * (a[i - 1] - a[i]);\n\t\tnum = a[--i];\n\t}\n}\nif (occ >= mocc) {\n\tmocc = occ;\n\tmnum = num;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "int n = in.nextInt(), k = in.nextInt();\nint[] a = new int[n];\nfor (int i = 0; i < n; i++) {\n\ta[i] = in.nextInt();\n}\nArrays.sort(a);\nint i = n - 1, j = n - 2;\nint mocc = 0;\nint mnum = 0;\nint num = a[n - 1];\nint tdiff = 0;\nint occ = 1;\nwhile (i >= 0 && j >= 0) {//0 2 3 4 6\n\tif (tdiff + num - a[j] <= k) {\n\t\ttdiff += num - a[j];\n\t\tocc++;\n\t\tj--;\n\t} else {\n\t\tif (occ >= mocc) {\n\t\t\tmocc = occ;\n\t\t\tmnum = num;\n\t\t}\n\t\tocc--;\n\t\ttdiff += (i - j - 1) * (a[i - 1] - a[i]);\n\t\tnum = a[--i];\n\t}\n}\nif (occ >= mocc) {\n\tmocc = occ;\n\tmnum = num;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "occ--;\ntdiff += (i - j - 1) * (a[i - 1] - a[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "occ--;\ntdiff += (i - j - 1) * (a[i - 1] - a[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n#include <regex>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(regex_match(s, regex(\"^[01]( +[01]){2}$\")), \"Invalid format on line %d\", i + 2);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n#include <regex>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(regex_match(s, regex(\"^[01]( +[01]){2}$\")), \"Invalid format on line %d\", i + 2);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n#include <regex>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(regex_match(s, regex(\"^[01]( +[01]){2}$\")), \"Invalid format on line %d\", i + 2);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the number of problems 'n' and the type of test case 'type' from command line arguments\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output the number of problems\n    printf(\"%d\\n\", n);\n\n    for (int i = 0; i < n; ++i) {\n        int a, b, c;\n\n        if (type == \"all_sure\") {\n            // All three friends are sure about every problem\n            a = b = c = 1;\n        } else if (type == \"none_sure\") {\n            // None of the friends are sure about any problem\n            a = b = c = 0;\n        } else if (type == \"one_sure\") {\n            // Exactly one friend is sure about each problem\n            int who = rnd.next(3); // Randomly choose which friend is sure\n            a = b = c = 0;\n            if (who == 0) a = 1;\n            else if (who == 1) b = 1;\n            else c = 1;\n        } else if (type == \"two_sure\") {\n            // Exactly two friends are sure about each problem\n            int who = rnd.next(3); // Randomly choose which friend is not sure\n            a = b = c = 1;\n            if (who == 0) a = 0;\n            else if (who == 1) b = 0;\n            else c = 0;\n        } else if (type == \"alternating\") {\n            // Alternate between different types of sureties\n            if (i % 5 == 0) {\n                a = b = c = 0;\n            } else if (i % 5 == 1) {\n                a = b = c = 1;\n            } else if (i % 5 == 2) {\n                int who = rnd.next(3);\n                a = b = c = 0;\n                if (who == 0) a = 1;\n                else if (who == 1) b = 1;\n                else c = 1;\n            } else if (i % 5 == 3) {\n                int who = rnd.next(3);\n                a = b = c = 1;\n                if (who == 0) a = 0;\n                else if (who == 1) b = 0;\n                else c = 0;\n            } else {\n                a = rnd.next(0, 1);\n                b = rnd.next(0, 1);\n                c = rnd.next(0, 1);\n            }\n        } else {\n            // Randomly decide each friend's surety\n            a = rnd.next(0, 1);\n            b = rnd.next(0, 1);\n            c = rnd.next(0, 1);\n        }\n\n        // Output the surety of Petya, Vasya, and Tonya for the problem\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the number of problems 'n' and the type of test case 'type' from command line arguments\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output the number of problems\n    printf(\"%d\\n\", n);\n\n    for (int i = 0; i < n; ++i) {\n        int a, b, c;\n\n        if (type == \"all_sure\") {\n            // All three friends are sure about every problem\n            a = b = c = 1;\n        } else if (type == \"none_sure\") {\n            // None of the friends are sure about any problem\n            a = b = c = 0;\n        } else if (type == \"one_sure\") {\n            // Exactly one friend is sure about each problem\n            int who = rnd.next(3); // Randomly choose which friend is sure\n            a = b = c = 0;\n            if (who == 0) a = 1;\n            else if (who == 1) b = 1;\n            else c = 1;\n        } else if (type == \"two_sure\") {\n            // Exactly two friends are sure about each problem\n            int who = rnd.next(3); // Randomly choose which friend is not sure\n            a = b = c = 1;\n            if (who == 0) a = 0;\n            else if (who == 1) b = 0;\n            else c = 0;\n        } else if (type == \"alternating\") {\n            // Alternate between different types of sureties\n            if (i % 5 == 0) {\n                a = b = c = 0;\n            } else if (i % 5 == 1) {\n                a = b = c = 1;\n            } else if (i % 5 == 2) {\n                int who = rnd.next(3);\n                a = b = c = 0;\n                if (who == 0) a = 1;\n                else if (who == 1) b = 1;\n                else c = 1;\n            } else if (i % 5 == 3) {\n                int who = rnd.next(3);\n                a = b = c = 1;\n                if (who == 0) a = 0;\n                else if (who == 1) b = 0;\n                else c = 0;\n            } else {\n                a = rnd.next(0, 1);\n                b = rnd.next(0, 1);\n                c = rnd.next(0, 1);\n            }\n        } else {\n            // Randomly decide each friend's surety\n            a = rnd.next(0, 1);\n            b = rnd.next(0, 1);\n            c = rnd.next(0, 1);\n        }\n\n        // Output the surety of Petya, Vasya, and Tonya for the problem\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_sure\n./gen -n 1 -type none_sure\n./gen -n 1 -type one_sure\n./gen -n 1 -type two_sure\n./gen -n 1 -type random\n./gen -n 1 -type alternating\n\n./gen -n 2 -type all_sure\n./gen -n 2 -type none_sure\n./gen -n 2 -type one_sure\n./gen -n 2 -type two_sure\n./gen -n 2 -type random\n./gen -n 2 -type alternating\n\n./gen -n 10 -type all_sure\n./gen -n 10 -type none_sure\n./gen -n 10 -type one_sure\n./gen -n 10 -type two_sure\n./gen -n 10 -type random\n./gen -n 10 -type alternating\n\n./gen -n 100 -type all_sure\n./gen -n 100 -type none_sure\n./gen -n 100 -type one_sure\n./gen -n 100 -type two_sure\n./gen -n 100 -type random\n./gen -n 100 -type alternating\n\n./gen -n 500 -type all_sure\n./gen -n 500 -type none_sure\n./gen -n 500 -type one_sure\n./gen -n 500 -type two_sure\n./gen -n 500 -type random\n./gen -n 500 -type alternating\n\n./gen -n 999 -type all_sure\n./gen -n 999 -type none_sure\n./gen -n 999 -type one_sure\n./gen -n 999 -type two_sure\n./gen -n 999 -type random\n./gen -n 999 -type alternating\n\n./gen -n 1000 -type all_sure\n./gen -n 1000 -type none_sure\n./gen -n 1000 -type one_sure\n./gen -n 1000 -type two_sure\n./gen -n 1000 -type random\n./gen -n 1000 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:49.407892",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "231/B",
      "title": "B. Magic, Wizardry and Wonders",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains three space-separated integers: n (2 ≤ n ≤ 100) — the initial number of cards on the table, d (|d| ≤ 104) — the number on the card that was left on the table after all the magical actions, and l (1 ≤ l ≤ 100) — the limits for the initial integers.",
      "output_spec": "OutputIf Vasya is mistaken, that is, if there doesn't exist a set that meets the requirements given in the statement, then print a single number -1, otherwise print the sought set containing n integers from 1 to l. Separate the integers by spaces. Print the integers in the order, in which they were written on the cards from left to right. If there are several suitable sets of numbers, you can print any of them.",
      "sample_tests": "ExamplesInputCopy3 3 2OutputCopy2 1 2 InputCopy5 -4 3OutputCopy-1InputCopy5 -4 4OutputCopy2 4 1 4 1",
      "description": "B. Magic, Wizardry and Wonders\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains three space-separated integers: n (2 ≤ n ≤ 100) — the initial number of cards on the table, d (|d| ≤ 104) — the number on the card that was left on the table after all the magical actions, and l (1 ≤ l ≤ 100) — the limits for the initial integers.\n\nOutputIf Vasya is mistaken, that is, if there doesn't exist a set that meets the requirements given in the statement, then print a single number -1, otherwise print the sought set containing n integers from 1 to l. Separate the integers by spaces. Print the integers in the order, in which they were written on the cards from left to right. If there are several suitable sets of numbers, you can print any of them.\n\nInputCopy3 3 2OutputCopy2 1 2 InputCopy5 -4 3OutputCopy-1InputCopy5 -4 4OutputCopy2 4 1 4 1\n\nInputCopy3 3 2\n\nOutputCopy2 1 2\n\nInputCopy5 -4 3\n\nOutputCopy-1\n\nInputCopy5 -4 4\n\nOutputCopy2 4 1 4 1",
      "solutions": [
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces",
          "content": "Hi to all!)Codeforces #143 for participants from second division is going to be today. I think, it is not necessary to remind, that coders with rating greater than 1699 will be able to take part out of the competition.Problems' autors for this event are Kholkin Pavel (HolkinPV) and Kuznetsov Nikolay (NALP). Kudryashov Igor Igor_Kudryashov and Agapov Gerald (Gerald) helped in contest's preparation too. Special thanks to creator great resource Codeforces Mike Mirzayanov (MikeMirzayanov) and our translator Maria Belova (Delinur).Score distribution will be determine later, monitor for changes).We wish you enjoy participating this competition and want you to get something new and useful.UPD: Score distribution will be standart 500-1000-1500-2000-2500.UPD2: Round is over. Thanks to all for participating. Six first coders solved all 5 problems, congratulations.1) teoy2) gomineral023) mrNobody4) Ryannnnnnn5) marschenly6) KuchumovIlyaEditorial will be published soon.UPD3: Editorial is published, you can find it here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5483",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1022
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces",
          "content": "Hi to all!)Codeforces #143 for participants from second division is going to be today. I think, it is not necessary to remind, that coders with rating greater than 1699 will be able to take part out of the competition.Problems' autors for this event are Kholkin Pavel (HolkinPV) and Kuznetsov Nikolay (NALP). Kudryashov Igor Igor_Kudryashov and Agapov Gerald (Gerald) helped in contest's preparation too. Special thanks to creator great resource Codeforces Mike Mirzayanov (MikeMirzayanov) and our translator Maria Belova (Delinur).Score distribution will be determine later, monitor for changes).We wish you enjoy participating this competition and want you to get something new and useful.UPD: Score distribution will be standart 500-1000-1500-2000-2500.UPD2: Round is over. Thanks to all for participating. Six first coders solved all 5 problems, congratulations.1) teoy2) gomineral023) mrNobody4) Ryannnnnnn5) marschenly6) KuchumovIlyaEditorial will be published soon.UPD3: Editorial is published, you can find it here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5483",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1022
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces",
          "content": "231A - TeamIt is needed just to implement actions described in statement. You had to read data and to calculate number of members of team, which were sure about the solution, for every task. If this number is greater than one, the answer must be increased by one.231B - Magic, Wizardry and WondersLet's see, what will be the last number of array after i iterations. After the first iteration it will be an - 1–an (and total number of elements will be decreased by one). After the second iteration the last number will be an - 2–an - 1 + an. It is not hard to see, that after n - 1 iterations remain a1–a2 + a3–a4 + ... + ( - 1)n + 1·an. In a such way, our task is to put numbers from 1 to l in array so, that sum of numbers in odd positions minus sum of numbers in even positions will equal to given d. This means sum of numbers in odd positions must be equal . But the minimal sum can be , and the maximal — .Because of this we should choose a2·k so, that s fits the boundaries. Constrains allow to do it in a such manner. Firstly, put ones on the even positions. If s > maxv after that, the answer is  - 1. Otherwise, let's increase each a2·k by one until s = minv. If we put l in all even positions and s < minv, than answer is  - 1 too. After we put numbers on even positions, let's write 1 in all odd positions, and while sum of this elements is less than s increase each one by fitting value.231C - To Add or Not to AddOne of the main observations, needed to solve this problem, is that the second number in answer always coincides with someone aj. Let's see why it is true. Suppose, the second number of the answer is aj + d for someone j and aj + d ≠ ai for all i. This means, we increased some numbers, which is less than aj, so that they became equal to aj, and then all this numbers and some numbers, which is equal to aj, we increased to aj + d. But if we didn't increase all this numbers to aj + d and remain they equal to aj, we'd perform less operations and the answer would be better.Due to this fact we can solve problem in a such manner. Sort array in non-decreasing order. Iterate over ai and calculate, what is the maximal number of ai we can obtain. For maximizing first number of answer, we must increase some lesser numbers to ai and perform not greater than k operations. It is obvious that firstly we should increase such aj that ai–aj is minimal. So, if we can solve problem in O(n2), we would iterate j from i to 0 and increase aj to ai, while we could. But the solution must be faster, and we will use binary search. We will brute the number of numbers, which we must do equal to ai. Suppose we fix cnt this value. Now we have to check if we can do cnt numbers equal to ai by not greater than k operations. For doing this, let’s calculate . If this value not greater than k, we can do it. For calculating sum quickly, we can save prefix sums and than si - cnt + 1, i = si–si–cnt. Finally we solved this problem in O(n·logn).231D - Magic BoxThe main subtask of this problem is to check whether we can observe the center of face of parallelepiped from point p = (x, y, z). Let’s see the case, when the face belongs to plane z = z1. For performing all calculations in integer numbers, multiply all coordinates x, y, z, x1, y1, z1 by 2. Take the point and normal to plane, containing the fixed face, which is directed out of interior of parallelepiped, that is . Also take vector . If undirected angle between this vectors is less than 90 degrees, we can observe a from p. For checking this we can use scalar product. If scalar product of and is strictly greater than zero, than that angle is fitting.231E - CactusIn this problem you should find the number of simple paths between some pair of vertices in vertex cactus. If you learn the structure of these graphs, it is not hard to see, that if we’ll squeeze each cycle in one vertex, we get a tree. So let’s squeeze all cycles in source graph and get this tree. Also every vertex of this tree we’ll mark, if it is squeezed cycle (let’s call this vertices 1-vertices) or single vertex in source graph (this vertices we’ll call 0-vertices).Then, we’ll do the following to find the number of paths between vertices a and b in source graph. Suppose c is a vertex, corresponding to a in obtained tree (it can be a single vertex or a vertex, corresponding to a squeezed cycle with a), and d is a vertex, corresponding to b. Let’s denote deg is the number of 1-vertices in path from c to d in tree. Than it is easy to understand, that the answer for query is , because every cycle (1-vertex) increase the number of possible ways twice (you can go from one vertex to other by two ways in cycle).It means that we need to count the number of 1-vertex on the path from one vertex to other in tree quickly to answer a query. We can do it in a following way. Hang our tree for one vertex, which we’ll call a root. Denote for every vertex cntv is the number of 1-vertex on the way to the root (including root and vertex itself). Suppose we want to find the number of 1-vertex on the path from a to b. Denote c is the least common ancestor of vertices a and b. Than number of 1-vertex on the way from a to b is equal to cnta + cntb–2·cntc, if c is 0-vertex and cnta + cntb–2·cntc + 1, if c is 1-vertex. The least common ancestor can be found by standard method — binary method recovery. Finally we have O(m + k·logn) solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5486",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 231\\s*B"
          },
          "content_length": 5387
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 1",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 2",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 1",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 2",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "stringstream",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "ONLINE_JUDGE",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "freopen(\"output.txt\", \"w\", stdout);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "while (cin >> first_variable_of_input)\n{\n    // Read remaining data for this test case\n    // Process data and print the answer\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "int n = in.nextInt(), k = in.nextInt();\nint[] a = new int[n];\nfor (int i = 0; i < n; i++) {\n\ta[i] = in.nextInt();\n}\nArrays.sort(a);\nint i = n - 1, j = n - 2;\nint mocc = 0;\nint mnum = 0;\nint num = a[n - 1];\nint tdiff = 0;\nint occ = 1;\nwhile (i >= 0 && j >= 0) {//0 2 3 4 6\n\tif (tdiff + num - a[j] <= k) {\n\t\ttdiff += num - a[j];\n\t\tocc++;\n\t\tj--;\n\t} else {\n\t\tif (occ >= mocc) {\n\t\t\tmocc = occ;\n\t\t\tmnum = num;\n\t\t}\n\t\tocc--;\n\t\ttdiff += (i - j - 1) * (a[i - 1] - a[i]);\n\t\tnum = a[--i];\n\t}\n}\nif (occ >= mocc) {\n\tmocc = occ;\n\tmnum = num;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "int n = in.nextInt(), k = in.nextInt();\nint[] a = new int[n];\nfor (int i = 0; i < n; i++) {\n\ta[i] = in.nextInt();\n}\nArrays.sort(a);\nint i = n - 1, j = n - 2;\nint mocc = 0;\nint mnum = 0;\nint num = a[n - 1];\nint tdiff = 0;\nint occ = 1;\nwhile (i >= 0 && j >= 0) {//0 2 3 4 6\n\tif (tdiff + num - a[j] <= k) {\n\t\ttdiff += num - a[j];\n\t\tocc++;\n\t\tj--;\n\t} else {\n\t\tif (occ >= mocc) {\n\t\t\tmocc = occ;\n\t\t\tmnum = num;\n\t\t}\n\t\tocc--;\n\t\ttdiff += (i - j - 1) * (a[i - 1] - a[i]);\n\t\tnum = a[--i];\n\t}\n}\nif (occ >= mocc) {\n\tmocc = occ;\n\tmnum = num;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "occ--;\ntdiff += (i - j - 1) * (a[i - 1] - a[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "occ--;\ntdiff += (i - j - 1) * (a[i - 1] - a[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(-10000, 10000, \"d\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(-10000, 10000, \"d\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(-10000, 10000, \"d\");\n    inf.readSpace();\n    int l = inf.readInt(1, 100, \"l\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    int n = inf.readInt();\n    int d = inf.readInt();\n    int l = inf.readInt();\n    \n    if (n < 2 || n > 100)\n        quitf(_fail, \"n is out of range\");\n\n    if (abs(d) > 10000)\n        quitf(_fail, \"d is out of range\");\n\n    if (l < 1 || l > 100)\n        quitf(_fail, \"l is out of range\");\n\n    if (ouf.seekEof())\n        quitf(_wa, \"Contestant output is empty\");\n\n    int firstInt = ouf.readInt(-1e9, 1e9, \"first integer\");\n    if (firstInt == -1) {\n        // Contestant says Vasya is mistaken\n        // Compute D_min and D_max\n        int n_odd = (n + 1) / 2;\n        int n_even = n / 2;\n        int D_max = n_odd * l - n_even * 1;\n        int D_min = n_odd * 1 - n_even * l;\n        if (D_min <= d && d <= D_max)\n            quitf(_wa, \"Vasya is not mistaken\");\n        else\n            quitf(_ok, \"Correct, Vasya is mistaken\");\n    } else {\n        // Contestant provides a sequence of n integers\n        std::vector<int> a;\n        a.push_back(firstInt);\n\n        for (int i = 1; i < n; ++i) {\n            if (ouf.seekEof())\n                quitf(_wa, \"Expected %d integers, but got %d\", n, a.size());\n            int x = ouf.readInt(-1e9, 1e9, format(\"number #%d\", i+1).c_str());\n            a.push_back(x);\n        }\n\n        if (!ouf.seekEof())\n            quitf(_wa, \"Excess tokens in output\");\n\n        for (size_t i = 0; i < a.size(); ++i) {\n            if (a[i] < 1 || a[i] > l)\n                quitf(_wa, \"a[%d]=%d is out of range [1, %d]\", i+1, a[i], l);\n        }\n\n        int sum = 0;\n        for (int i = 0; i < n; ++i) {\n            int coef = ((i % 2 == 0) ? 1 : -1); // Coef is 1 for i=0, -1 for i=1, etc.\n            sum += coef * a[i];\n        }\n\n        if (sum != d) {\n            quitf(_wa, \"Sum of sequence is %d, expected %d\", sum, d);\n        }\n\n        quitf(_ok, \"Correct sequence found\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int nmax = opt<int>(\"nmax\", 100); // Maximal n\n    int lmax = opt<int>(\"lmax\", 100); // Maximal l\n    string type = opt<string>(\"type\", \"random\");\n\n    int n, l, d;\n\n    if (type == \"valid\") {\n        // Generate n, l, and d such that there is a solution\n        n = rnd.next(2, nmax);\n        l = rnd.next(1, lmax);\n\n        int n_odd = (n + 1) / 2;\n        int n_even = n / 2;\n\n        int S_min = n_odd * 1 - n_even * l;\n        int S_max = n_odd * l - n_even *1;\n\n        int S_min_limit = max(S_min, -10000);\n        int S_max_limit = min(S_max, 10000);\n\n        d = rnd.next(S_min_limit, S_max_limit);\n    } else if (type == \"invalid\") {\n        // Generate n, l, and d such that there is no solution\n        n = rnd.next(2, nmax);\n        l = rnd.next(1, lmax);\n\n        int n_odd = (n + 1) / 2;\n        int n_even = n / 2;\n\n        int S_min = n_odd * 1 - n_even * l;\n        int S_max = n_odd * l - n_even *1;\n\n        int S_min_limit = max(S_min, -10000);\n        int S_max_limit = min(S_max, 10000);\n\n        // Pick d outside [S_min_limit, S_max_limit]\n        if (rnd.next(2) == 0) {\n            // d less than S_min_limit\n            d = S_min_limit - rnd.next(1, 10000);\n            if (d < -10000) d = -10000;\n        } else {\n            // d greater than S_max_limit\n            d = S_max_limit + rnd.next(1, 10000);\n            if (d > 10000) d = 10000;\n        }\n    } else if (type == \"d_at_limit\") {\n        n = rnd.next(2, nmax);\n        l = rnd.next(1, lmax);\n\n        int n_odd = (n + 1) / 2;\n        int n_even = n / 2;\n\n        int S_min = n_odd * 1 - n_even * l;\n        int S_max = n_odd * l - n_even *1;\n\n        int S_min_limit = max(S_min, -10000);\n        int S_max_limit = min(S_max, 10000);\n\n        if (rnd.next(2) == 0)\n            d = S_min_limit;\n        else\n            d = S_max_limit;\n\n    } else if (type == \"max_n\") {\n        n = nmax;\n        l = rnd.next(1, lmax);\n\n        int n_odd = (n +1)/2;\n        int n_even = n/2;\n\n        int S_min = n_odd *1 - n_even * l;\n        int S_max = n_odd * l - n_even *1;\n\n        int S_min_limit = max(S_min, -10000);\n        int S_max_limit = min(S_max, 10000);\n\n        d = rnd.next(S_min_limit, S_max_limit);\n    } else { // random\n        n = rnd.next(2, nmax);\n        l = rnd.next(1, lmax);\n\n        int n_odd = (n +1)/2;\n        int n_even = n/2;\n\n        int S_min = n_odd *1 - n_even * l;\n        int S_max = n_odd * l - n_even *1;\n\n        int S_min_limit = max(S_min, -10000);\n        int S_max_limit = min(S_max, 10000);\n\n        if (rnd.next(2) == 0) {\n            // Generate valid d\n            d = rnd.next(S_min_limit, S_max_limit);\n        } else {\n            // Generate invalid d\n            if (rnd.next(2)==0) {\n                // d less than S_min_limit\n                d = S_min_limit - rnd.next(1, 10000);\n                if (d < -10000) d = -10000;\n            } else {\n                // d greater than S_max_limit\n                d = S_max_limit + rnd.next(1, 10000);\n                if (d > 10000) d = 10000;\n            }\n        }\n    }\n\n    // Output n, d, l\n    printf(\"%d %d %d\\n\", n, d, l);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int nmax = opt<int>(\"nmax\", 100); // Maximal n\n    int lmax = opt<int>(\"lmax\", 100); // Maximal l\n    string type = opt<string>(\"type\", \"random\");\n\n    int n, l, d;\n\n    if (type == \"valid\") {\n        // Generate n, l, and d such that there is a solution\n        n = rnd.next(2, nmax);\n        l = rnd.next(1, lmax);\n\n        int n_odd = (n + 1) / 2;\n        int n_even = n / 2;\n\n        int S_min = n_odd * 1 - n_even * l;\n        int S_max = n_odd * l - n_even *1;\n\n        int S_min_limit = max(S_min, -10000);\n        int S_max_limit = min(S_max, 10000);\n\n        d = rnd.next(S_min_limit, S_max_limit);\n    } else if (type == \"invalid\") {\n        // Generate n, l, and d such that there is no solution\n        n = rnd.next(2, nmax);\n        l = rnd.next(1, lmax);\n\n        int n_odd = (n + 1) / 2;\n        int n_even = n / 2;\n\n        int S_min = n_odd * 1 - n_even * l;\n        int S_max = n_odd * l - n_even *1;\n\n        int S_min_limit = max(S_min, -10000);\n        int S_max_limit = min(S_max, 10000);\n\n        // Pick d outside [S_min_limit, S_max_limit]\n        if (rnd.next(2) == 0) {\n            // d less than S_min_limit\n            d = S_min_limit - rnd.next(1, 10000);\n            if (d < -10000) d = -10000;\n        } else {\n            // d greater than S_max_limit\n            d = S_max_limit + rnd.next(1, 10000);\n            if (d > 10000) d = 10000;\n        }\n    } else if (type == \"d_at_limit\") {\n        n = rnd.next(2, nmax);\n        l = rnd.next(1, lmax);\n\n        int n_odd = (n + 1) / 2;\n        int n_even = n / 2;\n\n        int S_min = n_odd * 1 - n_even * l;\n        int S_max = n_odd * l - n_even *1;\n\n        int S_min_limit = max(S_min, -10000);\n        int S_max_limit = min(S_max, 10000);\n\n        if (rnd.next(2) == 0)\n            d = S_min_limit;\n        else\n            d = S_max_limit;\n\n    } else if (type == \"max_n\") {\n        n = nmax;\n        l = rnd.next(1, lmax);\n\n        int n_odd = (n +1)/2;\n        int n_even = n/2;\n\n        int S_min = n_odd *1 - n_even * l;\n        int S_max = n_odd * l - n_even *1;\n\n        int S_min_limit = max(S_min, -10000);\n        int S_max_limit = min(S_max, 10000);\n\n        d = rnd.next(S_min_limit, S_max_limit);\n    } else { // random\n        n = rnd.next(2, nmax);\n        l = rnd.next(1, lmax);\n\n        int n_odd = (n +1)/2;\n        int n_even = n/2;\n\n        int S_min = n_odd *1 - n_even * l;\n        int S_max = n_odd * l - n_even *1;\n\n        int S_min_limit = max(S_min, -10000);\n        int S_max_limit = min(S_max, 10000);\n\n        if (rnd.next(2) == 0) {\n            // Generate valid d\n            d = rnd.next(S_min_limit, S_max_limit);\n        } else {\n            // Generate invalid d\n            if (rnd.next(2)==0) {\n                // d less than S_min_limit\n                d = S_min_limit - rnd.next(1, 10000);\n                if (d < -10000) d = -10000;\n            } else {\n                // d greater than S_max_limit\n                d = S_max_limit + rnd.next(1, 10000);\n                if (d > 10000) d = 10000;\n            }\n        }\n    }\n\n    // Output n, d, l\n    printf(\"%d %d %d\\n\", n, d, l);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Valid test cases\n./gen -type valid -nmax 2 -lmax 2\n./gen -type valid -nmax 2 -lmax 100\n./gen -type valid -nmax 100 -lmax 100\n./gen -type valid -nmax 100 -lmax 1\n./gen -type valid -nmax 50 -lmax 50\n\n# Invalid test cases\n./gen -type invalid -nmax 2 -lmax 2\n./gen -type invalid -nmax 2 -lmax 100\n./gen -type invalid -nmax 100 -lmax 1\n./gen -type invalid -nmax 50 -lmax 50\n\n# Random test cases\n./gen -type random -nmax 100 -lmax 100\n./gen -type random -nmax 100 -lmax 50\n./gen -type random -nmax 100 -lmax 1\n./gen -type random -nmax 2 -lmax 100\n./gen -type random -nmax 50 -lmax 50\n\n# Test cases with d at limit\n./gen -type d_at_limit -nmax 100 -lmax 100\n./gen -type d_at_limit -nmax 100 -lmax 1\n./gen -type d_at_limit -nmax 2 -lmax 100\n\n# Test cases with maximal n\n./gen -type max_n -nmax 100 -lmax 100\n./gen -type max_n -nmax 100 -lmax 50\n./gen -type max_n -nmax 100 -lmax 1\n\n# More selected test cases\n./gen -type valid -nmax 2 -lmax 1\n./gen -type valid -nmax 99 -lmax 99\n./gen -type invalid -nmax 99 -lmax 99\n./gen -type d_at_limit -nmax 99 -lmax 99\n./gen -type max_n -nmax 99 -lmax 99\n./gen -type random -nmax 99 -lmax 99\n\n# Edge cases with n=2\n./gen -type valid -nmax 2 -lmax 100\n./gen -type invalid -nmax 2 -lmax 100\n./gen -type d_at_limit -nmax 2 -lmax 100\n./gen -type max_n -nmax 2 -lmax 100\n\n# Edge cases with l=1\n./gen -type valid -nmax 100 -lmax 1\n./gen -type invalid -nmax 100 -lmax 1\n./gen -type d_at_limit -nmax 100 -lmax 1\n./gen -type max_n -nmax 100 -lmax 1\n\n# Random large n and l\n./gen -type valid -nmax 100 -lmax 100\n./gen -type invalid -nmax 100 -lmax 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:51.631411",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "231/C",
      "title": "C. Прибавляй не прибавляй",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы два целых числа n и k (1 ≤ n ≤ 105; 0 ≤ k ≤ 109) — количество элементов в массиве и количество операций, которое разрешается выполнить, соответственно.В третьей строке задана последовательность из n целых чисел a1, a2, ..., an (|ai| ≤ 109) — исходный массив. Числа в строках разделены одиночными пробелами.",
      "output_spec": "Выходные данныеВ единственной строке выведите два числа — максимальное количество вхождений некоторого числа в массив после выполнения не более k разрешенных операций, а также минимальное число, для которого достигается выведенный максимум. Выведенные числа разделяйте пробельными символами.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 36 3 4 0 2Выходные данныеСкопировать3 4Входные данныеСкопировать3 45 5 5Выходные данныеСкопировать3 5Входные данныеСкопировать5 33 1 2 2 1Выходные данныеСкопировать4 2",
      "description": "C. Прибавляй не прибавляй\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы два целых числа n и k (1 ≤ n ≤ 105; 0 ≤ k ≤ 109) — количество элементов в массиве и количество операций, которое разрешается выполнить, соответственно.В третьей строке задана последовательность из n целых чисел a1, a2, ..., an (|ai| ≤ 109) — исходный массив. Числа в строках разделены одиночными пробелами.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите два числа — максимальное количество вхождений некоторого числа в массив после выполнения не более k разрешенных операций, а также минимальное число, для которого достигается выведенный максимум. Выведенные числа разделяйте пробельными символами.\n\nВыходные данные\n\nВходные данныеСкопировать5 36 3 4 0 2Выходные данныеСкопировать3 4Входные данныеСкопировать3 45 5 5Выходные данныеСкопировать3 5Входные данныеСкопировать5 33 1 2 2 1Выходные данныеСкопировать4 2\n\nВходные данныеСкопировать5 36 3 4 0 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 45 5 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 33 1 2 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере нужно один раз увеличить второй элемент массива и дважды увеличить пятый элемент массива. Таким образом, получим последовательность 6, 4, 4, 0, 4, в которой число 4 встречается 3 раза.Во втором примере не нужно выполнять ни одной операции, либо увеличить каждый элемент на единицу. В первом случае получим массив 5, 5, 5, во втором — 6, 6, 6. В обоих случаях максимальное количество вхождений равно 3. В случае равенства требуется найти минимальное число. Поэтому нужно выбрать первый вариант, так как число 5 меньше числа 6.В третьем примере нужно один раз увеличить второй элемент массива и один раз увеличить пятый элемент массива. Таким образом, получим последовательность 3, 2, 2, 2, 2, в которой число 2 встречается 4 раза.",
      "solutions": [
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces",
          "content": "Всем привет!)Сегодня состоится очередной раунд Codeforces #143 для участников второго дивизиона. Наверное, нет смысла напоминать, что ребята с рейтингом больше 1699 могут поучаствовать в нем вне конкурса.Авторами задач для данного мероприятия являются Холкин Павел (HolkinPV) и Кузнецов Николай (NALP). В подготовке контеста также участвовали Кудряшов Игорь (Igor_Kudryashov) и Агапов Геральд (Gerald). Отдельную благодарность выражаем создателю прекрасного ресурса Codeforces Михаилу Мирзаянову (MikeMirzayanov) и нашей переводчице Марии Беловой (Delinur).Распределение баллов по задачам будет определено через некоторое время, следите за изменениями).Желаем всем получить удовольствие от соревнования и почерпнуть для себя что-то новое и полезное.UPD: Распределение баллов по задачам будет стандартное 500-1000-1500-2000-2500.UPD2: Раунд окончен. Благодарим всех за участие. Шесть человек, занявшие первые места решили все 5 задач, поздравляем их с отличным выступлением.1) teoy2) gomineral023) mrNobody4) Ryannnnnnn5) marschenly6) KuchumovIlyaРазбор задач будет опубликован через некоторое время.UPD3: Разбор опубликован, его можно найти здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5483",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1146
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces",
          "content": "Всем привет!)Сегодня состоится очередной раунд Codeforces #143 для участников второго дивизиона. Наверное, нет смысла напоминать, что ребята с рейтингом больше 1699 могут поучаствовать в нем вне конкурса.Авторами задач для данного мероприятия являются Холкин Павел (HolkinPV) и Кузнецов Николай (NALP). В подготовке контеста также участвовали Кудряшов Игорь (Igor_Kudryashov) и Агапов Геральд (Gerald). Отдельную благодарность выражаем создателю прекрасного ресурса Codeforces Михаилу Мирзаянову (MikeMirzayanov) и нашей переводчице Марии Беловой (Delinur).Распределение баллов по задачам будет определено через некоторое время, следите за изменениями).Желаем всем получить удовольствие от соревнования и почерпнуть для себя что-то новое и полезное.UPD: Распределение баллов по задачам будет стандартное 500-1000-1500-2000-2500.UPD2: Раунд окончен. Благодарим всех за участие. Шесть человек, занявшие первые места решили все 5 задач, поздравляем их с отличным выступлением.1) teoy2) gomineral023) mrNobody4) Ryannnnnnn5) marschenly6) KuchumovIlyaРазбор задач будет опубликован через некоторое время.UPD3: Разбор опубликован, его можно найти здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5483",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1146
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces",
          "content": "231A - КомандаВ данной задаче нужно было реализовать то, что написано в условии, то есть считать данные и для каждой задачи посчитать количество участников команды, уверенных в ее решении. Если таких участников больше одного, то к ответу прибавить единицу.231B - Магия, волшебство и чудесаДля того чтобы быстро и элегантно решить эту задачу, можно рассмотреть, каким будет последнее число массива после i итераций. После первой итерации оно будет равно an - 1–an (при этом количество элементов уменьшится на единицу). После второй –-- an - 2–an - 1 + an. Очевидно, что после n - 1 итерации останется a1–a2 + a3–a4 + ... + ( - 1)n + 1·an. Таким образом, наша задача состоит в том, чтобы расставить в массиве числа от 1 до l так, чтобы сумма чисел стоящих на нечетных позициях минус сумма чисел на четных позициях была равна заданному d. Тогда мы должны на нечетных позициях набрать число, равное . При этом минимальное число, которое мы сможем набрать , а максимальное –-- . Поэтому нужно подобрать a2·k так, чтобы s укладывалось в эти границы. Ограничения позволяли сделать это следующим образом. Расставим сначала на четных позициях единицы. Теперь если s > maxv, то ответ  - 1. Иначе будем увеличивать каждое a2·k на единицу до тех пор, пока s < minv. Если, даже расставив на всех четных позициях l, окажется, что s < minv, то ответ также  - 1. После того, как мы расставили значения на четных позициях, ставим 1 на всех нечетных местах, и пока сумма этих элементов меньше s увеличиваем каждое из них на допустимую величину.231C - Прибавляй не прибавляйДля решения этой задачи нужно было заметить, что второе число ответа всегда совпадает с каким-то из чисел исходного массива. Это можно объяснить следующим образом. Предположим, второе число ответа равно aj + d для какого-то j и при этом aj + d ≠ ai ни для какого i. Это значит, что мы увеличили некоторые числа, меньшие aj, до значения aj, а затем эти числа, вместе с некоторыми числами, равными aj, увеличили до значения aj + d. Но если бы мы не увеличивали все эти числа до aj + d, а оставили равными aj, то потратили бы меньше операций увеличения и при этом улучшили бы ответ.Используя этот факт можно решать задачу следующим образом. Отсортируем исходный массив по неубыванию. Переберем второе число ответа –-- ai и посчитаем, какое мы можем получить максимальное первое число ответа. Для того чтобы максимизировать первое число ответа, нам надо увеличить некоторые меньшие числа до значения ai, при этом используя максимум k операций. Очевидно, что в первую очередь нужно увеличивать те aj, для которых ai–aj минимально. То есть если бы можно было решать задачу за O(n2), то мы бы шли по j от i налево и увеличивали aj до значения ai, пока хватает операций. Однако нужно более быстрое решение. Поэтому нам поможет бинарный поиск по ответу. Мы будем бинарным поиском перебирать количество чисел, которые нужно сделать равными ai. Предположим мы зафиксировали cnt эту величину. Теперь нам нужно за O(1) проверить, можно ли за не более чем k операций сделать cnt чисел равными ai. Для этого подсчитаем следующую величину . Если эта величина не превосходит k, то мы можем это сделать. Для того чтобы быстро вычислять сумму, нужно подсчитать si частичные суммы на префиксе и тогда si - cnt + 1, i = si–si–cnt. Итого мы получаем решение за O(n·logn).231D - Волшебный ящикВ данной задаче, по сути, нужно было проверить, что из точки p = (x, y, z) виден центр грани параллелепипеда. Рассмотрим случай, когда грань находится в плоскости z = z1. Для того чтобы можно было все вычисления производить в целых числах, умножим все координаты x, y, z, x1, y1, z1 на 2. Возьмем точку и вектор нормали к плоскости, содержащей эту грань, который направлен в сторону от внутренности параллелепипеда, то есть . Рассмотрим также вектор . Если неориентированный угол между этими векторами меньше 90 градусов, то из точки p будет видно точку a. Чтобы просто проверить это условие, нужно вычислить скалярное произведение между векторами и , и если оно строго больше нуля, то угол будет подходящим.231E - КактусВ этой задаче нужно было в вершинном кактусе для некоторых пар вершин найти количество простых путей между ними. Изучив структуру данного вида графов, можно понять, что если сжать каждый цикл вершинного кактуса –-- то получится дерево. Поэтому сожмем циклы в исходном графе и получим это самое дерево. Также для каждой вершины этого дерева пометим, является ли она сжатым циклом (назовем такие вершины 1-вершинами) или отдельной вершиной в исходном графе (такие назовем 0-вершинами). Теперь, чтобы найти количество путей между вершинами a и b в исходном графе, проделаем следующее. Обозначим за c вершину, которая соответствует вершине a в полученном дереве (это может быть либо отдельная вершина, либо вершина, соответствующая сжатому циклу, в котором лежит a), за d --– вершину, соответствующую b. Подсчитаем величину deg --– количество 1-вершин на пути из c в d в дереве. Тогда несложно понять, что ответ на запрос равен , так как каждый цикл (1-вершина) увеличивает количество возможных путей вдвое (потому что в цикле из одной вершины в другую можно пройти двумя способами).Таким образом, для ответа на запрос, нам надо быстро считать количество 1-вершин на пути из одной вершины в другую в дереве. Это можно делать следующим образом. Подвесим полученное дерево за какую-нибудь вершину, которую назовем корнем. Подсчитаем для каждой вершины cntv — количество 1-вершин на пути до корня (включая корень и саму вершину). Допустим, мы хотим найти количество 1-вершин на пути из a в b. Обозначим за c наименьший общий предок вершин a и b. Тогда количество 1-вершин на пути из a в b, равно cnta + cntb–2·cntc, если c является 0-вершиной и cnta + cntb–2·cntc + 1, если c — 1-вершина. Наименьший общий предок можно искать стандартным приемом –-- методом двоичного подъема. Итого мы имеем решение за O(m + k·logn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5486",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 231\\s*C"
          },
          "content_length": 5856
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 1",
          "code": "5 5\n1 2\n2 3\n2 4\n2 5\n4 5\n1\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 2",
          "code": "5 5\n1 2\n2 3\n2 4\n2 5\n4 5\n1\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 3",
          "code": "a[x] != a[x-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 4",
          "code": "s += (x-y-1) * (a[x] - a[x-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 5",
          "code": "a[x] - a[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 6",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 7",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 8",
          "code": "public Random() { this(++seedUniquifier + System.nanoTime()); }\n    private static volatile long seedUniquifier = 8682522807148012L;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 9",
          "code": "public Random() { this(++seedUniquifier + System.nanoTime()); }\n    private static volatile long seedUniquifier = 8682522807148012L;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 1",
          "code": "5 5\n1 2\n2 3\n2 4\n2 5\n4 5\n1\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 2",
          "code": "5 5\n1 2\n2 3\n2 4\n2 5\n4 5\n1\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 3",
          "code": "a[x] != a[x-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 4",
          "code": "s += (x-y-1) * (a[x] - a[x-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 5",
          "code": "a[x] - a[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 6",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 7",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 8",
          "code": "public Random() { this(++seedUniquifier + System.nanoTime()); }\n    private static volatile long seedUniquifier = 8682522807148012L;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 9",
          "code": "public Random() { this(++seedUniquifier + System.nanoTime()); }\n    private static volatile long seedUniquifier = 8682522807148012L;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 1",
          "code": "stringstream",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 2",
          "code": "#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 3",
          "code": "ONLINE_JUDGE",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 4",
          "code": "freopen(\"output.txt\", \"w\", stdout);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 5",
          "code": "while (cin >> first_variable_of_input)\n{\n    // Read remaining data for this test case\n    // Process data and print the answer\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 6",
          "code": "int n = in.nextInt(), k = in.nextInt();\nint[] a = new int[n];\nfor (int i = 0; i < n; i++) {\n\ta[i] = in.nextInt();\n}\nArrays.sort(a);\nint i = n - 1, j = n - 2;\nint mocc = 0;\nint mnum = 0;\nint num = a[n - 1];\nint tdiff = 0;\nint occ = 1;\nwhile (i >= 0 && j >= 0) {//0 2 3 4 6\n\tif (tdiff + num - a[j] <= k) {\n\t\ttdiff += num - a[j];\n\t\tocc++;\n\t\tj--;\n\t} else {\n\t\tif (occ >= mocc) {\n\t\t\tmocc = occ;\n\t\t\tmnum = num;\n\t\t}\n\t\tocc--;\n\t\ttdiff += (i - j - 1) * (a[i - 1] - a[i]);\n\t\tnum = a[--i];\n\t}\n}\nif (occ >= mocc) {\n\tmocc = occ;\n\tmnum = num;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 7",
          "code": "int n = in.nextInt(), k = in.nextInt();\nint[] a = new int[n];\nfor (int i = 0; i < n; i++) {\n\ta[i] = in.nextInt();\n}\nArrays.sort(a);\nint i = n - 1, j = n - 2;\nint mocc = 0;\nint mnum = 0;\nint num = a[n - 1];\nint tdiff = 0;\nint occ = 1;\nwhile (i >= 0 && j >= 0) {//0 2 3 4 6\n\tif (tdiff + num - a[j] <= k) {\n\t\ttdiff += num - a[j];\n\t\tocc++;\n\t\tj--;\n\t} else {\n\t\tif (occ >= mocc) {\n\t\t\tmocc = occ;\n\t\t\tmnum = num;\n\t\t}\n\t\tocc--;\n\t\ttdiff += (i - j - 1) * (a[i - 1] - a[i]);\n\t\tnum = a[--i];\n\t}\n}\nif (occ >= mocc) {\n\tmocc = occ;\n\tmnum = num;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 8",
          "code": "occ--;\ntdiff += (i - j - 1) * (a[i - 1] - a[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 9",
          "code": "occ--;\ntdiff += (i - j - 1) * (a[i - 1] - a[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\");\n    string type = opt<string>(\"type\", \"random\"); // default type is \"random\"\n\n    vector<int> a;\n\n    if (type == \"random\") {\n        // Generate random array of size n, elements in [-1e9,1e9]\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"all_equal\") {\n        int x = rnd.next(-1000000000, 1000000000);\n        a.assign(n, x);\n    } else if (type == \"all_unique\") {\n        // Generate unique numbers in allowed range\n        // Since n ≤ 1e5, we can generate numbers from -1e9 upwards\n        a.resize(n);\n        int64_t start = rnd.next(-1000000000, 1000000000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_increase\") {\n        // Generate array where we need to increase elements significantly\n        a.resize(n);\n        int64_t start = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"negative_numbers\") {\n        // Generate negative numbers\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, -1);\n        }\n    } else if (type == \"multiple_max\") {\n        // Generate array where multiple numbers tie for max frequency\n        a.resize(n);\n        int x = rnd.next(-1000000000, 1000000000 - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = x;\n            else\n                a[i] = x + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"single_element\") {\n        // n = 1\n        n = 1;\n        a.resize(1);\n        a[0] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"exact_k\") {\n        // Generate an array where we need exactly k operations\n        // Only feasible for small n due to k limit of 1e9\n        if (n > 2000) n = 2000; // Ensure total_ops_needed ≤ 1e9\n        int x = rnd.next(-1000000000, 1000000000 - n + 1);\n        a.resize(n);\n        int64_t total_ops_needed = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = x + i;\n            total_ops_needed += (a[n - 1] - a[i]);\n        }\n        // We cannot set k in the generator, but in bash commands, set k = total_ops_needed\n    } else {\n        // Default to random\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %lld\\n\", n, k);\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\");\n    string type = opt<string>(\"type\", \"random\"); // default type is \"random\"\n\n    vector<int> a;\n\n    if (type == \"random\") {\n        // Generate random array of size n, elements in [-1e9,1e9]\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"all_equal\") {\n        int x = rnd.next(-1000000000, 1000000000);\n        a.assign(n, x);\n    } else if (type == \"all_unique\") {\n        // Generate unique numbers in allowed range\n        // Since n ≤ 1e5, we can generate numbers from -1e9 upwards\n        a.resize(n);\n        int64_t start = rnd.next(-1000000000, 1000000000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_increase\") {\n        // Generate array where we need to increase elements significantly\n        a.resize(n);\n        int64_t start = rnd.next(-1000000000, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } else if (type == \"negative_numbers\") {\n        // Generate negative numbers\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, -1);\n        }\n    } else if (type == \"multiple_max\") {\n        // Generate array where multiple numbers tie for max frequency\n        a.resize(n);\n        int x = rnd.next(-1000000000, 1000000000 - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = x;\n            else\n                a[i] = x + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"single_element\") {\n        // n = 1\n        n = 1;\n        a.resize(1);\n        a[0] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"exact_k\") {\n        // Generate an array where we need exactly k operations\n        // Only feasible for small n due to k limit of 1e9\n        if (n > 2000) n = 2000; // Ensure total_ops_needed ≤ 1e9\n        int x = rnd.next(-1000000000, 1000000000 - n + 1);\n        a.resize(n);\n        int64_t total_ops_needed = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = x + i;\n            total_ops_needed += (a[n - 1] - a[i]);\n        }\n        // We cannot set k in the generator, but in bash commands, set k = total_ops_needed\n    } else {\n        // Default to random\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %lld\\n\", n, k);\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random arrays of small size\n./gen -n 10 -k 0 -type random\n./gen -n 10 -k 100 -type random\n\n# Random arrays with maximum n\n./gen -n 100000 -k 1000000000 -type random\n./gen -n 100000 -k 0 -type random\n\n# All equal elements\n./gen -n 1 -k 0 -type all_equal\n./gen -n 100 -k 1000 -type all_equal\n./gen -n 100000 -k 1000000000 -type all_equal\n\n# All unique elements\n./gen -n 1 -k 0 -type all_unique\n./gen -n 100 -k 1000 -type all_unique\n./gen -n 100000 -k 1000000000 -type all_unique\n\n# Negative numbers\n./gen -n 10 -k 100 -type negative_numbers\n./gen -n 100000 -k 1000000000 -type negative_numbers\n\n# Multiple maximum frequency elements\n./gen -n 100000 -k 50000 -type multiple_max\n./gen -n 10 -k 5 -type multiple_max\n\n# Single element array\n./gen -n 1 -k 0 -type single_element\n\n# Zero operations allowed\n./gen -n 100000 -k 0 -type random\n\n# Maximum increase needed\n./gen -n 100000 -k 1000000 -type max_increase\n\n# Exact k operations\n./gen -n 1000 -k 499500 -type exact_k\n\n# Mixed types\n./gen -n 100000 -k 1000000000 -type all_equal\n./gen -n 100000 -k 1000000000 -type all_unique\n./gen -n 100000 -k 0 -type all_equal\n./gen -n 100000 -k 0 -type all_unique\n./gen -n 100000 -k 0 -type negative_numbers\n./gen -n 100000 -k 1000000000 -type random\n./gen -n 100000 -k 1000 -type multiple_max\n./gen -n 1000 -k 1000000 -type max_increase\n\n# Small n\n./gen -n 2 -k 1 -type random\n./gen -n 3 -k 0 -type random\n./gen -n 1 -k 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:53.937825",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "231/D",
      "title": "D. Magic Box",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe fist input line contains three space-separated integers x, y and z (|x|, |y|, |z| ≤ 106) — the coordinates of Vasya's position in space. The second line contains three space-separated integers x1, y1, z1 (1 ≤ x1, y1, z1 ≤ 106) — the coordinates of the box's vertex that is opposite to the vertex at point (0, 0, 0). The third line contains six space-separated integers a1, a2, ..., a6 (1 ≤ ai ≤ 106) — the numbers that are written on the box faces. It is guaranteed that point (x, y, z) is located strictly outside the box.",
      "output_spec": "OutputPrint a single integer — the sum of all numbers on the box faces that Vasya sees.",
      "sample_tests": "ExamplesInputCopy2 2 21 1 11 2 3 4 5 6OutputCopy12InputCopy0 0 103 2 31 2 3 4 5 6OutputCopy4",
      "description": "D. Magic Box\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe fist input line contains three space-separated integers x, y and z (|x|, |y|, |z| ≤ 106) — the coordinates of Vasya's position in space. The second line contains three space-separated integers x1, y1, z1 (1 ≤ x1, y1, z1 ≤ 106) — the coordinates of the box's vertex that is opposite to the vertex at point (0, 0, 0). The third line contains six space-separated integers a1, a2, ..., a6 (1 ≤ ai ≤ 106) — the numbers that are written on the box faces. It is guaranteed that point (x, y, z) is located strictly outside the box.\n\nOutputPrint a single integer — the sum of all numbers on the box faces that Vasya sees.\n\nInputCopy2 2 21 1 11 2 3 4 5 6OutputCopy12InputCopy0 0 103 2 31 2 3 4 5 6OutputCopy4\n\nInputCopy2 2 21 1 11 2 3 4 5 6\n\nOutputCopy12\n\nInputCopy0 0 103 2 31 2 3 4 5 6\n\nOutputCopy4\n\nNoteThe first sample corresponds to perspective, depicted on the picture. Vasya sees numbers a2 (on the top face that is the darkest), a6 (on the right face that is the lightest) and a4 (on the left visible face).In the second sample Vasya can only see number a4.",
      "solutions": [
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces",
          "content": "Hi to all!)Codeforces #143 for participants from second division is going to be today. I think, it is not necessary to remind, that coders with rating greater than 1699 will be able to take part out of the competition.Problems' autors for this event are Kholkin Pavel (HolkinPV) and Kuznetsov Nikolay (NALP). Kudryashov Igor Igor_Kudryashov and Agapov Gerald (Gerald) helped in contest's preparation too. Special thanks to creator great resource Codeforces Mike Mirzayanov (MikeMirzayanov) and our translator Maria Belova (Delinur).Score distribution will be determine later, monitor for changes).We wish you enjoy participating this competition and want you to get something new and useful.UPD: Score distribution will be standart 500-1000-1500-2000-2500.UPD2: Round is over. Thanks to all for participating. Six first coders solved all 5 problems, congratulations.1) teoy2) gomineral023) mrNobody4) Ryannnnnnn5) marschenly6) KuchumovIlyaEditorial will be published soon.UPD3: Editorial is published, you can find it here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5483",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1022
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces",
          "content": "Hi to all!)Codeforces #143 for participants from second division is going to be today. I think, it is not necessary to remind, that coders with rating greater than 1699 will be able to take part out of the competition.Problems' autors for this event are Kholkin Pavel (HolkinPV) and Kuznetsov Nikolay (NALP). Kudryashov Igor Igor_Kudryashov and Agapov Gerald (Gerald) helped in contest's preparation too. Special thanks to creator great resource Codeforces Mike Mirzayanov (MikeMirzayanov) and our translator Maria Belova (Delinur).Score distribution will be determine later, monitor for changes).We wish you enjoy participating this competition and want you to get something new and useful.UPD: Score distribution will be standart 500-1000-1500-2000-2500.UPD2: Round is over. Thanks to all for participating. Six first coders solved all 5 problems, congratulations.1) teoy2) gomineral023) mrNobody4) Ryannnnnnn5) marschenly6) KuchumovIlyaEditorial will be published soon.UPD3: Editorial is published, you can find it here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5483",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1022
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces",
          "content": "231A - TeamIt is needed just to implement actions described in statement. You had to read data and to calculate number of members of team, which were sure about the solution, for every task. If this number is greater than one, the answer must be increased by one.231B - Magic, Wizardry and WondersLet's see, what will be the last number of array after i iterations. After the first iteration it will be an - 1–an (and total number of elements will be decreased by one). After the second iteration the last number will be an - 2–an - 1 + an. It is not hard to see, that after n - 1 iterations remain a1–a2 + a3–a4 + ... + ( - 1)n + 1·an. In a such way, our task is to put numbers from 1 to l in array so, that sum of numbers in odd positions minus sum of numbers in even positions will equal to given d. This means sum of numbers in odd positions must be equal . But the minimal sum can be , and the maximal — .Because of this we should choose a2·k so, that s fits the boundaries. Constrains allow to do it in a such manner. Firstly, put ones on the even positions. If s > maxv after that, the answer is  - 1. Otherwise, let's increase each a2·k by one until s = minv. If we put l in all even positions and s < minv, than answer is  - 1 too. After we put numbers on even positions, let's write 1 in all odd positions, and while sum of this elements is less than s increase each one by fitting value.231C - To Add or Not to AddOne of the main observations, needed to solve this problem, is that the second number in answer always coincides with someone aj. Let's see why it is true. Suppose, the second number of the answer is aj + d for someone j and aj + d ≠ ai for all i. This means, we increased some numbers, which is less than aj, so that they became equal to aj, and then all this numbers and some numbers, which is equal to aj, we increased to aj + d. But if we didn't increase all this numbers to aj + d and remain they equal to aj, we'd perform less operations and the answer would be better.Due to this fact we can solve problem in a such manner. Sort array in non-decreasing order. Iterate over ai and calculate, what is the maximal number of ai we can obtain. For maximizing first number of answer, we must increase some lesser numbers to ai and perform not greater than k operations. It is obvious that firstly we should increase such aj that ai–aj is minimal. So, if we can solve problem in O(n2), we would iterate j from i to 0 and increase aj to ai, while we could. But the solution must be faster, and we will use binary search. We will brute the number of numbers, which we must do equal to ai. Suppose we fix cnt this value. Now we have to check if we can do cnt numbers equal to ai by not greater than k operations. For doing this, let’s calculate . If this value not greater than k, we can do it. For calculating sum quickly, we can save prefix sums and than si - cnt + 1, i = si–si–cnt. Finally we solved this problem in O(n·logn).231D - Magic BoxThe main subtask of this problem is to check whether we can observe the center of face of parallelepiped from point p = (x, y, z). Let’s see the case, when the face belongs to plane z = z1. For performing all calculations in integer numbers, multiply all coordinates x, y, z, x1, y1, z1 by 2. Take the point and normal to plane, containing the fixed face, which is directed out of interior of parallelepiped, that is . Also take vector . If undirected angle between this vectors is less than 90 degrees, we can observe a from p. For checking this we can use scalar product. If scalar product of and is strictly greater than zero, than that angle is fitting.231E - CactusIn this problem you should find the number of simple paths between some pair of vertices in vertex cactus. If you learn the structure of these graphs, it is not hard to see, that if we’ll squeeze each cycle in one vertex, we get a tree. So let’s squeeze all cycles in source graph and get this tree. Also every vertex of this tree we’ll mark, if it is squeezed cycle (let’s call this vertices 1-vertices) or single vertex in source graph (this vertices we’ll call 0-vertices).Then, we’ll do the following to find the number of paths between vertices a and b in source graph. Suppose c is a vertex, corresponding to a in obtained tree (it can be a single vertex or a vertex, corresponding to a squeezed cycle with a), and d is a vertex, corresponding to b. Let’s denote deg is the number of 1-vertices in path from c to d in tree. Than it is easy to understand, that the answer for query is , because every cycle (1-vertex) increase the number of possible ways twice (you can go from one vertex to other by two ways in cycle).It means that we need to count the number of 1-vertex on the path from one vertex to other in tree quickly to answer a query. We can do it in a following way. Hang our tree for one vertex, which we’ll call a root. Denote for every vertex cntv is the number of 1-vertex on the way to the root (including root and vertex itself). Suppose we want to find the number of 1-vertex on the path from a to b. Denote c is the least common ancestor of vertices a and b. Than number of 1-vertex on the way from a to b is equal to cnta + cntb–2·cntc, if c is 0-vertex and cnta + cntb–2·cntc + 1, if c is 1-vertex. The least common ancestor can be found by standard method — binary method recovery. Finally we have O(m + k·logn) solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5486",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 231\\s*D"
          },
          "content_length": 5387
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 1",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 2",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 1",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 2",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "stringstream",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "ONLINE_JUDGE",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "freopen(\"output.txt\", \"w\", stdout);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "while (cin >> first_variable_of_input)\n{\n    // Read remaining data for this test case\n    // Process data and print the answer\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "int n = in.nextInt(), k = in.nextInt();\nint[] a = new int[n];\nfor (int i = 0; i < n; i++) {\n\ta[i] = in.nextInt();\n}\nArrays.sort(a);\nint i = n - 1, j = n - 2;\nint mocc = 0;\nint mnum = 0;\nint num = a[n - 1];\nint tdiff = 0;\nint occ = 1;\nwhile (i >= 0 && j >= 0) {//0 2 3 4 6\n\tif (tdiff + num - a[j] <= k) {\n\t\ttdiff += num - a[j];\n\t\tocc++;\n\t\tj--;\n\t} else {\n\t\tif (occ >= mocc) {\n\t\t\tmocc = occ;\n\t\t\tmnum = num;\n\t\t}\n\t\tocc--;\n\t\ttdiff += (i - j - 1) * (a[i - 1] - a[i]);\n\t\tnum = a[--i];\n\t}\n}\nif (occ >= mocc) {\n\tmocc = occ;\n\tmnum = num;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "int n = in.nextInt(), k = in.nextInt();\nint[] a = new int[n];\nfor (int i = 0; i < n; i++) {\n\ta[i] = in.nextInt();\n}\nArrays.sort(a);\nint i = n - 1, j = n - 2;\nint mocc = 0;\nint mnum = 0;\nint num = a[n - 1];\nint tdiff = 0;\nint occ = 1;\nwhile (i >= 0 && j >= 0) {//0 2 3 4 6\n\tif (tdiff + num - a[j] <= k) {\n\t\ttdiff += num - a[j];\n\t\tocc++;\n\t\tj--;\n\t} else {\n\t\tif (occ >= mocc) {\n\t\t\tmocc = occ;\n\t\t\tmnum = num;\n\t\t}\n\t\tocc--;\n\t\ttdiff += (i - j - 1) * (a[i - 1] - a[i]);\n\t\tnum = a[--i];\n\t}\n}\nif (occ >= mocc) {\n\tmocc = occ;\n\tmnum = num;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "occ--;\ntdiff += (i - j - 1) * (a[i - 1] - a[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "occ--;\ntdiff += (i - j - 1) * (a[i - 1] - a[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read x, y, z\n    int x = inf.readInt(-1000000, 1000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000000, 1000000, \"y\");\n    inf.readSpace();\n    int z = inf.readInt(-1000000, 1000000, \"z\");\n    inf.readEoln();\n\n    // Read x1, y1, z1\n    int x1 = inf.readInt(1, 1000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, 1000000, \"y1\");\n    inf.readSpace();\n    int z1 = inf.readInt(1, 1000000, \"z1\");\n    inf.readEoln();\n\n    // Read a1, a2, ..., a6\n    int a1 = inf.readInt(1, 1000000, \"a1\");\n    inf.readSpace();\n    int a2 = inf.readInt(1, 1000000, \"a2\");\n    inf.readSpace();\n    int a3 = inf.readInt(1, 1000000, \"a3\");\n    inf.readSpace();\n    int a4 = inf.readInt(1, 1000000, \"a4\");\n    inf.readSpace();\n    int a5 = inf.readInt(1, 1000000, \"a5\");\n    inf.readSpace();\n    int a6 = inf.readInt(1, 1000000, \"a6\");\n    inf.readEoln();\n\n    // Ensure that Vasya's point is strictly outside the box\n    ensuref(\n        x < 0 || x > x1 || y < 0 || y > y1 || z < 0 || z > z1,\n        \"Point (x,y,z) must be located strictly outside the box.\"\n    );\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read x, y, z\n    int x = inf.readInt(-1000000, 1000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000000, 1000000, \"y\");\n    inf.readSpace();\n    int z = inf.readInt(-1000000, 1000000, \"z\");\n    inf.readEoln();\n\n    // Read x1, y1, z1\n    int x1 = inf.readInt(1, 1000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, 1000000, \"y1\");\n    inf.readSpace();\n    int z1 = inf.readInt(1, 1000000, \"z1\");\n    inf.readEoln();\n\n    // Read a1, a2, ..., a6\n    int a1 = inf.readInt(1, 1000000, \"a1\");\n    inf.readSpace();\n    int a2 = inf.readInt(1, 1000000, \"a2\");\n    inf.readSpace();\n    int a3 = inf.readInt(1, 1000000, \"a3\");\n    inf.readSpace();\n    int a4 = inf.readInt(1, 1000000, \"a4\");\n    inf.readSpace();\n    int a5 = inf.readInt(1, 1000000, \"a5\");\n    inf.readSpace();\n    int a6 = inf.readInt(1, 1000000, \"a6\");\n    inf.readEoln();\n\n    // Ensure that Vasya's point is strictly outside the box\n    ensuref(\n        x < 0 || x > x1 || y < 0 || y > y1 || z < 0 || z > z1,\n        \"Point (x,y,z) must be located strictly outside the box.\"\n    );\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read x, y, z\n    int x = inf.readInt(-1000000, 1000000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000000, 1000000, \"y\");\n    inf.readSpace();\n    int z = inf.readInt(-1000000, 1000000, \"z\");\n    inf.readEoln();\n\n    // Read x1, y1, z1\n    int x1 = inf.readInt(1, 1000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, 1000000, \"y1\");\n    inf.readSpace();\n    int z1 = inf.readInt(1, 1000000, \"z1\");\n    inf.readEoln();\n\n    // Read a1, a2, ..., a6\n    int a1 = inf.readInt(1, 1000000, \"a1\");\n    inf.readSpace();\n    int a2 = inf.readInt(1, 1000000, \"a2\");\n    inf.readSpace();\n    int a3 = inf.readInt(1, 1000000, \"a3\");\n    inf.readSpace();\n    int a4 = inf.readInt(1, 1000000, \"a4\");\n    inf.readSpace();\n    int a5 = inf.readInt(1, 1000000, \"a5\");\n    inf.readSpace();\n    int a6 = inf.readInt(1, 1000000, \"a6\");\n    inf.readEoln();\n\n    // Ensure that Vasya's point is strictly outside the box\n    ensuref(\n        x < 0 || x > x1 || y < 0 || y > y1 || z < 0 || z > z1,\n        \"Point (x,y,z) must be located strictly outside the box.\"\n    );\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateRandomVasyaPosition(int x1, int y1, int z1, int maxCoord, int &x, int &y, int &z) {\n    while (true) {\n        x = rnd.next(-maxCoord, maxCoord);\n        y = rnd.next(-maxCoord, maxCoord);\n        z = rnd.next(-maxCoord, maxCoord);\n        if (x < 0 || x > x1 || y < 0 || y > y1 || z < 0 || z > z1) {\n            break;\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int maxCoord = opt<int>(\"maxCoord\", 1000000);\n    int maxSize = opt<int>(\"maxSize\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int x1, y1, z1;\n    int x, y, z;\n    int a[6];\n\n    if (type == \"random\") {\n        // Generate random box dimensions\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        // Generate random Vasya position outside the box\n        generateRandomVasyaPosition(x1, y1, z1, maxCoord, x, y, z);\n\n        // Generate random numbers on faces\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"far_away\") {\n        // Maximize Vasya's coordinate(s)\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        // Vasya is far away in at least one coordinate\n        x = rnd.next(-maxCoord, maxCoord);\n        y = rnd.next(-maxCoord, maxCoord);\n        z = rnd.next(-maxCoord, maxCoord);\n\n        // Set at least one coordinate to maxCoord or -maxCoord\n        int coord = rnd.next(0, 2);\n        if (coord == 0) {\n            x = rnd.next(0, 1) ? maxCoord : -maxCoord;\n        } else if (coord == 1) {\n            y = rnd.next(0, 1) ? maxCoord : -maxCoord;\n        } else {\n            z = rnd.next(0, 1) ? maxCoord : -maxCoord;\n        }\n\n        // Ensure Vasya is outside the box\n        if (x >= 0 && x <= x1 && y >= 0 && y <= y1 && z >= 0 && z <= z1) {\n            if (coord == 0) {\n                x = x1 + 1;\n                if (x > maxCoord) x = maxCoord;\n            } else if (coord == 1) {\n                y = y1 + 1;\n                if (y > maxCoord) y = maxCoord;\n            } else {\n                z = z1 + 1;\n                if (z > maxCoord) z = maxCoord;\n            }\n        }\n\n        // Generate random numbers on faces\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"close_to_box\") {\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        // Randomly select a face\n        int face = rnd.next(1,6);\n\n        if (face == 1) { // face y=0\n            x = rnd.next(0, x1);\n            y = -1;\n            z = rnd.next(0, z1);\n        } else if (face == 2) { // face y=y1\n            x = rnd.next(0, x1);\n            y = y1 + 1;\n            z = rnd.next(0, z1);\n        } else if (face == 3) { // face z=0\n            x = rnd.next(0, x1);\n            y = rnd.next(0, y1);\n            z = -1;\n        } else if (face == 4) { // face z=z1\n            x = rnd.next(0, x1);\n            y = rnd.next(0, y1);\n            z = z1 + 1;\n        } else if (face == 5) { // face x=0\n            x = -1;\n            y = rnd.next(0, y1);\n            z = rnd.next(0, z1);\n        } else if (face == 6) { // face x=x1\n            x = x1 + 1;\n            y = rnd.next(0, y1);\n            z = rnd.next(0, z1);\n        }\n\n        // Generate random numbers on faces\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"single_face_visible\") {\n        // Randomly select a face\n        int face = rnd.next(1,6);\n\n        // Set box dimensions\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        if (face == 1) { // face y=0\n            x = x1 / 2;\n            y = -maxCoord;\n            z = z1 / 2;\n        } else if (face == 2) { // face y=y1\n            x = x1 / 2;\n            y = y1 + maxCoord;\n            z = z1 / 2;\n        } else if (face == 3) { // face z=0\n            x = x1 / 2;\n            y = y1 / 2;\n            z = -maxCoord;\n        } else if (face == 4) { // face z=z1\n            x = x1 / 2;\n            y = y1 / 2;\n            z = z1 + maxCoord;\n        } else if (face == 5) { // face x=0\n            x = -maxCoord;\n            y = y1 / 2;\n            z = z1 / 2;\n        } else if (face == 6) { // face x=x1\n            x = x1 + maxCoord;\n            y = y1 / 2;\n            z = z1 / 2;\n        }\n\n        // Generate random numbers on faces\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"along_axis\") {\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        int axis = rnd.next(0,2); // 0 for x-axis, 1 for y-axis, 2 for z-axis\n\n        if (axis == 0) {\n            x = rnd.next(-maxCoord, -1);\n            y = 0;\n            z = 0;\n        } else if (axis == 1) {\n            x = 0;\n            y = rnd.next(-maxCoord, -1);\n            z = 0;\n        } else if (axis == 2) {\n            x = 0;\n            y = 0;\n            z = rnd.next(-maxCoord, -1);\n        }\n\n        // Generate random numbers on faces\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else {\n        // Default: random test case\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        generateRandomVasyaPosition(x1, y1, z1, maxCoord, x, y, z);\n\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", x, y, z);\n    printf(\"%d %d %d\\n\", x1, y1, z1);\n    for (int i = 0; i < 6; i++) {\n        printf(\"%d%c\", a[i], (i==5)?'\\n':' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateRandomVasyaPosition(int x1, int y1, int z1, int maxCoord, int &x, int &y, int &z) {\n    while (true) {\n        x = rnd.next(-maxCoord, maxCoord);\n        y = rnd.next(-maxCoord, maxCoord);\n        z = rnd.next(-maxCoord, maxCoord);\n        if (x < 0 || x > x1 || y < 0 || y > y1 || z < 0 || z > z1) {\n            break;\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int maxCoord = opt<int>(\"maxCoord\", 1000000);\n    int maxSize = opt<int>(\"maxSize\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int x1, y1, z1;\n    int x, y, z;\n    int a[6];\n\n    if (type == \"random\") {\n        // Generate random box dimensions\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        // Generate random Vasya position outside the box\n        generateRandomVasyaPosition(x1, y1, z1, maxCoord, x, y, z);\n\n        // Generate random numbers on faces\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"far_away\") {\n        // Maximize Vasya's coordinate(s)\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        // Vasya is far away in at least one coordinate\n        x = rnd.next(-maxCoord, maxCoord);\n        y = rnd.next(-maxCoord, maxCoord);\n        z = rnd.next(-maxCoord, maxCoord);\n\n        // Set at least one coordinate to maxCoord or -maxCoord\n        int coord = rnd.next(0, 2);\n        if (coord == 0) {\n            x = rnd.next(0, 1) ? maxCoord : -maxCoord;\n        } else if (coord == 1) {\n            y = rnd.next(0, 1) ? maxCoord : -maxCoord;\n        } else {\n            z = rnd.next(0, 1) ? maxCoord : -maxCoord;\n        }\n\n        // Ensure Vasya is outside the box\n        if (x >= 0 && x <= x1 && y >= 0 && y <= y1 && z >= 0 && z <= z1) {\n            if (coord == 0) {\n                x = x1 + 1;\n                if (x > maxCoord) x = maxCoord;\n            } else if (coord == 1) {\n                y = y1 + 1;\n                if (y > maxCoord) y = maxCoord;\n            } else {\n                z = z1 + 1;\n                if (z > maxCoord) z = maxCoord;\n            }\n        }\n\n        // Generate random numbers on faces\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"close_to_box\") {\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        // Randomly select a face\n        int face = rnd.next(1,6);\n\n        if (face == 1) { // face y=0\n            x = rnd.next(0, x1);\n            y = -1;\n            z = rnd.next(0, z1);\n        } else if (face == 2) { // face y=y1\n            x = rnd.next(0, x1);\n            y = y1 + 1;\n            z = rnd.next(0, z1);\n        } else if (face == 3) { // face z=0\n            x = rnd.next(0, x1);\n            y = rnd.next(0, y1);\n            z = -1;\n        } else if (face == 4) { // face z=z1\n            x = rnd.next(0, x1);\n            y = rnd.next(0, y1);\n            z = z1 + 1;\n        } else if (face == 5) { // face x=0\n            x = -1;\n            y = rnd.next(0, y1);\n            z = rnd.next(0, z1);\n        } else if (face == 6) { // face x=x1\n            x = x1 + 1;\n            y = rnd.next(0, y1);\n            z = rnd.next(0, z1);\n        }\n\n        // Generate random numbers on faces\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"single_face_visible\") {\n        // Randomly select a face\n        int face = rnd.next(1,6);\n\n        // Set box dimensions\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        if (face == 1) { // face y=0\n            x = x1 / 2;\n            y = -maxCoord;\n            z = z1 / 2;\n        } else if (face == 2) { // face y=y1\n            x = x1 / 2;\n            y = y1 + maxCoord;\n            z = z1 / 2;\n        } else if (face == 3) { // face z=0\n            x = x1 / 2;\n            y = y1 / 2;\n            z = -maxCoord;\n        } else if (face == 4) { // face z=z1\n            x = x1 / 2;\n            y = y1 / 2;\n            z = z1 + maxCoord;\n        } else if (face == 5) { // face x=0\n            x = -maxCoord;\n            y = y1 / 2;\n            z = z1 / 2;\n        } else if (face == 6) { // face x=x1\n            x = x1 + maxCoord;\n            y = y1 / 2;\n            z = z1 / 2;\n        }\n\n        // Generate random numbers on faces\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"along_axis\") {\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        int axis = rnd.next(0,2); // 0 for x-axis, 1 for y-axis, 2 for z-axis\n\n        if (axis == 0) {\n            x = rnd.next(-maxCoord, -1);\n            y = 0;\n            z = 0;\n        } else if (axis == 1) {\n            x = 0;\n            y = rnd.next(-maxCoord, -1);\n            z = 0;\n        } else if (axis == 2) {\n            x = 0;\n            y = 0;\n            z = rnd.next(-maxCoord, -1);\n        }\n\n        // Generate random numbers on faces\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else {\n        // Default: random test case\n        x1 = rnd.next(1, maxSize);\n        y1 = rnd.next(1, maxSize);\n        z1 = rnd.next(1, maxSize);\n\n        generateRandomVasyaPosition(x1, y1, z1, maxCoord, x, y, z);\n\n        for (int i = 0; i < 6; i++) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", x, y, z);\n    printf(\"%d %d %d\\n\", x1, y1, z1);\n    for (int i = 0; i < 6; i++) {\n        printf(\"%d%c\", a[i], (i==5)?'\\n':' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -maxCoord 1000 -maxSize 1000 -type random\n./gen -maxCoord 1000000 -maxSize 1000000 -type random\n./gen -maxCoord 500000 -maxSize 500000 -type random\n\n./gen -maxCoord 1000000 -maxSize 1000000 -type far_away\n./gen -maxCoord 1000000 -maxSize 1000000 -type far_away\n./gen -maxCoord 1000000 -maxSize 500000 -type far_away\n\n./gen -maxCoord 1000 -maxSize 1000 -type close_to_box\n./gen -maxCoord 1000000 -maxSize 1000000 -type close_to_box\n./gen -maxCoord 500000 -maxSize 1000000 -type close_to_box\n\n./gen -maxCoord 1000000 -maxSize 1000000 -type single_face_visible\n./gen -maxCoord 100000 -maxSize 100000 -type single_face_visible\n./gen -maxCoord 10000 -maxSize 1000000 -type single_face_visible\n\n./gen -maxCoord 1000000 -maxSize 1000000 -type along_axis\n./gen -maxCoord 1000000 -maxSize 500000 -type along_axis\n./gen -maxCoord 1000000 -maxSize 10000 -type along_axis\n\n# Generate random test cases with varying maxCoord and maxSize\n./gen -maxCoord 1000 -maxSize 1000 -type random\n./gen -maxCoord 10000 -maxSize 10000 -type random\n./gen -maxCoord 100000 -maxSize 100000 -type random\n./gen -maxCoord 1000000 -maxSize 1000000 -type random\n\n# Generate more test cases for each type\n./gen -maxCoord 1000000 -maxSize 1000000 -type far_away\n./gen -maxCoord 500000 -maxSize 500000 -type far_away\n\n./gen -maxCoord 1000000 -maxSize 1000000 -type close_to_box\n./gen -maxCoord 500000 -maxSize 500000 -type close_to_box\n\n./gen -maxCoord 1000000 -maxSize 1000000 -type single_face_visible\n./gen -maxCoord 500000 -maxSize 500000 -type single_face_visible\n\n./gen -maxCoord 1000000 -maxSize 1000000 -type along_axis\n./gen -maxCoord 500000 -maxSize 500000 -type along_axis\n\n# Generate multiple random test cases in a loop\nfor ((i=1;i<=5;i++)); do ./gen -type random; done\n\n# Generate test cases with minimal box sizes\n./gen -maxCoord 10 -maxSize 1 -type random\n./gen -maxCoord 10 -maxSize 1 -type close_to_box\n\n# Generate test cases with maximum coordinate ranges\n./gen -maxCoord 1000000 -maxSize 1 -type far_away\n./gen -maxCoord 1000000 -maxSize 1 -type single_face_visible\n\n# Generate test cases with specific coordinate ranges\n./gen -maxCoord 500000 -maxSize 500000 -type random\n./gen -maxCoord 250000 -maxSize 250000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:56.235317",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "231/E",
      "title": "E. Кактус",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел записаны два целых числа n, m (2 ≤ n ≤ 105; 1 ≤ m ≤ 105) — количество вершин и ребер в графе соответственно. В следующих m строках задано описание ребер: в i-той строке через пробел записаны два целых числа ai, bi (1 ≤ ai, bi ≤ n) — номера вершин, которые соединяет i-тое ребро.Во следующей строке записано единственное целое число k (1 ≤ k ≤ 105) — количество пар интересных вершин. В следующих k строках задан список пар интересных вершин: в i-ой строке через пробел записаны два целых числа xi, yi (1 ≤ xi, yi ≤ n; xi ≠ yi) — номера интересных вершин в i-ой паре.Гарантируется, что заданный граф является вершинным кактусом. Гарантируется, что в графе отсутствуют петли и кратные ребра. Считайте, что вершины графа некоторым образом пронумерованы от 1 до n.",
      "output_spec": "Выходные данныеВыведите k строк: в i-ой строке выведите единственное число — остаток от деления количества различных простых путей, начинающихся в xi и заканчивающихся в yi, на 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать10 111 22 33 41 43 55 68 68 77 67 99 1061 23 56 99 29 39 10Выходные данныеСкопировать222441",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел записаны два целых числа n, m (2 ≤ n ≤ 105; 1 ≤ m ≤ 105) — количество вершин и ребер в графе соответственно. В следующих m строках задано описание ребер: в i-той строке через пробел записаны два целых числа ai, bi (1 ≤ ai, bi ≤ n) — номера вершин, которые соединяет i-тое ребро.Во следующей строке записано единственное целое число k (1 ≤ k ≤ 105) — количество пар интересных вершин. В следующих k строках задан список пар интересных вершин: в i-ой строке через пробел записаны два целых числа xi, yi (1 ≤ xi, yi ≤ n; xi ≠ yi) — номера интересных вершин в i-ой паре.Гарантируется, что заданный граф является вершинным кактусом. Гарантируется, что в графе отсутствуют петли и кратные ребра. Считайте, что вершины графа некоторым образом пронумерованы от 1 до n.\n\nВходные данные\n\nВыходные данныеВыведите k строк: в i-ой строке выведите единственное число — остаток от деления количества различных простых путей, начинающихся в xi и заканчивающихся в yi, на 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать10 111 22 33 41 43 55 68 68 77 67 99 1061 23 56 99 29 39 10Выходные данныеСкопировать222441\n\nВходные данныеСкопировать10 111 22 33 41 43 55 68 68 77 67 99 1061 23 56 99 29 39 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать222441\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces",
          "content": "Всем привет!)Сегодня состоится очередной раунд Codeforces #143 для участников второго дивизиона. Наверное, нет смысла напоминать, что ребята с рейтингом больше 1699 могут поучаствовать в нем вне конкурса.Авторами задач для данного мероприятия являются Холкин Павел (HolkinPV) и Кузнецов Николай (NALP). В подготовке контеста также участвовали Кудряшов Игорь (Igor_Kudryashov) и Агапов Геральд (Gerald). Отдельную благодарность выражаем создателю прекрасного ресурса Codeforces Михаилу Мирзаянову (MikeMirzayanov) и нашей переводчице Марии Беловой (Delinur).Распределение баллов по задачам будет определено через некоторое время, следите за изменениями).Желаем всем получить удовольствие от соревнования и почерпнуть для себя что-то новое и полезное.UPD: Распределение баллов по задачам будет стандартное 500-1000-1500-2000-2500.UPD2: Раунд окончен. Благодарим всех за участие. Шесть человек, занявшие первые места решили все 5 задач, поздравляем их с отличным выступлением.1) teoy2) gomineral023) mrNobody4) Ryannnnnnn5) marschenly6) KuchumovIlyaРазбор задач будет опубликован через некоторое время.UPD3: Разбор опубликован, его можно найти здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5483",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1146
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces",
          "content": "Всем привет!)Сегодня состоится очередной раунд Codeforces #143 для участников второго дивизиона. Наверное, нет смысла напоминать, что ребята с рейтингом больше 1699 могут поучаствовать в нем вне конкурса.Авторами задач для данного мероприятия являются Холкин Павел (HolkinPV) и Кузнецов Николай (NALP). В подготовке контеста также участвовали Кудряшов Игорь (Igor_Kudryashov) и Агапов Геральд (Gerald). Отдельную благодарность выражаем создателю прекрасного ресурса Codeforces Михаилу Мирзаянову (MikeMirzayanov) и нашей переводчице Марии Беловой (Delinur).Распределение баллов по задачам будет определено через некоторое время, следите за изменениями).Желаем всем получить удовольствие от соревнования и почерпнуть для себя что-то новое и полезное.UPD: Распределение баллов по задачам будет стандартное 500-1000-1500-2000-2500.UPD2: Раунд окончен. Благодарим всех за участие. Шесть человек, занявшие первые места решили все 5 задач, поздравляем их с отличным выступлением.1) teoy2) gomineral023) mrNobody4) Ryannnnnnn5) marschenly6) KuchumovIlyaРазбор задач будет опубликован через некоторое время.UPD3: Разбор опубликован, его можно найти здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5483",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1146
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces",
          "content": "231A - КомандаВ данной задаче нужно было реализовать то, что написано в условии, то есть считать данные и для каждой задачи посчитать количество участников команды, уверенных в ее решении. Если таких участников больше одного, то к ответу прибавить единицу.231B - Магия, волшебство и чудесаДля того чтобы быстро и элегантно решить эту задачу, можно рассмотреть, каким будет последнее число массива после i итераций. После первой итерации оно будет равно an - 1–an (при этом количество элементов уменьшится на единицу). После второй –-- an - 2–an - 1 + an. Очевидно, что после n - 1 итерации останется a1–a2 + a3–a4 + ... + ( - 1)n + 1·an. Таким образом, наша задача состоит в том, чтобы расставить в массиве числа от 1 до l так, чтобы сумма чисел стоящих на нечетных позициях минус сумма чисел на четных позициях была равна заданному d. Тогда мы должны на нечетных позициях набрать число, равное . При этом минимальное число, которое мы сможем набрать , а максимальное –-- . Поэтому нужно подобрать a2·k так, чтобы s укладывалось в эти границы. Ограничения позволяли сделать это следующим образом. Расставим сначала на четных позициях единицы. Теперь если s > maxv, то ответ  - 1. Иначе будем увеличивать каждое a2·k на единицу до тех пор, пока s < minv. Если, даже расставив на всех четных позициях l, окажется, что s < minv, то ответ также  - 1. После того, как мы расставили значения на четных позициях, ставим 1 на всех нечетных местах, и пока сумма этих элементов меньше s увеличиваем каждое из них на допустимую величину.231C - Прибавляй не прибавляйДля решения этой задачи нужно было заметить, что второе число ответа всегда совпадает с каким-то из чисел исходного массива. Это можно объяснить следующим образом. Предположим, второе число ответа равно aj + d для какого-то j и при этом aj + d ≠ ai ни для какого i. Это значит, что мы увеличили некоторые числа, меньшие aj, до значения aj, а затем эти числа, вместе с некоторыми числами, равными aj, увеличили до значения aj + d. Но если бы мы не увеличивали все эти числа до aj + d, а оставили равными aj, то потратили бы меньше операций увеличения и при этом улучшили бы ответ.Используя этот факт можно решать задачу следующим образом. Отсортируем исходный массив по неубыванию. Переберем второе число ответа –-- ai и посчитаем, какое мы можем получить максимальное первое число ответа. Для того чтобы максимизировать первое число ответа, нам надо увеличить некоторые меньшие числа до значения ai, при этом используя максимум k операций. Очевидно, что в первую очередь нужно увеличивать те aj, для которых ai–aj минимально. То есть если бы можно было решать задачу за O(n2), то мы бы шли по j от i налево и увеличивали aj до значения ai, пока хватает операций. Однако нужно более быстрое решение. Поэтому нам поможет бинарный поиск по ответу. Мы будем бинарным поиском перебирать количество чисел, которые нужно сделать равными ai. Предположим мы зафиксировали cnt эту величину. Теперь нам нужно за O(1) проверить, можно ли за не более чем k операций сделать cnt чисел равными ai. Для этого подсчитаем следующую величину . Если эта величина не превосходит k, то мы можем это сделать. Для того чтобы быстро вычислять сумму, нужно подсчитать si частичные суммы на префиксе и тогда si - cnt + 1, i = si–si–cnt. Итого мы получаем решение за O(n·logn).231D - Волшебный ящикВ данной задаче, по сути, нужно было проверить, что из точки p = (x, y, z) виден центр грани параллелепипеда. Рассмотрим случай, когда грань находится в плоскости z = z1. Для того чтобы можно было все вычисления производить в целых числах, умножим все координаты x, y, z, x1, y1, z1 на 2. Возьмем точку и вектор нормали к плоскости, содержащей эту грань, который направлен в сторону от внутренности параллелепипеда, то есть . Рассмотрим также вектор . Если неориентированный угол между этими векторами меньше 90 градусов, то из точки p будет видно точку a. Чтобы просто проверить это условие, нужно вычислить скалярное произведение между векторами и , и если оно строго больше нуля, то угол будет подходящим.231E - КактусВ этой задаче нужно было в вершинном кактусе для некоторых пар вершин найти количество простых путей между ними. Изучив структуру данного вида графов, можно понять, что если сжать каждый цикл вершинного кактуса –-- то получится дерево. Поэтому сожмем циклы в исходном графе и получим это самое дерево. Также для каждой вершины этого дерева пометим, является ли она сжатым циклом (назовем такие вершины 1-вершинами) или отдельной вершиной в исходном графе (такие назовем 0-вершинами). Теперь, чтобы найти количество путей между вершинами a и b в исходном графе, проделаем следующее. Обозначим за c вершину, которая соответствует вершине a в полученном дереве (это может быть либо отдельная вершина, либо вершина, соответствующая сжатому циклу, в котором лежит a), за d --– вершину, соответствующую b. Подсчитаем величину deg --– количество 1-вершин на пути из c в d в дереве. Тогда несложно понять, что ответ на запрос равен , так как каждый цикл (1-вершина) увеличивает количество возможных путей вдвое (потому что в цикле из одной вершины в другую можно пройти двумя способами).Таким образом, для ответа на запрос, нам надо быстро считать количество 1-вершин на пути из одной вершины в другую в дереве. Это можно делать следующим образом. Подвесим полученное дерево за какую-нибудь вершину, которую назовем корнем. Подсчитаем для каждой вершины cntv — количество 1-вершин на пути до корня (включая корень и саму вершину). Допустим, мы хотим найти количество 1-вершин на пути из a в b. Обозначим за c наименьший общий предок вершин a и b. Тогда количество 1-вершин на пути из a в b, равно cnta + cntb–2·cntc, если c является 0-вершиной и cnta + cntb–2·cntc + 1, если c — 1-вершина. Наименьший общий предок можно искать стандартным приемом –-- методом двоичного подъема. Итого мы имеем решение за O(m + k·logn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5486",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 231\\s*E"
          },
          "content_length": 5856
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 1",
          "code": "5 5\n1 2\n2 3\n2 4\n2 5\n4 5\n1\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 2",
          "code": "5 5\n1 2\n2 3\n2 4\n2 5\n4 5\n1\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 3",
          "code": "a[x] != a[x-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 4",
          "code": "s += (x-y-1) * (a[x] - a[x-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 5",
          "code": "a[x] - a[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 6",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 7",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 8",
          "code": "public Random() { this(++seedUniquifier + System.nanoTime()); }\n    private static volatile long seedUniquifier = 8682522807148012L;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 9",
          "code": "public Random() { this(++seedUniquifier + System.nanoTime()); }\n    private static volatile long seedUniquifier = 8682522807148012L;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 1",
          "code": "5 5\n1 2\n2 3\n2 4\n2 5\n4 5\n1\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 2",
          "code": "5 5\n1 2\n2 3\n2 4\n2 5\n4 5\n1\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 3",
          "code": "a[x] != a[x-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 4",
          "code": "s += (x-y-1) * (a[x] - a[x-1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 5",
          "code": "a[x] - a[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 6",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 7",
          "code": "10 0\n1 2 3 4 5 6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 8",
          "code": "public Random() { this(++seedUniquifier + System.nanoTime()); }\n    private static volatile long seedUniquifier = 8682522807148012L;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) - Codeforces - Code 9",
          "code": "public Random() { this(++seedUniquifier + System.nanoTime()); }\n    private static volatile long seedUniquifier = 8682522807148012L;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5483",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 1",
          "code": "stringstream",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 2",
          "code": "#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n#endif",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 3",
          "code": "ONLINE_JUDGE",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 4",
          "code": "freopen(\"output.txt\", \"w\", stdout);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 5",
          "code": "while (cin >> first_variable_of_input)\n{\n    // Read remaining data for this test case\n    // Process data and print the answer\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 6",
          "code": "int n = in.nextInt(), k = in.nextInt();\nint[] a = new int[n];\nfor (int i = 0; i < n; i++) {\n\ta[i] = in.nextInt();\n}\nArrays.sort(a);\nint i = n - 1, j = n - 2;\nint mocc = 0;\nint mnum = 0;\nint num = a[n - 1];\nint tdiff = 0;\nint occ = 1;\nwhile (i >= 0 && j >= 0) {//0 2 3 4 6\n\tif (tdiff + num - a[j] <= k) {\n\t\ttdiff += num - a[j];\n\t\tocc++;\n\t\tj--;\n\t} else {\n\t\tif (occ >= mocc) {\n\t\t\tmocc = occ;\n\t\t\tmnum = num;\n\t\t}\n\t\tocc--;\n\t\ttdiff += (i - j - 1) * (a[i - 1] - a[i]);\n\t\tnum = a[--i];\n\t}\n}\nif (occ >= mocc) {\n\tmocc = occ;\n\tmnum = num;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 7",
          "code": "int n = in.nextInt(), k = in.nextInt();\nint[] a = new int[n];\nfor (int i = 0; i < n; i++) {\n\ta[i] = in.nextInt();\n}\nArrays.sort(a);\nint i = n - 1, j = n - 2;\nint mocc = 0;\nint mnum = 0;\nint num = a[n - 1];\nint tdiff = 0;\nint occ = 1;\nwhile (i >= 0 && j >= 0) {//0 2 3 4 6\n\tif (tdiff + num - a[j] <= k) {\n\t\ttdiff += num - a[j];\n\t\tocc++;\n\t\tj--;\n\t} else {\n\t\tif (occ >= mocc) {\n\t\t\tmocc = occ;\n\t\t\tmnum = num;\n\t\t}\n\t\tocc--;\n\t\ttdiff += (i - j - 1) * (a[i - 1] - a[i]);\n\t\tnum = a[--i];\n\t}\n}\nif (occ >= mocc) {\n\tmocc = occ;\n\tmnum = num;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 8",
          "code": "occ--;\ntdiff += (i - j - 1) * (a[i - 1] - a[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #143 (Div. 2) Разбор задач - Codeforces - Code 9",
          "code": "occ--;\ntdiff += (i - j - 1) * (a[i - 1] - a[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5486",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n);\n        inf.readSpace();\n        int b = inf.readInt(1, n);\n        inf.readEoln();\n\n        ensuref(a != b, \"No loops allowed: edge from vertex %d to itself\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Multiple edges between vertices %d and %d\", u, v);\n\n        edgeSet.insert(edge);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<int> parent(n + 1, -1);\n    vector<bool> inCycle(n + 1, false);\n    vector<bool> visited(n + 1, false);\n\n    function<void(int, int)> dfsCheckCactus = [&](int u, int p) {\n        visited[u] = true;\n        parent[u] = p;\n        for (int v : adj[u]) {\n            if (v == p) continue; // Skip the edge to parent\n            if (!visited[v]) {\n                dfsCheckCactus(v, u);\n            } else {\n                // Found a back edge (u, v), v is ancestor of u\n                // Build the cycle from u to v\n                int curr = u;\n                while (curr != v) {\n                    if (inCycle[curr]) {\n                        ensuref(false, \"Vertex %d belongs to more than one cycle\", curr);\n                    }\n                    inCycle[curr] = true;\n                    curr = parent[curr];\n                }\n                if (inCycle[v]) {\n                    ensuref(false, \"Vertex %d belongs to more than one cycle\", v);\n                }\n                inCycle[v] = true;\n            }\n        }\n    };\n\n    dfsCheckCactus(1, -1);\n\n    for (int u = 1; u <= n; ++u) {\n        ensuref(visited[u], \"Graph is not connected, vertex %d is unreachable\", u);\n    }\n\n    int k = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for (int i = 0; i < k; ++i) {\n        int x = inf.readInt(1, n);\n        inf.readSpace();\n        int y = inf.readInt(1, n);\n        ensuref(x != y, \"In query %d, x_i (%d) should not be equal to y_i (%d)\", i + 1, x, y);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n);\n        inf.readSpace();\n        int b = inf.readInt(1, n);\n        inf.readEoln();\n\n        ensuref(a != b, \"No loops allowed: edge from vertex %d to itself\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Multiple edges between vertices %d and %d\", u, v);\n\n        edgeSet.insert(edge);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<int> parent(n + 1, -1);\n    vector<bool> inCycle(n + 1, false);\n    vector<bool> visited(n + 1, false);\n\n    function<void(int, int)> dfsCheckCactus = [&](int u, int p) {\n        visited[u] = true;\n        parent[u] = p;\n        for (int v : adj[u]) {\n            if (v == p) continue; // Skip the edge to parent\n            if (!visited[v]) {\n                dfsCheckCactus(v, u);\n            } else {\n                // Found a back edge (u, v), v is ancestor of u\n                // Build the cycle from u to v\n                int curr = u;\n                while (curr != v) {\n                    if (inCycle[curr]) {\n                        ensuref(false, \"Vertex %d belongs to more than one cycle\", curr);\n                    }\n                    inCycle[curr] = true;\n                    curr = parent[curr];\n                }\n                if (inCycle[v]) {\n                    ensuref(false, \"Vertex %d belongs to more than one cycle\", v);\n                }\n                inCycle[v] = true;\n            }\n        }\n    };\n\n    dfsCheckCactus(1, -1);\n\n    for (int u = 1; u <= n; ++u) {\n        ensuref(visited[u], \"Graph is not connected, vertex %d is unreachable\", u);\n    }\n\n    int k = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for (int i = 0; i < k; ++i) {\n        int x = inf.readInt(1, n);\n        inf.readSpace();\n        int y = inf.readInt(1, n);\n        ensuref(x != y, \"In query %d, x_i (%d) should not be equal to y_i (%d)\", i + 1, x, y);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n);\n        inf.readSpace();\n        int b = inf.readInt(1, n);\n        inf.readEoln();\n\n        ensuref(a != b, \"No loops allowed: edge from vertex %d to itself\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Multiple edges between vertices %d and %d\", u, v);\n\n        edgeSet.insert(edge);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<int> parent(n + 1, -1);\n    vector<bool> inCycle(n + 1, false);\n    vector<bool> visited(n + 1, false);\n\n    function<void(int, int)> dfsCheckCactus = [&](int u, int p) {\n        visited[u] = true;\n        parent[u] = p;\n        for (int v : adj[u]) {\n            if (v == p) continue; // Skip the edge to parent\n            if (!visited[v]) {\n                dfsCheckCactus(v, u);\n            } else {\n                // Found a back edge (u, v), v is ancestor of u\n                // Build the cycle from u to v\n                int curr = u;\n                while (curr != v) {\n                    if (inCycle[curr]) {\n                        ensuref(false, \"Vertex %d belongs to more than one cycle\", curr);\n                    }\n                    inCycle[curr] = true;\n                    curr = parent[curr];\n                }\n                if (inCycle[v]) {\n                    ensuref(false, \"Vertex %d belongs to more than one cycle\", v);\n                }\n                inCycle[v] = true;\n            }\n        }\n    };\n\n    dfsCheckCactus(1, -1);\n\n    for (int u = 1; u <= n; ++u) {\n        ensuref(visited[u], \"Graph is not connected, vertex %d is unreachable\", u);\n    }\n\n    int k = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for (int i = 0; i < k; ++i) {\n        int x = inf.readInt(1, n);\n        inf.readSpace();\n        int y = inf.readInt(1, n);\n        ensuref(x != y, \"In query %d, x_i (%d) should not be equal to y_i (%d)\", i + 1, x, y);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int c = opt<int>(\"c\", 0); // number of cycles\n    int k = opt<int>(\"k\", 0); // number of queries\n    string type = opt<string>(\"type\", \"random\");\n\n    int m = 0; // number of edges\n\n    vector<Edge> edges;\n    // initialize used vertices\n    vector<bool> inCycle(n + 1, false); // vertices in cycles, 1-based\n\n    int vertexId = 1;\n\n    // Adjust c according to type\n    if (type == \"tree\") {\n        c = 0;\n    } else if (type == \"maxCycles\") {\n        // Maximum number of cycles possible\n        c = (n - 1) / 2;\n        if (c < 1) c = 1;\n    }\n\n    int totalVertices = n;\n    int remainingVertices = n;\n    vector<int> vertices; // record the vertices to be connected\n\n    vector<vector<int>> cycles;\n\n    int maxCycleLength = opt<int>(\"maxCycleLength\", n);\n\n    // Generate cycles according to 'type'\n\n    if (type == \"chain\") {\n        // Build a chain (a tree with maximum depth)\n        vector<int> nodes;\n        for(int i = 1; i <= n; ++i) {\n            nodes.push_back(i);\n        }\n        for(int i = 1; i < n; ++i) {\n            edges.push_back({nodes[i - 1], nodes[i]});\n            m++;\n        }\n    } else if (type == \"star\") {\n        // Build a star graph\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n            m++;\n        }\n    } else {\n        // Proceed with cycles and tree connections\n        for(int i = 0; i < c; ++i) {\n            // Decide cycle length\n            int maxLength = min(maxCycleLength, remainingVertices - (c - i - 1));\n            int minLength = 3;\n            if (maxLength < minLength) {\n                // Can't proceed\n                break;\n            }\n            int l_i;\n            if (type == \"maxCycles\") {\n                l_i = minLength;\n            } else {\n                l_i = rnd.next(minLength, maxLength);\n            }\n            vector<int> cycle;\n            for(int j = 0; j < l_i; ++j) {\n                cycle.push_back(vertexId++);\n                remainingVertices--;\n            }\n            // Create cycle edges\n            for(int j = 0; j < l_i; ++j) {\n                int u = cycle[j];\n                int v = cycle[(j + 1) % l_i];\n                edges.push_back({u, v});\n                m++;\n            }\n            // Mark vertices as in cycles\n            for(int v : cycle) {\n                inCycle[v] = true;\n            }\n            // Save the cycle\n            cycles.push_back(cycle);\n            if (remainingVertices <= 0) break;\n        }\n\n        // Now, collect vertices from cycles to connect\n        vector<int> cycleVertices;\n        for(auto &cycle : cycles) {\n            int idx = rnd.next(0, (int)cycle.size() - 1);\n            cycleVertices.push_back(cycle[idx]);\n        }\n\n        // Remaining vertices (not in cycles) to build connecting trees\n        vector<int> treeVertices;\n        for(; vertexId <= n; vertexId++) {\n            treeVertices.push_back(vertexId);\n        }\n\n        vector<int> allVertices = cycleVertices;\n        allVertices.insert(allVertices.end(), treeVertices.begin(), treeVertices.end());\n\n        // Build a random tree with the vertices\n        shuffle(allVertices.begin(), allVertices.end());\n\n        if(allVertices.size() >= 2) {\n            for(int i = 1; i < allVertices.size(); ++i) {\n                int u = allVertices[i];\n                int v = allVertices[rnd.next(0, i - 1)];\n                edges.push_back({u, v});\n                m++;\n            }\n        }\n    }\n\n    // Now we have built the graph\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for(auto &e : edges) {\n        printf(\"%d %d\\n\", e.u, e.v);\n    }\n\n    int kParam = opt<int>(\"k\", 0);\n    if (kParam == 0) {\n        kParam = rnd.next(1, min(100000, n*(n-1)/2));\n    }\n\n    printf(\"%d\\n\", kParam);\n\n    // Generate k pairs\n    for(int i = 0; i < kParam; ++i) {\n        int xi = rnd.next(1, n);\n        int yi = rnd.next(1, n);\n        while (yi == xi) yi = rnd.next(1, n);\n        printf(\"%d %d\\n\", xi, yi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int c = opt<int>(\"c\", 0); // number of cycles\n    int k = opt<int>(\"k\", 0); // number of queries\n    string type = opt<string>(\"type\", \"random\");\n\n    int m = 0; // number of edges\n\n    vector<Edge> edges;\n    // initialize used vertices\n    vector<bool> inCycle(n + 1, false); // vertices in cycles, 1-based\n\n    int vertexId = 1;\n\n    // Adjust c according to type\n    if (type == \"tree\") {\n        c = 0;\n    } else if (type == \"maxCycles\") {\n        // Maximum number of cycles possible\n        c = (n - 1) / 2;\n        if (c < 1) c = 1;\n    }\n\n    int totalVertices = n;\n    int remainingVertices = n;\n    vector<int> vertices; // record the vertices to be connected\n\n    vector<vector<int>> cycles;\n\n    int maxCycleLength = opt<int>(\"maxCycleLength\", n);\n\n    // Generate cycles according to 'type'\n\n    if (type == \"chain\") {\n        // Build a chain (a tree with maximum depth)\n        vector<int> nodes;\n        for(int i = 1; i <= n; ++i) {\n            nodes.push_back(i);\n        }\n        for(int i = 1; i < n; ++i) {\n            edges.push_back({nodes[i - 1], nodes[i]});\n            m++;\n        }\n    } else if (type == \"star\") {\n        // Build a star graph\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n            m++;\n        }\n    } else {\n        // Proceed with cycles and tree connections\n        for(int i = 0; i < c; ++i) {\n            // Decide cycle length\n            int maxLength = min(maxCycleLength, remainingVertices - (c - i - 1));\n            int minLength = 3;\n            if (maxLength < minLength) {\n                // Can't proceed\n                break;\n            }\n            int l_i;\n            if (type == \"maxCycles\") {\n                l_i = minLength;\n            } else {\n                l_i = rnd.next(minLength, maxLength);\n            }\n            vector<int> cycle;\n            for(int j = 0; j < l_i; ++j) {\n                cycle.push_back(vertexId++);\n                remainingVertices--;\n            }\n            // Create cycle edges\n            for(int j = 0; j < l_i; ++j) {\n                int u = cycle[j];\n                int v = cycle[(j + 1) % l_i];\n                edges.push_back({u, v});\n                m++;\n            }\n            // Mark vertices as in cycles\n            for(int v : cycle) {\n                inCycle[v] = true;\n            }\n            // Save the cycle\n            cycles.push_back(cycle);\n            if (remainingVertices <= 0) break;\n        }\n\n        // Now, collect vertices from cycles to connect\n        vector<int> cycleVertices;\n        for(auto &cycle : cycles) {\n            int idx = rnd.next(0, (int)cycle.size() - 1);\n            cycleVertices.push_back(cycle[idx]);\n        }\n\n        // Remaining vertices (not in cycles) to build connecting trees\n        vector<int> treeVertices;\n        for(; vertexId <= n; vertexId++) {\n            treeVertices.push_back(vertexId);\n        }\n\n        vector<int> allVertices = cycleVertices;\n        allVertices.insert(allVertices.end(), treeVertices.begin(), treeVertices.end());\n\n        // Build a random tree with the vertices\n        shuffle(allVertices.begin(), allVertices.end());\n\n        if(allVertices.size() >= 2) {\n            for(int i = 1; i < allVertices.size(); ++i) {\n                int u = allVertices[i];\n                int v = allVertices[rnd.next(0, i - 1)];\n                edges.push_back({u, v});\n                m++;\n            }\n        }\n    }\n\n    // Now we have built the graph\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for(auto &e : edges) {\n        printf(\"%d %d\\n\", e.u, e.v);\n    }\n\n    int kParam = opt<int>(\"k\", 0);\n    if (kParam == 0) {\n        kParam = rnd.next(1, min(100000, n*(n-1)/2));\n    }\n\n    printf(\"%d\\n\", kParam);\n\n    // Generate k pairs\n    for(int i = 0; i < kParam; ++i) {\n        int xi = rnd.next(1, n);\n        int yi = rnd.next(1, n);\n        while (yi == xi) yi = rnd.next(1, n);\n        printf(\"%d %d\\n\", xi, yi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -c 0 -k 1 -type tree\n./gen -n 3 -c 1 -k 1 -type random\n./gen -n 5 -c 1 -k 10 -type random\n./gen -n 10 -c 0 -k 20 -type tree\n./gen -n 10 -c 3 -k 20 -type random\n./gen -n 10 -c 1 -k 10 -type maxCycles\n./gen -n 20 -c 5 -k 50 -type random\n./gen -n 50 -c 0 -k 100 -type chain\n./gen -n 50 -c 10 -k 100 -type random\n./gen -n 100 -c 0 -k 200 -type star\n./gen -n 100 -c 10 -k 1000 -type random\n./gen -n 100 -c 30 -k 1000 -type maxCycles\n./gen -n 1000 -c 0 -k 2000 -type chain\n./gen -n 1000 -c 100 -k 2000 -type random\n./gen -n 1000 -c 200 -k 5000 -type maxCycles\n./gen -n 5000 -c 0 -k 5000 -type tree\n./gen -n 5000 -c 2000 -k 5000 -type random\n./gen -n 10000 -c 0 -k 10000 -type chain\n./gen -n 10000 -c 500 -k 10000 -type random\n./gen -n 20000 -c 0 -k 20000 -type star\n./gen -n 20000 -c 10000 -k 20000 -type maxCycles\n./gen -n 30000 -c 0 -k 30000 -type tree\n./gen -n 30000 -c 5000 -k 30000 -type random\n./gen -n 50000 -c 0 -k 50000 -type chain\n./gen -n 50000 -c 1000 -k 50000 -type random\n./gen -n 70000 -c 0 -k 70000 -type star\n./gen -n 70000 -c 10000 -k 70000 -type maxCycles\n./gen -n 99999 -c 99998 -k 100000 -type maxCycles\n./gen -n 99999 -c 0 -k 1 -type star\n./gen -n 100000 -c 0 -k 100000 -type chain\n./gen -n 100000 -c 50000 -k 100000 -type maxCycles\n./gen -n 100000 -c 1000 -k 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:52:57.886618",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "232/A",
      "title": "A. Cycles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains an integer k (1 ≤ k ≤ 105) — the number of cycles of length 3 in the required graph.",
      "output_spec": "OutputIn the first line print integer n (3 ≤ n ≤ 100) — the number of vertices in the found graph. In each of next n lines print n characters \"0\" and \"1\": the i-th character of the j-th line should equal \"0\", if vertices i and j do not have an edge between them, otherwise it should equal \"1\". Note that as the required graph is undirected, the i-th character of the j-th line must equal the j-th character of the i-th line. The graph shouldn't contain self-loops, so the i-th character of the i-th line must equal \"0\" for all i.",
      "sample_tests": "ExamplesInputCopy1OutputCopy3011101110InputCopy10OutputCopy50111110111110111110111110",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains an integer k (1 ≤ k ≤ 105) — the number of cycles of length 3 in the required graph.\n\nOutputIn the first line print integer n (3 ≤ n ≤ 100) — the number of vertices in the found graph. In each of next n lines print n characters \"0\" and \"1\": the i-th character of the j-th line should equal \"0\", if vertices i and j do not have an edge between them, otherwise it should equal \"1\". Note that as the required graph is undirected, the i-th character of the j-th line must equal the j-th character of the i-th line. The graph shouldn't contain self-loops, so the i-th character of the i-th line must equal \"0\" for all i.\n\nInputCopy1OutputCopy3011101110InputCopy10OutputCopy50111110111110111110111110\n\nOutputCopy3011101110\n\nInputCopy10\n\nOutputCopy50111110111110111110111110",
      "solutions": [
        {
          "title": "Codeforces Round #144 - Codeforces",
          "content": "Hi all! Codeforces round #144 is going to be today. Round is prepared by: KAN, fdoer, Skird, tunyash. Special thanks to Gerald for coordinating round preparing, many awesome ideas and making statements easy-understandable. Also I thank MikeMirzayanov for enjoyable problem-preparing system, Delinur for statements translation. I hope, that all will be well and you will enjoy solving problems. Good luck!UPD: Score distribution will be announced a few minutes before the start of the contest.UPD2: score distribution is 500-1000-1500-2000-2500 in both divisionsUPD3:Congrats to winners.div1: tourist rng_58 Mimino Dmitry_Egorov, Egor div2: debug22 ryz dvdreddy vinodreddy rdivyanshu UPD: editoral for all problems, except div1.D is ready",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5510",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 737
        },
        {
          "title": "Editorial for Codeforces Round #144 - Codeforces",
          "content": "It will be finised in few hours. If you don't understand something, ask your questions, please.233A - Perfect PermutationIdea: Gerald Implementation: tunyash Editorial: fdoerConsider permutation p such that pi = i. Actually p is a sequence of numbers from 1 to n. Obviously ppi = i. Now the only trick is to change the permutation to satisfy the second equation: pi ≠ i. Let's swap every two consequtive elements. More formally, for each k: 2k ≤ n let's swap p2k - 1 and p2k. It's easy to see that the obtained permutation satisfies both equations for every n with the only exception: when n is odd, there is no answer and we should print  - 1.233B - Non-square EquationIdea: tunyash Implementation: tunyash, Gerald Editorial: fdoerFirstly let's find the interval of possible values of s(x). Hence x2 ≤ n and n ≤ 1018, x ≤ 109. In other words, for every considerable solution x the decimal length of x does not extend 10 digits. So smax ≤ s(9999999999) = 10·9 = 90.Let's bruteforce the value of s(x) (0 ≤ s(x) ≤ 90). Now we have an ordinary square equation. The deal is to solve it and to check that the current bruteforced value of s(x) is equal to sum of digits of the solution. If the solution exists and the equality holds, we should relax the answer.It seems that the most error-generating part of this problem is solving the equation.Knowing arrays is not neccessary to solve these two problems.232A - CyclesIdea: tunyash, fdoer Implementation: tunyash Editorial: tunyashLet's add edge in order of increasing a and for equal b in order of increasing b (here a and b — the least and the greatest vertices of the edge). If the new edge adds too much 3-cycles, we won't add it. We can count the number of new 3-cycles in O(n) complexity (they all contain the new edge, so it's enough to check all variants of the third vertex). Obviously we will obtain some proper graph, because we can always add a vertex and two edges to make a new triangle. So, there is always an answer. The complexity of this solution is O(n3).Let's proof that 100 vertices are always enough for the given restrictions on n. For some p after first p iterations we will have a complete graph of p vertices. Now we have exactly C(p, 3) triangles. Consider p such that C(p, 3) ≤ k and C(p, 3) is maximal. For the given restrictions p ≤ 85. From this moment, if we add u from some vertex, we increase the total number of 3-cycles on C(u, 2). So we have to present a small number that is less than C(85, 3) as sum of C(i, 2). The first number we subtruct will differ C(85, 1) on some value not greater than C(85, 1) = 85, because C(n, k) - C(n - 1, k) = C(n - 1, k - 1). The second number we subtruct will differ the number we have on some value not greater than C(14, 1) = 14. and so on. For every k it's enough to use not more that 90 vertices. 232B - TableIdea: tunyash, Skird Implementation: tunyash Editorial: tunyash Let si number of points in the column i. Two neighboring squares are drawn at this picture, A is the number of point it the left area (it is one column), B is the number of points in the middle area and C is the number of points in the right area (it is one column too). That's why by definition we have: Therefore A = C. That's why Divide all columns by equivalence classes on the basis of . For all a and b from one class sa = sb. cnta is number of columns in class with . There are (Cnk)cnta ways to draw k points in the each of columns in the class a independendently of the other classes. dp[i][j] is number of ways to fill all columns in classes 1, ... i in such way that . cnti take only two values and . Let's calc (Cna)cnti for all a and cnti and use it to calc our dp. We have O(n2·k) complexity. 232C - Doe Graphs Idea: Gerald,tunyash Implementation: tunyash, Gerald Editorial: tunyashLet's reduce the problem to the same problem for graphs with less orders. Vertex |D(n - 1)| + 1 is cutpoint (except cases n ≤ 2 but equations below is true for these cases).Without loss of generality a < b. Let dist(a, b, n) — length of the shortest path in graph of order n.The first case is a ≤ |D(n - 1)| and |D(n - 1)| + 1 ≤ b dist(a, b, n) = min(dist(a, |D(n - 1)|, n - 1), dist(a, 1, n - 1)) + dist(b - |D(n - 1)|, 1, n - 2) + 1Edges is marked in red, paths is marked in blue. This formula means that we can go from the vertex a by the path 1 to the vertex 1. Then we can go to the |D(n - 1)| + 1 by the edge and go to the vertex b by the path 3. Or we can go to the vertex |D(n - 1)| by the path 2 and then go to the vertex |D(n - 1)| + 1 by the path 2 and then go to the vertex b by the path 3.The second case is |D(n - 1)| + 1 ≤ a, b. dist(a, b, n) = dist(a - |D(n - 1)|, b - |D(n - 1)|, n - 2)That's easy case.The third case is a, b ≤ |D(n - 1)| dist(a, b, n) = min(dist(a, b, n - 1), min(dist(1, a, n - 1), dist(|D(n - 1)|, a, n - 1)) + min(dist(1, b, n - 1), dist(|D(n - 1)|, b, n - 1) + 2)If shortest path contains cutpoint (|D(n - 1)| + 1) we can go to the vertex 1 or |D(n - 1)+1$ form the both of a and b. After that we can go to the cutpoint. Else we should consider path from a to b in D(n - 1).Let's notice that for all of n will be no more than 4 distinct runnings of dist(i, j, n).It can be prooved by the considering many cases of our actions.In authors colution we cashed all dist(1, i, n) and dist(i, |D(n)|, n) for all achieveable i and n. We have complexity for one query. (it's log because |D(n)| grows like φn).232D - FenceIdea: Gerald, tunyash Implementation: fdoer Editorial: fdoerLet d and d' be arrays such that di = hi - hi + 1, d'i =  - di for every 1 ≤ i ≤ (n - 1). With that notation the conditions of matching look somehow like these: the pieces do not intersect, that is, there isn't a single plank, such that it occurs in both pieces of the fence; the pieces are of the same width; for all i i (0 ≤ i ≤ r1 - l1 - 1) the following condition holds: dl1 + i = d'l2 + i (that is true in case when l = r). The main idea of our solution is stated in the next sentence. For each query l...r the answer is number of pairs (a, b) such that (a > r or b < l), 1 ≤ a ≤ b ≤ n - 1, b - a = r - l and dl...r - 1 exactly matches d'a...b - 1. Let's build a suffix array sa from the concatenation of arrays d and d' with a fictive number between them for separation. Let position of suffix i in sa be posi. For each query all pieces of the fence that satisfy both second and third conditions of matching will be placed in sa on some segment boundleft...boundright such that boundleft ≤ posl ≤ boundright and lcp(boundleft...boundright) ≥ (r - l). So, it's possible to use binary search to find bound's. Depending on complexity of lcp finding algorithm, we could get them in O(logn) or O(log2n) complexity.But there is still a problem to count the number of suffixes from saboundleft...boundright that satisfy the first condition too. Actually it is equal to count the number of i (boundleft ≤ i ≤ boundright) such that (n + 1 ≤ sai ≤ n + l - (r - l) - 1 or sai ≥ n + r) (in the concatenation d' starts from n + 1). It is a classic problem to count numbers from the given interval in the given subarray. For each query it could be solved in O(logn) complexity.For instance, we could solve it offline using sweep line method and any data structure that support queries of sum on an interval and increment of an element. Or we could use some 2D/persistent structure.So, the summary of the algorithm looks like this: build d and d'. Build a suffix array on their concatenation. For each query: find the interval (boundleft...boundright) with two consecutive binary searches using lcp function. query the count of suffixes from that interval that do not intersect with the given piece of the fence. The best author's solution complexity is O(nlogn + qlogn), but careful written solutions in O(nlog2n) comply with the lime limit too.232E - Quick Tortoise Idea: tunyash Implementation: tunyash, KAN Editorial: tunyashLet's choose central column of the area and for all cells to the left from column calc masks of achieveable cells in the central column and for all cells to the right from column calc masks of cells of which this is achievable. It's easy dp with bitsets. for the right part of board. ( — logical or, here it's bitwise or for masks) for the left part. dp calcs mask of achieveable points in the central column.For query x1, y1, x2, y2 (if y1 ≤ mid ≤ y2, where mid is chosen central column) answer is yes if ( is bitwise and) is not empty.Run this algo for left and right part of board we will get answers for all queries. Complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 232\\s*A"
          },
          "content_length": 8557
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #144 - Codeforces - Code 1",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 2",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 3",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 4",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int K_MIN = 1;\n    const int K_MAX = 100000;\n\n    int k = inf.readInt(K_MIN, K_MAX, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int K_MIN = 1;\n    const int K_MAX = 100000;\n\n    int k = inf.readInt(K_MIN, K_MAX, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int K_MIN = 1;\n    const int K_MAX = 100000;\n\n    int k = inf.readInt(K_MIN, K_MAX, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read k from the input file\n    int k = inf.readInt(1, 100000);\n\n    // Read n from the contestant's output\n    int n = ouf.readInt(3, 100, \"n\");\n\n    vector<string> matrix(n);\n    for (int i = 0; i < n; i++) {\n        matrix[i] = ouf.readToken();\n        if ((int)matrix[i].length() != n)\n            quitf(_wa, \"Line %d: expected length %d, got %d\", i + 1, n, (int)matrix[i].length());\n        for (int j = 0; j < n; j++) {\n            if (matrix[i][j] != '0' && matrix[i][j] != '1')\n                quitf(_wa, \"Invalid character at position (%d, %d): expected '0' or '1', got '%c'\", i + 1, j + 1, matrix[i][j]);\n        }\n        if (matrix[i][i] != '0')\n            quitf(_wa, \"Diagonal element at (%d, %d) is not zero\", i + 1, i + 1);\n    }\n\n    // Check symmetry of the adjacency matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (matrix[i][j] != matrix[j][i])\n                quitf(_wa, \"Matrix is not symmetric at positions (%d, %d) and (%d, %d)\", i + 1, j + 1, j + 1, i + 1);\n        }\n    }\n\n    // Count the number of cycles of length 3 (triangles)\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (matrix[i][j] == '1') {\n                for (int k = j + 1; k < n; k++) {\n                    if (matrix[i][k] == '1' && matrix[j][k] == '1') {\n                        cnt++;\n                    }\n                }\n            }\n        }\n    }\n\n    // Check if the number of cycles matches k\n    if (cnt != k)\n        quitf(_wa, \"Number of cycles of length 3 is %d, expected %d\", cnt, k);\n\n    quitf(_ok, \"Correct. Number of cycles is %d\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register this generator with Testlib.\n    registerGen(argc, argv, 1);\n\n    // We will produce a single integer k that satisfies:\n    // 1 ≤ k ≤ 100000\n\n    // Available generator parameters.\n    //   1) k (int): If provided, we output exactly this k.\n    //   2) type (string): If k not provided, we pick k at random\n    //      from different ranges based on \"type\".\n    //         \"small\"   -> k in [1..100]\n    //         \"medium\"  -> k in [101..10000]\n    //         \"large\"   -> k in [10001..100000]\n    //         \"various\" -> one random pick among several ranges\n    //         \"random\"  -> default in [1..100000]\n    //\n    // Example usage:\n    //    ./gen -k 42\n    //    ./gen -type small\n    //    ./gen -type large\n\n    int specifiedK = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int k;\n    if (specifiedK != -1) {\n        // Use the user-provided k if given.\n        k = specifiedK;\n    } else {\n        // Otherwise, pick k according to the \"type\" parameter.\n        if (type == \"small\") {\n            // small k in [1..100]\n            k = rnd.next(1, 100);\n        } else if (type == \"medium\") {\n            // medium k in [101..10000]\n            k = rnd.next(101, 10000);\n        } else if (type == \"large\") {\n            // large k in [10001..100000]\n            k = rnd.next(10001, 100000);\n        } else if (type == \"various\") {\n            // pick from one of several intervals\n            int choice = rnd.next(1, 4);\n            if (choice == 1) {\n                k = rnd.next(1, 100);\n            } else if (choice == 2) {\n                k = rnd.next(101, 10000);\n            } else if (choice == 3) {\n                k = rnd.next(10001, 99999);\n            } else {\n                k = 100000;\n            }\n        } else {\n            // default random in [1..100000]\n            k = rnd.next(1, 100000);\n        }\n    }\n\n    // Output the single integer k as the entire test case.\n    cout << k << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register this generator with Testlib.\n    registerGen(argc, argv, 1);\n\n    // We will produce a single integer k that satisfies:\n    // 1 ≤ k ≤ 100000\n\n    // Available generator parameters.\n    //   1) k (int): If provided, we output exactly this k.\n    //   2) type (string): If k not provided, we pick k at random\n    //      from different ranges based on \"type\".\n    //         \"small\"   -> k in [1..100]\n    //         \"medium\"  -> k in [101..10000]\n    //         \"large\"   -> k in [10001..100000]\n    //         \"various\" -> one random pick among several ranges\n    //         \"random\"  -> default in [1..100000]\n    //\n    // Example usage:\n    //    ./gen -k 42\n    //    ./gen -type small\n    //    ./gen -type large\n\n    int specifiedK = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int k;\n    if (specifiedK != -1) {\n        // Use the user-provided k if given.\n        k = specifiedK;\n    } else {\n        // Otherwise, pick k according to the \"type\" parameter.\n        if (type == \"small\") {\n            // small k in [1..100]\n            k = rnd.next(1, 100);\n        } else if (type == \"medium\") {\n            // medium k in [101..10000]\n            k = rnd.next(101, 10000);\n        } else if (type == \"large\") {\n            // large k in [10001..100000]\n            k = rnd.next(10001, 100000);\n        } else if (type == \"various\") {\n            // pick from one of several intervals\n            int choice = rnd.next(1, 4);\n            if (choice == 1) {\n                k = rnd.next(1, 100);\n            } else if (choice == 2) {\n                k = rnd.next(101, 10000);\n            } else if (choice == 3) {\n                k = rnd.next(10001, 99999);\n            } else {\n                k = 100000;\n            }\n        } else {\n            // default random in [1..100000]\n            k = rnd.next(1, 100000);\n        }\n    }\n\n    // Output the single integer k as the entire test case.\n    cout << k << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are some example commands to produce a variety of test inputs.\n# Each command prints exactly one integer k, which is the test case input.\n\n# 1) Minimal corner cases:\n./gen -k 1\n./gen -k 2\n./gen -k 3\n\n# 2) Small random values (type=small):\n./gen -type small\n./gen -type small\n./gen -type small\n./gen -type small\n./gen -type small\n\n# 3) Medium random values (type=medium):\n./gen -type medium\n./gen -type medium\n./gen -type medium\n./gen -type medium\n./gen -type medium\n\n# 4) Large random values (type=large):\n./gen -type large\n./gen -type large\n./gen -type large\n./gen -type large\n./gen -type large\n\n# 5) Mixed random values (type=various):\n./gen -type various\n./gen -type various\n./gen -type various\n./gen -type various\n./gen -type various\n\n# 6) Maximum possible k:\n./gen -k 100000\n\n# 7) A few more specialized k's near upper constraint:\n./gen -k 99999\n./gen -k 50000\n./gen -k 99950\n./gen -k 75000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:00.234256",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "232/B",
      "title": "B. Таблица",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ единственной строке через пробел записаны целые числа n, m, k (1 ≤ n ≤ 100; n ≤ m ≤ 1018; 0 ≤ k ≤ n2) — количество строк в таблице, количество столбцов в таблице и количество точек, которое должно быть в каждом квадрате.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВ единственной строке выведите целое число — остаток от деления описанного количества способов на 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать5 6 1Выходные данныеСкопировать45",
      "description": "ограничение по времени на тест4 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке через пробел записаны целые числа n, m, k (1 ≤ n ≤ 100; n ≤ m ≤ 1018; 0 ≤ k ≤ n2) — количество строк в таблице, количество столбцов в таблице и количество точек, которое должно быть в каждом квадрате.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите целое число — остаток от деления описанного количества способов на 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать5 6 1Выходные данныеСкопировать45\n\nВходные данныеСкопировать5 6 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать45\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый тестовый пример:     Серая область принадлежит обоим квадратам 5 × 5. Поэтому, если в ней есть одна точка, то больше нигде точек быть не может. Если в одной из белых областей есть точка, то в другой тоже должна быть точка. Таким образом есть 20 вариантов, в которых точка стоит в серой области и 25 вариантов в которых в каждой из белых областей стоит по точке. Всего 45 вариантов.",
      "solutions": [
        {
          "title": "Codeforces Round #144 - Codeforces",
          "content": "Всем привет! Сегодня состоится очередной codeforces-round. Он пройдет в обоих дивизионах, в каждом из которых будет предложено пять задач разной сложности.В его подготовке, принимало участие несколько человек: KAN, fdoer, Skird, tunyash. Огромное спасибо Gerald, за координацию подготовки задач, множество клевых идей и понятизацию условий. Так же благодарю MikeMirzayanov за отличную систему подготовки задач, Delinur за перевод условий. Надеюсь, все пройдет гладко и вам понравятся задачи. Про разбалловку вы узнаете перед контестом.Удачи!UPD: разбалловка стандартная (500-1000-1500-2000-2500) в обоих дивизионах.UPD: появился очень кратенький разборUPD:Поздравляю победителей! div1: tourist rng_58 Mimino Dmitry_Egorov, Egor div2: debug22 ryz dvdreddy vinodreddy rdivyanshu UPD: есть полный разбор на русском.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5510",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 812
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces",
          "content": "Задачи, которые не успели написать, разберу кратко. Задавайте вопросы.233A - Идеальная перестановкаИдея: Gerald Реализация: tunyash Разбор: fdoerЭту задачу можно было решать разными способами, например, таким: рассмотрим перестановку p, в которой pi = i, то есть просто последовательность чисел от 1 до n. Очевидно, для неё условие ppi = i выполняется всегда. Осталось только преобразовать её таким образом, чтобы выполнялось и второе условие: pi ≠ i. Для этого поменяем местами каждые два соседних элемента, т.е. для каждого k: k * 2 ≤ n поменяем местами значения p2k - 1 и p2k. Нетрудно убедиться, что для полученной перестановки оба условия выполняются всегда.233B - Неквадратное уравнениеИдея: tunyash Реализация: tunyash, Gerald Разбор: fdoerДля начала найдем диапазон значений, которые может принимать s(x). Так как из уравнения x2 ≤ n, а по условию n ≤ 1018, x ≤ 109, иначе говоря, десятичная запись любого решения не длиннее 10 цифр. Значит, максимальное значение smax = s(9999999999) = 10·9 = 90 (на самом деле это грубая оценка, smax даже меньше, но нам достаточно и её).Переберем значение s(x): 0 ≤ s(x) ≤ 90. Получаем обычное квадратное уравнение относительно переменной x. Осталось решить его и проверить равенство того значения s(x), что мы зафиксировали, сумме цифр в разрядах полученного корня. Если корень нашелся и равенство выполнено, обновим ответ.Пожалуй, самое важное в этой задаче — аккуратно и без ошибок вычислений считать дискриминант.Подчеркну, что для решения задач div2.A и div2.B не требовалось знание массивов.232A - Циклы Идея: tunyash, fdoer Реализация: tunyash Разбор: tunyashБудем добавлять ребра в порядке сортировки сначала по вершине в меньшим номером, затем с большим (просто два for'a). Если добавление ребра вызывает переполнение кол-ва циклов, не добавляем его. Считать количество циклов, которые добавятся можно за O(n) (могут появиться только циклы, содержащие добавленное ребро, следовательно достаточно перебрать третью вершину). Очевидно, что это найдет какой-то ответ, потому что, добавив два ребра из вершины мы всегда можем получить 1 треугольник. Тогда получается, что ответ всегда есть. Можно довольно просто доказать, что мы уложимся в 100. Асимптотика решения O(n3).Доказательство Первыми несколькими шагами алгоритма мы сгенерируем полный граф. Потому что каждое ребро можно будет добавить Полученное количество треугольников — C(p, 3) для какого-то p. C(p, 3) ≤ k при этом p максимально. Для данных ограничений p ≤ 85. После первой фазы алгоритма, если из некоторой вершины мы добавляем u ребер, то количество треугольников увеличивается на C(u, 2). Получается, мы представляем маленькое число  ≤ C(85, 2) в виде суммы C(i, 2). Первое число, которое мы вычтем, будет отличаться от нашего не более чем на C(85, 1) = 85, поскольку C(n, k) - C(n - 1, k) = C(n - 1, k - 1). Второе число — не более чем на C(14, 1) = 14. Далее можно применять данную оценку аналогично. Для всех возможных k данный алгоритм укладывается в 90 вершин. Может быть есть что-то более красивое, но вообще на контесте можно было остановиться пункте на пятом и забить. 232B - ТаблицаИдея: tunyash, Skird Реализация: tunyash Разбор: tunyash Пусть si — количество точек в столбце i. На картинке изображены два соседних квадрата n × n, A — количество вершин в левой части рисунка (это один столбец), B — количество точек в средней области и C — количество точек в правой области (это тоже один столбец). По условию, имеем: Следовательно A = C. Таким образом Разделим столбцы на классы эквивалентности по признаку . Для всех a и b из одного класса sa = sb. cnta — количество столбцов в классе с . Существует (Cnk)cnta способов нарисовать по x точек в каждом из столбцов этого класса независимо от других классов. dp[i][j] — количество способов заполнить классы 1, ... i таким образом, что . cnti принимает и . Посчитаем (Cna)cnti для всех a и cnti и будем использовать при подсчете дп. Получаем сложность O(n2·k). 232C - Графы ДоуИдея: tunyash, Gerald Реализация: tunyash, Gerald Разбор: tunyashБудем рекурсивно разворачивать граф, сводя задачу к поиску кратч. пути в графаз меньших порядков. Заметим, что вершина |D(n - 1)| + 1 — точка сочленения (кроме случаев n ≤ 2, но для них описанные ниже равенства так же выполняются). Тогда, если вершины находятся по разные стороны от нее, то путь обязательно через нее проходит. Пусть dist(a, b, n) — длина кратчайшего пути между a и b в графе порядка n. dist(a, b, n) = min(dist(a, |D(n - 1)|, n - 1), dist(a, 1, n - 1)) + dist(b - |D(n - 1)|, 1, n - 2) + 1Красным обозначены ребра, синим — пути. Записанная формула обозначает, что мы можем пойти из вершины a по пути 1 в вершину 1, затем по прямому ребру в вершину |D(n - 1)| + 1 и по пути 3 в вершину b, либо пойти по пути 2, попасть в вершину |D(n - 1)|, пройти по ребру в вершину |D(n - 1)| + 1, а затем по пути 3 в вершину b. Если обе вершины лежат в меньшей половине графа — то dist(a, b, n) = dist(a - |D(n - 1)|, b - |D(n - 1)|, n - 2)Если они лежат в большей половине, то нужно дополнительно разобрать случай прохождения пути через точку сочленения, то есть dist(a, b, n) = min(dist(a, b, n - 1), min(dist(1, a, n - 1), dist(|D(n - 1)|, a, n - 1)) + min(dist(1, b, n - 1), dist(|D(n - 1)|, b, n - 1) + 2)Если искомый путь проходит через точку сочленения, то для каждой вершины мы можем пройти либо в вершину 1, либо в вершину |D(n - 1)| + 1, а затем по прямому ребру в вершину |D(n - 1)| + 1. Если путь не проходит через точку сочленения, то рассмотрим его в графе меньшего порядка.Можно заметить, что для каждого k будет не более 4 различных запусков dist(i, j, n).Как это понять? Во первых, если отбросить запросы, где либо a = 1, либо b = |D(n)|, все запросы получаются из первого последовательным отнятием от изначальной пары (ai, bi) одинаковых чисел Фибоначчи (по построению D(i) — числа Фибоначчи). Получается, таких запросов будет O(n). Запросы вида (1, a) и (a, |D(n)|) можно рассмотреть отдельно, они хорошо выражаются из самих себя. Учитывая то, что все другие запросы получаются друг из друга прибавлением или отнятием чисел Фибоначчи, запросы этого вида тоже будут получаться друг из друга таким образом. Таким образом, у нас будет не более O(1) серий по O(n) запросов. Это не совсем строго, но, вроде, понятно. Это довольно нетривиальный момент, рекомендую задавать вопросы, если непонятно.Получим асимптотику на запрос (логарифм возникает из соображения о том, что размеры графов в зависимости от порядка растут экспоненциально). Важно было запускать алгоритм не для данного n, а для наименьшего n, такого, что max(a, b) ≤ D(n - 1)232D - ЗаборИдея: tunyash, Gerald Реализация: fdoer Разбор: fdoerВ разборе этой задачи подразумевается, что читатель имеет представление о суффиксных массивах и о быстром нахождении lcp (наибольшего общего префикса) двух суффиксов строки. Об этом можно почитать, например, на e-maxx.ru.Итак, пусть d и d' — массивы такие, что di = hi - hi + 1, d'i =  - di для любого 1 ≤ i ≤ (n - 1). Тогда мы можем переформулировать условие, при котором два куска забора считаются подходящими, следующим образом: куски не пересекаются, то есть, нет ни одной доски, такой, что она содержится в обоих кусках забора; куски имеют одинаковую ширину; для любого i (0 ≤ i ≤ r1 - l1 - 1) выполняется dl1 + i = d'l2 + i (если ширина забора — 1, это выполняется всегда). Отсюда возникает следующая идея: для ответа на запрос нам достаточно узнать, сколько подотрезков массива d' длины (r - l) совпадают с отрезком массива d, соответствующим этому запросу, и при этом не пересекаются с ним ни в каком индексе. Построим суффиксный массив sa на последовательности-конкатенации массивов d и d', между которыми поставим еще разделитель — число, которого ни в одном из этих массивов нет. Запомним также для каждого суффикса di его позицию posi в суффиксном массиве. При поступлении нового запроса на отрезке l...r все куски забора, подходящие по второму и третьему условиям, будут началами суффиксов, лежащих в суффиксном массиве подряд на позициях boundleft...boundright, причем boundleft ≤ posl ≤ boundright и lcp(boundleft...boundright) ≥ (r - l). Поэтому границы этого отрезка можно найти с помощью бинарного поиска. В зависимости от реализации функции lcp для отрезка значения bound мы определим за или за . Теперь осталось найти число позиций из saboundleft...boundright, удовлетворяющих еще и первому условию, т.е. таких, которые соответствуют суффиксам d', префикс длины r - l которых не пересекается по индексам с отрезком (l...r - 1). Иными словами, количество i (boundleft ≤ i ≤ boundright) таких, что либо n + 1 ≤ sai ≤ n + l - (r - l) - 1, либо sai ≥ n + r (суффиксы d' начинаются в конкатенации с позиции n + 1, т.к. в массиве d (n - 1) элемент, а на n-ном месте расположен разделитель). Это тоже классическая задача поиска количества чисел из заданного диапазона на заданном отрезке массива, она может быть решена за на запрос. Её можно решать, например, offline с помощью метода scanline и любой структуры данных, поддерживающей запросы суммы на отрезке и увеличения в точке, либо online с помощью персистентных/двумерных структур вроде дерева отрезков.Таким образом, вкратце алгоритм выглядит примерно так: построение массивов d и d'. Построение на конкатенации суффиксного массива. препроцессинг для вычисления lcp на отрезке Для каждого запроса: определение промежутка (boundleft...boundright) с помощью двух бинарных поисков, обращающихся к lcp на отрезке. запрос на число суффиксов, которые лежат в суффиксном массиве на этом промежутке и которые соответствуют подотрезкам, не пересекающимся с отрезком запроса. Если массив строить за , запрос lcp выполнять за O(1) с предподсчетом за (с RMQ на разреженных таблицах), а числа из диапазона искать за на запрос, итоговая асимптотика получается . Однако решения, выполняющие запрос lcp за логарифм с использованием, например, дерева отрезков, тоже укладывались в ограничения.232E - Быстрая Черепаха Идея: tunyash Реализация: tunyash, KAN Разбор: tunyashВыберем центральный столбец на поле. Посчитаем для каждой клетки слева доступные на столбце, для каждой клетки справа те из которых доступна данная. Это простая динамика с битсетами, она полностью аналогична динамике в классической задачи о черепашке, для правой половины доски. ( — логическое или, в данном случае имеется в виду побитовое или для масок) для левой. Динамика считаем маску доступных клеток на центральном столбце.С помощью этих данных мы получим ответы на все запросы, точки которых лежат по разные стороны от выбранного столбца за n/32 на запрос (просто сделаем and битсетов). На картинке кружочками обведены две клетки, через которые может проходить путь между точками запроса. Далее запустимся от двух половинок доски, выполняя тот же алгоритм. Получается время работы . Запросы можно выполнять онлайн, храня для каждой клетки битсетов — множеств доступных клеток на столбцах, выбираемых центральными.Альтернативное решение от mrNobody. Оно оказалось быстрее и проще авторского, но, к сожалению, он не смог сдать его на контесте. Будем считать динамику range[i][j][k] — самую верхнюю и самую нижнюю клетку столбца k, доступную из клетки (i, j). Ее можно считать аналогично динамике из авторского решения. Кроме того посчитаем динамику able[i][j][k] — доступна ли хотя бы одна клетка столбца k из клетки (i, j) при движении влево и вверх. Обе эти динамики можно посчитать за O(n·m2) времени и памяти (потом будет понятно, что на памяти можно сэкономить). Рассмотрим запрос (x1, y1) (x2, y2). Утверждается, что путь из (x1, y1) (x2, y2) существует тогда и только тогда, когда и верно able[x2][y2][y1]. Действительно, рассмотрим три пути. 1 — из (x1, y1) в самую верхнюю доступную клетку столбца y2. 2 — из (x1, y1) в самую нижнюю доступную клетку столбца y2 и 3 — из (x2, y2) в одну из клеток столбца y1. Если эта клетка расположена ниже (x1, y1), то путь 3 пересекает путь 2, а значит мы можем пройти по пути два до точки пересечения, а затем по пути 3 до точки (x2, y2). Случай пересечения путей 1 и 3 аналогичен. Мы получили решение за O(n·m2 + q) времени и такое же количество памяти, однако можно заметить, что хранить все состояния динамики не обязательно, достаточно только q из них. Пользуясь этим, можно сократить используемую память до O(nm + q).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 232\\s*B"
          },
          "content_length": 12233
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #144 - Codeforces - Code 1",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 2",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 3",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 4",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 5",
          "code": "Интересно, а против моего рандомного решения есть контртесты??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\nuint64_t sum(uint64_t x)\n{\n\tuint64_t k,s1,s=0;\n\tk=x;\n\twhile (k>0){\n\t\ts1=k%10;\n\t\tk-=s1;\n\t\ts+=s1;\n\t\tk/=10;\n\t}\n\treturn s;\n}\nint main()\n{\n\tint i;\n\tdouble t;\n\tuint64_t n,z=0,x=1;\n\tscanf(\"%I64d\",&n);\n\tfor (i=1;i<91;i++){\n\t\tt=i*i+4*n;\n\t\tt=sqrt(t);\n\t\tt=t-i;\n\t\tt/=2;\n\t\tif(t-(int)t==0 && (t*t+sum(t)*t-n==0)) {z=1;break;} \n\t}\n\t\n\tif (z)printf(\"%d\\n\",(int)t); else printf(\"-1\");\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\nuint64_t sum(uint64_t x)\n{\n\tuint64_t k,s1,s=0;\n\tk=x;\n\twhile (k>0){\n\t\ts1=k%10;\n\t\tk-=s1;\n\t\ts+=s1;\n\t\tk/=10;\n\t}\n\treturn s;\n}\nint main()\n{\n\tint i;\n\tdouble t;\n\tuint64_t n,z=0,x=1;\n\tscanf(\"%I64d\",&n);\n\tfor (i=1;i<91;i++){\n\t\tt=i*i+4*n;\n\t\tt=sqrt(t);\n\t\tt=t-i;\n\t\tt/=2;\n\t\tif(t-(int)t==0 && (t*t+sum(t)*t-n==0)) {z=1;break;} \n\t}\n\t\n\tif (z)printf(\"%d\\n\",(int)t); else printf(\"-1\");\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 3",
          "code": "fabs(expr) <= eps",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 4",
          "code": "int x = sqrt(i*i+4*n) + 0.5;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong((long long)n, 1000000000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong((long long)n, 1000000000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong((long long)n, 1000000000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n\n    int n = opt<int>(\"n\", -1);\n    long long m = opt<long long>(\"m\", -1LL);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Set default ranges if variables are to be generated\n    const int N_MIN = 1, N_MAX = 100;\n    const long long M_MAX = 1000000000000000000LL; // 1e18\n\n    if (type == \"min\") {\n        n = N_MIN;\n        m = n;\n        k = 0;\n    } else if (type == \"max\") {\n        n = N_MAX;\n        m = M_MAX;\n        k = n * n;\n    } else if (type == \"small_n\") {\n        n = N_MIN;\n        m = rnd.next((long long)n, M_MAX);\n        k = rnd.next(0, n * n);\n    } else if (type == \"large_n\") {\n        n = N_MAX;\n        m = rnd.next((long long)n, M_MAX);\n        k = rnd.next(0, n * n);\n    } else if (type == \"k_zero\") {\n        n = n != -1 ? n : rnd.next(N_MIN, N_MAX);\n        m = m != -1 ? m : rnd.next((long long)n, M_MAX);\n        k = 0;\n    } else if (type == \"k_max\") {\n        n = n != -1 ? n : rnd.next(N_MIN, N_MAX);\n        m = m != -1 ? m : rnd.next((long long)n, M_MAX);\n        k = n * n;\n    } else if (type == \"large_m\") {\n        n = n != -1 ? n : rnd.next(N_MIN, N_MAX);\n        m = M_MAX;\n        k = k != -1 ? k : rnd.next(0, n * n);\n    } else if (type == \"small_m\") {\n        n = n != -1 ? n : rnd.next(N_MIN, N_MAX);\n        m = (long long)n;\n        k = k != -1 ? k : rnd.next(0, n * n);\n    } else { // custom or random\n        if (n == -1)\n            n = rnd.next(N_MIN, N_MAX);\n        else\n            n = max(N_MIN, min(n, N_MAX));\n        if (m == -1)\n            m = rnd.next((long long)n, M_MAX);\n        else\n            m = max((long long)n, min(m, M_MAX));\n        if (k == -1)\n            k = rnd.next(0, n * n);\n        else\n            k = max(0, min(k, n * n));\n    }\n\n    // Ensure n ∈ [N_MIN, N_MAX]\n    n = max(N_MIN, min(n, N_MAX));\n\n    // Ensure m ≥ n and m ≤ M_MAX\n    m = max((long long)n, min(m, M_MAX));\n\n    // Ensure k ∈ [0, n^2]\n    k = max(0, min(k, n * n));\n\n    printf(\"%d %lld %d\\n\", n, m, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n\n    int n = opt<int>(\"n\", -1);\n    long long m = opt<long long>(\"m\", -1LL);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Set default ranges if variables are to be generated\n    const int N_MIN = 1, N_MAX = 100;\n    const long long M_MAX = 1000000000000000000LL; // 1e18\n\n    if (type == \"min\") {\n        n = N_MIN;\n        m = n;\n        k = 0;\n    } else if (type == \"max\") {\n        n = N_MAX;\n        m = M_MAX;\n        k = n * n;\n    } else if (type == \"small_n\") {\n        n = N_MIN;\n        m = rnd.next((long long)n, M_MAX);\n        k = rnd.next(0, n * n);\n    } else if (type == \"large_n\") {\n        n = N_MAX;\n        m = rnd.next((long long)n, M_MAX);\n        k = rnd.next(0, n * n);\n    } else if (type == \"k_zero\") {\n        n = n != -1 ? n : rnd.next(N_MIN, N_MAX);\n        m = m != -1 ? m : rnd.next((long long)n, M_MAX);\n        k = 0;\n    } else if (type == \"k_max\") {\n        n = n != -1 ? n : rnd.next(N_MIN, N_MAX);\n        m = m != -1 ? m : rnd.next((long long)n, M_MAX);\n        k = n * n;\n    } else if (type == \"large_m\") {\n        n = n != -1 ? n : rnd.next(N_MIN, N_MAX);\n        m = M_MAX;\n        k = k != -1 ? k : rnd.next(0, n * n);\n    } else if (type == \"small_m\") {\n        n = n != -1 ? n : rnd.next(N_MIN, N_MAX);\n        m = (long long)n;\n        k = k != -1 ? k : rnd.next(0, n * n);\n    } else { // custom or random\n        if (n == -1)\n            n = rnd.next(N_MIN, N_MAX);\n        else\n            n = max(N_MIN, min(n, N_MAX));\n        if (m == -1)\n            m = rnd.next((long long)n, M_MAX);\n        else\n            m = max((long long)n, min(m, M_MAX));\n        if (k == -1)\n            k = rnd.next(0, n * n);\n        else\n            k = max(0, min(k, n * n));\n    }\n\n    // Ensure n ∈ [N_MIN, N_MAX]\n    n = max(N_MIN, min(n, N_MAX));\n\n    // Ensure m ≥ n and m ≤ M_MAX\n    m = max((long long)n, min(m, M_MAX));\n\n    // Ensure k ∈ [0, n^2]\n    k = max(0, min(k, n * n));\n\n    printf(\"%d %lld %d\\n\", n, m, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal case\n./gen -type min\n\n# Maximal case\n./gen -type max\n\n# Random values\n./gen -type random\n\n# Small n\n./gen -type small_n\n\n# Large n\n./gen -type large_n\n\n# Small m\n./gen -type small_m\n\n# Large m\n./gen -type large_m\n\n# k equals 0\n./gen -type k_zero\n\n# k equals n^2\n./gen -type k_max\n\n# k is half of n^2\n./gen -n 50 -k 1250 -type custom\n\n# m just bigger than n\n./gen -n 100 -m 101 -type custom\n\n# m equals n\n./gen -n 100 -m 100 -type custom\n\n# m is maximum\n./gen -n 1 -m 1000000000000000000 -type custom\n\n# n is minimum\n./gen -n 1 -m 1 -k 0 -type custom\n\n# Random with fixed n\n./gen -n 50 -type random\n\n# Random with fixed m\n./gen -m 1000000000000000000 -type random\n\n# Random with fixed k\n./gen -k 100 -type random\n\n# Random with n and m at maximum\n./gen -n 100 -m 1000000000000000000 -type random\n\n# Random with n and k at maximum\n./gen -n 100 -k 10000 -type random\n\n# Random with m minimal\n./gen -m 100 -type random\n\n# Random with n minimal\n./gen -n 1 -type random\n\n# Edge case with k equals n^2\n./gen -n 10 -k 100 -type custom\n\n# Edge case with k equals 0\n./gen -n 100 -k 0 -type custom\n\n# Very large m, small n\n./gen -n 2 -m 1000000000000000000 -type custom\n\n# Very large n, large m, k = n^2 / 2\n./gen -n 100 -m 1000000000000000000 -k 5000 -type custom\n\n# Medium values\n./gen -n 50 -m 100000 -k 2500 -type custom\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:02.658250",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "232/C",
      "title": "C. Графы Доу",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа t и n (1 ≤ t ≤ 105; 1 ≤ n ≤ 103) — количество запросов и порядок рассматриваемого графа. В i-той из следующих t строк записано два целых числа ai и bi (1 ≤ ai, bi ≤ 1016, ai ≠ bi) — номера двух вершин в i-м запросе. Гарантируется, что ai, bi ≤ |D(n)|.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеДля каждого запроса выведите в отдельной строке единственное целое число — длину кратчайшего пути между вершинами ai и bi. Ответы на запросы выводите в том порядке, в котором запросы заданы во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 51 21 31 41 52 32 42 53 43 54 5Выходные данныеСкопировать1112123121",
      "description": "C. Графы Доу\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа t и n (1 ≤ t ≤ 105; 1 ≤ n ≤ 103) — количество запросов и порядок рассматриваемого графа. В i-той из следующих t строк записано два целых числа ai и bi (1 ≤ ai, bi ≤ 1016, ai ≠ bi) — номера двух вершин в i-м запросе. Гарантируется, что ai, bi ≤ |D(n)|.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеДля каждого запроса выведите в отдельной строке единственное целое число — длину кратчайшего пути между вершинами ai и bi. Ответы на запросы выводите в том порядке, в котором запросы заданы во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать10 51 21 31 41 52 32 42 53 43 54 5Выходные данныеСкопировать1112123121\n\nВходные данныеСкопировать10 51 21 31 41 52 32 42 53 43 54 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1112123121\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #144 - Codeforces",
          "content": "Всем привет! Сегодня состоится очередной codeforces-round. Он пройдет в обоих дивизионах, в каждом из которых будет предложено пять задач разной сложности.В его подготовке, принимало участие несколько человек: KAN, fdoer, Skird, tunyash. Огромное спасибо Gerald, за координацию подготовки задач, множество клевых идей и понятизацию условий. Так же благодарю MikeMirzayanov за отличную систему подготовки задач, Delinur за перевод условий. Надеюсь, все пройдет гладко и вам понравятся задачи. Про разбалловку вы узнаете перед контестом.Удачи!UPD: разбалловка стандартная (500-1000-1500-2000-2500) в обоих дивизионах.UPD: появился очень кратенький разборUPD:Поздравляю победителей! div1: tourist rng_58 Mimino Dmitry_Egorov, Egor div2: debug22 ryz dvdreddy vinodreddy rdivyanshu UPD: есть полный разбор на русском.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5510",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 812
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces",
          "content": "Задачи, которые не успели написать, разберу кратко. Задавайте вопросы.233A - Идеальная перестановкаИдея: Gerald Реализация: tunyash Разбор: fdoerЭту задачу можно было решать разными способами, например, таким: рассмотрим перестановку p, в которой pi = i, то есть просто последовательность чисел от 1 до n. Очевидно, для неё условие ppi = i выполняется всегда. Осталось только преобразовать её таким образом, чтобы выполнялось и второе условие: pi ≠ i. Для этого поменяем местами каждые два соседних элемента, т.е. для каждого k: k * 2 ≤ n поменяем местами значения p2k - 1 и p2k. Нетрудно убедиться, что для полученной перестановки оба условия выполняются всегда.233B - Неквадратное уравнениеИдея: tunyash Реализация: tunyash, Gerald Разбор: fdoerДля начала найдем диапазон значений, которые может принимать s(x). Так как из уравнения x2 ≤ n, а по условию n ≤ 1018, x ≤ 109, иначе говоря, десятичная запись любого решения не длиннее 10 цифр. Значит, максимальное значение smax = s(9999999999) = 10·9 = 90 (на самом деле это грубая оценка, smax даже меньше, но нам достаточно и её).Переберем значение s(x): 0 ≤ s(x) ≤ 90. Получаем обычное квадратное уравнение относительно переменной x. Осталось решить его и проверить равенство того значения s(x), что мы зафиксировали, сумме цифр в разрядах полученного корня. Если корень нашелся и равенство выполнено, обновим ответ.Пожалуй, самое важное в этой задаче — аккуратно и без ошибок вычислений считать дискриминант.Подчеркну, что для решения задач div2.A и div2.B не требовалось знание массивов.232A - Циклы Идея: tunyash, fdoer Реализация: tunyash Разбор: tunyashБудем добавлять ребра в порядке сортировки сначала по вершине в меньшим номером, затем с большим (просто два for'a). Если добавление ребра вызывает переполнение кол-ва циклов, не добавляем его. Считать количество циклов, которые добавятся можно за O(n) (могут появиться только циклы, содержащие добавленное ребро, следовательно достаточно перебрать третью вершину). Очевидно, что это найдет какой-то ответ, потому что, добавив два ребра из вершины мы всегда можем получить 1 треугольник. Тогда получается, что ответ всегда есть. Можно довольно просто доказать, что мы уложимся в 100. Асимптотика решения O(n3).Доказательство Первыми несколькими шагами алгоритма мы сгенерируем полный граф. Потому что каждое ребро можно будет добавить Полученное количество треугольников — C(p, 3) для какого-то p. C(p, 3) ≤ k при этом p максимально. Для данных ограничений p ≤ 85. После первой фазы алгоритма, если из некоторой вершины мы добавляем u ребер, то количество треугольников увеличивается на C(u, 2). Получается, мы представляем маленькое число  ≤ C(85, 2) в виде суммы C(i, 2). Первое число, которое мы вычтем, будет отличаться от нашего не более чем на C(85, 1) = 85, поскольку C(n, k) - C(n - 1, k) = C(n - 1, k - 1). Второе число — не более чем на C(14, 1) = 14. Далее можно применять данную оценку аналогично. Для всех возможных k данный алгоритм укладывается в 90 вершин. Может быть есть что-то более красивое, но вообще на контесте можно было остановиться пункте на пятом и забить. 232B - ТаблицаИдея: tunyash, Skird Реализация: tunyash Разбор: tunyash Пусть si — количество точек в столбце i. На картинке изображены два соседних квадрата n × n, A — количество вершин в левой части рисунка (это один столбец), B — количество точек в средней области и C — количество точек в правой области (это тоже один столбец). По условию, имеем: Следовательно A = C. Таким образом Разделим столбцы на классы эквивалентности по признаку . Для всех a и b из одного класса sa = sb. cnta — количество столбцов в классе с . Существует (Cnk)cnta способов нарисовать по x точек в каждом из столбцов этого класса независимо от других классов. dp[i][j] — количество способов заполнить классы 1, ... i таким образом, что . cnti принимает и . Посчитаем (Cna)cnti для всех a и cnti и будем использовать при подсчете дп. Получаем сложность O(n2·k). 232C - Графы ДоуИдея: tunyash, Gerald Реализация: tunyash, Gerald Разбор: tunyashБудем рекурсивно разворачивать граф, сводя задачу к поиску кратч. пути в графаз меньших порядков. Заметим, что вершина |D(n - 1)| + 1 — точка сочленения (кроме случаев n ≤ 2, но для них описанные ниже равенства так же выполняются). Тогда, если вершины находятся по разные стороны от нее, то путь обязательно через нее проходит. Пусть dist(a, b, n) — длина кратчайшего пути между a и b в графе порядка n. dist(a, b, n) = min(dist(a, |D(n - 1)|, n - 1), dist(a, 1, n - 1)) + dist(b - |D(n - 1)|, 1, n - 2) + 1Красным обозначены ребра, синим — пути. Записанная формула обозначает, что мы можем пойти из вершины a по пути 1 в вершину 1, затем по прямому ребру в вершину |D(n - 1)| + 1 и по пути 3 в вершину b, либо пойти по пути 2, попасть в вершину |D(n - 1)|, пройти по ребру в вершину |D(n - 1)| + 1, а затем по пути 3 в вершину b. Если обе вершины лежат в меньшей половине графа — то dist(a, b, n) = dist(a - |D(n - 1)|, b - |D(n - 1)|, n - 2)Если они лежат в большей половине, то нужно дополнительно разобрать случай прохождения пути через точку сочленения, то есть dist(a, b, n) = min(dist(a, b, n - 1), min(dist(1, a, n - 1), dist(|D(n - 1)|, a, n - 1)) + min(dist(1, b, n - 1), dist(|D(n - 1)|, b, n - 1) + 2)Если искомый путь проходит через точку сочленения, то для каждой вершины мы можем пройти либо в вершину 1, либо в вершину |D(n - 1)| + 1, а затем по прямому ребру в вершину |D(n - 1)| + 1. Если путь не проходит через точку сочленения, то рассмотрим его в графе меньшего порядка.Можно заметить, что для каждого k будет не более 4 различных запусков dist(i, j, n).Как это понять? Во первых, если отбросить запросы, где либо a = 1, либо b = |D(n)|, все запросы получаются из первого последовательным отнятием от изначальной пары (ai, bi) одинаковых чисел Фибоначчи (по построению D(i) — числа Фибоначчи). Получается, таких запросов будет O(n). Запросы вида (1, a) и (a, |D(n)|) можно рассмотреть отдельно, они хорошо выражаются из самих себя. Учитывая то, что все другие запросы получаются друг из друга прибавлением или отнятием чисел Фибоначчи, запросы этого вида тоже будут получаться друг из друга таким образом. Таким образом, у нас будет не более O(1) серий по O(n) запросов. Это не совсем строго, но, вроде, понятно. Это довольно нетривиальный момент, рекомендую задавать вопросы, если непонятно.Получим асимптотику на запрос (логарифм возникает из соображения о том, что размеры графов в зависимости от порядка растут экспоненциально). Важно было запускать алгоритм не для данного n, а для наименьшего n, такого, что max(a, b) ≤ D(n - 1)232D - ЗаборИдея: tunyash, Gerald Реализация: fdoer Разбор: fdoerВ разборе этой задачи подразумевается, что читатель имеет представление о суффиксных массивах и о быстром нахождении lcp (наибольшего общего префикса) двух суффиксов строки. Об этом можно почитать, например, на e-maxx.ru.Итак, пусть d и d' — массивы такие, что di = hi - hi + 1, d'i =  - di для любого 1 ≤ i ≤ (n - 1). Тогда мы можем переформулировать условие, при котором два куска забора считаются подходящими, следующим образом: куски не пересекаются, то есть, нет ни одной доски, такой, что она содержится в обоих кусках забора; куски имеют одинаковую ширину; для любого i (0 ≤ i ≤ r1 - l1 - 1) выполняется dl1 + i = d'l2 + i (если ширина забора — 1, это выполняется всегда). Отсюда возникает следующая идея: для ответа на запрос нам достаточно узнать, сколько подотрезков массива d' длины (r - l) совпадают с отрезком массива d, соответствующим этому запросу, и при этом не пересекаются с ним ни в каком индексе. Построим суффиксный массив sa на последовательности-конкатенации массивов d и d', между которыми поставим еще разделитель — число, которого ни в одном из этих массивов нет. Запомним также для каждого суффикса di его позицию posi в суффиксном массиве. При поступлении нового запроса на отрезке l...r все куски забора, подходящие по второму и третьему условиям, будут началами суффиксов, лежащих в суффиксном массиве подряд на позициях boundleft...boundright, причем boundleft ≤ posl ≤ boundright и lcp(boundleft...boundright) ≥ (r - l). Поэтому границы этого отрезка можно найти с помощью бинарного поиска. В зависимости от реализации функции lcp для отрезка значения bound мы определим за или за . Теперь осталось найти число позиций из saboundleft...boundright, удовлетворяющих еще и первому условию, т.е. таких, которые соответствуют суффиксам d', префикс длины r - l которых не пересекается по индексам с отрезком (l...r - 1). Иными словами, количество i (boundleft ≤ i ≤ boundright) таких, что либо n + 1 ≤ sai ≤ n + l - (r - l) - 1, либо sai ≥ n + r (суффиксы d' начинаются в конкатенации с позиции n + 1, т.к. в массиве d (n - 1) элемент, а на n-ном месте расположен разделитель). Это тоже классическая задача поиска количества чисел из заданного диапазона на заданном отрезке массива, она может быть решена за на запрос. Её можно решать, например, offline с помощью метода scanline и любой структуры данных, поддерживающей запросы суммы на отрезке и увеличения в точке, либо online с помощью персистентных/двумерных структур вроде дерева отрезков.Таким образом, вкратце алгоритм выглядит примерно так: построение массивов d и d'. Построение на конкатенации суффиксного массива. препроцессинг для вычисления lcp на отрезке Для каждого запроса: определение промежутка (boundleft...boundright) с помощью двух бинарных поисков, обращающихся к lcp на отрезке. запрос на число суффиксов, которые лежат в суффиксном массиве на этом промежутке и которые соответствуют подотрезкам, не пересекающимся с отрезком запроса. Если массив строить за , запрос lcp выполнять за O(1) с предподсчетом за (с RMQ на разреженных таблицах), а числа из диапазона искать за на запрос, итоговая асимптотика получается . Однако решения, выполняющие запрос lcp за логарифм с использованием, например, дерева отрезков, тоже укладывались в ограничения.232E - Быстрая Черепаха Идея: tunyash Реализация: tunyash, KAN Разбор: tunyashВыберем центральный столбец на поле. Посчитаем для каждой клетки слева доступные на столбце, для каждой клетки справа те из которых доступна данная. Это простая динамика с битсетами, она полностью аналогична динамике в классической задачи о черепашке, для правой половины доски. ( — логическое или, в данном случае имеется в виду побитовое или для масок) для левой. Динамика считаем маску доступных клеток на центральном столбце.С помощью этих данных мы получим ответы на все запросы, точки которых лежат по разные стороны от выбранного столбца за n/32 на запрос (просто сделаем and битсетов). На картинке кружочками обведены две клетки, через которые может проходить путь между точками запроса. Далее запустимся от двух половинок доски, выполняя тот же алгоритм. Получается время работы . Запросы можно выполнять онлайн, храня для каждой клетки битсетов — множеств доступных клеток на столбцах, выбираемых центральными.Альтернативное решение от mrNobody. Оно оказалось быстрее и проще авторского, но, к сожалению, он не смог сдать его на контесте. Будем считать динамику range[i][j][k] — самую верхнюю и самую нижнюю клетку столбца k, доступную из клетки (i, j). Ее можно считать аналогично динамике из авторского решения. Кроме того посчитаем динамику able[i][j][k] — доступна ли хотя бы одна клетка столбца k из клетки (i, j) при движении влево и вверх. Обе эти динамики можно посчитать за O(n·m2) времени и памяти (потом будет понятно, что на памяти можно сэкономить). Рассмотрим запрос (x1, y1) (x2, y2). Утверждается, что путь из (x1, y1) (x2, y2) существует тогда и только тогда, когда и верно able[x2][y2][y1]. Действительно, рассмотрим три пути. 1 — из (x1, y1) в самую верхнюю доступную клетку столбца y2. 2 — из (x1, y1) в самую нижнюю доступную клетку столбца y2 и 3 — из (x2, y2) в одну из клеток столбца y1. Если эта клетка расположена ниже (x1, y1), то путь 3 пересекает путь 2, а значит мы можем пройти по пути два до точки пересечения, а затем по пути 3 до точки (x2, y2). Случай пересечения путей 1 и 3 аналогичен. Мы получили решение за O(n·m2 + q) времени и такое же количество памяти, однако можно заметить, что хранить все состояния динамики не обязательно, достаточно только q из них. Пользуясь этим, можно сократить используемую память до O(nm + q).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 232\\s*C"
          },
          "content_length": 12233
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #144 - Codeforces - Code 1",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 2",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 3",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 4",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 5",
          "code": "Интересно, а против моего рандомного решения есть контртесты??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\nuint64_t sum(uint64_t x)\n{\n\tuint64_t k,s1,s=0;\n\tk=x;\n\twhile (k>0){\n\t\ts1=k%10;\n\t\tk-=s1;\n\t\ts+=s1;\n\t\tk/=10;\n\t}\n\treturn s;\n}\nint main()\n{\n\tint i;\n\tdouble t;\n\tuint64_t n,z=0,x=1;\n\tscanf(\"%I64d\",&n);\n\tfor (i=1;i<91;i++){\n\t\tt=i*i+4*n;\n\t\tt=sqrt(t);\n\t\tt=t-i;\n\t\tt/=2;\n\t\tif(t-(int)t==0 && (t*t+sum(t)*t-n==0)) {z=1;break;} \n\t}\n\t\n\tif (z)printf(\"%d\\n\",(int)t); else printf(\"-1\");\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\nuint64_t sum(uint64_t x)\n{\n\tuint64_t k,s1,s=0;\n\tk=x;\n\twhile (k>0){\n\t\ts1=k%10;\n\t\tk-=s1;\n\t\ts+=s1;\n\t\tk/=10;\n\t}\n\treturn s;\n}\nint main()\n{\n\tint i;\n\tdouble t;\n\tuint64_t n,z=0,x=1;\n\tscanf(\"%I64d\",&n);\n\tfor (i=1;i<91;i++){\n\t\tt=i*i+4*n;\n\t\tt=sqrt(t);\n\t\tt=t-i;\n\t\tt/=2;\n\t\tif(t-(int)t==0 && (t*t+sum(t)*t-n==0)) {z=1;break;} \n\t}\n\t\n\tif (z)printf(\"%d\\n\",(int)t); else printf(\"-1\");\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 3",
          "code": "fabs(expr) <= eps",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 4",
          "code": "int x = sqrt(i*i+4*n) + 0.5;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <vector>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read t and n\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    // Compute |D(n)| if necessary\n    const int MaxFibIndex = 93; // Fib(93) can be stored in uint64_t\n    unsigned long long DnSize = 0; // To store |D(n)| when n <= MaxFibIndex - 1\n\n    if (n <= MaxFibIndex - 1) { // Since we need Fib(n+1)\n        vector<unsigned long long> Fib(n + 2);\n        Fib[0] = 0;\n        Fib[1] = 1;\n        for (int i = 2; i <= n + 1; i++) {\n            Fib[i] = Fib[i - 1] + Fib[i - 2];\n        }\n        DnSize = Fib[n + 1];\n        // Now DnSize is |D(n)| = Fib(n + 1)\n    } else {\n        // For n >= MaxFibIndex - 1\n        // |D(n)| exceeds uint64_t capacity, but since ai, bi ≤ 1e16, and |D(n)| >> 1e16\n        // ai, bi ≤ |D(n)| holds\n    }\n\n    const long long maxAiBi = 10000000000000000LL; // 1e16 as per constraints\n\n    for (int i = 0; i < t; i++) {\n        // Read ai and bi\n        long long ai = inf.readLong(1LL, maxAiBi, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1LL, maxAiBi, \"bi\"); // Ensure ai, bi ≤ 1e16\n\n        ensuref(ai != bi, \"ai and bi must be different, but both are %lld\", ai);\n\n        if (DnSize != 0) {\n            // For n ≤ MaxFibIndex - 1, ensure ai, bi ≤ |D(n)|\n            ensuref(ai <= (long long)DnSize, \"ai must be ≤ |D(n)|=%llu, but ai=%lld\", DnSize, ai);\n            ensuref(bi <= (long long)DnSize, \"bi must be ≤ |D(n)|=%llu, but bi=%lld\", DnSize, bi);\n        }\n        // For n ≥ MaxFibIndex - 1, since |D(n)| >> 1e16, ai, bi ≤ |D(n)|\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <vector>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read t and n\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    // Compute |D(n)| if necessary\n    const int MaxFibIndex = 93; // Fib(93) can be stored in uint64_t\n    unsigned long long DnSize = 0; // To store |D(n)| when n <= MaxFibIndex - 1\n\n    if (n <= MaxFibIndex - 1) { // Since we need Fib(n+1)\n        vector<unsigned long long> Fib(n + 2);\n        Fib[0] = 0;\n        Fib[1] = 1;\n        for (int i = 2; i <= n + 1; i++) {\n            Fib[i] = Fib[i - 1] + Fib[i - 2];\n        }\n        DnSize = Fib[n + 1];\n        // Now DnSize is |D(n)| = Fib(n + 1)\n    } else {\n        // For n >= MaxFibIndex - 1\n        // |D(n)| exceeds uint64_t capacity, but since ai, bi ≤ 1e16, and |D(n)| >> 1e16\n        // ai, bi ≤ |D(n)| holds\n    }\n\n    const long long maxAiBi = 10000000000000000LL; // 1e16 as per constraints\n\n    for (int i = 0; i < t; i++) {\n        // Read ai and bi\n        long long ai = inf.readLong(1LL, maxAiBi, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1LL, maxAiBi, \"bi\"); // Ensure ai, bi ≤ 1e16\n\n        ensuref(ai != bi, \"ai and bi must be different, but both are %lld\", ai);\n\n        if (DnSize != 0) {\n            // For n ≤ MaxFibIndex - 1, ensure ai, bi ≤ |D(n)|\n            ensuref(ai <= (long long)DnSize, \"ai must be ≤ |D(n)|=%llu, but ai=%lld\", DnSize, ai);\n            ensuref(bi <= (long long)DnSize, \"bi must be ≤ |D(n)|=%llu, but bi=%lld\", DnSize, bi);\n        }\n        // For n ≥ MaxFibIndex - 1, since |D(n)| >> 1e16, ai, bi ≤ |D(n)|\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <vector>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read t and n\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    // Compute |D(n)| if necessary\n    const int MaxFibIndex = 93; // Fib(93) can be stored in uint64_t\n    unsigned long long DnSize = 0; // To store |D(n)| when n <= MaxFibIndex - 1\n\n    if (n <= MaxFibIndex - 1) { // Since we need Fib(n+1)\n        vector<unsigned long long> Fib(n + 2);\n        Fib[0] = 0;\n        Fib[1] = 1;\n        for (int i = 2; i <= n + 1; i++) {\n            Fib[i] = Fib[i - 1] + Fib[i - 2];\n        }\n        DnSize = Fib[n + 1];\n        // Now DnSize is |D(n)| = Fib(n + 1)\n    } else {\n        // For n >= MaxFibIndex - 1\n        // |D(n)| exceeds uint64_t capacity, but since ai, bi ≤ 1e16, and |D(n)| >> 1e16\n        // ai, bi ≤ |D(n)| holds\n    }\n\n    const long long maxAiBi = 10000000000000000LL; // 1e16 as per constraints\n\n    for (int i = 0; i < t; i++) {\n        // Read ai and bi\n        long long ai = inf.readLong(1LL, maxAiBi, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1LL, maxAiBi, \"bi\"); // Ensure ai, bi ≤ 1e16\n\n        ensuref(ai != bi, \"ai and bi must be different, but both are %lld\", ai);\n\n        if (DnSize != 0) {\n            // For n ≤ MaxFibIndex - 1, ensure ai, bi ≤ |D(n)|\n            ensuref(ai <= (long long)DnSize, \"ai must be ≤ |D(n)|=%llu, but ai=%lld\", DnSize, ai);\n            ensuref(bi <= (long long)DnSize, \"bi must be ≤ |D(n)|=%llu, but bi=%lld\", DnSize, bi);\n        }\n        // For n ≥ MaxFibIndex - 1, since |D(n)| >> 1e16, ai, bi ≤ |D(n)|\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\null Fib[83]; // Stores Fibonacci numbers up to n = 82\n\nvoid initFib() {\n    Fib[0] = 1;\n    Fib[1] = 2;\n    for(int i = 2; i <= 82; ++i) {\n        Fib[i] = Fib[i-1] + Fib[i-2];\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    initFib();\n    ull maxV;\n    if(n <= 82) {\n        maxV = min(Fib[n], 10000000000000000ULL); // Ensure maxV does not exceed 1e16\n    } else {\n        maxV = 10000000000000000ULL; // Set maxV to 1e16 for n > 82\n    }\n\n    cout << t << \" \" << n << endl;\n\n    if(type == \"random\") {\n        for(int i = 0; i < t; ++i) {\n            ull ai, bi;\n            do {\n                ai = rnd.next(1ULL, maxV);\n                bi = rnd.next(1ULL, maxV);\n            } while(ai == bi);\n            cout << ai << \" \" << bi << endl;\n        }\n    } else if(type == \"maxdistance\") {\n        for(int i = 0; i < t; ++i) {\n            ull ai = 1, bi = maxV;\n            if(ai == bi) bi = maxV - 1; // Ensure ai != bi\n            cout << ai << \" \" << bi << endl;\n        }\n    } else if(type == \"mindistance\") {\n        for(int i = 0; i < t; ++i) {\n            ull ai = 1, bi = 2;\n            if(maxV < 2) {\n                // If there's no vertex 2, generate random distinct vertices\n                do {\n                    ai = rnd.next(1ULL, maxV);\n                    bi = rnd.next(1ULL, maxV);\n                } while(ai == bi);\n            }\n            cout << ai << \" \" << bi << endl;\n        }\n    } else {\n        // Default to random if an unknown type is provided\n        for(int i = 0; i < t; ++i) {\n            ull ai, bi;\n            do {\n                ai = rnd.next(1ULL, maxV);\n                bi = rnd.next(1ULL, maxV);\n            } while(ai == bi);\n            cout << ai << \" \" << bi << endl;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\null Fib[83]; // Stores Fibonacci numbers up to n = 82\n\nvoid initFib() {\n    Fib[0] = 1;\n    Fib[1] = 2;\n    for(int i = 2; i <= 82; ++i) {\n        Fib[i] = Fib[i-1] + Fib[i-2];\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    initFib();\n    ull maxV;\n    if(n <= 82) {\n        maxV = min(Fib[n], 10000000000000000ULL); // Ensure maxV does not exceed 1e16\n    } else {\n        maxV = 10000000000000000ULL; // Set maxV to 1e16 for n > 82\n    }\n\n    cout << t << \" \" << n << endl;\n\n    if(type == \"random\") {\n        for(int i = 0; i < t; ++i) {\n            ull ai, bi;\n            do {\n                ai = rnd.next(1ULL, maxV);\n                bi = rnd.next(1ULL, maxV);\n            } while(ai == bi);\n            cout << ai << \" \" << bi << endl;\n        }\n    } else if(type == \"maxdistance\") {\n        for(int i = 0; i < t; ++i) {\n            ull ai = 1, bi = maxV;\n            if(ai == bi) bi = maxV - 1; // Ensure ai != bi\n            cout << ai << \" \" << bi << endl;\n        }\n    } else if(type == \"mindistance\") {\n        for(int i = 0; i < t; ++i) {\n            ull ai = 1, bi = 2;\n            if(maxV < 2) {\n                // If there's no vertex 2, generate random distinct vertices\n                do {\n                    ai = rnd.next(1ULL, maxV);\n                    bi = rnd.next(1ULL, maxV);\n                } while(ai == bi);\n            }\n            cout << ai << \" \" << bi << endl;\n        }\n    } else {\n        // Default to random if an unknown type is provided\n        for(int i = 0; i < t; ++i) {\n            ull ai, bi;\n            do {\n                ai = rnd.next(1ULL, maxV);\n                bi = rnd.next(1ULL, maxV);\n            } while(ai == bi);\n            cout << ai << \" \" << bi << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -n 1 -type random\n./gen -t 1 -n 2 -type random\n./gen -t 5 -n 5 -type random\n./gen -t 10 -n 10 -type random\n./gen -t 100 -n 100 -type random\n./gen -t 1000 -n 1000 -type random\n./gen -t 100000 -n 1000 -type random\n./gen -t 100000 -n 82 -type random\n./gen -t 100000 -n 83 -type random\n\n./gen -t 1 -n 1 -type maxdistance\n./gen -t 10 -n 10 -type maxdistance\n./gen -t 100 -n 100 -type maxdistance\n./gen -t 1000 -n 1000 -type maxdistance\n./gen -t 100000 -n 1000 -type maxdistance\n\n./gen -t 1 -n 1 -type mindistance\n./gen -t 10 -n 10 -type mindistance\n./gen -t 100 -n 100 -type mindistance\n./gen -t 1000 -n 1000 -type mindistance\n./gen -t 100000 -n 1000 -type mindistance\n\n./gen -t 100000 -n 1 -type random\n./gen -t 100000 -n 2 -type random\n./gen -t 100000 -n 10 -type random\n./gen -t 100000 -n 50 -type random\n./gen -t 100000 -n 100 -type random\n./gen -t 100000 -n 500 -type random\n./gen -t 100000 -n 750 -type random\n./gen -t 100000 -n 1000 -type random\n\n./gen -t 1 -n 82 -type random\n./gen -t 1 -n 83 -type random\n./gen -t 1 -n 1000 -type random\n./gen -t 1 -n 1000 -type maxdistance\n./gen -t 1 -n 1000 -type mindistance\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:04.893070",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "232/D",
      "title": "D. Fence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of wood planks in the fence. The second line contains n space-separated integers h1, h2, ..., hn (1 ≤ hi ≤ 109) — the heights of fence planks.The third line contains integer q (1 ≤ q ≤ 105) — the number of queries. Next q lines contain two space-separated integers li and ri (1 ≤ li ≤ ri ≤ n) — the boundaries of the i-th piece of the fence.",
      "output_spec": "OutputFor each query on a single line print a single integer — the number of pieces of the fence that match the given one. Print the answers to the queries in the order, in which the queries are given in the input.",
      "sample_tests": "ExamplesInputCopy101 2 2 1 100 99 99 100 100 10061 41 23 41 59 1010 10OutputCopy122029",
      "description": "time limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of wood planks in the fence. The second line contains n space-separated integers h1, h2, ..., hn (1 ≤ hi ≤ 109) — the heights of fence planks.The third line contains integer q (1 ≤ q ≤ 105) — the number of queries. Next q lines contain two space-separated integers li and ri (1 ≤ li ≤ ri ≤ n) — the boundaries of the i-th piece of the fence.\n\nOutputFor each query on a single line print a single integer — the number of pieces of the fence that match the given one. Print the answers to the queries in the order, in which the queries are given in the input.\n\nInputCopy101 2 2 1 100 99 99 100 100 10061 41 23 41 59 1010 10OutputCopy122029\n\nInputCopy101 2 2 1 100 99 99 100 100 10061 41 23 41 59 1010 10\n\nOutputCopy122029",
      "solutions": [
        {
          "title": "Codeforces Round #144 - Codeforces",
          "content": "Hi all! Codeforces round #144 is going to be today. Round is prepared by: KAN, fdoer, Skird, tunyash. Special thanks to Gerald for coordinating round preparing, many awesome ideas and making statements easy-understandable. Also I thank MikeMirzayanov for enjoyable problem-preparing system, Delinur for statements translation. I hope, that all will be well and you will enjoy solving problems. Good luck!UPD: Score distribution will be announced a few minutes before the start of the contest.UPD2: score distribution is 500-1000-1500-2000-2500 in both divisionsUPD3:Congrats to winners.div1: tourist rng_58 Mimino Dmitry_Egorov, Egor div2: debug22 ryz dvdreddy vinodreddy rdivyanshu UPD: editoral for all problems, except div1.D is ready",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5510",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 737
        },
        {
          "title": "Editorial for Codeforces Round #144 - Codeforces",
          "content": "It will be finised in few hours. If you don't understand something, ask your questions, please.233A - Perfect PermutationIdea: Gerald Implementation: tunyash Editorial: fdoerConsider permutation p such that pi = i. Actually p is a sequence of numbers from 1 to n. Obviously ppi = i. Now the only trick is to change the permutation to satisfy the second equation: pi ≠ i. Let's swap every two consequtive elements. More formally, for each k: 2k ≤ n let's swap p2k - 1 and p2k. It's easy to see that the obtained permutation satisfies both equations for every n with the only exception: when n is odd, there is no answer and we should print  - 1.233B - Non-square EquationIdea: tunyash Implementation: tunyash, Gerald Editorial: fdoerFirstly let's find the interval of possible values of s(x). Hence x2 ≤ n and n ≤ 1018, x ≤ 109. In other words, for every considerable solution x the decimal length of x does not extend 10 digits. So smax ≤ s(9999999999) = 10·9 = 90.Let's bruteforce the value of s(x) (0 ≤ s(x) ≤ 90). Now we have an ordinary square equation. The deal is to solve it and to check that the current bruteforced value of s(x) is equal to sum of digits of the solution. If the solution exists and the equality holds, we should relax the answer.It seems that the most error-generating part of this problem is solving the equation.Knowing arrays is not neccessary to solve these two problems.232A - CyclesIdea: tunyash, fdoer Implementation: tunyash Editorial: tunyashLet's add edge in order of increasing a and for equal b in order of increasing b (here a and b — the least and the greatest vertices of the edge). If the new edge adds too much 3-cycles, we won't add it. We can count the number of new 3-cycles in O(n) complexity (they all contain the new edge, so it's enough to check all variants of the third vertex). Obviously we will obtain some proper graph, because we can always add a vertex and two edges to make a new triangle. So, there is always an answer. The complexity of this solution is O(n3).Let's proof that 100 vertices are always enough for the given restrictions on n. For some p after first p iterations we will have a complete graph of p vertices. Now we have exactly C(p, 3) triangles. Consider p such that C(p, 3) ≤ k and C(p, 3) is maximal. For the given restrictions p ≤ 85. From this moment, if we add u from some vertex, we increase the total number of 3-cycles on C(u, 2). So we have to present a small number that is less than C(85, 3) as sum of C(i, 2). The first number we subtruct will differ C(85, 1) on some value not greater than C(85, 1) = 85, because C(n, k) - C(n - 1, k) = C(n - 1, k - 1). The second number we subtruct will differ the number we have on some value not greater than C(14, 1) = 14. and so on. For every k it's enough to use not more that 90 vertices. 232B - TableIdea: tunyash, Skird Implementation: tunyash Editorial: tunyash Let si number of points in the column i. Two neighboring squares are drawn at this picture, A is the number of point it the left area (it is one column), B is the number of points in the middle area and C is the number of points in the right area (it is one column too). That's why by definition we have: Therefore A = C. That's why Divide all columns by equivalence classes on the basis of . For all a and b from one class sa = sb. cnta is number of columns in class with . There are (Cnk)cnta ways to draw k points in the each of columns in the class a independendently of the other classes. dp[i][j] is number of ways to fill all columns in classes 1, ... i in such way that . cnti take only two values and . Let's calc (Cna)cnti for all a and cnti and use it to calc our dp. We have O(n2·k) complexity. 232C - Doe Graphs Idea: Gerald,tunyash Implementation: tunyash, Gerald Editorial: tunyashLet's reduce the problem to the same problem for graphs with less orders. Vertex |D(n - 1)| + 1 is cutpoint (except cases n ≤ 2 but equations below is true for these cases).Without loss of generality a < b. Let dist(a, b, n) — length of the shortest path in graph of order n.The first case is a ≤ |D(n - 1)| and |D(n - 1)| + 1 ≤ b dist(a, b, n) = min(dist(a, |D(n - 1)|, n - 1), dist(a, 1, n - 1)) + dist(b - |D(n - 1)|, 1, n - 2) + 1Edges is marked in red, paths is marked in blue. This formula means that we can go from the vertex a by the path 1 to the vertex 1. Then we can go to the |D(n - 1)| + 1 by the edge and go to the vertex b by the path 3. Or we can go to the vertex |D(n - 1)| by the path 2 and then go to the vertex |D(n - 1)| + 1 by the path 2 and then go to the vertex b by the path 3.The second case is |D(n - 1)| + 1 ≤ a, b. dist(a, b, n) = dist(a - |D(n - 1)|, b - |D(n - 1)|, n - 2)That's easy case.The third case is a, b ≤ |D(n - 1)| dist(a, b, n) = min(dist(a, b, n - 1), min(dist(1, a, n - 1), dist(|D(n - 1)|, a, n - 1)) + min(dist(1, b, n - 1), dist(|D(n - 1)|, b, n - 1) + 2)If shortest path contains cutpoint (|D(n - 1)| + 1) we can go to the vertex 1 or |D(n - 1)+1$ form the both of a and b. After that we can go to the cutpoint. Else we should consider path from a to b in D(n - 1).Let's notice that for all of n will be no more than 4 distinct runnings of dist(i, j, n).It can be prooved by the considering many cases of our actions.In authors colution we cashed all dist(1, i, n) and dist(i, |D(n)|, n) for all achieveable i and n. We have complexity for one query. (it's log because |D(n)| grows like φn).232D - FenceIdea: Gerald, tunyash Implementation: fdoer Editorial: fdoerLet d and d' be arrays such that di = hi - hi + 1, d'i =  - di for every 1 ≤ i ≤ (n - 1). With that notation the conditions of matching look somehow like these: the pieces do not intersect, that is, there isn't a single plank, such that it occurs in both pieces of the fence; the pieces are of the same width; for all i i (0 ≤ i ≤ r1 - l1 - 1) the following condition holds: dl1 + i = d'l2 + i (that is true in case when l = r). The main idea of our solution is stated in the next sentence. For each query l...r the answer is number of pairs (a, b) such that (a > r or b < l), 1 ≤ a ≤ b ≤ n - 1, b - a = r - l and dl...r - 1 exactly matches d'a...b - 1. Let's build a suffix array sa from the concatenation of arrays d and d' with a fictive number between them for separation. Let position of suffix i in sa be posi. For each query all pieces of the fence that satisfy both second and third conditions of matching will be placed in sa on some segment boundleft...boundright such that boundleft ≤ posl ≤ boundright and lcp(boundleft...boundright) ≥ (r - l). So, it's possible to use binary search to find bound's. Depending on complexity of lcp finding algorithm, we could get them in O(logn) or O(log2n) complexity.But there is still a problem to count the number of suffixes from saboundleft...boundright that satisfy the first condition too. Actually it is equal to count the number of i (boundleft ≤ i ≤ boundright) such that (n + 1 ≤ sai ≤ n + l - (r - l) - 1 or sai ≥ n + r) (in the concatenation d' starts from n + 1). It is a classic problem to count numbers from the given interval in the given subarray. For each query it could be solved in O(logn) complexity.For instance, we could solve it offline using sweep line method and any data structure that support queries of sum on an interval and increment of an element. Or we could use some 2D/persistent structure.So, the summary of the algorithm looks like this: build d and d'. Build a suffix array on their concatenation. For each query: find the interval (boundleft...boundright) with two consecutive binary searches using lcp function. query the count of suffixes from that interval that do not intersect with the given piece of the fence. The best author's solution complexity is O(nlogn + qlogn), but careful written solutions in O(nlog2n) comply with the lime limit too.232E - Quick Tortoise Idea: tunyash Implementation: tunyash, KAN Editorial: tunyashLet's choose central column of the area and for all cells to the left from column calc masks of achieveable cells in the central column and for all cells to the right from column calc masks of cells of which this is achievable. It's easy dp with bitsets. for the right part of board. ( — logical or, here it's bitwise or for masks) for the left part. dp calcs mask of achieveable points in the central column.For query x1, y1, x2, y2 (if y1 ≤ mid ≤ y2, where mid is chosen central column) answer is yes if ( is bitwise and) is not empty.Run this algo for left and right part of board we will get answers for all queries. Complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 232\\s*D"
          },
          "content_length": 8557
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #144 - Codeforces - Code 1",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 2",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 3",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 4",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string h_type = opt<string>(\"h_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    vector<int> h(n);\n\n    if (h_type == \"random\") {\n        // Random h_i in [1, 1e9]\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, 1000000000);\n        }\n    } else if (h_type == \"constant\") {\n        // All h_i same\n        int val = rnd.next(1, 1000000000);\n        fill(h.begin(), h.end(), val);\n    } else if (h_type == \"increasing\") {\n        int start = rnd.next(1, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            h[i] = start + i;\n        }\n    } else if (h_type == \"decreasing\") {\n        int start = rnd.next(n, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            h[i] = start - i;\n        }\n    } else if (h_type == \"alternating\") {\n        int val1 = rnd.next(1, 1000000000);\n        int val2 = rnd.next(1, 1000000000);\n        if (val1 == val2) val2 = (val1 % 1000000000) + 1; // Ensure different\n        for (int i = 0; i < n; ++i) {\n            h[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (h_type == \"palindrome\") {\n        int half = n / 2;\n        for (int i = 0; i < half; ++i) {\n            h[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < n - half; ++i) {\n            h[half + i] = h[half - i - 1];\n        }\n    } else if (h_type == \"repeating\") {\n        int pattern_length = rnd.next(1, min(n, 1000)); // small pattern\n        vector<int> pattern(pattern_length);\n        for (int i = 0; i < pattern_length; ++i) {\n            pattern[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < n; ++i) {\n            h[i] = pattern[i % pattern_length];\n        }\n    } else if (h_type == \"max\") {\n        // All h_i = 1e9\n        fill(h.begin(), h.end(), 1000000000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output h_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", h[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Generate queries\n    printf(\"%d\\n\", q);\n    vector<pair<int, int>> queries;\n    if (q_type == \"random\") {\n        // Random queries\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            queries.push_back({l, r});\n        }\n    } else if (q_type == \"edge\") {\n        // Include queries of length 1, length n, overlapping ranges, etc.\n        for (int i = 0; i < q; ++i) {\n            int l, r;\n            if (i % 5 == 0) {\n                // Length 1 query\n                l = rnd.next(1, n);\n                r = l;\n            } else if (i % 5 == 1) {\n                // Max length query\n                l = 1;\n                r = n;\n            } else if (i % 5 == 2) {\n                // Left half\n                l = 1;\n                r = n / 2;\n            } else if (i % 5 == 3) {\n                // Right half\n                l = n / 2 + 1;\n                r = n;\n            } else {\n                // Random\n                l = rnd.next(1, n);\n                r = rnd.next(1, n);\n                if (l > r) swap(l, r);\n            }\n            queries.push_back({l, r});\n        }\n    }\n\n    // Output queries\n    for (auto& query : queries) {\n        printf(\"%d %d\\n\", query.first, query.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string h_type = opt<string>(\"h_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    vector<int> h(n);\n\n    if (h_type == \"random\") {\n        // Random h_i in [1, 1e9]\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, 1000000000);\n        }\n    } else if (h_type == \"constant\") {\n        // All h_i same\n        int val = rnd.next(1, 1000000000);\n        fill(h.begin(), h.end(), val);\n    } else if (h_type == \"increasing\") {\n        int start = rnd.next(1, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            h[i] = start + i;\n        }\n    } else if (h_type == \"decreasing\") {\n        int start = rnd.next(n, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            h[i] = start - i;\n        }\n    } else if (h_type == \"alternating\") {\n        int val1 = rnd.next(1, 1000000000);\n        int val2 = rnd.next(1, 1000000000);\n        if (val1 == val2) val2 = (val1 % 1000000000) + 1; // Ensure different\n        for (int i = 0; i < n; ++i) {\n            h[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (h_type == \"palindrome\") {\n        int half = n / 2;\n        for (int i = 0; i < half; ++i) {\n            h[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < n - half; ++i) {\n            h[half + i] = h[half - i - 1];\n        }\n    } else if (h_type == \"repeating\") {\n        int pattern_length = rnd.next(1, min(n, 1000)); // small pattern\n        vector<int> pattern(pattern_length);\n        for (int i = 0; i < pattern_length; ++i) {\n            pattern[i] = rnd.next(1, 1000000000);\n        }\n        for (int i = 0; i < n; ++i) {\n            h[i] = pattern[i % pattern_length];\n        }\n    } else if (h_type == \"max\") {\n        // All h_i = 1e9\n        fill(h.begin(), h.end(), 1000000000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output h_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", h[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Generate queries\n    printf(\"%d\\n\", q);\n    vector<pair<int, int>> queries;\n    if (q_type == \"random\") {\n        // Random queries\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            queries.push_back({l, r});\n        }\n    } else if (q_type == \"edge\") {\n        // Include queries of length 1, length n, overlapping ranges, etc.\n        for (int i = 0; i < q; ++i) {\n            int l, r;\n            if (i % 5 == 0) {\n                // Length 1 query\n                l = rnd.next(1, n);\n                r = l;\n            } else if (i % 5 == 1) {\n                // Max length query\n                l = 1;\n                r = n;\n            } else if (i % 5 == 2) {\n                // Left half\n                l = 1;\n                r = n / 2;\n            } else if (i % 5 == 3) {\n                // Right half\n                l = n / 2 + 1;\n                r = n;\n            } else {\n                // Random\n                l = rnd.next(1, n);\n                r = rnd.next(1, n);\n                if (l > r) swap(l, r);\n            }\n            queries.push_back({l, r});\n        }\n    }\n\n    // Output queries\n    for (auto& query : queries) {\n        printf(\"%d %d\\n\", query.first, query.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -q 5 -h_type random -q_type random\n./gen -n 10 -q 5 -h_type constant -q_type random\n./gen -n 10 -q 5 -h_type increasing -q_type edge\n./gen -n 100 -q 50 -h_type decreasing -q_type random\n./gen -n 100 -q 50 -h_type alternating -q_type edge\n./gen -n 100 -q 50 -h_type palindrome -q_type random\n./gen -n 1000 -q 500 -h_type repeating -q_type random\n./gen -n 1000 -q 500 -h_type random -q_type edge\n./gen -n 10000 -q 5000 -h_type constant -q_type random\n./gen -n 10000 -q 5000 -h_type max -q_type edge\n./gen -n 100000 -q 100000 -h_type random -q_type random\n./gen -n 100000 -q 100000 -h_type increasing -q_type random\n./gen -n 100000 -q 100000 -h_type decreasing -q_type random\n./gen -n 100000 -q 100000 -h_type alternating -q_type random\n./gen -n 100000 -q 100000 -h_type palindrome -q_type random\n./gen -n 100000 -q 100000 -h_type repeating -q_type random\n./gen -n 100000 -q 100000 -h_type constant -q_type edge\n./gen -n 100000 -q 100000 -h_type random -q_type edge\n./gen -n 100000 -q 100000 -h_type palindrome -q_type edge\n./gen -n 100000 -q 100000 -h_type max -q_type edge\n./gen -n 99999 -q 99999 -h_type repeating -q_type random\n./gen -n 1 -q 1 -h_type constant -q_type random\n./gen -n 1 -q 1 -h_type max -q_type random\n./gen -n 100000 -q 1 -h_type random -q_type random\n./gen -n 1 -q 100000 -h_type random -q_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:06.701540",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "232/E",
      "title": "E. Quick Tortoise",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 500) — the field sizes.Each of the next n lines contains m characters \"#\" and \".\": the j-th character of the i-th line equals \"#\", if the cell (i; j) is painted black and \".\", if it is painted white.The next line contains integer q (1 ≤ q ≤ 6·105) — the number of queries. Next q lines contain four space-separated integers x1, y1, x2 and y2 (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ m) — the coordinates of the starting and the finishing cells. It is guaranteed that cells (x1; y1) and (x2; y2) are white.",
      "output_spec": "OutputFor each of q queries print on a single line \"Yes\", if there is a way from cell (x1; y1) to cell (x2; y2), that meets the requirements, and \"No\" otherwise. Print the answers to the queries in the order, in which the queries are given in the input.",
      "sample_tests": "ExamplesInputCopy3 3....##.#.51 1 3 31 1 1 31 1 3 11 1 1 21 1 2 1OutputCopyNoYesYesYesYesInputCopy5 5......###.......###......51 1 5 51 1 1 51 1 3 42 1 2 51 1 2 5OutputCopyYesYesYesNoYes",
      "description": "E. Quick Tortoise\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 500) — the field sizes.Each of the next n lines contains m characters \"#\" and \".\": the j-th character of the i-th line equals \"#\", if the cell (i; j) is painted black and \".\", if it is painted white.The next line contains integer q (1 ≤ q ≤ 6·105) — the number of queries. Next q lines contain four space-separated integers x1, y1, x2 and y2 (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ m) — the coordinates of the starting and the finishing cells. It is guaranteed that cells (x1; y1) and (x2; y2) are white.\n\nOutputFor each of q queries print on a single line \"Yes\", if there is a way from cell (x1; y1) to cell (x2; y2), that meets the requirements, and \"No\" otherwise. Print the answers to the queries in the order, in which the queries are given in the input.\n\nInputCopy3 3....##.#.51 1 3 31 1 1 31 1 3 11 1 1 21 1 2 1OutputCopyNoYesYesYesYesInputCopy5 5......###.......###......51 1 5 51 1 1 51 1 3 42 1 2 51 1 2 5OutputCopyYesYesYesNoYes\n\nInputCopy3 3....##.#.51 1 3 31 1 1 31 1 3 11 1 1 21 1 2 1\n\nOutputCopyNoYesYesYesYes\n\nInputCopy5 5......###.......###......51 1 5 51 1 1 51 1 3 42 1 2 51 1 2 5\n\nOutputCopyYesYesYesNoYes",
      "solutions": [
        {
          "title": "Codeforces Round #144 - Codeforces",
          "content": "Hi all! Codeforces round #144 is going to be today. Round is prepared by: KAN, fdoer, Skird, tunyash. Special thanks to Gerald for coordinating round preparing, many awesome ideas and making statements easy-understandable. Also I thank MikeMirzayanov for enjoyable problem-preparing system, Delinur for statements translation. I hope, that all will be well and you will enjoy solving problems. Good luck!UPD: Score distribution will be announced a few minutes before the start of the contest.UPD2: score distribution is 500-1000-1500-2000-2500 in both divisionsUPD3:Congrats to winners.div1: tourist rng_58 Mimino Dmitry_Egorov, Egor div2: debug22 ryz dvdreddy vinodreddy rdivyanshu UPD: editoral for all problems, except div1.D is ready",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5510",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 737
        },
        {
          "title": "Editorial for Codeforces Round #144 - Codeforces",
          "content": "It will be finised in few hours. If you don't understand something, ask your questions, please.233A - Perfect PermutationIdea: Gerald Implementation: tunyash Editorial: fdoerConsider permutation p such that pi = i. Actually p is a sequence of numbers from 1 to n. Obviously ppi = i. Now the only trick is to change the permutation to satisfy the second equation: pi ≠ i. Let's swap every two consequtive elements. More formally, for each k: 2k ≤ n let's swap p2k - 1 and p2k. It's easy to see that the obtained permutation satisfies both equations for every n with the only exception: when n is odd, there is no answer and we should print  - 1.233B - Non-square EquationIdea: tunyash Implementation: tunyash, Gerald Editorial: fdoerFirstly let's find the interval of possible values of s(x). Hence x2 ≤ n and n ≤ 1018, x ≤ 109. In other words, for every considerable solution x the decimal length of x does not extend 10 digits. So smax ≤ s(9999999999) = 10·9 = 90.Let's bruteforce the value of s(x) (0 ≤ s(x) ≤ 90). Now we have an ordinary square equation. The deal is to solve it and to check that the current bruteforced value of s(x) is equal to sum of digits of the solution. If the solution exists and the equality holds, we should relax the answer.It seems that the most error-generating part of this problem is solving the equation.Knowing arrays is not neccessary to solve these two problems.232A - CyclesIdea: tunyash, fdoer Implementation: tunyash Editorial: tunyashLet's add edge in order of increasing a and for equal b in order of increasing b (here a and b — the least and the greatest vertices of the edge). If the new edge adds too much 3-cycles, we won't add it. We can count the number of new 3-cycles in O(n) complexity (they all contain the new edge, so it's enough to check all variants of the third vertex). Obviously we will obtain some proper graph, because we can always add a vertex and two edges to make a new triangle. So, there is always an answer. The complexity of this solution is O(n3).Let's proof that 100 vertices are always enough for the given restrictions on n. For some p after first p iterations we will have a complete graph of p vertices. Now we have exactly C(p, 3) triangles. Consider p such that C(p, 3) ≤ k and C(p, 3) is maximal. For the given restrictions p ≤ 85. From this moment, if we add u from some vertex, we increase the total number of 3-cycles on C(u, 2). So we have to present a small number that is less than C(85, 3) as sum of C(i, 2). The first number we subtruct will differ C(85, 1) on some value not greater than C(85, 1) = 85, because C(n, k) - C(n - 1, k) = C(n - 1, k - 1). The second number we subtruct will differ the number we have on some value not greater than C(14, 1) = 14. and so on. For every k it's enough to use not more that 90 vertices. 232B - TableIdea: tunyash, Skird Implementation: tunyash Editorial: tunyash Let si number of points in the column i. Two neighboring squares are drawn at this picture, A is the number of point it the left area (it is one column), B is the number of points in the middle area and C is the number of points in the right area (it is one column too). That's why by definition we have: Therefore A = C. That's why Divide all columns by equivalence classes on the basis of . For all a and b from one class sa = sb. cnta is number of columns in class with . There are (Cnk)cnta ways to draw k points in the each of columns in the class a independendently of the other classes. dp[i][j] is number of ways to fill all columns in classes 1, ... i in such way that . cnti take only two values and . Let's calc (Cna)cnti for all a and cnti and use it to calc our dp. We have O(n2·k) complexity. 232C - Doe Graphs Idea: Gerald,tunyash Implementation: tunyash, Gerald Editorial: tunyashLet's reduce the problem to the same problem for graphs with less orders. Vertex |D(n - 1)| + 1 is cutpoint (except cases n ≤ 2 but equations below is true for these cases).Without loss of generality a < b. Let dist(a, b, n) — length of the shortest path in graph of order n.The first case is a ≤ |D(n - 1)| and |D(n - 1)| + 1 ≤ b dist(a, b, n) = min(dist(a, |D(n - 1)|, n - 1), dist(a, 1, n - 1)) + dist(b - |D(n - 1)|, 1, n - 2) + 1Edges is marked in red, paths is marked in blue. This formula means that we can go from the vertex a by the path 1 to the vertex 1. Then we can go to the |D(n - 1)| + 1 by the edge and go to the vertex b by the path 3. Or we can go to the vertex |D(n - 1)| by the path 2 and then go to the vertex |D(n - 1)| + 1 by the path 2 and then go to the vertex b by the path 3.The second case is |D(n - 1)| + 1 ≤ a, b. dist(a, b, n) = dist(a - |D(n - 1)|, b - |D(n - 1)|, n - 2)That's easy case.The third case is a, b ≤ |D(n - 1)| dist(a, b, n) = min(dist(a, b, n - 1), min(dist(1, a, n - 1), dist(|D(n - 1)|, a, n - 1)) + min(dist(1, b, n - 1), dist(|D(n - 1)|, b, n - 1) + 2)If shortest path contains cutpoint (|D(n - 1)| + 1) we can go to the vertex 1 or |D(n - 1)+1$ form the both of a and b. After that we can go to the cutpoint. Else we should consider path from a to b in D(n - 1).Let's notice that for all of n will be no more than 4 distinct runnings of dist(i, j, n).It can be prooved by the considering many cases of our actions.In authors colution we cashed all dist(1, i, n) and dist(i, |D(n)|, n) for all achieveable i and n. We have complexity for one query. (it's log because |D(n)| grows like φn).232D - FenceIdea: Gerald, tunyash Implementation: fdoer Editorial: fdoerLet d and d' be arrays such that di = hi - hi + 1, d'i =  - di for every 1 ≤ i ≤ (n - 1). With that notation the conditions of matching look somehow like these: the pieces do not intersect, that is, there isn't a single plank, such that it occurs in both pieces of the fence; the pieces are of the same width; for all i i (0 ≤ i ≤ r1 - l1 - 1) the following condition holds: dl1 + i = d'l2 + i (that is true in case when l = r). The main idea of our solution is stated in the next sentence. For each query l...r the answer is number of pairs (a, b) such that (a > r or b < l), 1 ≤ a ≤ b ≤ n - 1, b - a = r - l and dl...r - 1 exactly matches d'a...b - 1. Let's build a suffix array sa from the concatenation of arrays d and d' with a fictive number between them for separation. Let position of suffix i in sa be posi. For each query all pieces of the fence that satisfy both second and third conditions of matching will be placed in sa on some segment boundleft...boundright such that boundleft ≤ posl ≤ boundright and lcp(boundleft...boundright) ≥ (r - l). So, it's possible to use binary search to find bound's. Depending on complexity of lcp finding algorithm, we could get them in O(logn) or O(log2n) complexity.But there is still a problem to count the number of suffixes from saboundleft...boundright that satisfy the first condition too. Actually it is equal to count the number of i (boundleft ≤ i ≤ boundright) such that (n + 1 ≤ sai ≤ n + l - (r - l) - 1 or sai ≥ n + r) (in the concatenation d' starts from n + 1). It is a classic problem to count numbers from the given interval in the given subarray. For each query it could be solved in O(logn) complexity.For instance, we could solve it offline using sweep line method and any data structure that support queries of sum on an interval and increment of an element. Or we could use some 2D/persistent structure.So, the summary of the algorithm looks like this: build d and d'. Build a suffix array on their concatenation. For each query: find the interval (boundleft...boundright) with two consecutive binary searches using lcp function. query the count of suffixes from that interval that do not intersect with the given piece of the fence. The best author's solution complexity is O(nlogn + qlogn), but careful written solutions in O(nlog2n) comply with the lime limit too.232E - Quick Tortoise Idea: tunyash Implementation: tunyash, KAN Editorial: tunyashLet's choose central column of the area and for all cells to the left from column calc masks of achieveable cells in the central column and for all cells to the right from column calc masks of cells of which this is achievable. It's easy dp with bitsets. for the right part of board. ( — logical or, here it's bitwise or for masks) for the left part. dp calcs mask of achieveable points in the central column.For query x1, y1, x2, y2 (if y1 ≤ mid ≤ y2, where mid is chosen central column) answer is yes if ( is bitwise and) is not empty.Run this algo for left and right part of board we will get answers for all queries. Complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 232\\s*E"
          },
          "content_length": 8557
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #144 - Codeforces - Code 1",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 2",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 3",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 4",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d length is not equal to m\", i+1);\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.', \"Invalid character '%c' at line %d position %d\", c, i+1, j+1);\n        }\n        grid[i] = s;\n    }\n\n    int q = inf.readInt(1, 600000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int x1 = inf.readInt(1, n, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, m, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(1, n, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(1, m, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 <= x2, \"Query %d: x1 (%d) > x2 (%d)\", i+1, x1, x2);\n        ensuref(y1 <= y2, \"Query %d: y1 (%d) > y2 (%d)\", i+1, y1, y2);\n\n        int xi1 = x1 - 1;\n        int yi1 = y1 - 1;\n        int xi2 = x2 - 1;\n        int yi2 = y2 - 1;\n        ensuref(grid[xi1][yi1] == '.', \"Query %d: Starting cell (%d,%d) is black\", i+1, x1, y1);\n        ensuref(grid[xi2][yi2] == '.', \"Query %d: Ending cell (%d,%d) is black\", i+1, x2, y2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d length is not equal to m\", i+1);\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.', \"Invalid character '%c' at line %d position %d\", c, i+1, j+1);\n        }\n        grid[i] = s;\n    }\n\n    int q = inf.readInt(1, 600000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int x1 = inf.readInt(1, n, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, m, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(1, n, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(1, m, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 <= x2, \"Query %d: x1 (%d) > x2 (%d)\", i+1, x1, x2);\n        ensuref(y1 <= y2, \"Query %d: y1 (%d) > y2 (%d)\", i+1, y1, y2);\n\n        int xi1 = x1 - 1;\n        int yi1 = y1 - 1;\n        int xi2 = x2 - 1;\n        int yi2 = y2 - 1;\n        ensuref(grid[xi1][yi1] == '.', \"Query %d: Starting cell (%d,%d) is black\", i+1, x1, y1);\n        ensuref(grid[xi2][yi2] == '.', \"Query %d: Ending cell (%d,%d) is black\", i+1, x2, y2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d length is not equal to m\", i+1);\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.', \"Invalid character '%c' at line %d position %d\", c, i+1, j+1);\n        }\n        grid[i] = s;\n    }\n\n    int q = inf.readInt(1, 600000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int x1 = inf.readInt(1, n, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, m, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(1, n, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(1, m, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 <= x2, \"Query %d: x1 (%d) > x2 (%d)\", i+1, x1, x2);\n        ensuref(y1 <= y2, \"Query %d: y1 (%d) > y2 (%d)\", i+1, y1, y2);\n\n        int xi1 = x1 - 1;\n        int yi1 = y1 - 1;\n        int xi2 = x2 - 1;\n        int yi2 = y2 - 1;\n        ensuref(grid[xi1][yi1] == '.', \"Query %d: Starting cell (%d,%d) is black\", i+1, x1, y1);\n        ensuref(grid[xi2][yi2] == '.', \"Query %d: Ending cell (%d,%d) is black\", i+1, x2, y2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    Final Revised Generator for the \"Tortoise in a Grid\" problem.\n\n    **Key Point** for Checkerboard (and any other pattern):\n      We only choose queries where both the start and end cells are white,\n      and we also ensure rowStart <= rowEnd, colStart <= colEnd.\n      This guarantees the query is valid (the start is never black and \n      x1 ≤ x2, y1 ≤ y2).\n\n    Implementation details:\n      - Gather all white cells in a vector \"whites\".\n      - We attempt to form up to qRequested queries:\n          * Repeatedly pick two random indices s, t from [0..whites.size()-1].\n          * Let (r1, c1) = whites[s], (r2, c2) = whites[t].\n          * If r1 <= r2 AND c1 <= c2, we accept the pair.\n            (Convert them to 1-based and store in queries.)\n          * If not, we discard and retry up to some attempt limit.\n      - If we can't find enough valid pairs by retrial, we'll produce fewer\n        than qRequested queries.\n\n    This method fully avoids accidentally starting on a black cell or \n    reversing row/column coordinates in a way that leads to an invalid query.\n*/\n\nstatic const char BLACK = '#';\nstatic const char WHITE = '.';\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read generator parameters\n    int n = opt<int>(\"n\");         // rows\n    int m = opt<int>(\"m\");         // columns\n    int qRequested = opt<int>(\"q\");// number of queries requested\n    string patternType = opt<string>(\"type\", \"random\");\n    int p = opt<int>(\"p\", 50);     // % chance of white if type==\"random\"\n\n    // Initialize the grid as all white\n    vector<string> grid(n, string(m, WHITE));\n\n    // 1) All white\n    if (patternType == \"allwhite\") {\n        // Already all white\n    }\n    // 2) Almostblack: fill black, ensure a few white cells\n    else if (patternType == \"almostblack\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = BLACK;\n            }\n        }\n        // Force ~10 or up to (n*m/10 + 1) white cells\n        int desiredWhites = min(10, (n*m)/10 + 1);\n        for (int k = 0; k < desiredWhites; k++) {\n            int r = rnd.next(0, n - 1);\n            int c = rnd.next(0, m - 1);\n            grid[r][c] = WHITE;\n        }\n    }\n    // 3) Random: each cell white with probability p%\n    else if (patternType == \"random\") {\n        bool foundWhite = false;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int roll = rnd.next(100); \n                if (roll < p) {\n                    grid[i][j] = WHITE;\n                    foundWhite = true;\n                } else {\n                    grid[i][j] = BLACK;\n                }\n            }\n        }\n        // Ensure at least one white cell\n        if (!foundWhite) {\n            grid[0][0] = WHITE;\n        }\n    }\n    // 4) Checkerboard\n    else if (patternType == \"checkerboard\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (((i + j) & 1) == 0) {\n                    grid[i][j] = WHITE;\n                } else {\n                    grid[i][j] = BLACK;\n                }\n            }\n        }\n    }\n    // Otherwise: treat as random\n    else {\n        bool foundWhite = false;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int roll = rnd.next(100);\n                if (roll < p) {\n                    grid[i][j] = WHITE;\n                    foundWhite = true;\n                } else {\n                    grid[i][j] = BLACK;\n                }\n            }\n        }\n        if (!foundWhite) {\n            grid[0][0] = WHITE;\n        }\n    }\n\n    // Output n, m\n    cout << n << \" \" << m << \"\\n\";\n\n    // Output the grid\n    for (int i = 0; i < n; i++) {\n        cout << grid[i] << \"\\n\";\n    }\n\n    // Collect all white cells\n    vector<pair<int,int>> whites;\n    whites.reserve(n*m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == WHITE) {\n                whites.push_back({i, j});\n            }\n        }\n    }\n\n    // If no white cells, no valid queries\n    if (whites.empty()) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n\n    // Generate queries\n    // We'll accept up to qRequested queries, each must satisfy r1 <= r2, c1 <= c2.\n    vector<array<int,4>> queries;\n    queries.reserve(qRequested);\n\n    // Attempt up to qRequested times; each time, we may need multiple tries\n    // to find a valid pair.\n    for (int i = 0; i < qRequested; i++) {\n        bool foundValid = false;\n        // up to 100 random picks to find a valid pair\n        for (int attempt = 0; attempt < 100; attempt++) {\n            int s = rnd.next(0, (int)whites.size() - 1);\n            int t = rnd.next(0, (int)whites.size() - 1);\n            auto [r1, c1] = whites[s];\n            auto [r2, c2] = whites[t];\n            if (r1 <= r2 && c1 <= c2) {\n                // valid pair; store it\n                queries.push_back({r1+1, c1+1, r2+1, c2+1});\n                foundValid = true;\n                break;\n            }\n        }\n        // if we failed to find in 100 tries, we stop to avoid an infinite loop\n        if (!foundValid) {\n            break;\n        }\n    }\n\n    // Output the number of queries actually chosen\n    cout << (int)queries.size() << \"\\n\";\n    // Output each query\n    for (auto &arr : queries) {\n        cout << arr[0] << \" \" << arr[1] << \" \" << arr[2] << \" \" << arr[3] << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    Final Revised Generator for the \"Tortoise in a Grid\" problem.\n\n    **Key Point** for Checkerboard (and any other pattern):\n      We only choose queries where both the start and end cells are white,\n      and we also ensure rowStart <= rowEnd, colStart <= colEnd.\n      This guarantees the query is valid (the start is never black and \n      x1 ≤ x2, y1 ≤ y2).\n\n    Implementation details:\n      - Gather all white cells in a vector \"whites\".\n      - We attempt to form up to qRequested queries:\n          * Repeatedly pick two random indices s, t from [0..whites.size()-1].\n          * Let (r1, c1) = whites[s], (r2, c2) = whites[t].\n          * If r1 <= r2 AND c1 <= c2, we accept the pair.\n            (Convert them to 1-based and store in queries.)\n          * If not, we discard and retry up to some attempt limit.\n      - If we can't find enough valid pairs by retrial, we'll produce fewer\n        than qRequested queries.\n\n    This method fully avoids accidentally starting on a black cell or \n    reversing row/column coordinates in a way that leads to an invalid query.\n*/\n\nstatic const char BLACK = '#';\nstatic const char WHITE = '.';\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read generator parameters\n    int n = opt<int>(\"n\");         // rows\n    int m = opt<int>(\"m\");         // columns\n    int qRequested = opt<int>(\"q\");// number of queries requested\n    string patternType = opt<string>(\"type\", \"random\");\n    int p = opt<int>(\"p\", 50);     // % chance of white if type==\"random\"\n\n    // Initialize the grid as all white\n    vector<string> grid(n, string(m, WHITE));\n\n    // 1) All white\n    if (patternType == \"allwhite\") {\n        // Already all white\n    }\n    // 2) Almostblack: fill black, ensure a few white cells\n    else if (patternType == \"almostblack\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = BLACK;\n            }\n        }\n        // Force ~10 or up to (n*m/10 + 1) white cells\n        int desiredWhites = min(10, (n*m)/10 + 1);\n        for (int k = 0; k < desiredWhites; k++) {\n            int r = rnd.next(0, n - 1);\n            int c = rnd.next(0, m - 1);\n            grid[r][c] = WHITE;\n        }\n    }\n    // 3) Random: each cell white with probability p%\n    else if (patternType == \"random\") {\n        bool foundWhite = false;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int roll = rnd.next(100); \n                if (roll < p) {\n                    grid[i][j] = WHITE;\n                    foundWhite = true;\n                } else {\n                    grid[i][j] = BLACK;\n                }\n            }\n        }\n        // Ensure at least one white cell\n        if (!foundWhite) {\n            grid[0][0] = WHITE;\n        }\n    }\n    // 4) Checkerboard\n    else if (patternType == \"checkerboard\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (((i + j) & 1) == 0) {\n                    grid[i][j] = WHITE;\n                } else {\n                    grid[i][j] = BLACK;\n                }\n            }\n        }\n    }\n    // Otherwise: treat as random\n    else {\n        bool foundWhite = false;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int roll = rnd.next(100);\n                if (roll < p) {\n                    grid[i][j] = WHITE;\n                    foundWhite = true;\n                } else {\n                    grid[i][j] = BLACK;\n                }\n            }\n        }\n        if (!foundWhite) {\n            grid[0][0] = WHITE;\n        }\n    }\n\n    // Output n, m\n    cout << n << \" \" << m << \"\\n\";\n\n    // Output the grid\n    for (int i = 0; i < n; i++) {\n        cout << grid[i] << \"\\n\";\n    }\n\n    // Collect all white cells\n    vector<pair<int,int>> whites;\n    whites.reserve(n*m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == WHITE) {\n                whites.push_back({i, j});\n            }\n        }\n    }\n\n    // If no white cells, no valid queries\n    if (whites.empty()) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n\n    // Generate queries\n    // We'll accept up to qRequested queries, each must satisfy r1 <= r2, c1 <= c2.\n    vector<array<int,4>> queries;\n    queries.reserve(qRequested);\n\n    // Attempt up to qRequested times; each time, we may need multiple tries\n    // to find a valid pair.\n    for (int i = 0; i < qRequested; i++) {\n        bool foundValid = false;\n        // up to 100 random picks to find a valid pair\n        for (int attempt = 0; attempt < 100; attempt++) {\n            int s = rnd.next(0, (int)whites.size() - 1);\n            int t = rnd.next(0, (int)whites.size() - 1);\n            auto [r1, c1] = whites[s];\n            auto [r2, c2] = whites[t];\n            if (r1 <= r2 && c1 <= c2) {\n                // valid pair; store it\n                queries.push_back({r1+1, c1+1, r2+1, c2+1});\n                foundValid = true;\n                break;\n            }\n        }\n        // if we failed to find in 100 tries, we stop to avoid an infinite loop\n        if (!foundValid) {\n            break;\n        }\n    }\n\n    // Output the number of queries actually chosen\n    cout << (int)queries.size() << \"\\n\";\n    // Output each query\n    for (auto &arr : queries) {\n        cout << arr[0] << \" \" << arr[1] << \" \" << arr[2] << \" \" << arr[3] << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Revised bash commands to test this final generator thoroughly:\n\n# 1) Minimal grid, single cell all white\n./gen -n 1 -m 1 -q 1 -type allwhite\n\n# 2) Single cell, multiple queries (all identical)\n./gen -n 1 -m 1 -q 5 -type random -p 100\n\n# 3) Small grid, allwhite\n./gen -n 3 -m 5 -q 5 -type allwhite\n\n# 4) Small grid, almost all black\n./gen -n 3 -m 6 -q 5 -type almostblack\n\n# 5) Small checkerboard (the scenario that previously failed)\n./gen -n 4 -m 4 -q 5 -type checkerboard\n\n# 6) Small random, 50% white\n./gen -n 5 -m 5 -q 5 -type random -p 50\n\n# 7) Medium random, 30% white\n./gen -n 10 -m 10 -q 10 -type random -p 30\n\n# 8) Medium random, 70% white\n./gen -n 10 -m 12 -q 12 -type random -p 70\n\n# 9) Medium checkerboard\n./gen -n 12 -m 12 -q 15 -type checkerboard\n\n# 10) Medium almostblack\n./gen -n 12 -m 12 -q 15 -type almostblack\n\n# 11) Larger allwhite\n./gen -n 50 -m 50 -q 20 -type allwhite\n\n# 12) Larger checkerboard\n./gen -n 50 -m 60 -q 30 -type checkerboard\n\n# 13) Larger random, 25% white\n./gen -n 80 -m 80 -q 50 -type random -p 25\n\n# 14) Larger random, 75% white\n./gen -n 80 -m 100 -q 50 -type random -p 75\n\n# 15) Even bigger grid, almostblack\n./gen -n 100 -m 100 -q 100 -type almostblack\n\n# 16) Bigger random, half white\n./gen -n 100 -m 120 -q 200 -type random -p 50\n\n# 17) Large allwhite\n./gen -n 200 -m 200 -q 300 -type allwhite\n\n# 18) Large checkerboard\n./gen -n 300 -m 300 -q 500 -type checkerboard\n\n# 19) Max dimension, moderate queries, random\n./gen -n 500 -m 500 -q 1000 -type random -p 50\n\n# 20) Stress test with near-max queries, random\n./gen -n 500 -m 500 -q 600000 -type random -p 30\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:08.452377",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "233/A",
      "title": "A. Perfect Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains a single integer n (1 ≤ n ≤ 100) — the permutation size.",
      "output_spec": "OutputIf a perfect permutation of size n doesn't exist, print a single integer -1. Otherwise print n distinct integers from 1 to n, p1, p2, ..., pn — permutation p, that is perfect. Separate printed numbers by whitespaces.",
      "sample_tests": "ExamplesInputCopy1OutputCopy-1InputCopy2OutputCopy2 1 InputCopy4OutputCopy2 1 4 3",
      "description": "A. Perfect Permutation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains a single integer n (1 ≤ n ≤ 100) — the permutation size.\n\nOutputIf a perfect permutation of size n doesn't exist, print a single integer -1. Otherwise print n distinct integers from 1 to n, p1, p2, ..., pn — permutation p, that is perfect. Separate printed numbers by whitespaces.\n\nInputCopy1OutputCopy-1InputCopy2OutputCopy2 1 InputCopy4OutputCopy2 1 4 3\n\nOutputCopy-1\n\nOutputCopy2 1\n\nOutputCopy2 1 4 3",
      "solutions": [
        {
          "title": "Codeforces Round #144 - Codeforces",
          "content": "Hi all! Codeforces round #144 is going to be today. Round is prepared by: KAN, fdoer, Skird, tunyash. Special thanks to Gerald for coordinating round preparing, many awesome ideas and making statements easy-understandable. Also I thank MikeMirzayanov for enjoyable problem-preparing system, Delinur for statements translation. I hope, that all will be well and you will enjoy solving problems. Good luck!UPD: Score distribution will be announced a few minutes before the start of the contest.UPD2: score distribution is 500-1000-1500-2000-2500 in both divisionsUPD3:Congrats to winners.div1: tourist rng_58 Mimino Dmitry_Egorov, Egor div2: debug22 ryz dvdreddy vinodreddy rdivyanshu UPD: editoral for all problems, except div1.D is ready",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5510",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 737
        },
        {
          "title": "Editorial for Codeforces Round #144 - Codeforces",
          "content": "It will be finised in few hours. If you don't understand something, ask your questions, please.233A - Perfect PermutationIdea: Gerald Implementation: tunyash Editorial: fdoerConsider permutation p such that pi = i. Actually p is a sequence of numbers from 1 to n. Obviously ppi = i. Now the only trick is to change the permutation to satisfy the second equation: pi ≠ i. Let's swap every two consequtive elements. More formally, for each k: 2k ≤ n let's swap p2k - 1 and p2k. It's easy to see that the obtained permutation satisfies both equations for every n with the only exception: when n is odd, there is no answer and we should print  - 1.233B - Non-square EquationIdea: tunyash Implementation: tunyash, Gerald Editorial: fdoerFirstly let's find the interval of possible values of s(x). Hence x2 ≤ n and n ≤ 1018, x ≤ 109. In other words, for every considerable solution x the decimal length of x does not extend 10 digits. So smax ≤ s(9999999999) = 10·9 = 90.Let's bruteforce the value of s(x) (0 ≤ s(x) ≤ 90). Now we have an ordinary square equation. The deal is to solve it and to check that the current bruteforced value of s(x) is equal to sum of digits of the solution. If the solution exists and the equality holds, we should relax the answer.It seems that the most error-generating part of this problem is solving the equation.Knowing arrays is not neccessary to solve these two problems.232A - CyclesIdea: tunyash, fdoer Implementation: tunyash Editorial: tunyashLet's add edge in order of increasing a and for equal b in order of increasing b (here a and b — the least and the greatest vertices of the edge). If the new edge adds too much 3-cycles, we won't add it. We can count the number of new 3-cycles in O(n) complexity (they all contain the new edge, so it's enough to check all variants of the third vertex). Obviously we will obtain some proper graph, because we can always add a vertex and two edges to make a new triangle. So, there is always an answer. The complexity of this solution is O(n3).Let's proof that 100 vertices are always enough for the given restrictions on n. For some p after first p iterations we will have a complete graph of p vertices. Now we have exactly C(p, 3) triangles. Consider p such that C(p, 3) ≤ k and C(p, 3) is maximal. For the given restrictions p ≤ 85. From this moment, if we add u from some vertex, we increase the total number of 3-cycles on C(u, 2). So we have to present a small number that is less than C(85, 3) as sum of C(i, 2). The first number we subtruct will differ C(85, 1) on some value not greater than C(85, 1) = 85, because C(n, k) - C(n - 1, k) = C(n - 1, k - 1). The second number we subtruct will differ the number we have on some value not greater than C(14, 1) = 14. and so on. For every k it's enough to use not more that 90 vertices. 232B - TableIdea: tunyash, Skird Implementation: tunyash Editorial: tunyash Let si number of points in the column i. Two neighboring squares are drawn at this picture, A is the number of point it the left area (it is one column), B is the number of points in the middle area and C is the number of points in the right area (it is one column too). That's why by definition we have: Therefore A = C. That's why Divide all columns by equivalence classes on the basis of . For all a and b from one class sa = sb. cnta is number of columns in class with . There are (Cnk)cnta ways to draw k points in the each of columns in the class a independendently of the other classes. dp[i][j] is number of ways to fill all columns in classes 1, ... i in such way that . cnti take only two values and . Let's calc (Cna)cnti for all a and cnti and use it to calc our dp. We have O(n2·k) complexity. 232C - Doe Graphs Idea: Gerald,tunyash Implementation: tunyash, Gerald Editorial: tunyashLet's reduce the problem to the same problem for graphs with less orders. Vertex |D(n - 1)| + 1 is cutpoint (except cases n ≤ 2 but equations below is true for these cases).Without loss of generality a < b. Let dist(a, b, n) — length of the shortest path in graph of order n.The first case is a ≤ |D(n - 1)| and |D(n - 1)| + 1 ≤ b dist(a, b, n) = min(dist(a, |D(n - 1)|, n - 1), dist(a, 1, n - 1)) + dist(b - |D(n - 1)|, 1, n - 2) + 1Edges is marked in red, paths is marked in blue. This formula means that we can go from the vertex a by the path 1 to the vertex 1. Then we can go to the |D(n - 1)| + 1 by the edge and go to the vertex b by the path 3. Or we can go to the vertex |D(n - 1)| by the path 2 and then go to the vertex |D(n - 1)| + 1 by the path 2 and then go to the vertex b by the path 3.The second case is |D(n - 1)| + 1 ≤ a, b. dist(a, b, n) = dist(a - |D(n - 1)|, b - |D(n - 1)|, n - 2)That's easy case.The third case is a, b ≤ |D(n - 1)| dist(a, b, n) = min(dist(a, b, n - 1), min(dist(1, a, n - 1), dist(|D(n - 1)|, a, n - 1)) + min(dist(1, b, n - 1), dist(|D(n - 1)|, b, n - 1) + 2)If shortest path contains cutpoint (|D(n - 1)| + 1) we can go to the vertex 1 or |D(n - 1)+1$ form the both of a and b. After that we can go to the cutpoint. Else we should consider path from a to b in D(n - 1).Let's notice that for all of n will be no more than 4 distinct runnings of dist(i, j, n).It can be prooved by the considering many cases of our actions.In authors colution we cashed all dist(1, i, n) and dist(i, |D(n)|, n) for all achieveable i and n. We have complexity for one query. (it's log because |D(n)| grows like φn).232D - FenceIdea: Gerald, tunyash Implementation: fdoer Editorial: fdoerLet d and d' be arrays such that di = hi - hi + 1, d'i =  - di for every 1 ≤ i ≤ (n - 1). With that notation the conditions of matching look somehow like these: the pieces do not intersect, that is, there isn't a single plank, such that it occurs in both pieces of the fence; the pieces are of the same width; for all i i (0 ≤ i ≤ r1 - l1 - 1) the following condition holds: dl1 + i = d'l2 + i (that is true in case when l = r). The main idea of our solution is stated in the next sentence. For each query l...r the answer is number of pairs (a, b) such that (a > r or b < l), 1 ≤ a ≤ b ≤ n - 1, b - a = r - l and dl...r - 1 exactly matches d'a...b - 1. Let's build a suffix array sa from the concatenation of arrays d and d' with a fictive number between them for separation. Let position of suffix i in sa be posi. For each query all pieces of the fence that satisfy both second and third conditions of matching will be placed in sa on some segment boundleft...boundright such that boundleft ≤ posl ≤ boundright and lcp(boundleft...boundright) ≥ (r - l). So, it's possible to use binary search to find bound's. Depending on complexity of lcp finding algorithm, we could get them in O(logn) or O(log2n) complexity.But there is still a problem to count the number of suffixes from saboundleft...boundright that satisfy the first condition too. Actually it is equal to count the number of i (boundleft ≤ i ≤ boundright) such that (n + 1 ≤ sai ≤ n + l - (r - l) - 1 or sai ≥ n + r) (in the concatenation d' starts from n + 1). It is a classic problem to count numbers from the given interval in the given subarray. For each query it could be solved in O(logn) complexity.For instance, we could solve it offline using sweep line method and any data structure that support queries of sum on an interval and increment of an element. Or we could use some 2D/persistent structure.So, the summary of the algorithm looks like this: build d and d'. Build a suffix array on their concatenation. For each query: find the interval (boundleft...boundright) with two consecutive binary searches using lcp function. query the count of suffixes from that interval that do not intersect with the given piece of the fence. The best author's solution complexity is O(nlogn + qlogn), but careful written solutions in O(nlog2n) comply with the lime limit too.232E - Quick Tortoise Idea: tunyash Implementation: tunyash, KAN Editorial: tunyashLet's choose central column of the area and for all cells to the left from column calc masks of achieveable cells in the central column and for all cells to the right from column calc masks of cells of which this is achievable. It's easy dp with bitsets. for the right part of board. ( — logical or, here it's bitwise or for masks) for the left part. dp calcs mask of achieveable points in the central column.For query x1, y1, x2, y2 (if y1 ≤ mid ≤ y2, where mid is chosen central column) answer is yes if ( is bitwise and) is not empty.Run this algo for left and right part of board we will get answers for all queries. Complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 233\\s*A"
          },
          "content_length": 8557
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #144 - Codeforces - Code 1",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 2",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 3",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 4",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool exists_perfect_permutation(int n) {\n    return n % 2 == 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt();\n\n    int first_token = ouf.readInt(-1, n, \"first number\");\n\n    if (first_token == -1) {\n        if (exists_perfect_permutation(n)) {\n            quitf(_wa, \"A perfect permutation exists for n = %d, but contestant outputs -1\", n);\n        } else {\n            quitf(_ok, \"Correctly outputs -1 when no perfect permutation exists for n = %d\", n);\n        }\n    } else {\n        vector<int> p(n + 1); // 1-based indexing\n        vector<bool> used(n + 1, false); // 1-based indexing\n\n        p[1] = first_token;\n        if (p[1] < 1 || p[1] > n) {\n            quitf(_wa, \"p[1] = %d is out of range [1, %d]\", p[1], n);\n        }\n        used[p[1]] = true;\n\n        for (int i = 2; i <= n; ++i) {\n            p[i] = ouf.readInt(1, n, format(\"p[%d]\", i).c_str());\n            if (used[p[i]]) {\n                quitf(_wa, \"Duplicate number %d at position %d\", p[i], i);\n            }\n            used[p[i]] = true;\n        }\n\n        for (int i = 1; i <= n; ++i) {\n            if (p[i] == i) {\n                quitf(_wa, \"At position %d, p[%d] == %d\", i, i, i);\n            }\n            if (p[p[i]] != i) {\n                quitf(_wa, \"At position %d, p[p[%d]] != %d\", i, i, i);\n            }\n        }\n\n        quitf(_ok, \"Correct perfect permutation\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) {\n        if (type == \"min\") {\n            n = 1;\n        } else if (type == \"max\") {\n            n = 100;\n        } else if (type == \"small_odd\") {\n            n = rnd.next(1, 9);\n            if (n % 2 == 0) n += 1;\n            if (n > 9) n -= 2;\n        } else if (type == \"small_even\") {\n            n = rnd.next(1, 10);\n            if (n % 2 != 0) n += 1;\n            if (n > 10) n -= 2;\n        } else if (type == \"random_even\") {\n            n = rnd.next(1, 100);\n            if (n % 2 != 0) n += 1;\n            if (n > 100) n -= 2;\n        } else if (type == \"random_odd\") {\n            n = rnd.next(1, 100);\n            if (n % 2 == 0) n += 1;\n            if (n > 100) n -= 2;\n        } else { // \"random\"\n            n = rnd.next(1, 100);\n        }\n    } else {\n        // n is provided\n        if (n < 1 || n > 100) {\n            fprintf(stderr, \"Error: n must be between 1 and 100\\n\");\n            return 1;\n        }\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) {\n        if (type == \"min\") {\n            n = 1;\n        } else if (type == \"max\") {\n            n = 100;\n        } else if (type == \"small_odd\") {\n            n = rnd.next(1, 9);\n            if (n % 2 == 0) n += 1;\n            if (n > 9) n -= 2;\n        } else if (type == \"small_even\") {\n            n = rnd.next(1, 10);\n            if (n % 2 != 0) n += 1;\n            if (n > 10) n -= 2;\n        } else if (type == \"random_even\") {\n            n = rnd.next(1, 100);\n            if (n % 2 != 0) n += 1;\n            if (n > 100) n -= 2;\n        } else if (type == \"random_odd\") {\n            n = rnd.next(1, 100);\n            if (n % 2 == 0) n += 1;\n            if (n > 100) n -= 2;\n        } else { // \"random\"\n            n = rnd.next(1, 100);\n        }\n    } else {\n        // n is provided\n        if (n < 1 || n > 100) {\n            fprintf(stderr, \"Error: n must be between 1 and 100\\n\");\n            return 1;\n        }\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1      # n=1, smallest n, odd\n./gen -n 2      # n=2, smallest even n\n./gen -n 3      # n=3, small odd n\n./gen -n 4      # n=4, small even n\n./gen -n 5      # n=5, small odd n\n./gen -n 6      # n=6, small even n\n./gen -n 7      # n=7, small odd n\n./gen -n 8      # n=8, small even n\n./gen -n 9      # n=9, small odd n\n./gen -n 10     # n=10, small even n\n./gen -n 11     # n=11\n./gen -n 12     # n=12\n./gen -n 50     # n=50, medium even n\n./gen -n 51     # n=51, medium odd n\n./gen -n 97     # n=97, large odd n\n./gen -n 98     # n=98, large even n\n./gen -n 99     # n=99, large odd n near max\n./gen -n 100    # n=100, maximum n\n\n./gen -type min         # n=1\n./gen -type max         # n=100\n./gen -type small_odd   # random small odd n\n./gen -type small_even  # random small even n\n./gen -type random_even # random even n\n./gen -type random_odd  # random odd n\n./gen -type random      # random n between 1 and 100\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type small_odd\n./gen -type small_even\n./gen -type random_even\n./gen -type random_odd\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:10.710613",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "233/B",
      "title": "B. Неквадратное уравнение",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано целое число n (1 ≤ n ≤ 1018) — параметр уравнения.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВыведите -1, если уравнение не имеет целых положительных корней. Иначе выведите такое наименьшее целое x (x > 0), что описанное в условии равенство выполняется.",
      "sample_tests": "ПримерыВходные данныеСкопировать2Выходные данныеСкопировать1Входные данныеСкопировать110Выходные данныеСкопировать10Входные данныеСкопировать4Выходные данныеСкопировать-1",
      "description": "B. Неквадратное уравнение\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записано целое число n (1 ≤ n ≤ 1018) — параметр уравнения.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВыведите -1, если уравнение не имеет целых положительных корней. Иначе выведите такое наименьшее целое x (x > 0), что описанное в условии равенство выполняется.\n\nВыходные данные\n\nВходные данныеСкопировать2Выходные данныеСкопировать1Входные данныеСкопировать110Выходные данныеСкопировать10Входные данныеСкопировать4Выходные данныеСкопировать-1\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать110\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере x = 1 является наименьшим корнем. Так как s(1) = 1 и 12 + 1·1 - 2 = 0.Во втором тестовом примере x = 10 является наименьшим корнем. Так как s(10) = 1 + 0 = 1 и 102 + 1·10 - 110 = 0.В третьем тестовом примере корней у уравнения нет.",
      "solutions": [
        {
          "title": "Codeforces Round #144 - Codeforces",
          "content": "Всем привет! Сегодня состоится очередной codeforces-round. Он пройдет в обоих дивизионах, в каждом из которых будет предложено пять задач разной сложности.В его подготовке, принимало участие несколько человек: KAN, fdoer, Skird, tunyash. Огромное спасибо Gerald, за координацию подготовки задач, множество клевых идей и понятизацию условий. Так же благодарю MikeMirzayanov за отличную систему подготовки задач, Delinur за перевод условий. Надеюсь, все пройдет гладко и вам понравятся задачи. Про разбалловку вы узнаете перед контестом.Удачи!UPD: разбалловка стандартная (500-1000-1500-2000-2500) в обоих дивизионах.UPD: появился очень кратенький разборUPD:Поздравляю победителей! div1: tourist rng_58 Mimino Dmitry_Egorov, Egor div2: debug22 ryz dvdreddy vinodreddy rdivyanshu UPD: есть полный разбор на русском.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5510",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 812
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces",
          "content": "Задачи, которые не успели написать, разберу кратко. Задавайте вопросы.233A - Идеальная перестановкаИдея: Gerald Реализация: tunyash Разбор: fdoerЭту задачу можно было решать разными способами, например, таким: рассмотрим перестановку p, в которой pi = i, то есть просто последовательность чисел от 1 до n. Очевидно, для неё условие ppi = i выполняется всегда. Осталось только преобразовать её таким образом, чтобы выполнялось и второе условие: pi ≠ i. Для этого поменяем местами каждые два соседних элемента, т.е. для каждого k: k * 2 ≤ n поменяем местами значения p2k - 1 и p2k. Нетрудно убедиться, что для полученной перестановки оба условия выполняются всегда.233B - Неквадратное уравнениеИдея: tunyash Реализация: tunyash, Gerald Разбор: fdoerДля начала найдем диапазон значений, которые может принимать s(x). Так как из уравнения x2 ≤ n, а по условию n ≤ 1018, x ≤ 109, иначе говоря, десятичная запись любого решения не длиннее 10 цифр. Значит, максимальное значение smax = s(9999999999) = 10·9 = 90 (на самом деле это грубая оценка, smax даже меньше, но нам достаточно и её).Переберем значение s(x): 0 ≤ s(x) ≤ 90. Получаем обычное квадратное уравнение относительно переменной x. Осталось решить его и проверить равенство того значения s(x), что мы зафиксировали, сумме цифр в разрядах полученного корня. Если корень нашелся и равенство выполнено, обновим ответ.Пожалуй, самое важное в этой задаче — аккуратно и без ошибок вычислений считать дискриминант.Подчеркну, что для решения задач div2.A и div2.B не требовалось знание массивов.232A - Циклы Идея: tunyash, fdoer Реализация: tunyash Разбор: tunyashБудем добавлять ребра в порядке сортировки сначала по вершине в меньшим номером, затем с большим (просто два for'a). Если добавление ребра вызывает переполнение кол-ва циклов, не добавляем его. Считать количество циклов, которые добавятся можно за O(n) (могут появиться только циклы, содержащие добавленное ребро, следовательно достаточно перебрать третью вершину). Очевидно, что это найдет какой-то ответ, потому что, добавив два ребра из вершины мы всегда можем получить 1 треугольник. Тогда получается, что ответ всегда есть. Можно довольно просто доказать, что мы уложимся в 100. Асимптотика решения O(n3).Доказательство Первыми несколькими шагами алгоритма мы сгенерируем полный граф. Потому что каждое ребро можно будет добавить Полученное количество треугольников — C(p, 3) для какого-то p. C(p, 3) ≤ k при этом p максимально. Для данных ограничений p ≤ 85. После первой фазы алгоритма, если из некоторой вершины мы добавляем u ребер, то количество треугольников увеличивается на C(u, 2). Получается, мы представляем маленькое число  ≤ C(85, 2) в виде суммы C(i, 2). Первое число, которое мы вычтем, будет отличаться от нашего не более чем на C(85, 1) = 85, поскольку C(n, k) - C(n - 1, k) = C(n - 1, k - 1). Второе число — не более чем на C(14, 1) = 14. Далее можно применять данную оценку аналогично. Для всех возможных k данный алгоритм укладывается в 90 вершин. Может быть есть что-то более красивое, но вообще на контесте можно было остановиться пункте на пятом и забить. 232B - ТаблицаИдея: tunyash, Skird Реализация: tunyash Разбор: tunyash Пусть si — количество точек в столбце i. На картинке изображены два соседних квадрата n × n, A — количество вершин в левой части рисунка (это один столбец), B — количество точек в средней области и C — количество точек в правой области (это тоже один столбец). По условию, имеем: Следовательно A = C. Таким образом Разделим столбцы на классы эквивалентности по признаку . Для всех a и b из одного класса sa = sb. cnta — количество столбцов в классе с . Существует (Cnk)cnta способов нарисовать по x точек в каждом из столбцов этого класса независимо от других классов. dp[i][j] — количество способов заполнить классы 1, ... i таким образом, что . cnti принимает и . Посчитаем (Cna)cnti для всех a и cnti и будем использовать при подсчете дп. Получаем сложность O(n2·k). 232C - Графы ДоуИдея: tunyash, Gerald Реализация: tunyash, Gerald Разбор: tunyashБудем рекурсивно разворачивать граф, сводя задачу к поиску кратч. пути в графаз меньших порядков. Заметим, что вершина |D(n - 1)| + 1 — точка сочленения (кроме случаев n ≤ 2, но для них описанные ниже равенства так же выполняются). Тогда, если вершины находятся по разные стороны от нее, то путь обязательно через нее проходит. Пусть dist(a, b, n) — длина кратчайшего пути между a и b в графе порядка n. dist(a, b, n) = min(dist(a, |D(n - 1)|, n - 1), dist(a, 1, n - 1)) + dist(b - |D(n - 1)|, 1, n - 2) + 1Красным обозначены ребра, синим — пути. Записанная формула обозначает, что мы можем пойти из вершины a по пути 1 в вершину 1, затем по прямому ребру в вершину |D(n - 1)| + 1 и по пути 3 в вершину b, либо пойти по пути 2, попасть в вершину |D(n - 1)|, пройти по ребру в вершину |D(n - 1)| + 1, а затем по пути 3 в вершину b. Если обе вершины лежат в меньшей половине графа — то dist(a, b, n) = dist(a - |D(n - 1)|, b - |D(n - 1)|, n - 2)Если они лежат в большей половине, то нужно дополнительно разобрать случай прохождения пути через точку сочленения, то есть dist(a, b, n) = min(dist(a, b, n - 1), min(dist(1, a, n - 1), dist(|D(n - 1)|, a, n - 1)) + min(dist(1, b, n - 1), dist(|D(n - 1)|, b, n - 1) + 2)Если искомый путь проходит через точку сочленения, то для каждой вершины мы можем пройти либо в вершину 1, либо в вершину |D(n - 1)| + 1, а затем по прямому ребру в вершину |D(n - 1)| + 1. Если путь не проходит через точку сочленения, то рассмотрим его в графе меньшего порядка.Можно заметить, что для каждого k будет не более 4 различных запусков dist(i, j, n).Как это понять? Во первых, если отбросить запросы, где либо a = 1, либо b = |D(n)|, все запросы получаются из первого последовательным отнятием от изначальной пары (ai, bi) одинаковых чисел Фибоначчи (по построению D(i) — числа Фибоначчи). Получается, таких запросов будет O(n). Запросы вида (1, a) и (a, |D(n)|) можно рассмотреть отдельно, они хорошо выражаются из самих себя. Учитывая то, что все другие запросы получаются друг из друга прибавлением или отнятием чисел Фибоначчи, запросы этого вида тоже будут получаться друг из друга таким образом. Таким образом, у нас будет не более O(1) серий по O(n) запросов. Это не совсем строго, но, вроде, понятно. Это довольно нетривиальный момент, рекомендую задавать вопросы, если непонятно.Получим асимптотику на запрос (логарифм возникает из соображения о том, что размеры графов в зависимости от порядка растут экспоненциально). Важно было запускать алгоритм не для данного n, а для наименьшего n, такого, что max(a, b) ≤ D(n - 1)232D - ЗаборИдея: tunyash, Gerald Реализация: fdoer Разбор: fdoerВ разборе этой задачи подразумевается, что читатель имеет представление о суффиксных массивах и о быстром нахождении lcp (наибольшего общего префикса) двух суффиксов строки. Об этом можно почитать, например, на e-maxx.ru.Итак, пусть d и d' — массивы такие, что di = hi - hi + 1, d'i =  - di для любого 1 ≤ i ≤ (n - 1). Тогда мы можем переформулировать условие, при котором два куска забора считаются подходящими, следующим образом: куски не пересекаются, то есть, нет ни одной доски, такой, что она содержится в обоих кусках забора; куски имеют одинаковую ширину; для любого i (0 ≤ i ≤ r1 - l1 - 1) выполняется dl1 + i = d'l2 + i (если ширина забора — 1, это выполняется всегда). Отсюда возникает следующая идея: для ответа на запрос нам достаточно узнать, сколько подотрезков массива d' длины (r - l) совпадают с отрезком массива d, соответствующим этому запросу, и при этом не пересекаются с ним ни в каком индексе. Построим суффиксный массив sa на последовательности-конкатенации массивов d и d', между которыми поставим еще разделитель — число, которого ни в одном из этих массивов нет. Запомним также для каждого суффикса di его позицию posi в суффиксном массиве. При поступлении нового запроса на отрезке l...r все куски забора, подходящие по второму и третьему условиям, будут началами суффиксов, лежащих в суффиксном массиве подряд на позициях boundleft...boundright, причем boundleft ≤ posl ≤ boundright и lcp(boundleft...boundright) ≥ (r - l). Поэтому границы этого отрезка можно найти с помощью бинарного поиска. В зависимости от реализации функции lcp для отрезка значения bound мы определим за или за . Теперь осталось найти число позиций из saboundleft...boundright, удовлетворяющих еще и первому условию, т.е. таких, которые соответствуют суффиксам d', префикс длины r - l которых не пересекается по индексам с отрезком (l...r - 1). Иными словами, количество i (boundleft ≤ i ≤ boundright) таких, что либо n + 1 ≤ sai ≤ n + l - (r - l) - 1, либо sai ≥ n + r (суффиксы d' начинаются в конкатенации с позиции n + 1, т.к. в массиве d (n - 1) элемент, а на n-ном месте расположен разделитель). Это тоже классическая задача поиска количества чисел из заданного диапазона на заданном отрезке массива, она может быть решена за на запрос. Её можно решать, например, offline с помощью метода scanline и любой структуры данных, поддерживающей запросы суммы на отрезке и увеличения в точке, либо online с помощью персистентных/двумерных структур вроде дерева отрезков.Таким образом, вкратце алгоритм выглядит примерно так: построение массивов d и d'. Построение на конкатенации суффиксного массива. препроцессинг для вычисления lcp на отрезке Для каждого запроса: определение промежутка (boundleft...boundright) с помощью двух бинарных поисков, обращающихся к lcp на отрезке. запрос на число суффиксов, которые лежат в суффиксном массиве на этом промежутке и которые соответствуют подотрезкам, не пересекающимся с отрезком запроса. Если массив строить за , запрос lcp выполнять за O(1) с предподсчетом за (с RMQ на разреженных таблицах), а числа из диапазона искать за на запрос, итоговая асимптотика получается . Однако решения, выполняющие запрос lcp за логарифм с использованием, например, дерева отрезков, тоже укладывались в ограничения.232E - Быстрая Черепаха Идея: tunyash Реализация: tunyash, KAN Разбор: tunyashВыберем центральный столбец на поле. Посчитаем для каждой клетки слева доступные на столбце, для каждой клетки справа те из которых доступна данная. Это простая динамика с битсетами, она полностью аналогична динамике в классической задачи о черепашке, для правой половины доски. ( — логическое или, в данном случае имеется в виду побитовое или для масок) для левой. Динамика считаем маску доступных клеток на центральном столбце.С помощью этих данных мы получим ответы на все запросы, точки которых лежат по разные стороны от выбранного столбца за n/32 на запрос (просто сделаем and битсетов). На картинке кружочками обведены две клетки, через которые может проходить путь между точками запроса. Далее запустимся от двух половинок доски, выполняя тот же алгоритм. Получается время работы . Запросы можно выполнять онлайн, храня для каждой клетки битсетов — множеств доступных клеток на столбцах, выбираемых центральными.Альтернативное решение от mrNobody. Оно оказалось быстрее и проще авторского, но, к сожалению, он не смог сдать его на контесте. Будем считать динамику range[i][j][k] — самую верхнюю и самую нижнюю клетку столбца k, доступную из клетки (i, j). Ее можно считать аналогично динамике из авторского решения. Кроме того посчитаем динамику able[i][j][k] — доступна ли хотя бы одна клетка столбца k из клетки (i, j) при движении влево и вверх. Обе эти динамики можно посчитать за O(n·m2) времени и памяти (потом будет понятно, что на памяти можно сэкономить). Рассмотрим запрос (x1, y1) (x2, y2). Утверждается, что путь из (x1, y1) (x2, y2) существует тогда и только тогда, когда и верно able[x2][y2][y1]. Действительно, рассмотрим три пути. 1 — из (x1, y1) в самую верхнюю доступную клетку столбца y2. 2 — из (x1, y1) в самую нижнюю доступную клетку столбца y2 и 3 — из (x2, y2) в одну из клеток столбца y1. Если эта клетка расположена ниже (x1, y1), то путь 3 пересекает путь 2, а значит мы можем пройти по пути два до точки пересечения, а затем по пути 3 до точки (x2, y2). Случай пересечения путей 1 и 3 аналогичен. Мы получили решение за O(n·m2 + q) времени и такое же количество памяти, однако можно заметить, что хранить все состояния динамики не обязательно, достаточно только q из них. Пользуясь этим, можно сократить используемую память до O(nm + q).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 233\\s*B"
          },
          "content_length": 12233
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #144 - Codeforces - Code 1",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 2",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 3",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 4",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 5",
          "code": "Интересно, а против моего рандомного решения есть контртесты??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\nuint64_t sum(uint64_t x)\n{\n\tuint64_t k,s1,s=0;\n\tk=x;\n\twhile (k>0){\n\t\ts1=k%10;\n\t\tk-=s1;\n\t\ts+=s1;\n\t\tk/=10;\n\t}\n\treturn s;\n}\nint main()\n{\n\tint i;\n\tdouble t;\n\tuint64_t n,z=0,x=1;\n\tscanf(\"%I64d\",&n);\n\tfor (i=1;i<91;i++){\n\t\tt=i*i+4*n;\n\t\tt=sqrt(t);\n\t\tt=t-i;\n\t\tt/=2;\n\t\tif(t-(int)t==0 && (t*t+sum(t)*t-n==0)) {z=1;break;} \n\t}\n\t\n\tif (z)printf(\"%d\\n\",(int)t); else printf(\"-1\");\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\nuint64_t sum(uint64_t x)\n{\n\tuint64_t k,s1,s=0;\n\tk=x;\n\twhile (k>0){\n\t\ts1=k%10;\n\t\tk-=s1;\n\t\ts+=s1;\n\t\tk/=10;\n\t}\n\treturn s;\n}\nint main()\n{\n\tint i;\n\tdouble t;\n\tuint64_t n,z=0,x=1;\n\tscanf(\"%I64d\",&n);\n\tfor (i=1;i<91;i++){\n\t\tt=i*i+4*n;\n\t\tt=sqrt(t);\n\t\tt=t-i;\n\t\tt/=2;\n\t\tif(t-(int)t==0 && (t*t+sum(t)*t-n==0)) {z=1;break;} \n\t}\n\t\n\tif (z)printf(\"%d\\n\",(int)t); else printf(\"-1\");\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 3",
          "code": "fabs(expr) <= eps",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 4",
          "code": "int x = sqrt(i*i+4*n) + 0.5;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator.\n    registerGen(argc, argv, 1);\n\n    // ---------------------------------------------------------\n    // Parse parameters using testlib.h's argument parser (opt).\n    // ---------------------------------------------------------\n    // The user can specify the range [minN, maxN] for n,\n    // and also specify a \"type\" that influences how n is chosen.\n    // By default, minN = 1, maxN = 1000, and type = \"random\".\n    long long minN = opt<long long>(\"minN\", 1LL);\n    long long maxN = opt<long long>(\"maxN\", 1000LL);\n    string type     = opt<string>(\"type\", \"random\");\n\n    // Make sure the range is valid and within [1, 1e18].\n    // In a real contest environment, you might add extra checks here\n    // or simply rely on the test environment to set valid parameters.\n    // We'll do a minimal check:\n    assert(minN >= 1 && maxN >= minN && maxN <= 1000000000000000000LL);\n\n    // We will generate exactly one test case per run of this program.\n    // The test case is just a single number n in [1, 10^18].\n\n    long long n = 0; // The value we will output.\n\n    if (type == \"min\") {\n        // Always produce n = 1.\n        n = 1LL;\n    }\n    else if (type == \"max\") {\n        // Always produce n = 10^18.\n        n = 1000000000000000000LL;\n    }\n    else if (type == \"special\") {\n        // Produce a known tricky value from a small set.\n        // For example, these are from the problem statement’s examples or corner cases:\n        //   2 (solution x=1), 4 (no solution), 110 (solution x=10), 1 (solution x=1),\n        //   999999999999999999 (just below 10^18), etc.\n        vector<long long> specials = {\n            1LL, 2LL, 4LL, 110LL,\n            999999999999999999LL, // near 10^18\n            999999999999999998LL, // also near 10^18\n            999999999999999990LL  // etc.\n        };\n        // Choose one of them at random.\n        n = specials[rnd.next(0, (int)specials.size() - 1)];\n    }\n    else if (type == \"small\") {\n        // Produce a random n in [1, 10^6].\n        // Make sure we don't exceed the user-specified maxN.\n        long long upper = min(maxN, 1000000LL);\n        long long lower = minN;\n        n = rnd.next(lower, upper);\n    }\n    else if (type == \"medium\") {\n        // Produce a random n in [10^6, 10^12] intersected with [minN, maxN].\n        long long lower = max(minN, 1000000LL);\n        long long upper = min(maxN, 1000000000000LL);\n        // If lower > upper, we fallback to the \"random\" approach.\n        if (lower <= upper) {\n            n = rnd.next(lower, upper);\n        } else {\n            n = rnd.next(minN, maxN);\n        }\n    }\n    else if (type == \"large\") {\n        // Produce a random n in [10^12, 10^18] intersected with [minN, maxN].\n        long long lower = max(minN, 1000000000000LL);\n        long long upper = min(maxN, 1000000000000000000LL);\n        // If lower > upper, fallback to random in [minN, maxN].\n        if (lower <= upper) {\n            n = rnd.next(lower, upper);\n        } else {\n            n = rnd.next(minN, maxN);\n        }\n    }\n    else {\n        // Default: \"random\" type\n        // Just pick n in [minN, maxN].\n        n = rnd.next(minN, maxN);\n    }\n\n    // Finally, print n.\n    // The problem statement says to print a single line with the integer n.\n    cout << n << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator.\n    registerGen(argc, argv, 1);\n\n    // ---------------------------------------------------------\n    // Parse parameters using testlib.h's argument parser (opt).\n    // ---------------------------------------------------------\n    // The user can specify the range [minN, maxN] for n,\n    // and also specify a \"type\" that influences how n is chosen.\n    // By default, minN = 1, maxN = 1000, and type = \"random\".\n    long long minN = opt<long long>(\"minN\", 1LL);\n    long long maxN = opt<long long>(\"maxN\", 1000LL);\n    string type     = opt<string>(\"type\", \"random\");\n\n    // Make sure the range is valid and within [1, 1e18].\n    // In a real contest environment, you might add extra checks here\n    // or simply rely on the test environment to set valid parameters.\n    // We'll do a minimal check:\n    assert(minN >= 1 && maxN >= minN && maxN <= 1000000000000000000LL);\n\n    // We will generate exactly one test case per run of this program.\n    // The test case is just a single number n in [1, 10^18].\n\n    long long n = 0; // The value we will output.\n\n    if (type == \"min\") {\n        // Always produce n = 1.\n        n = 1LL;\n    }\n    else if (type == \"max\") {\n        // Always produce n = 10^18.\n        n = 1000000000000000000LL;\n    }\n    else if (type == \"special\") {\n        // Produce a known tricky value from a small set.\n        // For example, these are from the problem statement’s examples or corner cases:\n        //   2 (solution x=1), 4 (no solution), 110 (solution x=10), 1 (solution x=1),\n        //   999999999999999999 (just below 10^18), etc.\n        vector<long long> specials = {\n            1LL, 2LL, 4LL, 110LL,\n            999999999999999999LL, // near 10^18\n            999999999999999998LL, // also near 10^18\n            999999999999999990LL  // etc.\n        };\n        // Choose one of them at random.\n        n = specials[rnd.next(0, (int)specials.size() - 1)];\n    }\n    else if (type == \"small\") {\n        // Produce a random n in [1, 10^6].\n        // Make sure we don't exceed the user-specified maxN.\n        long long upper = min(maxN, 1000000LL);\n        long long lower = minN;\n        n = rnd.next(lower, upper);\n    }\n    else if (type == \"medium\") {\n        // Produce a random n in [10^6, 10^12] intersected with [minN, maxN].\n        long long lower = max(minN, 1000000LL);\n        long long upper = min(maxN, 1000000000000LL);\n        // If lower > upper, we fallback to the \"random\" approach.\n        if (lower <= upper) {\n            n = rnd.next(lower, upper);\n        } else {\n            n = rnd.next(minN, maxN);\n        }\n    }\n    else if (type == \"large\") {\n        // Produce a random n in [10^12, 10^18] intersected with [minN, maxN].\n        long long lower = max(minN, 1000000000000LL);\n        long long upper = min(maxN, 1000000000000000000LL);\n        // If lower > upper, fallback to random in [minN, maxN].\n        if (lower <= upper) {\n            n = rnd.next(lower, upper);\n        } else {\n            n = rnd.next(minN, maxN);\n        }\n    }\n    else {\n        // Default: \"random\" type\n        // Just pick n in [minN, maxN].\n        n = rnd.next(minN, maxN);\n    }\n\n    // Finally, print n.\n    // The problem statement says to print a single line with the integer n.\n    cout << n << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are about 20 distinct example commands to run this generator.\n# Each will produce exactly one test case (a single line with one integer n).\n\n# 1) Min boundary\n./gen -type min\n\n# 2) Max boundary\n./gen -type max\n\n# 3) Special corner cases\n./gen -type special\n\n# 4) Small random in default range (1..1000)\n./gen\n\n# 5) Small random in range [1..1000], explicitly\n./gen -type random -minN 1 -maxN 1000\n\n# 6) Random in range [1..10]\n./gen -type random -minN 1 -maxN 10\n\n# 7) Small type (range forced to [1..10^6] then clipped by user constraints)\n./gen -type small -minN 1 -maxN 500000\n\n# 8) Medium type in [10^6..10^12], intersect with [1..10^13]\n./gen -type medium -minN 1 -maxN 10000000000000\n\n# 9) Large type in [10^12..10^18], only up to [10^15]\n./gen -type large -minN 1000000000000 -maxN 1000000000000000\n\n# 10) Another small type\n./gen -type small -minN 10 -maxN 200\n\n# 11) Another large type\n./gen -type large -minN 5000000000000 -maxN 999999999999999999\n\n# 12) Special corners again\n./gen -type special\n\n# 13) Random in [50..60]\n./gen -type random -minN 50 -maxN 60\n\n# 14) Random in [999999999999999900..1000000000000000000]\n./gen -type random -minN 999999999999999900 -maxN 1000000000000000000\n\n# 15) Medium type in a narrow range\n./gen -type medium -minN 500000 -maxN 2000000\n\n# 16) Large type in a narrower range\n./gen -type large -minN 1000000000000 -maxN 2000000000000\n\n# 17) Another special\n./gen -type special\n\n# 18) Another random with big range\n./gen -type random -minN 123456789 -maxN 98765432123456789\n\n# 19) Medium type partially overlapping big range\n./gen -type medium -minN 999000000 -maxN 999999999999\n\n# 20) One more small-type test\n./gen -type small -minN 90 -maxN 130\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:12.322921",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "233/C",
      "title": "C. Циклы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано целое число k (1 ≤ k ≤ 105) — количество циклов длины 3 в искомом графе.",
      "output_spec": "Выходные данныеВ первой строке выведите целое число n (3 ≤ n ≤ 100) — количество вершин в найденном графе. В следующих n строках выведите по n символов «0» и «1»: i-тый символ j-той из этих строк должен быть равен «0», если между вершинами i и j нет ребра и «1» в противном случае. Обратите внимание, так как искомый граф неориентированный, i-тый символ j-той строки должен быть равен j-тому символу i-той строки. Граф не должен содержать петель, поэтому i-тый символ i-той строки должен быть равен «0» для всех i.",
      "sample_tests": "ПримерыВходные данныеСкопировать1Выходные данныеСкопировать3011101110Входные данныеСкопировать10Выходные данныеСкопировать50111110111110111110111110",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записано целое число k (1 ≤ k ≤ 105) — количество циклов длины 3 в искомом графе.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите целое число n (3 ≤ n ≤ 100) — количество вершин в найденном графе. В следующих n строках выведите по n символов «0» и «1»: i-тый символ j-той из этих строк должен быть равен «0», если между вершинами i и j нет ребра и «1» в противном случае. Обратите внимание, так как искомый граф неориентированный, i-тый символ j-той строки должен быть равен j-тому символу i-той строки. Граф не должен содержать петель, поэтому i-тый символ i-той строки должен быть равен «0» для всех i.\n\nВыходные данные\n\nВходные данныеСкопировать1Выходные данныеСкопировать3011101110Входные данныеСкопировать10Выходные данныеСкопировать50111110111110111110111110\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3011101110\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать50111110111110111110111110\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #144 - Codeforces",
          "content": "Всем привет! Сегодня состоится очередной codeforces-round. Он пройдет в обоих дивизионах, в каждом из которых будет предложено пять задач разной сложности.В его подготовке, принимало участие несколько человек: KAN, fdoer, Skird, tunyash. Огромное спасибо Gerald, за координацию подготовки задач, множество клевых идей и понятизацию условий. Так же благодарю MikeMirzayanov за отличную систему подготовки задач, Delinur за перевод условий. Надеюсь, все пройдет гладко и вам понравятся задачи. Про разбалловку вы узнаете перед контестом.Удачи!UPD: разбалловка стандартная (500-1000-1500-2000-2500) в обоих дивизионах.UPD: появился очень кратенький разборUPD:Поздравляю победителей! div1: tourist rng_58 Mimino Dmitry_Egorov, Egor div2: debug22 ryz dvdreddy vinodreddy rdivyanshu UPD: есть полный разбор на русском.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5510",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 812
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces",
          "content": "Задачи, которые не успели написать, разберу кратко. Задавайте вопросы.233A - Идеальная перестановкаИдея: Gerald Реализация: tunyash Разбор: fdoerЭту задачу можно было решать разными способами, например, таким: рассмотрим перестановку p, в которой pi = i, то есть просто последовательность чисел от 1 до n. Очевидно, для неё условие ppi = i выполняется всегда. Осталось только преобразовать её таким образом, чтобы выполнялось и второе условие: pi ≠ i. Для этого поменяем местами каждые два соседних элемента, т.е. для каждого k: k * 2 ≤ n поменяем местами значения p2k - 1 и p2k. Нетрудно убедиться, что для полученной перестановки оба условия выполняются всегда.233B - Неквадратное уравнениеИдея: tunyash Реализация: tunyash, Gerald Разбор: fdoerДля начала найдем диапазон значений, которые может принимать s(x). Так как из уравнения x2 ≤ n, а по условию n ≤ 1018, x ≤ 109, иначе говоря, десятичная запись любого решения не длиннее 10 цифр. Значит, максимальное значение smax = s(9999999999) = 10·9 = 90 (на самом деле это грубая оценка, smax даже меньше, но нам достаточно и её).Переберем значение s(x): 0 ≤ s(x) ≤ 90. Получаем обычное квадратное уравнение относительно переменной x. Осталось решить его и проверить равенство того значения s(x), что мы зафиксировали, сумме цифр в разрядах полученного корня. Если корень нашелся и равенство выполнено, обновим ответ.Пожалуй, самое важное в этой задаче — аккуратно и без ошибок вычислений считать дискриминант.Подчеркну, что для решения задач div2.A и div2.B не требовалось знание массивов.232A - Циклы Идея: tunyash, fdoer Реализация: tunyash Разбор: tunyashБудем добавлять ребра в порядке сортировки сначала по вершине в меньшим номером, затем с большим (просто два for'a). Если добавление ребра вызывает переполнение кол-ва циклов, не добавляем его. Считать количество циклов, которые добавятся можно за O(n) (могут появиться только циклы, содержащие добавленное ребро, следовательно достаточно перебрать третью вершину). Очевидно, что это найдет какой-то ответ, потому что, добавив два ребра из вершины мы всегда можем получить 1 треугольник. Тогда получается, что ответ всегда есть. Можно довольно просто доказать, что мы уложимся в 100. Асимптотика решения O(n3).Доказательство Первыми несколькими шагами алгоритма мы сгенерируем полный граф. Потому что каждое ребро можно будет добавить Полученное количество треугольников — C(p, 3) для какого-то p. C(p, 3) ≤ k при этом p максимально. Для данных ограничений p ≤ 85. После первой фазы алгоритма, если из некоторой вершины мы добавляем u ребер, то количество треугольников увеличивается на C(u, 2). Получается, мы представляем маленькое число  ≤ C(85, 2) в виде суммы C(i, 2). Первое число, которое мы вычтем, будет отличаться от нашего не более чем на C(85, 1) = 85, поскольку C(n, k) - C(n - 1, k) = C(n - 1, k - 1). Второе число — не более чем на C(14, 1) = 14. Далее можно применять данную оценку аналогично. Для всех возможных k данный алгоритм укладывается в 90 вершин. Может быть есть что-то более красивое, но вообще на контесте можно было остановиться пункте на пятом и забить. 232B - ТаблицаИдея: tunyash, Skird Реализация: tunyash Разбор: tunyash Пусть si — количество точек в столбце i. На картинке изображены два соседних квадрата n × n, A — количество вершин в левой части рисунка (это один столбец), B — количество точек в средней области и C — количество точек в правой области (это тоже один столбец). По условию, имеем: Следовательно A = C. Таким образом Разделим столбцы на классы эквивалентности по признаку . Для всех a и b из одного класса sa = sb. cnta — количество столбцов в классе с . Существует (Cnk)cnta способов нарисовать по x точек в каждом из столбцов этого класса независимо от других классов. dp[i][j] — количество способов заполнить классы 1, ... i таким образом, что . cnti принимает и . Посчитаем (Cna)cnti для всех a и cnti и будем использовать при подсчете дп. Получаем сложность O(n2·k). 232C - Графы ДоуИдея: tunyash, Gerald Реализация: tunyash, Gerald Разбор: tunyashБудем рекурсивно разворачивать граф, сводя задачу к поиску кратч. пути в графаз меньших порядков. Заметим, что вершина |D(n - 1)| + 1 — точка сочленения (кроме случаев n ≤ 2, но для них описанные ниже равенства так же выполняются). Тогда, если вершины находятся по разные стороны от нее, то путь обязательно через нее проходит. Пусть dist(a, b, n) — длина кратчайшего пути между a и b в графе порядка n. dist(a, b, n) = min(dist(a, |D(n - 1)|, n - 1), dist(a, 1, n - 1)) + dist(b - |D(n - 1)|, 1, n - 2) + 1Красным обозначены ребра, синим — пути. Записанная формула обозначает, что мы можем пойти из вершины a по пути 1 в вершину 1, затем по прямому ребру в вершину |D(n - 1)| + 1 и по пути 3 в вершину b, либо пойти по пути 2, попасть в вершину |D(n - 1)|, пройти по ребру в вершину |D(n - 1)| + 1, а затем по пути 3 в вершину b. Если обе вершины лежат в меньшей половине графа — то dist(a, b, n) = dist(a - |D(n - 1)|, b - |D(n - 1)|, n - 2)Если они лежат в большей половине, то нужно дополнительно разобрать случай прохождения пути через точку сочленения, то есть dist(a, b, n) = min(dist(a, b, n - 1), min(dist(1, a, n - 1), dist(|D(n - 1)|, a, n - 1)) + min(dist(1, b, n - 1), dist(|D(n - 1)|, b, n - 1) + 2)Если искомый путь проходит через точку сочленения, то для каждой вершины мы можем пройти либо в вершину 1, либо в вершину |D(n - 1)| + 1, а затем по прямому ребру в вершину |D(n - 1)| + 1. Если путь не проходит через точку сочленения, то рассмотрим его в графе меньшего порядка.Можно заметить, что для каждого k будет не более 4 различных запусков dist(i, j, n).Как это понять? Во первых, если отбросить запросы, где либо a = 1, либо b = |D(n)|, все запросы получаются из первого последовательным отнятием от изначальной пары (ai, bi) одинаковых чисел Фибоначчи (по построению D(i) — числа Фибоначчи). Получается, таких запросов будет O(n). Запросы вида (1, a) и (a, |D(n)|) можно рассмотреть отдельно, они хорошо выражаются из самих себя. Учитывая то, что все другие запросы получаются друг из друга прибавлением или отнятием чисел Фибоначчи, запросы этого вида тоже будут получаться друг из друга таким образом. Таким образом, у нас будет не более O(1) серий по O(n) запросов. Это не совсем строго, но, вроде, понятно. Это довольно нетривиальный момент, рекомендую задавать вопросы, если непонятно.Получим асимптотику на запрос (логарифм возникает из соображения о том, что размеры графов в зависимости от порядка растут экспоненциально). Важно было запускать алгоритм не для данного n, а для наименьшего n, такого, что max(a, b) ≤ D(n - 1)232D - ЗаборИдея: tunyash, Gerald Реализация: fdoer Разбор: fdoerВ разборе этой задачи подразумевается, что читатель имеет представление о суффиксных массивах и о быстром нахождении lcp (наибольшего общего префикса) двух суффиксов строки. Об этом можно почитать, например, на e-maxx.ru.Итак, пусть d и d' — массивы такие, что di = hi - hi + 1, d'i =  - di для любого 1 ≤ i ≤ (n - 1). Тогда мы можем переформулировать условие, при котором два куска забора считаются подходящими, следующим образом: куски не пересекаются, то есть, нет ни одной доски, такой, что она содержится в обоих кусках забора; куски имеют одинаковую ширину; для любого i (0 ≤ i ≤ r1 - l1 - 1) выполняется dl1 + i = d'l2 + i (если ширина забора — 1, это выполняется всегда). Отсюда возникает следующая идея: для ответа на запрос нам достаточно узнать, сколько подотрезков массива d' длины (r - l) совпадают с отрезком массива d, соответствующим этому запросу, и при этом не пересекаются с ним ни в каком индексе. Построим суффиксный массив sa на последовательности-конкатенации массивов d и d', между которыми поставим еще разделитель — число, которого ни в одном из этих массивов нет. Запомним также для каждого суффикса di его позицию posi в суффиксном массиве. При поступлении нового запроса на отрезке l...r все куски забора, подходящие по второму и третьему условиям, будут началами суффиксов, лежащих в суффиксном массиве подряд на позициях boundleft...boundright, причем boundleft ≤ posl ≤ boundright и lcp(boundleft...boundright) ≥ (r - l). Поэтому границы этого отрезка можно найти с помощью бинарного поиска. В зависимости от реализации функции lcp для отрезка значения bound мы определим за или за . Теперь осталось найти число позиций из saboundleft...boundright, удовлетворяющих еще и первому условию, т.е. таких, которые соответствуют суффиксам d', префикс длины r - l которых не пересекается по индексам с отрезком (l...r - 1). Иными словами, количество i (boundleft ≤ i ≤ boundright) таких, что либо n + 1 ≤ sai ≤ n + l - (r - l) - 1, либо sai ≥ n + r (суффиксы d' начинаются в конкатенации с позиции n + 1, т.к. в массиве d (n - 1) элемент, а на n-ном месте расположен разделитель). Это тоже классическая задача поиска количества чисел из заданного диапазона на заданном отрезке массива, она может быть решена за на запрос. Её можно решать, например, offline с помощью метода scanline и любой структуры данных, поддерживающей запросы суммы на отрезке и увеличения в точке, либо online с помощью персистентных/двумерных структур вроде дерева отрезков.Таким образом, вкратце алгоритм выглядит примерно так: построение массивов d и d'. Построение на конкатенации суффиксного массива. препроцессинг для вычисления lcp на отрезке Для каждого запроса: определение промежутка (boundleft...boundright) с помощью двух бинарных поисков, обращающихся к lcp на отрезке. запрос на число суффиксов, которые лежат в суффиксном массиве на этом промежутке и которые соответствуют подотрезкам, не пересекающимся с отрезком запроса. Если массив строить за , запрос lcp выполнять за O(1) с предподсчетом за (с RMQ на разреженных таблицах), а числа из диапазона искать за на запрос, итоговая асимптотика получается . Однако решения, выполняющие запрос lcp за логарифм с использованием, например, дерева отрезков, тоже укладывались в ограничения.232E - Быстрая Черепаха Идея: tunyash Реализация: tunyash, KAN Разбор: tunyashВыберем центральный столбец на поле. Посчитаем для каждой клетки слева доступные на столбце, для каждой клетки справа те из которых доступна данная. Это простая динамика с битсетами, она полностью аналогична динамике в классической задачи о черепашке, для правой половины доски. ( — логическое или, в данном случае имеется в виду побитовое или для масок) для левой. Динамика считаем маску доступных клеток на центральном столбце.С помощью этих данных мы получим ответы на все запросы, точки которых лежат по разные стороны от выбранного столбца за n/32 на запрос (просто сделаем and битсетов). На картинке кружочками обведены две клетки, через которые может проходить путь между точками запроса. Далее запустимся от двух половинок доски, выполняя тот же алгоритм. Получается время работы . Запросы можно выполнять онлайн, храня для каждой клетки битсетов — множеств доступных клеток на столбцах, выбираемых центральными.Альтернативное решение от mrNobody. Оно оказалось быстрее и проще авторского, но, к сожалению, он не смог сдать его на контесте. Будем считать динамику range[i][j][k] — самую верхнюю и самую нижнюю клетку столбца k, доступную из клетки (i, j). Ее можно считать аналогично динамике из авторского решения. Кроме того посчитаем динамику able[i][j][k] — доступна ли хотя бы одна клетка столбца k из клетки (i, j) при движении влево и вверх. Обе эти динамики можно посчитать за O(n·m2) времени и памяти (потом будет понятно, что на памяти можно сэкономить). Рассмотрим запрос (x1, y1) (x2, y2). Утверждается, что путь из (x1, y1) (x2, y2) существует тогда и только тогда, когда и верно able[x2][y2][y1]. Действительно, рассмотрим три пути. 1 — из (x1, y1) в самую верхнюю доступную клетку столбца y2. 2 — из (x1, y1) в самую нижнюю доступную клетку столбца y2 и 3 — из (x2, y2) в одну из клеток столбца y1. Если эта клетка расположена ниже (x1, y1), то путь 3 пересекает путь 2, а значит мы можем пройти по пути два до точки пересечения, а затем по пути 3 до точки (x2, y2). Случай пересечения путей 1 и 3 аналогичен. Мы получили решение за O(n·m2 + q) времени и такое же количество памяти, однако можно заметить, что хранить все состояния динамики не обязательно, достаточно только q из них. Пользуясь этим, можно сократить используемую память до O(nm + q).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 233 和字母"
          },
          "content_length": 12233
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #144 - Codeforces - Code 1",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 2",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 3",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 4",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 5",
          "code": "Интересно, а против моего рандомного решения есть контртесты??",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 1",
          "code": "#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\nuint64_t sum(uint64_t x)\n{\n\tuint64_t k,s1,s=0;\n\tk=x;\n\twhile (k>0){\n\t\ts1=k%10;\n\t\tk-=s1;\n\t\ts+=s1;\n\t\tk/=10;\n\t}\n\treturn s;\n}\nint main()\n{\n\tint i;\n\tdouble t;\n\tuint64_t n,z=0,x=1;\n\tscanf(\"%I64d\",&n);\n\tfor (i=1;i<91;i++){\n\t\tt=i*i+4*n;\n\t\tt=sqrt(t);\n\t\tt=t-i;\n\t\tt/=2;\n\t\tif(t-(int)t==0 && (t*t+sum(t)*t-n==0)) {z=1;break;} \n\t}\n\t\n\tif (z)printf(\"%d\\n\",(int)t); else printf(\"-1\");\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 2",
          "code": "#include <stdio.h>\n#include <math.h>\n#include <stdint.h>\nuint64_t sum(uint64_t x)\n{\n\tuint64_t k,s1,s=0;\n\tk=x;\n\twhile (k>0){\n\t\ts1=k%10;\n\t\tk-=s1;\n\t\ts+=s1;\n\t\tk/=10;\n\t}\n\treturn s;\n}\nint main()\n{\n\tint i;\n\tdouble t;\n\tuint64_t n,z=0,x=1;\n\tscanf(\"%I64d\",&n);\n\tfor (i=1;i<91;i++){\n\t\tt=i*i+4*n;\n\t\tt=sqrt(t);\n\t\tt=t-i;\n\t\tt/=2;\n\t\tif(t-(int)t==0 && (t*t+sum(t)*t-n==0)) {z=1;break;} \n\t}\n\t\n\tif (z)printf(\"%d\\n\",(int)t); else printf(\"-1\");\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 3",
          "code": "fabs(expr) <= eps",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #144 - Codeforces - Code 4",
          "code": "int x = sqrt(i*i+4*n) + 0.5;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5514",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read input k from inf\n    int k = inf.readInt(1, 100000, \"k\");\n    \n    // Read contestant's output from ouf\n    int n = ouf.readInt(3, 100, \"n\");\n    vector<string> adj(n);\n    for(int i = 0; i < n; ++i) {\n        adj[i] = ouf.readToken();\n        if (adj[i].length() != n) {\n            quitf(_wa, \"Line %d does not contain %d characters\", i+2, n);\n        }\n    }\n    \n    // Build the adjacency matrix and validate\n    vector<vector<int>> matrix(n, vector<int>(n));\n    for(int i = 0; i < n; ++i) {\n        string line = adj[i];\n        if (line.size() != n) {\n            quitf(_wa, \"Line %d does not contain %d characters\", i+2, n);\n        }\n        for(int j = 0; j < n; ++j) {\n            char c = line[j];\n            if (c != '0' && c != '1') {\n                quitf(_wa, \"Invalid character '%c' in line %d position %d\", c, i+2, j+1);\n            }\n            matrix[i][j] = c - '0';\n            if (i == j && matrix[i][j] != 0) {\n                quitf(_wa, \"Self-loop at vertex %d\", i+1);\n            }\n        }\n    }\n    \n    // Check symmetry\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if (matrix[i][j] != matrix[j][i]) {\n                quitf(_wa, \"Adjacency matrix is not symmetric at positions (%d,%d) and (%d,%d)\", i+1, j+1, j+1, i+1);\n            }\n        }\n    }\n    \n    // Count the number of cycles of length 3\n    long long num_cycles = 0;\n    for(int i = 0; i < n; ++i) {\n        for(int j = i+1; j < n; ++j) {\n            if (matrix[i][j]) {\n                for(int k = j+1; k < n; ++k) {\n                    if (matrix[i][k] && matrix[j][k]) {\n                        // Found a triangle\n                        num_cycles++;\n                    }\n                }\n            }\n        }\n    }\n    \n    if (num_cycles != k) {\n        quitf(_wa, \"Number of cycles of length 3 is %lld, expected %d\", num_cycles, k);\n    }\n    \n    quitf(_ok, \"Found %lld cycles of length 3\", num_cycles);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int min_k = opt<int>(\"min_k\", 1);\n    int max_k = opt<int>(\"max_k\", 100000); // Ensure max_k ≤ 100000\n    string type = opt<string>(\"type\", \"random\");\n\n    int k;\n\n    if(type == \"min\") {\n        k = min_k;\n    } else if(type == \"max\") {\n        k = max_k;\n    } else if(type == \"small\") {\n        k = rnd.next(min_k, min(max_k, 100));\n    } else if(type == \"large\") {\n        k = rnd.next(max(min_k, 90000), max_k);\n    } else if(type == \"edge\") {\n        // Edge cases\n        vector<int> edges;\n        edges.push_back(1);               // Minimal k\n        edges.push_back(2);               // Small k\n        edges.push_back(3);\n        edges.push_back(100000);          // Max k\n        edges.push_back(99999);           // Near max k\n        edges.push_back(50000);           // Medium k\n        edges.push_back(99998);\n        edges.push_back(99990);\n        edges.push_back(100);             // Small k\n        edges.push_back(9999);\n\n        k = edges[rnd.next(0, (int)edges.size()-1)];\n    } else if(type == \"random\") {\n        k = rnd.next(min_k, max_k);\n    } else {\n        // Default is random\n        k = rnd.next(min_k, max_k);\n    }\n\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int min_k = opt<int>(\"min_k\", 1);\n    int max_k = opt<int>(\"max_k\", 100000); // Ensure max_k ≤ 100000\n    string type = opt<string>(\"type\", \"random\");\n\n    int k;\n\n    if(type == \"min\") {\n        k = min_k;\n    } else if(type == \"max\") {\n        k = max_k;\n    } else if(type == \"small\") {\n        k = rnd.next(min_k, min(max_k, 100));\n    } else if(type == \"large\") {\n        k = rnd.next(max(min_k, 90000), max_k);\n    } else if(type == \"edge\") {\n        // Edge cases\n        vector<int> edges;\n        edges.push_back(1);               // Minimal k\n        edges.push_back(2);               // Small k\n        edges.push_back(3);\n        edges.push_back(100000);          // Max k\n        edges.push_back(99999);           // Near max k\n        edges.push_back(50000);           // Medium k\n        edges.push_back(99998);\n        edges.push_back(99990);\n        edges.push_back(100);             // Small k\n        edges.push_back(9999);\n\n        k = edges[rnd.next(0, (int)edges.size()-1)];\n    } else if(type == \"random\") {\n        k = rnd.next(min_k, max_k);\n    } else {\n        // Default is random\n        k = rnd.next(min_k, max_k);\n    }\n\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type large\n./gen -type large\n./gen -type large\n\n./gen -type edge\n./gen -type edge\n./gen -type edge\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -min_k 1 -max_k 10 -type random\n./gen -min_k 1 -max_k 10 -type random\n./gen -min_k 1 -max_k 10 -type random\n\n./gen -min_k 99990 -max_k 100000 -type random\n./gen -min_k 99990 -max_k 100000 -type random\n./gen -min_k 99990 -max_k 100000 -type random\n\n./gen -min_k 50000 -max_k 50000 -type random\n\n./gen -min_k 12345 -max_k 12345 -type random\n\n./gen -min_k 99999 -max_k 99999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:14.334576",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "233/D",
      "title": "D. Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains space-separated integers n, m, k (1 ≤ n ≤ 100; n ≤ m ≤ 1018; 0 ≤ k ≤ n2) — the number of rows of the table, the number of columns of the table and the number of points each square must contain.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputIn a single line print a single integer — the remainder from dividing the described number of ways by 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy5 6 1OutputCopy45",
      "description": "time limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains space-separated integers n, m, k (1 ≤ n ≤ 100; n ≤ m ≤ 1018; 0 ≤ k ≤ n2) — the number of rows of the table, the number of columns of the table and the number of points each square must contain.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputIn a single line print a single integer — the remainder from dividing the described number of ways by 1000000007 (109 + 7).\n\nInputCopy5 6 1OutputCopy45\n\nInputCopy5 6 1\n\nOutputCopy45\n\nNoteLet's consider the first test case:     The gray area belongs to both 5 × 5 squares. So, if it has one point, then there shouldn't be points in any other place. If one of the white areas has a point, then the other one also must have a point. Thus, there are about 20 variants, where the point lies in the gray area and 25 variants, where each of the white areas contains a point. Overall there are 45 variants.",
      "solutions": [
        {
          "title": "Codeforces Round #144 - Codeforces",
          "content": "Hi all! Codeforces round #144 is going to be today. Round is prepared by: KAN, fdoer, Skird, tunyash. Special thanks to Gerald for coordinating round preparing, many awesome ideas and making statements easy-understandable. Also I thank MikeMirzayanov for enjoyable problem-preparing system, Delinur for statements translation. I hope, that all will be well and you will enjoy solving problems. Good luck!UPD: Score distribution will be announced a few minutes before the start of the contest.UPD2: score distribution is 500-1000-1500-2000-2500 in both divisionsUPD3:Congrats to winners.div1: tourist rng_58 Mimino Dmitry_Egorov, Egor div2: debug22 ryz dvdreddy vinodreddy rdivyanshu UPD: editoral for all problems, except div1.D is ready",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5510",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 737
        },
        {
          "title": "Editorial for Codeforces Round #144 - Codeforces",
          "content": "It will be finised in few hours. If you don't understand something, ask your questions, please.233A - Perfect PermutationIdea: Gerald Implementation: tunyash Editorial: fdoerConsider permutation p such that pi = i. Actually p is a sequence of numbers from 1 to n. Obviously ppi = i. Now the only trick is to change the permutation to satisfy the second equation: pi ≠ i. Let's swap every two consequtive elements. More formally, for each k: 2k ≤ n let's swap p2k - 1 and p2k. It's easy to see that the obtained permutation satisfies both equations for every n with the only exception: when n is odd, there is no answer and we should print  - 1.233B - Non-square EquationIdea: tunyash Implementation: tunyash, Gerald Editorial: fdoerFirstly let's find the interval of possible values of s(x). Hence x2 ≤ n and n ≤ 1018, x ≤ 109. In other words, for every considerable solution x the decimal length of x does not extend 10 digits. So smax ≤ s(9999999999) = 10·9 = 90.Let's bruteforce the value of s(x) (0 ≤ s(x) ≤ 90). Now we have an ordinary square equation. The deal is to solve it and to check that the current bruteforced value of s(x) is equal to sum of digits of the solution. If the solution exists and the equality holds, we should relax the answer.It seems that the most error-generating part of this problem is solving the equation.Knowing arrays is not neccessary to solve these two problems.232A - CyclesIdea: tunyash, fdoer Implementation: tunyash Editorial: tunyashLet's add edge in order of increasing a and for equal b in order of increasing b (here a and b — the least and the greatest vertices of the edge). If the new edge adds too much 3-cycles, we won't add it. We can count the number of new 3-cycles in O(n) complexity (they all contain the new edge, so it's enough to check all variants of the third vertex). Obviously we will obtain some proper graph, because we can always add a vertex and two edges to make a new triangle. So, there is always an answer. The complexity of this solution is O(n3).Let's proof that 100 vertices are always enough for the given restrictions on n. For some p after first p iterations we will have a complete graph of p vertices. Now we have exactly C(p, 3) triangles. Consider p such that C(p, 3) ≤ k and C(p, 3) is maximal. For the given restrictions p ≤ 85. From this moment, if we add u from some vertex, we increase the total number of 3-cycles on C(u, 2). So we have to present a small number that is less than C(85, 3) as sum of C(i, 2). The first number we subtruct will differ C(85, 1) on some value not greater than C(85, 1) = 85, because C(n, k) - C(n - 1, k) = C(n - 1, k - 1). The second number we subtruct will differ the number we have on some value not greater than C(14, 1) = 14. and so on. For every k it's enough to use not more that 90 vertices. 232B - TableIdea: tunyash, Skird Implementation: tunyash Editorial: tunyash Let si number of points in the column i. Two neighboring squares are drawn at this picture, A is the number of point it the left area (it is one column), B is the number of points in the middle area and C is the number of points in the right area (it is one column too). That's why by definition we have: Therefore A = C. That's why Divide all columns by equivalence classes on the basis of . For all a and b from one class sa = sb. cnta is number of columns in class with . There are (Cnk)cnta ways to draw k points in the each of columns in the class a independendently of the other classes. dp[i][j] is number of ways to fill all columns in classes 1, ... i in such way that . cnti take only two values and . Let's calc (Cna)cnti for all a and cnti and use it to calc our dp. We have O(n2·k) complexity. 232C - Doe Graphs Idea: Gerald,tunyash Implementation: tunyash, Gerald Editorial: tunyashLet's reduce the problem to the same problem for graphs with less orders. Vertex |D(n - 1)| + 1 is cutpoint (except cases n ≤ 2 but equations below is true for these cases).Without loss of generality a < b. Let dist(a, b, n) — length of the shortest path in graph of order n.The first case is a ≤ |D(n - 1)| and |D(n - 1)| + 1 ≤ b dist(a, b, n) = min(dist(a, |D(n - 1)|, n - 1), dist(a, 1, n - 1)) + dist(b - |D(n - 1)|, 1, n - 2) + 1Edges is marked in red, paths is marked in blue. This formula means that we can go from the vertex a by the path 1 to the vertex 1. Then we can go to the |D(n - 1)| + 1 by the edge and go to the vertex b by the path 3. Or we can go to the vertex |D(n - 1)| by the path 2 and then go to the vertex |D(n - 1)| + 1 by the path 2 and then go to the vertex b by the path 3.The second case is |D(n - 1)| + 1 ≤ a, b. dist(a, b, n) = dist(a - |D(n - 1)|, b - |D(n - 1)|, n - 2)That's easy case.The third case is a, b ≤ |D(n - 1)| dist(a, b, n) = min(dist(a, b, n - 1), min(dist(1, a, n - 1), dist(|D(n - 1)|, a, n - 1)) + min(dist(1, b, n - 1), dist(|D(n - 1)|, b, n - 1) + 2)If shortest path contains cutpoint (|D(n - 1)| + 1) we can go to the vertex 1 or |D(n - 1)+1$ form the both of a and b. After that we can go to the cutpoint. Else we should consider path from a to b in D(n - 1).Let's notice that for all of n will be no more than 4 distinct runnings of dist(i, j, n).It can be prooved by the considering many cases of our actions.In authors colution we cashed all dist(1, i, n) and dist(i, |D(n)|, n) for all achieveable i and n. We have complexity for one query. (it's log because |D(n)| grows like φn).232D - FenceIdea: Gerald, tunyash Implementation: fdoer Editorial: fdoerLet d and d' be arrays such that di = hi - hi + 1, d'i =  - di for every 1 ≤ i ≤ (n - 1). With that notation the conditions of matching look somehow like these: the pieces do not intersect, that is, there isn't a single plank, such that it occurs in both pieces of the fence; the pieces are of the same width; for all i i (0 ≤ i ≤ r1 - l1 - 1) the following condition holds: dl1 + i = d'l2 + i (that is true in case when l = r). The main idea of our solution is stated in the next sentence. For each query l...r the answer is number of pairs (a, b) such that (a > r or b < l), 1 ≤ a ≤ b ≤ n - 1, b - a = r - l and dl...r - 1 exactly matches d'a...b - 1. Let's build a suffix array sa from the concatenation of arrays d and d' with a fictive number between them for separation. Let position of suffix i in sa be posi. For each query all pieces of the fence that satisfy both second and third conditions of matching will be placed in sa on some segment boundleft...boundright such that boundleft ≤ posl ≤ boundright and lcp(boundleft...boundright) ≥ (r - l). So, it's possible to use binary search to find bound's. Depending on complexity of lcp finding algorithm, we could get them in O(logn) or O(log2n) complexity.But there is still a problem to count the number of suffixes from saboundleft...boundright that satisfy the first condition too. Actually it is equal to count the number of i (boundleft ≤ i ≤ boundright) such that (n + 1 ≤ sai ≤ n + l - (r - l) - 1 or sai ≥ n + r) (in the concatenation d' starts from n + 1). It is a classic problem to count numbers from the given interval in the given subarray. For each query it could be solved in O(logn) complexity.For instance, we could solve it offline using sweep line method and any data structure that support queries of sum on an interval and increment of an element. Or we could use some 2D/persistent structure.So, the summary of the algorithm looks like this: build d and d'. Build a suffix array on their concatenation. For each query: find the interval (boundleft...boundright) with two consecutive binary searches using lcp function. query the count of suffixes from that interval that do not intersect with the given piece of the fence. The best author's solution complexity is O(nlogn + qlogn), but careful written solutions in O(nlog2n) comply with the lime limit too.232E - Quick Tortoise Idea: tunyash Implementation: tunyash, KAN Editorial: tunyashLet's choose central column of the area and for all cells to the left from column calc masks of achieveable cells in the central column and for all cells to the right from column calc masks of cells of which this is achievable. It's easy dp with bitsets. for the right part of board. ( — logical or, here it's bitwise or for masks) for the left part. dp calcs mask of achieveable points in the central column.For query x1, y1, x2, y2 (if y1 ≤ mid ≤ y2, where mid is chosen central column) answer is yes if ( is bitwise and) is not empty.Run this algo for left and right part of board we will get answers for all queries. Complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 233 和字母"
          },
          "content_length": 8557
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #144 - Codeforces - Code 1",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 2",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 3",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 4",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(n, 1000000000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(n, 1000000000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    long long m = inf.readLong(n, 1000000000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string m_str = opt<string>(\"m\", \"n\");\n    string k_str = opt<string>(\"k\", \"0\");\n\n    long long m;\n    int k;\n\n    if (m_str == \"max\") {\n        m = 1000000000000000000LL;\n    } else if (m_str == \"n\") {\n        m = n;\n    } else if (m_str == \"n_plus_1\") {\n        m = n + 1;\n    } else if (m_str == \"random\") {\n        m = rnd.next((long long)n, 1000000000000000000LL);\n    } else {\n        // Try to parse m_str as a number\n        m = atoll(m_str.c_str());\n    }\n\n    if (k_str == \"zero\") {\n        k = 0;\n    } else if (k_str == \"nsq\") {\n        k = n * n;\n    } else if (k_str == \"mid\") {\n        k = n * n / 2;\n    } else if (k_str == \"random\") {\n        k = rnd.next(0, n * n);\n    } else {\n        // Try to parse k_str as a number\n        k = atoi(k_str.c_str());\n    }\n\n    // Check constraints\n    if (n < 1 || n > 100) {\n        fprintf(stderr, \"Error: n must be between 1 and 100 inclusive.\\n\");\n        return 1;\n    }\n    if (m < n || m > 1000000000000000000LL) {\n        fprintf(stderr, \"Error: m must be between n and 1e18 inclusive.\\n\");\n        return 1;\n    }\n    if (k < 0 || k > n * n) {\n        fprintf(stderr, \"Error: k must be between 0 and n^2 inclusive.\\n\");\n        return 1;\n    }\n    cout << n << \" \" << m << \" \" << k << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string m_str = opt<string>(\"m\", \"n\");\n    string k_str = opt<string>(\"k\", \"0\");\n\n    long long m;\n    int k;\n\n    if (m_str == \"max\") {\n        m = 1000000000000000000LL;\n    } else if (m_str == \"n\") {\n        m = n;\n    } else if (m_str == \"n_plus_1\") {\n        m = n + 1;\n    } else if (m_str == \"random\") {\n        m = rnd.next((long long)n, 1000000000000000000LL);\n    } else {\n        // Try to parse m_str as a number\n        m = atoll(m_str.c_str());\n    }\n\n    if (k_str == \"zero\") {\n        k = 0;\n    } else if (k_str == \"nsq\") {\n        k = n * n;\n    } else if (k_str == \"mid\") {\n        k = n * n / 2;\n    } else if (k_str == \"random\") {\n        k = rnd.next(0, n * n);\n    } else {\n        // Try to parse k_str as a number\n        k = atoi(k_str.c_str());\n    }\n\n    // Check constraints\n    if (n < 1 || n > 100) {\n        fprintf(stderr, \"Error: n must be between 1 and 100 inclusive.\\n\");\n        return 1;\n    }\n    if (m < n || m > 1000000000000000000LL) {\n        fprintf(stderr, \"Error: m must be between n and 1e18 inclusive.\\n\");\n        return 1;\n    }\n    if (k < 0 || k > n * n) {\n        fprintf(stderr, \"Error: k must be between 0 and n^2 inclusive.\\n\");\n        return 1;\n    }\n    cout << n << \" \" << m << \" \" << k << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m n -k 0\n./gen -n 1 -m n -k 1\n./gen -n 1 -m max -k 0\n./gen -n 1 -m max -k 1\n\n./gen -n 10 -m n -k zero\n./gen -n 10 -m n -k nsq\n./gen -n 10 -m max -k zero\n./gen -n 10 -m max -k nsq\n./gen -n 10 -m max -k mid\n./gen -n 10 -m 1000000000 -k random\n\n./gen -n 50 -m n -k zero\n./gen -n 50 -m n -k nsq\n./gen -n 50 -m n_plus_1 -k zero\n./gen -n 50 -m n_plus_1 -k nsq\n./gen -n 50 -m max -k zero\n./gen -n 50 -m max -k nsq\n./gen -n 50 -m max -k random\n\n./gen -n 100 -m n -k zero\n./gen -n 100 -m n -k nsq\n./gen -n 100 -m n_plus_1 -k zero\n./gen -n 100 -m n_plus_1 -k nsq\n./gen -n 100 -m max -k zero\n./gen -n 100 -m max -k nsq\n./gen -n 100 -m max -k mid\n./gen -n 100 -m max -k random\n\n./gen -n 2 -m random -k random\n./gen -n 99 -m max -k random\n./gen -n 100 -m 999999999999999999 -k random\n\n./gen -n 100 -m max -k 0\n./gen -n 100 -m max -k 1\n./gen -n 100 -m max -k 9999\n./gen -n 100 -m max -k 10000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:16.257801",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "233/E",
      "title": "E. Doe Graphs",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers t and n (1 ≤ t ≤ 105; 1 ≤ n ≤ 103) — the number of queries and the order of the given graph. The i-th of the next t lines contains two integers ai and bi (1 ≤ ai, bi ≤ 1016, ai ≠ bi) — numbers of two vertices in the i-th query. It is guaranteed that ai, bi ≤ |D(n)|.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputFor each query print a single integer on a single line — the length of the shortest path between vertices ai and bi. Print the answers to the queries in the order, in which the queries are given in the input.",
      "sample_tests": "ExamplesInputCopy10 51 21 31 41 52 32 42 53 43 54 5OutputCopy1112123121",
      "description": "E. Doe Graphs\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers t and n (1 ≤ t ≤ 105; 1 ≤ n ≤ 103) — the number of queries and the order of the given graph. The i-th of the next t lines contains two integers ai and bi (1 ≤ ai, bi ≤ 1016, ai ≠ bi) — numbers of two vertices in the i-th query. It is guaranteed that ai, bi ≤ |D(n)|.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nOutputFor each query print a single integer on a single line — the length of the shortest path between vertices ai and bi. Print the answers to the queries in the order, in which the queries are given in the input.\n\nInputCopy10 51 21 31 41 52 32 42 53 43 54 5OutputCopy1112123121\n\nInputCopy10 51 21 31 41 52 32 42 53 43 54 5\n\nOutputCopy1112123121",
      "solutions": [
        {
          "title": "Codeforces Round #144 - Codeforces",
          "content": "Hi all! Codeforces round #144 is going to be today. Round is prepared by: KAN, fdoer, Skird, tunyash. Special thanks to Gerald for coordinating round preparing, many awesome ideas and making statements easy-understandable. Also I thank MikeMirzayanov for enjoyable problem-preparing system, Delinur for statements translation. I hope, that all will be well and you will enjoy solving problems. Good luck!UPD: Score distribution will be announced a few minutes before the start of the contest.UPD2: score distribution is 500-1000-1500-2000-2500 in both divisionsUPD3:Congrats to winners.div1: tourist rng_58 Mimino Dmitry_Egorov, Egor div2: debug22 ryz dvdreddy vinodreddy rdivyanshu UPD: editoral for all problems, except div1.D is ready",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5510",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 737
        },
        {
          "title": "Editorial for Codeforces Round #144 - Codeforces",
          "content": "It will be finised in few hours. If you don't understand something, ask your questions, please.233A - Perfect PermutationIdea: Gerald Implementation: tunyash Editorial: fdoerConsider permutation p such that pi = i. Actually p is a sequence of numbers from 1 to n. Obviously ppi = i. Now the only trick is to change the permutation to satisfy the second equation: pi ≠ i. Let's swap every two consequtive elements. More formally, for each k: 2k ≤ n let's swap p2k - 1 and p2k. It's easy to see that the obtained permutation satisfies both equations for every n with the only exception: when n is odd, there is no answer and we should print  - 1.233B - Non-square EquationIdea: tunyash Implementation: tunyash, Gerald Editorial: fdoerFirstly let's find the interval of possible values of s(x). Hence x2 ≤ n and n ≤ 1018, x ≤ 109. In other words, for every considerable solution x the decimal length of x does not extend 10 digits. So smax ≤ s(9999999999) = 10·9 = 90.Let's bruteforce the value of s(x) (0 ≤ s(x) ≤ 90). Now we have an ordinary square equation. The deal is to solve it and to check that the current bruteforced value of s(x) is equal to sum of digits of the solution. If the solution exists and the equality holds, we should relax the answer.It seems that the most error-generating part of this problem is solving the equation.Knowing arrays is not neccessary to solve these two problems.232A - CyclesIdea: tunyash, fdoer Implementation: tunyash Editorial: tunyashLet's add edge in order of increasing a and for equal b in order of increasing b (here a and b — the least and the greatest vertices of the edge). If the new edge adds too much 3-cycles, we won't add it. We can count the number of new 3-cycles in O(n) complexity (they all contain the new edge, so it's enough to check all variants of the third vertex). Obviously we will obtain some proper graph, because we can always add a vertex and two edges to make a new triangle. So, there is always an answer. The complexity of this solution is O(n3).Let's proof that 100 vertices are always enough for the given restrictions on n. For some p after first p iterations we will have a complete graph of p vertices. Now we have exactly C(p, 3) triangles. Consider p such that C(p, 3) ≤ k and C(p, 3) is maximal. For the given restrictions p ≤ 85. From this moment, if we add u from some vertex, we increase the total number of 3-cycles on C(u, 2). So we have to present a small number that is less than C(85, 3) as sum of C(i, 2). The first number we subtruct will differ C(85, 1) on some value not greater than C(85, 1) = 85, because C(n, k) - C(n - 1, k) = C(n - 1, k - 1). The second number we subtruct will differ the number we have on some value not greater than C(14, 1) = 14. and so on. For every k it's enough to use not more that 90 vertices. 232B - TableIdea: tunyash, Skird Implementation: tunyash Editorial: tunyash Let si number of points in the column i. Two neighboring squares are drawn at this picture, A is the number of point it the left area (it is one column), B is the number of points in the middle area and C is the number of points in the right area (it is one column too). That's why by definition we have: Therefore A = C. That's why Divide all columns by equivalence classes on the basis of . For all a and b from one class sa = sb. cnta is number of columns in class with . There are (Cnk)cnta ways to draw k points in the each of columns in the class a independendently of the other classes. dp[i][j] is number of ways to fill all columns in classes 1, ... i in such way that . cnti take only two values and . Let's calc (Cna)cnti for all a and cnti and use it to calc our dp. We have O(n2·k) complexity. 232C - Doe Graphs Idea: Gerald,tunyash Implementation: tunyash, Gerald Editorial: tunyashLet's reduce the problem to the same problem for graphs with less orders. Vertex |D(n - 1)| + 1 is cutpoint (except cases n ≤ 2 but equations below is true for these cases).Without loss of generality a < b. Let dist(a, b, n) — length of the shortest path in graph of order n.The first case is a ≤ |D(n - 1)| and |D(n - 1)| + 1 ≤ b dist(a, b, n) = min(dist(a, |D(n - 1)|, n - 1), dist(a, 1, n - 1)) + dist(b - |D(n - 1)|, 1, n - 2) + 1Edges is marked in red, paths is marked in blue. This formula means that we can go from the vertex a by the path 1 to the vertex 1. Then we can go to the |D(n - 1)| + 1 by the edge and go to the vertex b by the path 3. Or we can go to the vertex |D(n - 1)| by the path 2 and then go to the vertex |D(n - 1)| + 1 by the path 2 and then go to the vertex b by the path 3.The second case is |D(n - 1)| + 1 ≤ a, b. dist(a, b, n) = dist(a - |D(n - 1)|, b - |D(n - 1)|, n - 2)That's easy case.The third case is a, b ≤ |D(n - 1)| dist(a, b, n) = min(dist(a, b, n - 1), min(dist(1, a, n - 1), dist(|D(n - 1)|, a, n - 1)) + min(dist(1, b, n - 1), dist(|D(n - 1)|, b, n - 1) + 2)If shortest path contains cutpoint (|D(n - 1)| + 1) we can go to the vertex 1 or |D(n - 1)+1$ form the both of a and b. After that we can go to the cutpoint. Else we should consider path from a to b in D(n - 1).Let's notice that for all of n will be no more than 4 distinct runnings of dist(i, j, n).It can be prooved by the considering many cases of our actions.In authors colution we cashed all dist(1, i, n) and dist(i, |D(n)|, n) for all achieveable i and n. We have complexity for one query. (it's log because |D(n)| grows like φn).232D - FenceIdea: Gerald, tunyash Implementation: fdoer Editorial: fdoerLet d and d' be arrays such that di = hi - hi + 1, d'i =  - di for every 1 ≤ i ≤ (n - 1). With that notation the conditions of matching look somehow like these: the pieces do not intersect, that is, there isn't a single plank, such that it occurs in both pieces of the fence; the pieces are of the same width; for all i i (0 ≤ i ≤ r1 - l1 - 1) the following condition holds: dl1 + i = d'l2 + i (that is true in case when l = r). The main idea of our solution is stated in the next sentence. For each query l...r the answer is number of pairs (a, b) such that (a > r or b < l), 1 ≤ a ≤ b ≤ n - 1, b - a = r - l and dl...r - 1 exactly matches d'a...b - 1. Let's build a suffix array sa from the concatenation of arrays d and d' with a fictive number between them for separation. Let position of suffix i in sa be posi. For each query all pieces of the fence that satisfy both second and third conditions of matching will be placed in sa on some segment boundleft...boundright such that boundleft ≤ posl ≤ boundright and lcp(boundleft...boundright) ≥ (r - l). So, it's possible to use binary search to find bound's. Depending on complexity of lcp finding algorithm, we could get them in O(logn) or O(log2n) complexity.But there is still a problem to count the number of suffixes from saboundleft...boundright that satisfy the first condition too. Actually it is equal to count the number of i (boundleft ≤ i ≤ boundright) such that (n + 1 ≤ sai ≤ n + l - (r - l) - 1 or sai ≥ n + r) (in the concatenation d' starts from n + 1). It is a classic problem to count numbers from the given interval in the given subarray. For each query it could be solved in O(logn) complexity.For instance, we could solve it offline using sweep line method and any data structure that support queries of sum on an interval and increment of an element. Or we could use some 2D/persistent structure.So, the summary of the algorithm looks like this: build d and d'. Build a suffix array on their concatenation. For each query: find the interval (boundleft...boundright) with two consecutive binary searches using lcp function. query the count of suffixes from that interval that do not intersect with the given piece of the fence. The best author's solution complexity is O(nlogn + qlogn), but careful written solutions in O(nlog2n) comply with the lime limit too.232E - Quick Tortoise Idea: tunyash Implementation: tunyash, KAN Editorial: tunyashLet's choose central column of the area and for all cells to the left from column calc masks of achieveable cells in the central column and for all cells to the right from column calc masks of cells of which this is achievable. It's easy dp with bitsets. for the right part of board. ( — logical or, here it's bitwise or for masks) for the left part. dp calcs mask of achieveable points in the central column.For query x1, y1, x2, y2 (if y1 ≤ mid ≤ y2, where mid is chosen central column) answer is yes if ( is bitwise and) is not empty.Run this algo for left and right part of board we will get answers for all queries. Complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5514",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 233 和字母"
          },
          "content_length": 8557
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #144 - Codeforces - Code 1",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 2",
          "code": "5 1000\n1 10000000000000000\n1 9999999999999999\n2 9999999999999999\n3 9999999999999999\n4 9999999999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 3",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #144 - Codeforces - Code 4",
          "code": "20\n20 \n21\n21\n21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5510",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MAX_T = 100000;\nconst long long MAX_A_B = 10000000000000000LL; // 1e16\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int t = inf.readInt(1, MAX_T, \"t\");\n    inf.readSpace();\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n    \n    // Compute |D(n)|\n    long long maxNode;\n    if (n <= 77) {\n        vector<long long> fib(n + 1);\n        fib[0] = 1; // D(0)\n        fib[1] = 2; // D(1)\n        for (int i = 2; i <= n; ++i) {\n            fib[i] = fib[i - 1] + fib[i - 2];\n        }\n        maxNode = fib[n]; // |D(n)|\n    } else {\n        maxNode = MAX_A_B;\n    }\n    \n    for (int i = 0; i < t; ++i) {\n        long long ai = inf.readLong(1, maxNode, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1, maxNode, \"bi\");\n        ensuref(ai != bi, \"ai and bi must be different (ai=%lld, bi=%lld)\", ai, bi);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MAX_T = 100000;\nconst long long MAX_A_B = 10000000000000000LL; // 1e16\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int t = inf.readInt(1, MAX_T, \"t\");\n    inf.readSpace();\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n    \n    // Compute |D(n)|\n    long long maxNode;\n    if (n <= 77) {\n        vector<long long> fib(n + 1);\n        fib[0] = 1; // D(0)\n        fib[1] = 2; // D(1)\n        for (int i = 2; i <= n; ++i) {\n            fib[i] = fib[i - 1] + fib[i - 2];\n        }\n        maxNode = fib[n]; // |D(n)|\n    } else {\n        maxNode = MAX_A_B;\n    }\n    \n    for (int i = 0; i < t; ++i) {\n        long long ai = inf.readLong(1, maxNode, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1, maxNode, \"bi\");\n        ensuref(ai != bi, \"ai and bi must be different (ai=%lld, bi=%lld)\", ai, bi);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MAX_T = 100000;\nconst long long MAX_A_B = 10000000000000000LL; // 1e16\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int t = inf.readInt(1, MAX_T, \"t\");\n    inf.readSpace();\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n    \n    // Compute |D(n)|\n    long long maxNode;\n    if (n <= 77) {\n        vector<long long> fib(n + 1);\n        fib[0] = 1; // D(0)\n        fib[1] = 2; // D(1)\n        for (int i = 2; i <= n; ++i) {\n            fib[i] = fib[i - 1] + fib[i - 2];\n        }\n        maxNode = fib[n]; // |D(n)|\n    } else {\n        maxNode = MAX_A_B;\n    }\n    \n    for (int i = 0; i < t; ++i) {\n        long long ai = inf.readLong(1, maxNode, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1, maxNode, \"bi\");\n        ensuref(ai != bi, \"ai and bi must be different (ai=%lld, bi=%lld)\", ai, bi);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int FIB_LIMIT = 91; // Fib[91] > 1e16\n\nunsigned long long Fib[FIB_LIMIT + 1];\n\nvoid computeFib() {\n    Fib[0] = 1; // |D(0)|\n    Fib[1] = 2; // |D(1)|\n    for (int i = 2; i <= FIB_LIMIT; ++i) {\n        Fib[i] = Fib[i - 1] + Fib[i - 2];\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    computeFib();\n\n    unsigned long long max_vertex;\n\n    if (n <= FIB_LIMIT) {\n        max_vertex = Fib[n];\n        if (max_vertex > (unsigned long long)1e16)\n            max_vertex = (unsigned long long)1e16;\n    } else {\n        max_vertex = (unsigned long long)1e16;\n    }\n\n    // Depending on the type, we may override t and n\n    if (type == \"min_values\") {\n        t = 1;\n        n = 1;\n    } else if (type == \"max_values\") {\n        t = 100000;\n        n = 1000;\n    } else if (type == \"small_n_small_t\") {\n        t = rnd.next(1, 100);\n        n = rnd.next(1, 10);\n    } else if (type == \"large_n_small_t\") {\n        t = rnd.next(1, 100);\n        n = rnd.next(900, 1000);\n    } else if (type == \"small_n_large_t\") {\n        t = 100000;\n        n = rnd.next(1, 10);\n    } else if (type == \"large_n_large_t\") {\n        t = 100000;\n        n = 1000;\n    }\n\n    // Recompute max_vertex if n was overridden\n    if (n <= FIB_LIMIT) {\n        max_vertex = Fib[n];\n        if (max_vertex > (unsigned long long)1e16)\n            max_vertex = (unsigned long long)1e16;\n    } else {\n        max_vertex = (unsigned long long)1e16;\n    }\n\n    printf(\"%d %d\\n\", t, n);\n\n    if (type == \"min_values\") {\n        // For n = 1, |D(1)| = Fib[1] = 2\n        printf(\"1 2\\n\");\n    } else if (type == \"path_tests\") {\n        for (int i = 0; i < t; ++i) {\n            unsigned long long ai, bi;\n            if (i % 3 == 0) {\n                ai = 1;\n                bi = max_vertex;\n            } else if (i % 3 == 1) {\n                ai = max_vertex / 2;\n                bi = (max_vertex / 2) + 1;\n            } else {\n                ai = rnd.next(1ULL, max_vertex);\n                bi = rnd.next(1ULL, max_vertex);\n                while (ai == bi) {\n                    bi = rnd.next(1ULL, max_vertex);\n                }\n            }\n            printf(\"%llu %llu\\n\", ai, bi);\n        }\n    } else {\n        for (int i = 0; i < t; ++i) {\n            unsigned long long ai = rnd.next(1ULL, max_vertex);\n            unsigned long long bi = rnd.next(1ULL, max_vertex);\n            while (ai == bi) {\n                bi = rnd.next(1ULL, max_vertex);\n            }\n            printf(\"%llu %llu\\n\", ai, bi);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int FIB_LIMIT = 91; // Fib[91] > 1e16\n\nunsigned long long Fib[FIB_LIMIT + 1];\n\nvoid computeFib() {\n    Fib[0] = 1; // |D(0)|\n    Fib[1] = 2; // |D(1)|\n    for (int i = 2; i <= FIB_LIMIT; ++i) {\n        Fib[i] = Fib[i - 1] + Fib[i - 2];\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    computeFib();\n\n    unsigned long long max_vertex;\n\n    if (n <= FIB_LIMIT) {\n        max_vertex = Fib[n];\n        if (max_vertex > (unsigned long long)1e16)\n            max_vertex = (unsigned long long)1e16;\n    } else {\n        max_vertex = (unsigned long long)1e16;\n    }\n\n    // Depending on the type, we may override t and n\n    if (type == \"min_values\") {\n        t = 1;\n        n = 1;\n    } else if (type == \"max_values\") {\n        t = 100000;\n        n = 1000;\n    } else if (type == \"small_n_small_t\") {\n        t = rnd.next(1, 100);\n        n = rnd.next(1, 10);\n    } else if (type == \"large_n_small_t\") {\n        t = rnd.next(1, 100);\n        n = rnd.next(900, 1000);\n    } else if (type == \"small_n_large_t\") {\n        t = 100000;\n        n = rnd.next(1, 10);\n    } else if (type == \"large_n_large_t\") {\n        t = 100000;\n        n = 1000;\n    }\n\n    // Recompute max_vertex if n was overridden\n    if (n <= FIB_LIMIT) {\n        max_vertex = Fib[n];\n        if (max_vertex > (unsigned long long)1e16)\n            max_vertex = (unsigned long long)1e16;\n    } else {\n        max_vertex = (unsigned long long)1e16;\n    }\n\n    printf(\"%d %d\\n\", t, n);\n\n    if (type == \"min_values\") {\n        // For n = 1, |D(1)| = Fib[1] = 2\n        printf(\"1 2\\n\");\n    } else if (type == \"path_tests\") {\n        for (int i = 0; i < t; ++i) {\n            unsigned long long ai, bi;\n            if (i % 3 == 0) {\n                ai = 1;\n                bi = max_vertex;\n            } else if (i % 3 == 1) {\n                ai = max_vertex / 2;\n                bi = (max_vertex / 2) + 1;\n            } else {\n                ai = rnd.next(1ULL, max_vertex);\n                bi = rnd.next(1ULL, max_vertex);\n                while (ai == bi) {\n                    bi = rnd.next(1ULL, max_vertex);\n                }\n            }\n            printf(\"%llu %llu\\n\", ai, bi);\n        }\n    } else {\n        for (int i = 0; i < t; ++i) {\n            unsigned long long ai = rnd.next(1ULL, max_vertex);\n            unsigned long long bi = rnd.next(1ULL, max_vertex);\n            while (ai == bi) {\n                bi = rnd.next(1ULL, max_vertex);\n            }\n            printf(\"%llu %llu\\n\", ai, bi);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 10 -n 5 -type min_values\n./gen -t 20 -n 5 -type small_n_small_t\n./gen -t 100 -n 50 -type small_n_small_t\n./gen -t 1000 -n 50 -type small_n_large_t\n./gen -t 100 -n 1000 -type large_n_small_t\n./gen -t 1000 -n 1000 -type large_n_large_t\n./gen -t 100000 -n 1000 -type max_values\n./gen -t 1000 -n 1 -type min_values\n./gen -t 50000 -n 78 -type random\n./gen -t 50000 -n 79 -type random\n./gen -t 100000 -n 80 -type large_n_large_t\n./gen -t 100000 -n 100 -type small_n_large_t\n./gen -t 50000 -n 1000 -type path_tests\n./gen -t 1000 -n 80 -type path_tests\n./gen -t 2000 -n 90 -type path_tests\n./gen -t 100000 -n 1000 -type random\n./gen -t 1 -n 1 -type min_values\n./gen -t 1 -n 1000 -type large_n_small_t\n./gen -t 100000 -n 1 -type small_n_large_t\n./gen -t 100000 -n 1000 -type max_values\n./gen -t 10 -n 1 -type small_n_small_t\n./gen -t 10000 -n 100 -type random\n./gen -t 1000 -n 500 -type random\n./gen -t 10000 -n 1000 -type large_n_large_t\n./gen -t 100000 -n 1000 -type random\n./gen -t 100 -n 80 -type small_n_small_t\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:18.207505",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "234/A",
      "title": "A. Lefthanders and Righthanders",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains a single even integer n (4 ≤ n ≤ 100) — the number of students in the class. The second line contains exactly n capital English letters \"L\" and \"R\". If the i-th letter at the second line equals \"L\", then the student number i is a lefthander, otherwise he is a righthander.",
      "output_spec": "OutputPrint  integer pairs, one pair per line. In the i-th line print the numbers of students that will sit at the i-th desk. The first number in the pair stands for the student who is sitting to the left, and the second number stands for the student who is sitting to the right. Separate the numbers in the pairs by spaces. If there are multiple solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy6LLRLLLOutputCopy1 42 56 3InputCopy4RRLLOutputCopy3 14 2",
      "description": "A. Lefthanders and Righthanders\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputinput.txt\n\noutputoutput.txt\n\nInputThe first input line contains a single even integer n (4 ≤ n ≤ 100) — the number of students in the class. The second line contains exactly n capital English letters \"L\" and \"R\". If the i-th letter at the second line equals \"L\", then the student number i is a lefthander, otherwise he is a righthander.\n\nOutputPrint  integer pairs, one pair per line. In the i-th line print the numbers of students that will sit at the i-th desk. The first number in the pair stands for the student who is sitting to the left, and the second number stands for the student who is sitting to the right. Separate the numbers in the pairs by spaces. If there are multiple solutions, print any of them.\n\nInputCopy6LLRLLLOutputCopy1 42 56 3InputCopy4RRLLOutputCopy3 14 2\n\nInputCopy6LLRLLL\n\nOutputCopy1 42 56 3\n\nInputCopy4RRLL\n\nOutputCopy3 14 2",
      "solutions": [
        {
          "title": "Codeforces Round #145 (ACM-ICPC Rules) - Codeforces",
          "content": "Good day, Codeforces!I can't wait to give you a good news that a new competition for div1 participants is appeared in the list of events. This competition is a broadcast of the Saratov Team Olympiad on Programming and therefore will be held by the ACM-ICPC rules. Especially for div1 participants, we complicate this school competition a bit, so that everyone was interested to solve the problems.This Competition is individual, it will be rated for both divisions.Please note that the start time of the competition is different from the usual. Also note the unusual length of the competition.See you at Codeforces Round #145! I hope that everyone will find the time to participate in the competition.UPD. The competition finished, the editorial will come soon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5531",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 761
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 100, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 0, \"n must be even, but n = %d\", n);\n\n    string s = inf.readToken(\"[LR]{4,100}\", \"handedness\");\n\n    ensuref(int(s.length()) == n, \"Length of handedness string must be n=%d, but it's %d\", n, int(s.length()));\n\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 100, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 0, \"n must be even, but n = %d\", n);\n\n    string s = inf.readToken(\"[LR]{4,100}\", \"handedness\");\n\n    ensuref(int(s.length()) == n, \"Length of handedness string must be n=%d, but it's %d\", n, int(s.length()));\n\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(4, 100, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 0, \"n must be even, but n = %d\", n);\n\n    string s = inf.readToken(\"[LR]{4,100}\", \"handedness\");\n\n    ensuref(int(s.length()) == n, \"Length of handedness string must be n=%d, but it's %d\", n, int(s.length()));\n\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is even and in the specified range\n    assert(n % 2 == 0 && 4 <= n && n <= 100);\n\n    string handedness;  // the string of 'L's and 'R's\n\n    if (type == \"random\") {\n        // Generate random handedness\n        for (int i = 0; i < n; ++i) {\n            int r = rnd.next(2);\n            if (r == 0) handedness += 'L';\n            else handedness += 'R';\n        }\n    } else if (type == \"all_L\") {\n        // All left-handed\n        handedness = string(n, 'L');\n    } else if (type == \"all_R\") {\n        // All right-handed\n        handedness = string(n, 'R');\n    } else if (type == \"alternating\") {\n        // Alternating 'L' and 'R'\n        char c[] = {'L', 'R'};\n        for (int i = 0; i < n; ++i) {\n            handedness += c[i%2];\n        }\n    } else if (type == \"reverse_alternating\") {\n        // Alternating 'R' and 'L'\n        char c[] = {'R', 'L'};\n        for (int i = 0; i < n; ++i) {\n            handedness += c[i%2];\n        }\n    } else if (type == \"tricky\") {\n        // Create a configuration where students whose numbers differ by 1 have opposite handedness\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) handedness += 'L';\n            else handedness += 'R';\n        }\n    } else if (type == \"pairwise_same\") {\n        // Every two students have the same handedness\n        for (int i = 0; i < n; i+=2) {\n            char h = (rnd.next(2) == 0) ? 'L' : 'R';\n            handedness += h;\n            handedness += h;\n        }\n    } else if (type == \"pairwise_opposite\") {\n        // Every two students have opposite handedness\n        for (int i = 0; i < n; i+=2) {\n            char h1 = (rnd.next(2) == 0) ? 'L' : 'R';\n            char h2 = (h1 == 'L') ? 'R' : 'L';\n            handedness += h1;\n            handedness += h2;\n        }\n    } else if (type == \"edge_case_1\") {\n        // Minimal n=4\n        n = 4;\n        handedness = \"LRLR\";\n    } else if (type == \"edge_case_2\") {\n        // Maximal n=100\n        n = 100;\n        for (int i = 0; i < n; ++i) {\n            handedness += (rnd.next(2) == 0) ? 'L' : 'R';\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int r = rnd.next(2);\n            if (r == 0) handedness += 'L';\n            else handedness += 'R';\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", handedness.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is even and in the specified range\n    assert(n % 2 == 0 && 4 <= n && n <= 100);\n\n    string handedness;  // the string of 'L's and 'R's\n\n    if (type == \"random\") {\n        // Generate random handedness\n        for (int i = 0; i < n; ++i) {\n            int r = rnd.next(2);\n            if (r == 0) handedness += 'L';\n            else handedness += 'R';\n        }\n    } else if (type == \"all_L\") {\n        // All left-handed\n        handedness = string(n, 'L');\n    } else if (type == \"all_R\") {\n        // All right-handed\n        handedness = string(n, 'R');\n    } else if (type == \"alternating\") {\n        // Alternating 'L' and 'R'\n        char c[] = {'L', 'R'};\n        for (int i = 0; i < n; ++i) {\n            handedness += c[i%2];\n        }\n    } else if (type == \"reverse_alternating\") {\n        // Alternating 'R' and 'L'\n        char c[] = {'R', 'L'};\n        for (int i = 0; i < n; ++i) {\n            handedness += c[i%2];\n        }\n    } else if (type == \"tricky\") {\n        // Create a configuration where students whose numbers differ by 1 have opposite handedness\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) handedness += 'L';\n            else handedness += 'R';\n        }\n    } else if (type == \"pairwise_same\") {\n        // Every two students have the same handedness\n        for (int i = 0; i < n; i+=2) {\n            char h = (rnd.next(2) == 0) ? 'L' : 'R';\n            handedness += h;\n            handedness += h;\n        }\n    } else if (type == \"pairwise_opposite\") {\n        // Every two students have opposite handedness\n        for (int i = 0; i < n; i+=2) {\n            char h1 = (rnd.next(2) == 0) ? 'L' : 'R';\n            char h2 = (h1 == 'L') ? 'R' : 'L';\n            handedness += h1;\n            handedness += h2;\n        }\n    } else if (type == \"edge_case_1\") {\n        // Minimal n=4\n        n = 4;\n        handedness = \"LRLR\";\n    } else if (type == \"edge_case_2\") {\n        // Maximal n=100\n        n = 100;\n        for (int i = 0; i < n; ++i) {\n            handedness += (rnd.next(2) == 0) ? 'L' : 'R';\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int r = rnd.next(2);\n            if (r == 0) handedness += 'L';\n            else handedness += 'R';\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", handedness.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -type edge_case_1\n\n./gen -n 100 -type edge_case_2\n\n./gen -n 6 -type random\n\n./gen -n 8 -type random\n\n./gen -n 10 -type random\n\n./gen -n 12 -type random\n\n./gen -n 4 -type all_L\n\n./gen -n 4 -type all_R\n\n./gen -n 6 -type all_L\n\n./gen -n 6 -type all_R\n\n./gen -n 8 -type all_L\n\n./gen -n 8 -type all_R\n\n./gen -n 10 -type alternating\n\n./gen -n 10 -type reverse_alternating\n\n./gen -n 12 -type alternating\n\n./gen -n 12 -type reverse_alternating\n\n./gen -n 14 -type pairwise_same\n\n./gen -n 14 -type pairwise_opposite\n\n./gen -n 16 -type tricky\n\n./gen -n 16 -type random\n\n./gen -n 20 -type random\n\n./gen -n 20 -type all_L\n\n./gen -n 20 -type all_R\n\n./gen -n 50 -type random\n\n./gen -n 50 -type alternating\n\n./gen -n 50 -type reverse_alternating\n\n./gen -n 100 -type random\n\n./gen -n 100 -type pairwise_opposite\n\n./gen -n 100 -type tricky\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:20.297022",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "234/B",
      "title": "B. Reading",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains two integers n and k (1 ≤ n ≤ 1000, 1 ≤ k ≤ n) — the number of hours on the train and the number of hours to read, correspondingly. The second line contains n space-separated integers ai (0 ≤ ai ≤ 100), ai is the light level at the i-th hour.",
      "output_spec": "OutputIn the first output line print the minimum light level Vasya will read at. In the second line print k distinct space-separated integers b1, b2, ..., bk, — the indexes of hours Vasya will read at (1 ≤ bi ≤ n). The hours are indexed starting from 1. If there are multiple optimal solutions, print any of them. Print the numbers bi in an arbitrary order.",
      "sample_tests": "ExamplesInputCopy5 320 10 30 40 10OutputCopy201 3 4 InputCopy6 590 20 35 40 60 100OutputCopy351 3 4 5 6",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputinput.txt\n\noutputoutput.txt\n\nInputThe first input line contains two integers n and k (1 ≤ n ≤ 1000, 1 ≤ k ≤ n) — the number of hours on the train and the number of hours to read, correspondingly. The second line contains n space-separated integers ai (0 ≤ ai ≤ 100), ai is the light level at the i-th hour.\n\nOutputIn the first output line print the minimum light level Vasya will read at. In the second line print k distinct space-separated integers b1, b2, ..., bk, — the indexes of hours Vasya will read at (1 ≤ bi ≤ n). The hours are indexed starting from 1. If there are multiple optimal solutions, print any of them. Print the numbers bi in an arbitrary order.\n\nInputCopy5 320 10 30 40 10OutputCopy201 3 4 InputCopy6 590 20 35 40 60 100OutputCopy351 3 4 5 6\n\nInputCopy5 320 10 30 40 10\n\nOutputCopy201 3 4\n\nInputCopy6 590 20 35 40 60 100\n\nOutputCopy351 3 4 5 6\n\nNoteIn the first sample Vasya should read at the first hour (light 20), third hour (light 30) and at the fourth hour (light 40). The minimum light Vasya will have to read at is 20.",
      "solutions": [
        {
          "title": "Codeforces Round #145 (ACM-ICPC Rules) - Codeforces",
          "content": "Good day, Codeforces!I can't wait to give you a good news that a new competition for div1 participants is appeared in the list of events. This competition is a broadcast of the Saratov Team Olympiad on Programming and therefore will be held by the ACM-ICPC rules. Especially for div1 participants, we complicate this school competition a bit, so that everyone was interested to solve the problems.This Competition is individual, it will be rated for both divisions.Please note that the start time of the competition is different from the usual. Also note the unusual length of the competition.See you at Codeforces Round #145! I hope that everyone will find the time to participate in the competition.UPD. The competition finished, the editorial will come soon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5531",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 761
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, 100, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, 100, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, 100, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nvector<int> ai;\n\nint readAns(InStream& stream) {\n    // Read the minimal light level reported\n    int reported_min = stream.readInt(0, 100, \"reported_min\");\n\n    // Read k distinct integers between 1 and n\n    vector<int> bi = stream.readInts(k, 1, n, \"bi\");\n\n    // Check that the indices are distinct\n    set<int> indices(bi.begin(), bi.end());\n    if ((int)indices.size() != k)\n        stream.quitf(_wa, \"Indices are not distinct\");\n\n    // Compute the minimal light level among selected hours\n    int actual_min = 100; // Since ai[i] are between 0 and 100\n\n    for (int i = 0; i < k; ++i) {\n        int idx = bi[i] - 1; // Convert to 0-based index\n        actual_min = min(actual_min, ai[idx]);\n    }\n\n    if (actual_min != reported_min)\n        stream.quitf(_wa, \"Reported minimal light level (%d) does not match actual minimal light level (%d)\", reported_min, actual_min);\n\n    return reported_min;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    n = inf.readInt(1, 1000, \"n\");\n    k = inf.readInt(1, n, \"k\");\n\n    ai.resize(n);\n    for (int i = 0; i < n; ++i) {\n        ai[i] = inf.readInt(0, 100, \"ai[\" + vtos(i + 1) + \"]\");\n    }\n\n    // Read the jury's answer\n    int jans = readAns(ans);\n\n    // Read the contestant's answer\n    int pans = readAns(ouf);\n\n    if (pans < jans) {\n        quitf(_wa, \"Contestant's minimal light level (%d) is less than jury's (%d)\", pans, jans);\n    } else if (pans == jans) {\n        quitf(_ok, \"Answer is correct with minimal light level %d\", pans);\n    } else { // pans > jans\n        quitf(_fail, \"Contestant's minimal light level (%d) is greater than jury's (%d)\", pans, jans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n < 1 || n > 1000) {\n        fprintf(stderr, \"n is out of bounds: %d\\n\", n);\n        exit(1);\n    }\n    if (k < 1 || k > n) {\n        fprintf(stderr, \"k is out of bounds: %d\\n\", k);\n        exit(1);\n    }\n    \n    vector<int> ai(n);\n    \n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 100);\n        }\n    }\n    else if (type == \"all_same\") {\n        int val = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = val;\n        }\n    }\n    else if (type == \"increasing\") {\n        ai[0] = rnd.next(0, 10);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = min(ai[i-1] + rnd.next(0, 10), 100);\n        }\n        shuffle(ai.begin(), ai.end());\n    }\n    else if (type == \"decreasing\") {\n        ai[0] = rnd.next(90, 100);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = max(ai[i-1] - rnd.next(0, 10), 0);\n        }\n        shuffle(ai.begin(), ai.end());\n    }\n    else if (type == \"max_light\") {\n        fill(ai.begin(), ai.end(), 100);\n    }\n    else if (type == \"min_light\") {\n        fill(ai.begin(), ai.end(), 0);\n    }\n    else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2 == 0) ? 100 : 0;\n        }\n        shuffle(ai.begin(), ai.end());\n    }\n    else if (type == \"few_good\") {\n        if (k > n) {\n            fprintf(stderr, \"k is greater than n in type 'few_good'\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < k; ++i) {\n            ai[i] = rnd.next(70, 100);\n        }\n        for (int i = k; i < n; ++i) {\n            ai[i] = rnd.next(0, 30);\n        }\n        shuffle(ai.begin(), ai.end());\n    }\n    else if (type == \"some_duplicates\") {\n        vector<int> vals = {0, 25, 50, 75, 100};\n        for (int i = 0; i < n; ++i) {\n            ai[i] = vals[rnd.next(0, (int)vals.size() - 1)];\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    \n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n < 1 || n > 1000) {\n        fprintf(stderr, \"n is out of bounds: %d\\n\", n);\n        exit(1);\n    }\n    if (k < 1 || k > n) {\n        fprintf(stderr, \"k is out of bounds: %d\\n\", k);\n        exit(1);\n    }\n    \n    vector<int> ai(n);\n    \n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 100);\n        }\n    }\n    else if (type == \"all_same\") {\n        int val = rnd.next(0, 100);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = val;\n        }\n    }\n    else if (type == \"increasing\") {\n        ai[0] = rnd.next(0, 10);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = min(ai[i-1] + rnd.next(0, 10), 100);\n        }\n        shuffle(ai.begin(), ai.end());\n    }\n    else if (type == \"decreasing\") {\n        ai[0] = rnd.next(90, 100);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = max(ai[i-1] - rnd.next(0, 10), 0);\n        }\n        shuffle(ai.begin(), ai.end());\n    }\n    else if (type == \"max_light\") {\n        fill(ai.begin(), ai.end(), 100);\n    }\n    else if (type == \"min_light\") {\n        fill(ai.begin(), ai.end(), 0);\n    }\n    else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2 == 0) ? 100 : 0;\n        }\n        shuffle(ai.begin(), ai.end());\n    }\n    else if (type == \"few_good\") {\n        if (k > n) {\n            fprintf(stderr, \"k is greater than n in type 'few_good'\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < k; ++i) {\n            ai[i] = rnd.next(70, 100);\n        }\n        for (int i = k; i < n; ++i) {\n            ai[i] = rnd.next(0, 30);\n        }\n        shuffle(ai.begin(), ai.end());\n    }\n    else if (type == \"some_duplicates\") {\n        vector<int> vals = {0, 25, 50, 75, 100};\n        for (int i = 0; i < n; ++i) {\n            ai[i] = vals[rnd.next(0, (int)vals.size() - 1)];\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    \n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random cases\n./gen -n 1 -k 1 -type random\n./gen -n 5 -k 3 -type random\n./gen -n 10 -k 5 -type random\n\n# Edge cases with maximum n\n./gen -n 1000 -k 1 -type random\n./gen -n 1000 -k 1000 -type random\n./gen -n 1 -k 1 -type all_same\n\n# All light levels are the same\n./gen -n 1000 -k 500 -type all_same\n\n# Increasing light levels\n./gen -n 1000 -k 500 -type increasing\n\n# Decreasing light levels\n./gen -n 1000 -k 500 -type decreasing\n\n# Maximum light levels\n./gen -n 1000 -k 500 -type max_light\n\n# Minimum light levels\n./gen -n 1000 -k 500 -type min_light\n\n# Alternating light levels\n./gen -n 1000 -k 500 -type alternating\n\n# Some duplicates in light levels\n./gen -n 1000 -k 500 -type some_duplicates\n\n# Few good light levels\n./gen -n 1000 -k 500 -type few_good\n\n# k close to n\n./gen -n 1000 -k 999 -type random\n./gen -n 1000 -k 998 -type few_good\n\n# Small k\n./gen -n 1000 -k 2 -type random\n./gen -n 1000 -k 2 -type few_good\n\n# All light levels are maximum\n./gen -n 1000 -k 1000 -type max_light\n\n# All light levels are minimum\n./gen -n 1000 -k 1000 -type min_light\n\n# Edge cases with minimal number of hours\n./gen -n 1 -k 1 -type max_light\n./gen -n 1 -k 1 -type min_light\n\n# Edge cases with k = 1\n./gen -n 1000 -k 1 -type random\n\n# Cases with duplicates and tie in minimal light level\n./gen -n 10 -k 5 -type some_duplicates\n./gen -n 1000 -k 500 -type some_duplicates\n\n# Random cases\n./gen -n 1000 -k 300 -type random\n./gen -n 1000 -k 700 -type random\n\n# Random cases with smaller n\n./gen -n 100 -k 50 -type random\n./gen -n 500 -k 250 -type random\n\n# Mixed types\n./gen -n 1000 -k 400 -type increasing\n./gen -n 1000 -k 600 -type decreasing\n\n# Additional random cases\n./gen -n 999 -k 500 -type random\n./gen -n 1000 -k 1 -type few_good\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:21.922187",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "234/C",
      "title": "C. Weather",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of days for which Vasya has been measuring the temperature. The second line contains a sequence of n integers t1, t2, ..., tn (|ti| ≤ 109) — the sequence of temperature values. Numbers ti are separated by single spaces.",
      "output_spec": "OutputPrint a single integer — the answer to the given task.",
      "sample_tests": "ExamplesInputCopy4-1 1 -2 1OutputCopy1InputCopy50 -1 1 2 -5OutputCopy2",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputinput.txt\n\noutputoutput.txt\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of days for which Vasya has been measuring the temperature. The second line contains a sequence of n integers t1, t2, ..., tn (|ti| ≤ 109) — the sequence of temperature values. Numbers ti are separated by single spaces.\n\nOutputPrint a single integer — the answer to the given task.\n\nInputCopy4-1 1 -2 1OutputCopy1InputCopy50 -1 1 2 -5OutputCopy2\n\nInputCopy4-1 1 -2 1\n\nOutputCopy1\n\nInputCopy50 -1 1 2 -5\n\nOutputCopy2\n\nNoteNote to the first sample: there are two ways to change exactly one number so that the sequence met Vasya's condition. You can either replace the first number 1 by any negative number or replace the number -2 by any positive number.",
      "solutions": [
        {
          "title": "Codeforces Round #145 (ACM-ICPC Rules) - Codeforces",
          "content": "Good day, Codeforces!I can't wait to give you a good news that a new competition for div1 participants is appeared in the list of events. This competition is a broadcast of the Saratov Team Olympiad on Programming and therefore will be held by the ACM-ICPC rules. Especially for div1 participants, we complicate this school competition a bit, so that everyone was interested to solve the problems.This Competition is individual, it will be rated for both divisions.Please note that the start time of the competition is different from the usual. Also note the unusual length of the competition.See you at Codeforces Round #145! I hope that everyone will find the time to participate in the competition.UPD. The competition finished, the editorial will come soon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5531",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 761
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int t_i = inf.readInt(-1000000000, 1000000000, \"t_i\");\n        if (i < n) {\n            inf.readChar(' ');\n        } else {\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int t_i = inf.readInt(-1000000000, 1000000000, \"t_i\");\n        if (i < n) {\n            inf.readChar(' ');\n        } else {\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int t_i = inf.readInt(-1000000000, 1000000000, \"t_i\");\n        if (i < n) {\n            inf.readChar(' ');\n        } else {\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> t(n);\n\n    if (type == \"already_satisfying\") {\n        int k = rnd.next(1, n - 1);\n        // Generate k negative numbers\n        // Generate n - k positive numbers\n        for (int i = 0; i < k; ++i) {\n            t[i] = -rnd.next(1, 1000000000);\n        }\n        for (int i = k; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"all_negative\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = -rnd.next(1, 1000000000);\n        }\n    } else if (type == \"all_positive\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                t[i] = -rnd.next(1, 1000000000);\n            else\n                t[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) // random 0 or 1\n                t[i] = rnd.next(1, 1000000000);\n            else\n                t[i] = -rnd.next(1, 1000000000);\n        }\n    } else if (type == \"negative_positive_negative\") {\n        if (n < 3) {\n            // This type needs at least 3 elements\n            printf(\"3\\n-1 1 -1\\n\");\n            return 0;\n        }\n        int k1 = rnd.next(1, n - 2);\n        int k2 = rnd.next(k1 + 1, n - 1);\n        for (int i = 0; i < k1; ++i)\n            t[i] = -rnd.next(1, 1000000000);\n        for (int i = k1; i < k2; ++i)\n            t[i] = rnd.next(1, 1000000000);\n        for (int i = k2; i < n; ++i)\n            t[i] = -rnd.next(1, 1000000000);\n    } else if (type == \"positive_negative_positive\") {\n        if (n < 3) {\n            // This type needs at least 3 elements\n            printf(\"3\\n1 -1 1\\n\");\n            return 0;\n        }\n        int k1 = rnd.next(1, n - 2);\n        int k2 = rnd.next(k1 + 1, n - 1);\n        for (int i = 0; i < k1; ++i)\n            t[i] = rnd.next(1, 1000000000);\n        for (int i = k1; i < k2; ++i)\n            t[i] = -rnd.next(1, 1000000000);\n        for (int i = k2; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n    } else if (type == \"needs_minimal_changes\") {\n        int k = rnd.next(1, n - 1);\n        for (int i = 0; i < k; ++i)\n            t[i] = -rnd.next(1, 1000000000);\n        for (int i = k; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n        // Now, introduce a single violation\n        int pos = rnd.next(0, n - 1);\n        if (t[pos] < 0)\n            t[pos] = rnd.next(1, 1000000000);\n        else\n            t[pos] = -rnd.next(1, 1000000000);\n    } else if (type == \"needs_max_changes\") {\n        // Generate a sequence where minimal changes required is maximum\n        // Let's make all signs opposite to Vasya's condition\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000000);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1))\n                t[i] = rnd.next(1, 1000000000);\n            else\n                t[i] = -rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", t[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> t(n);\n\n    if (type == \"already_satisfying\") {\n        int k = rnd.next(1, n - 1);\n        // Generate k negative numbers\n        // Generate n - k positive numbers\n        for (int i = 0; i < k; ++i) {\n            t[i] = -rnd.next(1, 1000000000);\n        }\n        for (int i = k; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"all_negative\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = -rnd.next(1, 1000000000);\n        }\n    } else if (type == \"all_positive\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                t[i] = -rnd.next(1, 1000000000);\n            else\n                t[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) // random 0 or 1\n                t[i] = rnd.next(1, 1000000000);\n            else\n                t[i] = -rnd.next(1, 1000000000);\n        }\n    } else if (type == \"negative_positive_negative\") {\n        if (n < 3) {\n            // This type needs at least 3 elements\n            printf(\"3\\n-1 1 -1\\n\");\n            return 0;\n        }\n        int k1 = rnd.next(1, n - 2);\n        int k2 = rnd.next(k1 + 1, n - 1);\n        for (int i = 0; i < k1; ++i)\n            t[i] = -rnd.next(1, 1000000000);\n        for (int i = k1; i < k2; ++i)\n            t[i] = rnd.next(1, 1000000000);\n        for (int i = k2; i < n; ++i)\n            t[i] = -rnd.next(1, 1000000000);\n    } else if (type == \"positive_negative_positive\") {\n        if (n < 3) {\n            // This type needs at least 3 elements\n            printf(\"3\\n1 -1 1\\n\");\n            return 0;\n        }\n        int k1 = rnd.next(1, n - 2);\n        int k2 = rnd.next(k1 + 1, n - 1);\n        for (int i = 0; i < k1; ++i)\n            t[i] = rnd.next(1, 1000000000);\n        for (int i = k1; i < k2; ++i)\n            t[i] = -rnd.next(1, 1000000000);\n        for (int i = k2; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n    } else if (type == \"needs_minimal_changes\") {\n        int k = rnd.next(1, n - 1);\n        for (int i = 0; i < k; ++i)\n            t[i] = -rnd.next(1, 1000000000);\n        for (int i = k; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n        // Now, introduce a single violation\n        int pos = rnd.next(0, n - 1);\n        if (t[pos] < 0)\n            t[pos] = rnd.next(1, 1000000000);\n        else\n            t[pos] = -rnd.next(1, 1000000000);\n    } else if (type == \"needs_max_changes\") {\n        // Generate a sequence where minimal changes required is maximum\n        // Let's make all signs opposite to Vasya's condition\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000000);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1))\n                t[i] = rnd.next(1, 1000000000);\n            else\n                t[i] = -rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", t[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type already_satisfying\n./gen -n 2 -type all_negative\n./gen -n 2 -type all_positive\n./gen -n 2 -type alternating\n./gen -n 2 -type random\n./gen -n 2 -type negative_positive_negative\n./gen -n 2 -type positive_negative_positive\n\n./gen -n 3 -type already_satisfying\n./gen -n 3 -type all_negative\n./gen -n 3 -type all_positive\n./gen -n 3 -type alternating\n./gen -n 3 -type random\n./gen -n 3 -type negative_positive_negative\n./gen -n 3 -type positive_negative_positive\n\n./gen -n 10 -type already_satisfying\n./gen -n 10 -type needs_minimal_changes\n./gen -n 10 -type needs_max_changes\n./gen -n 10 -type alternating\n./gen -n 10 -type random\n\n./gen -n 1000 -type already_satisfying\n./gen -n 1000 -type needs_minimal_changes\n./gen -n 1000 -type needs_max_changes\n./gen -n 1000 -type alternating\n./gen -n 1000 -type random\n\n./gen -n 100000 -type already_satisfying\n./gen -n 100000 -type needs_minimal_changes\n./gen -n 100000 -type needs_max_changes\n./gen -n 100000 -type all_negative\n./gen -n 100000 -type all_positive\n./gen -n 100000 -type alternating\n./gen -n 100000 -type negative_positive_negative\n./gen -n 100000 -type positive_negative_positive\n./gen -n 100000 -type random\n\n./gen -n 99999 -type random\n\n./gen -n 50000 -type alternating\n./gen -n 50000 -type needs_minimal_changes\n./gen -n 50000 -type negative_positive_negative\n./gen -n 50000 -type positive_negative_positive\n\n./gen -n 10 -type negative_positive_negative\n./gen -n 10 -type positive_negative_positive\n\n./gen -n 2 -type needs_minimal_changes\n./gen -n 2 -type needs_max_changes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:23.873377",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "234/E",
      "title": "E. Лига Чемпионов",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входного файла записано целое число n (4 ≤ n ≤ 64, n кратно четырем) — количество команд, принимающих участие в жеребьевке. Во второй строке записаны четыре целых числа x, a, b, c, разделенные пробелами (1 ≤ x, a, b, c ≤ 1000) — параметры генератора случайных чисел. Каждая из следующих n строк описывает по одной команде. Описание состоит из названия команды и ее рейтинга, разделенных одиночным пробелом. Название команды состоит из строчных и прописных букв латинского алфавита и имеет длину от 1 до 20 символов. Рейтинг команды это целое число от 0 до 1000. Названия всех команд различны. Рейтинги всех команд также различны.",
      "output_spec": "Выходные данныеВыведите распределение команд на группы. Группы выводите в порядке их составления в процессе жеребьевки. Группы нумеруйте последовательными заглавными буквами латинского алфавита, начиная с буквы 'A'. Внутри каждой группы выводите названия команд по одной в строке, в порядке убывания рейтинга команды. Смотрите примеры к условию для уточнения формата выходных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать81 3 1 7Barcelona 158Milan 90Spartak 46Anderlecht 48Celtic 32Benfica 87Zenit 79Malaga 16Выходные данныеСкопироватьGroup A:BarcelonaBenficaSpartakCelticGroup B:MilanZenitAnderlechtMalaga",
      "description": "E. Лига Чемпионов\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводinput.txt\n\nвыводoutput.txt\n\nВходные данныеВ первой строке входного файла записано целое число n (4 ≤ n ≤ 64, n кратно четырем) — количество команд, принимающих участие в жеребьевке. Во второй строке записаны четыре целых числа x, a, b, c, разделенные пробелами (1 ≤ x, a, b, c ≤ 1000) — параметры генератора случайных чисел. Каждая из следующих n строк описывает по одной команде. Описание состоит из названия команды и ее рейтинга, разделенных одиночным пробелом. Название команды состоит из строчных и прописных букв латинского алфавита и имеет длину от 1 до 20 символов. Рейтинг команды это целое число от 0 до 1000. Названия всех команд различны. Рейтинги всех команд также различны.\n\nВходные данные\n\nВыходные данныеВыведите распределение команд на группы. Группы выводите в порядке их составления в процессе жеребьевки. Группы нумеруйте последовательными заглавными буквами латинского алфавита, начиная с буквы 'A'. Внутри каждой группы выводите названия команд по одной в строке, в порядке убывания рейтинга команды. Смотрите примеры к условию для уточнения формата выходных данных.\n\nВыходные данные\n\nВходные данныеСкопировать81 3 1 7Barcelona 158Milan 90Spartak 46Anderlecht 48Celtic 32Benfica 87Zenit 79Malaga 16Выходные данныеСкопироватьGroup A:BarcelonaBenficaSpartakCelticGroup B:MilanZenitAnderlechtMalaga\n\nВходные данныеСкопировать81 3 1 7Barcelona 158Milan 90Spartak 46Anderlecht 48Celtic 32Benfica 87Zenit 79Malaga 16\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьGroup A:BarcelonaBenficaSpartakCelticGroup B:MilanZenitAnderlechtMalaga\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ данном примере генератор случайных чисел будет вызван четыре раза:   ,  ,  ,  .",
      "solutions": [
        {
          "title": "Codeforces Round #145 (ACM-ICPC Rules) - Codeforces",
          "content": "Доброго дня, Codeforces!Спешу обрадовать всем тем, что в списке соревнований появилось новое соревнование для div1 участников. Это соревнование является трансляцией Саратовской командной олимпиады школьников по программированию и поэтому будет проходить по правилам ACM-ICPC. Специально для div1 участников мы немного усложнили школьную олимпиаду, чтобы всем было интересно решать задачи. Соревнование — индивидуальное, оно будет рейтинговым для обоих дивизионов.Обратите внимание, что время начала соревнования отличается от обычного. Также обратите внимание, на необычную продолжительность соревнования.До встречи на Codeforces Round #145! Надеюсь, что все найдут время поучаствовать в соревновании.UPD. Соревнование закончено, скоро появится разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5531",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 752
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #145 (ACM-ICPC Rules) - Codeforces - Code 1",
          "code": "4 3\n2 3 0\n4 3 0\n1 4 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5531",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #145 (ACM-ICPC Rules) - Codeforces - Code 2",
          "code": "4 3\n2 3 0\n4 3 0\n1 4 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5531",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #145 (ACM-ICPC Rules) - Codeforces - Code 3",
          "code": "5 6\n2 1 0\n1 3 0\n4 5 0\n3 5 1\n5 2 0\n2 4 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5531",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #145 (ACM-ICPC Rules) - Codeforces - Code 4",
          "code": "5 6\n2 1 0\n1 3 0\n4 5 0\n3 5 1\n5 2 0\n2 4 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5531",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #145 (ACM-ICPC Rules) - Codeforces - Code 5",
          "code": "-2 1 -2 -2 -2 1 1 1 -2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5531",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #145 (ACM-ICPC Rules) - Codeforces - Code 6",
          "code": "-2 1 -2 -2 -2 1 1 1 -2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5531",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(4, 64, \"n\");\n    ensuref(n % 4 == 0, \"n must be divisible by 4\");\n    inf.readEoln();\n\n    int x = inf.readInt(1, 1000, \"x\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n\n    set<string> teamNames;\n    set<int> ratings;\n    for (int i = 0; i < n; ++i) {\n        string teamName = inf.readToken(\"[A-Za-z]{1,20}\", \"teamName\");\n        ensuref(teamName.size() >= 1 && teamName.size() <= 20, \"Team name \\\"%s\\\" length must be between 1 and 20\", teamName.c_str());\n        ensuref(teamNames.insert(teamName).second, \"Team name \\\"%s\\\" is not unique\", teamName.c_str());\n        inf.readSpace();\n        int rating = inf.readInt(0, 1000, \"rating\");\n        ensuref(ratings.insert(rating).second, \"Rating %d is not unique\", rating);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(4, 64, \"n\");\n    ensuref(n % 4 == 0, \"n must be divisible by 4\");\n    inf.readEoln();\n\n    int x = inf.readInt(1, 1000, \"x\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n\n    set<string> teamNames;\n    set<int> ratings;\n    for (int i = 0; i < n; ++i) {\n        string teamName = inf.readToken(\"[A-Za-z]{1,20}\", \"teamName\");\n        ensuref(teamName.size() >= 1 && teamName.size() <= 20, \"Team name \\\"%s\\\" length must be between 1 and 20\", teamName.c_str());\n        ensuref(teamNames.insert(teamName).second, \"Team name \\\"%s\\\" is not unique\", teamName.c_str());\n        inf.readSpace();\n        int rating = inf.readInt(0, 1000, \"rating\");\n        ensuref(ratings.insert(rating).second, \"Rating %d is not unique\", rating);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(4, 64, \"n\");\n    ensuref(n % 4 == 0, \"n must be divisible by 4\");\n    inf.readEoln();\n\n    int x = inf.readInt(1, 1000, \"x\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n\n    set<string> teamNames;\n    set<int> ratings;\n    for (int i = 0; i < n; ++i) {\n        string teamName = inf.readToken(\"[A-Za-z]{1,20}\", \"teamName\");\n        ensuref(teamName.size() >= 1 && teamName.size() <= 20, \"Team name \\\"%s\\\" length must be between 1 and 20\", teamName.c_str());\n        ensuref(teamNames.insert(teamName).second, \"Team name \\\"%s\\\" is not unique\", teamName.c_str());\n        inf.readSpace();\n        int rating = inf.readInt(0, 1000, \"rating\");\n        ensuref(ratings.insert(rating).second, \"Rating %d is not unique\", rating);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate random ratings\nvector<int> generateRandomRatings(int n) {\n    vector<int> ratings;\n    set<int> used_ratings;\n    for (int i = 0; i < n; ++i) {\n        int r;\n        do {\n            r = rnd.next(0, 1000);\n        } while (used_ratings.count(r));\n        used_ratings.insert(r);\n        ratings.push_back(r);\n    }\n    return ratings;\n}\n\n// Function to generate ascending ratings\nvector<int> generateAscendingRatings(int n) {\n    vector<int> ratings(n);\n    int step = max(1, 1000 / n);\n    int rating = 0;\n    for (int i = 0; i < n; ++i) {\n        ratings[i] = rating;\n        rating += step;\n        if (rating > 1000) rating = 1000;\n    }\n    return ratings;\n}\n\n// Function to generate descending ratings\nvector<int> generateDescendingRatings(int n) {\n    vector<int> ratings(n);\n    int step = max(1, 1000 / n);\n    int rating = 1000;\n    for (int i = 0; i < n; ++i) {\n        ratings[i] = rating;\n        rating -= step;\n        if (rating < 0) rating = 0;\n    }\n    return ratings;\n}\n\n// Function to generate random team names\nvector<string> generateRandomNames(int n) {\n    vector<string> names;\n    set<string> used_names;\n    for (int i = 0; i < n; ++i) {\n        int len = rnd.next(1, 20);\n        string s;\n        do {\n            s = \"\";\n            for (int j = 0; j < len; ++j) {\n                char c;\n                int t = rnd.next(0, 1); // 0 for lowercase, 1 for uppercase\n                if (t == 0)\n                    c = (char)rnd.next('a', 'z');\n                else\n                    c = (char)rnd.next('A', 'Z');\n                s += c;\n            }\n        } while (used_names.count(s));\n        used_names.insert(s);\n        names.push_back(s);\n    }\n    return names;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of teams\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    ensure(n % 4 == 0 && n >= 4 && n <= 64);\n\n    int x, a, b, c; // Parameters for RNG\n    vector<int> ratings;\n    vector<string> names = generateRandomNames(n);\n\n    if (type == \"random\") {\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        ratings = generateRandomRatings(n);\n    } else if (type == \"ascending\") {\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        ratings = generateAscendingRatings(n);\n    } else if (type == \"descending\") {\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        ratings = generateDescendingRatings(n);\n    } else if (type == \"max_params\") {\n        x = 1000;\n        a = 1000;\n        b = 1000;\n        c = 1000;\n        ratings = generateRandomRatings(n);\n    } else if (type == \"min_params\") {\n        x = 1;\n        a = 1;\n        b = 1;\n        c = 1;\n        ratings = generateRandomRatings(n);\n    } else if (type == \"small_c\") {\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(2, 10); // small c\n        ratings = generateRandomRatings(n);\n    } else if (type == \"boundary_ratings\") {\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        ratings.resize(n);\n        ratings[0] = 1000;\n        ratings[1] = 0;\n        set<int> used;\n        used.insert(1000);\n        used.insert(0);\n        for (int i = 2; i < n; ++i) {\n            int r;\n            do {\n                r = rnd.next(1, 999);\n            } while (used.count(r));\n            used.insert(r);\n            ratings[i] = r;\n        }\n    } else {\n        // Default to \"random\"\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        ratings = generateRandomRatings(n);\n    }\n\n    // Pair up ratings and names\n    vector<pair<int, string>> teams(n);\n    for (int i = 0; i < n; ++i) {\n        teams[i] = make_pair(ratings[i], names[i]);\n    }\n\n    // Sort teams in decreasing order of ratings\n    sort(teams.begin(), teams.end(), [](const pair<int, string>& a, const pair<int, string>& b) {\n        return a.first > b.first;\n    });\n\n    // Output the data\n    cout << n << '\\n';\n    cout << x << ' ' << a << ' ' << b << ' ' << c << '\\n';\n    for (int i = 0; i < n; ++i) {\n        cout << teams[i].second << ' ' << teams[i].first << '\\n';\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate random ratings\nvector<int> generateRandomRatings(int n) {\n    vector<int> ratings;\n    set<int> used_ratings;\n    for (int i = 0; i < n; ++i) {\n        int r;\n        do {\n            r = rnd.next(0, 1000);\n        } while (used_ratings.count(r));\n        used_ratings.insert(r);\n        ratings.push_back(r);\n    }\n    return ratings;\n}\n\n// Function to generate ascending ratings\nvector<int> generateAscendingRatings(int n) {\n    vector<int> ratings(n);\n    int step = max(1, 1000 / n);\n    int rating = 0;\n    for (int i = 0; i < n; ++i) {\n        ratings[i] = rating;\n        rating += step;\n        if (rating > 1000) rating = 1000;\n    }\n    return ratings;\n}\n\n// Function to generate descending ratings\nvector<int> generateDescendingRatings(int n) {\n    vector<int> ratings(n);\n    int step = max(1, 1000 / n);\n    int rating = 1000;\n    for (int i = 0; i < n; ++i) {\n        ratings[i] = rating;\n        rating -= step;\n        if (rating < 0) rating = 0;\n    }\n    return ratings;\n}\n\n// Function to generate random team names\nvector<string> generateRandomNames(int n) {\n    vector<string> names;\n    set<string> used_names;\n    for (int i = 0; i < n; ++i) {\n        int len = rnd.next(1, 20);\n        string s;\n        do {\n            s = \"\";\n            for (int j = 0; j < len; ++j) {\n                char c;\n                int t = rnd.next(0, 1); // 0 for lowercase, 1 for uppercase\n                if (t == 0)\n                    c = (char)rnd.next('a', 'z');\n                else\n                    c = (char)rnd.next('A', 'Z');\n                s += c;\n            }\n        } while (used_names.count(s));\n        used_names.insert(s);\n        names.push_back(s);\n    }\n    return names;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of teams\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    ensure(n % 4 == 0 && n >= 4 && n <= 64);\n\n    int x, a, b, c; // Parameters for RNG\n    vector<int> ratings;\n    vector<string> names = generateRandomNames(n);\n\n    if (type == \"random\") {\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        ratings = generateRandomRatings(n);\n    } else if (type == \"ascending\") {\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        ratings = generateAscendingRatings(n);\n    } else if (type == \"descending\") {\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        ratings = generateDescendingRatings(n);\n    } else if (type == \"max_params\") {\n        x = 1000;\n        a = 1000;\n        b = 1000;\n        c = 1000;\n        ratings = generateRandomRatings(n);\n    } else if (type == \"min_params\") {\n        x = 1;\n        a = 1;\n        b = 1;\n        c = 1;\n        ratings = generateRandomRatings(n);\n    } else if (type == \"small_c\") {\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(2, 10); // small c\n        ratings = generateRandomRatings(n);\n    } else if (type == \"boundary_ratings\") {\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        ratings.resize(n);\n        ratings[0] = 1000;\n        ratings[1] = 0;\n        set<int> used;\n        used.insert(1000);\n        used.insert(0);\n        for (int i = 2; i < n; ++i) {\n            int r;\n            do {\n                r = rnd.next(1, 999);\n            } while (used.count(r));\n            used.insert(r);\n            ratings[i] = r;\n        }\n    } else {\n        // Default to \"random\"\n        x = rnd.next(1, 1000);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        ratings = generateRandomRatings(n);\n    }\n\n    // Pair up ratings and names\n    vector<pair<int, string>> teams(n);\n    for (int i = 0; i < n; ++i) {\n        teams[i] = make_pair(ratings[i], names[i]);\n    }\n\n    // Sort teams in decreasing order of ratings\n    sort(teams.begin(), teams.end(), [](const pair<int, string>& a, const pair<int, string>& b) {\n        return a.first > b.first;\n    });\n\n    // Output the data\n    cout << n << '\\n';\n    cout << x << ' ' << a << ' ' << b << ' ' << c << '\\n';\n    for (int i = 0; i < n; ++i) {\n        cout << teams[i].second << ' ' << teams[i].first << '\\n';\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -type random\n./gen -n 4 -type ascending\n./gen -n 4 -type descending\n./gen -n 4 -type min_params\n./gen -n 4 -type max_params\n./gen -n 4 -type small_c\n./gen -n 4 -type boundary_ratings\n\n./gen -n 8 -type random\n./gen -n 8 -type ascending\n./gen -n 8 -type descending\n./gen -n 8 -type min_params\n./gen -n 8 -type max_params\n./gen -n 8 -type small_c\n./gen -n 8 -type boundary_ratings\n\n./gen -n 16 -type random\n./gen -n 16 -type ascending\n./gen -n 16 -type descending\n./gen -n 16 -type min_params\n./gen -n 16 -type max_params\n./gen -n 16 -type small_c\n./gen -n 16 -type boundary_ratings\n\n./gen -n 32 -type random\n./gen -n 32 -type ascending\n./gen -n 32 -type descending\n./gen -n 32 -type min_params\n./gen -n 32 -type max_params\n./gen -n 32 -type small_c\n./gen -n 32 -type boundary_ratings\n\n./gen -n 64 -type random\n./gen -n 64 -type ascending\n./gen -n 64 -type descending\n./gen -n 64 -type min_params\n./gen -n 64 -type max_params\n./gen -n 64 -type small_c\n./gen -n 64 -type boundary_ratings\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:25.550377",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "235/A",
      "title": "A. LCM Challenge",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 106) — the n mentioned in the statement.",
      "output_spec": "OutputPrint a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than n.",
      "sample_tests": "ExamplesInputCopy9OutputCopy504InputCopy7OutputCopy210",
      "description": "A. LCM Challenge\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 106) — the n mentioned in the statement.\n\nOutputPrint a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than n.\n\nInputCopy9OutputCopy504InputCopy7OutputCopy210\n\nOutputCopy504\n\nOutputCopy210\n\nNoteThe least common multiple of some positive integers is the least positive integer which is multiple for each of them.The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.",
      "solutions": [
        {
          "title": "Codeforces Round #146 - Codeforces",
          "content": "Hi!Codeforces Round #146 is going to be here soon. Round is prepared by YuukaKazami, MinakoKojima. I write problems for Div I and MinakoKojima write for Div II. Gerald did a great job in coordinating round preparing, and he also give some pretty good advise about problems. I'd like to express my gratitude to him. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Polygon system as well and Mary Belova (Delinur) for translating problems. Also thanks to donehl for testing the problems and making his comments about the problems.Score distribution is 500-1000-1500-2000-2500 in both divisions.Hope you enjoy the problems! =)I apologize for the 10 minutes delay.I'm very sorry for the inconvenience I caused. So I'm writing a good editorial for compensation :)The Editorial is here: EditorialCongrats to winners!Div1:1.rng_582.Dmitry_Egorov3.bjin4.Petr5.Egor6.touristDiv2:1.RiKang2.Caesar113.Gabaum4.ilona5.Bidhan6.sm_hossein",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5586",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 969
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces",
          "content": "236A - Boy or GirlIt is a very simple problem, just count how many distinct chars in the input and output the correct answer.236B - Easy Number ChallengeFirst of all, we can make a table of size a*b*c to store every number's d value. Then we can just brute force through every tripe to calculate the answer.235A - LCM ChallengeIt is a simple problem, but many competitors used some wrong guesses and failed. First of all, we should check if n is at most 3 and then we can simply output 1,2,6.Now there are two cases: When n is odd, the answer is obviously n(n-1)(n-2). When n is even, we can still get at least (n-1)(n-2)(n-3), so these three numbers in the optimal answer would not be very small compared to n. So we can just iterate every 3 number triple in [n-50,n] and update the answer.235B - Let's Play Osu!Let us take a deep look at how this score is calculated. For an n long 'O' block, it contributes n2 to the answer.Let us reformat this problem a bit and consider the following alternative definition of the score: (1) For each two 'O' pair which there is no 'X' between them, they add 2 to the score. (2) For each 'O', it adds 1 to the score.We claim that this new definition of the score is equivalent to the definition in the problem statement.Proof of the claim: For an n long 'O' block, there are Cn2 pairs of 'O' in it and n 'O' in it. Note that 2Cn2 + n = n2. So now we work with the new definition of the score. For each event(i,j) (which means s[i] and s[j] are 'O', and there is no 'X' between them). If event(i,j) happens, it adds 2 to the score. So we only need to sum up the probabilities of all events and multiply them by 2, and our task becomes how to calculate the sum of probabilities of all the event(i,j). Let P(i,j) be the probability of event(i,j).We can see that P(i,j) can be computed by . Then we denote P(j) as the sum of all event(i,j) for i<j. We have dp(0)=0 and dp(j)=(dp(j-1)+pj - 1)*pj235C - Cyclical QuestThis problem can be solved by many suffix structures. Probably using suffix automaton is the best way to solve it since suffix automaton is simple and clear.Let us build a suffix automaton of the input string S, and consider the query string x.Let us also build a string t as x concatenated with x dropping the last char. One can see that every consecutive sub-string of t with length |x| is a rotation of x.Let us read the string t with suffix automaton we have build, and every time take the first char out and add a new char, add the answer by the number of string equal to this current sub-string of t (which is a rotation of x).And one more thing, we should consider the repetend of x as well, check my solution here:2403375.Check here if you are not familiar with suffix automaton :e-maxx's blog235D - Graph GameFirst of all, let us consider the simpler case of trees.Let us use Event(A,B) to denote the following event \"when we select A as the deleting point, B is connected to A\".Clearly, if Event(A,B) happens, it would add 1 to totolCost.So we can just simply calculate the probability of every Event(A,B), and add them up.Let us consider how to calculate the probability of Event(A,B).Assume there are n vertices in the path between A and B, we claim that the probability is simply 1 / n.Let us try to prove it using induction.First let us assume there's a connected sub-graph of the tree containing both A and B, if the sub-graph only has n vertices, then the event happens only if we select vertex A, so the probability is 1 / n.Otherwise, assume it has x vertices there is two cases: whether the selected vertex is on the path between A and B or not.In the first case, the probability of Event(A,B) happen is 1 / x because if we don't select A, Event(A,B) will never happen.In the second case, the sub-graph containing A,B has become smaller, so the probability is (x - n) / xn.So add them up we can prove this statement.Then we can solve the tree case by simply add up the inverse of every path's length in the tree.And for the original case, there's at most 2 paths between A and B.If there's only one path, then everything is the same with the tree case.Otherwise, the path between A and B should pass the cycle in the graph.Let us examine this case, you can see that there 2 types of vertex:Vertex on the path of A to cycle or B to cycle, they should not be selected before A because once they're selected, A and B lost connectivity, let us call them X.Vertex on the cycle, the two paths from A to B, each path contains a path in the cycle, let us call them Y and Z.So there are two possibilities: X and Y are free when A is selected, X and Z are free when A is selected.And we should subtract the case that X and Y, Z are all free when A is selected because it double-counts before.So the probability is 1 / (X + Y + 1) + 1 / (X + Z + 1) - 1 / (X + Y + Z + 1).Check Petr 's solution for the details: 2401228And my C++ implementation: 2403938235E - Number ChallengeLet us consider each prime in one step, the upper limit for a, b, c is recorded.So if we fixed the power of 2 in each i, j, k like 2x, 2y, 2z, then their upper limit becomes a / 2x, b / 2y, c / 2z, and the power of 2 in their multiplication is just x+y+z.Let us denote dp(a, b, c, p) for the answer to the original problem that i, j, k 's upper limit is a, b, c. And their can only use the prime factors which are not less than p.Let the next prime to be q, so we can try to fix the power of p in i, j, k and get the new upper limit.So we can do transform like this: dp(a, b, c, p) = sum of dp(a / px, b / py, c / pz, q)·(x + y + z + 1)Check my code here: 2404223Also you can check rng_58 solution here: http://codeforces.com/blog/entry/5600If you have any problems, you can ask here :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 235\\s*A"
          },
          "content_length": 5718
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #146 - Codeforces - Code 1",
          "code": "IGNORE HER!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 2",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 3",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 4",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 5",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 1",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 2",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 3",
          "code": "n = int(input())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 4",
          "code": "if n==1 or n==2:     print(n)     exit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 5",
          "code": "if n&1:     print((n)*(n-1)*(n-2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 6",
          "code": "else:     print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 7",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 8",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n_max = 1000000; // 1e6\n    string type = opt<string>(\"type\", \"random\");\n    int n;\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"small\") {\n        // Generate small n in range 2 to 10\n        n = rnd.next(2, 10);\n    } else if (type == \"medium\") {\n        // Generate medium n in range 100 to 1000\n        n = rnd.next(100, 1000);\n    } else if (type == \"large\") {\n        // Generate large n in range 10000 to 100000\n        n = rnd.next(10000, 100000);\n    } else if (type == \"max\") {\n        n = n_max;\n    } else if (type == \"even\") {\n        // Generate even n up to n_max\n        n = rnd.next(1, n_max / 2) * 2;\n    } else if (type == \"odd\") {\n        // Generate odd n up to n_max\n        n = rnd.next(1, n_max / 2) * 2 - 1;\n        if (n < 1) n = 1;\n    } else if (type == \"random\") {\n        n = rnd.next(1, n_max);\n    } else if (type == \"n_minus_one\") {\n        n = n_max - 1;\n    } else if (type == \"near_three\") {\n        n = 3;\n    } else if (type == \"even_small\") {\n        n = rnd.next(1, 5) * 2;\n    } else if (type == \"odd_small\") {\n        n = rnd.next(1, 5) * 2 - 1;\n    } else if (type == \"multiple_of_three\") {\n        n = rnd.next(1, n_max / 3) * 3;\n    } else if (type == \"multiple_of_five\") {\n        n = rnd.next(1, n_max / 5) * 5;\n    } else if (type == \"multiple_of_seven\") {\n        n = rnd.next(1, n_max / 7) * 7;\n    } else if (type == \"multiple_of_ten\") {\n        n = rnd.next(1, n_max / 10) * 10;\n    } else {\n        // Default to random\n        n = rnd.next(1, n_max);\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n_max = 1000000; // 1e6\n    string type = opt<string>(\"type\", \"random\");\n    int n;\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"small\") {\n        // Generate small n in range 2 to 10\n        n = rnd.next(2, 10);\n    } else if (type == \"medium\") {\n        // Generate medium n in range 100 to 1000\n        n = rnd.next(100, 1000);\n    } else if (type == \"large\") {\n        // Generate large n in range 10000 to 100000\n        n = rnd.next(10000, 100000);\n    } else if (type == \"max\") {\n        n = n_max;\n    } else if (type == \"even\") {\n        // Generate even n up to n_max\n        n = rnd.next(1, n_max / 2) * 2;\n    } else if (type == \"odd\") {\n        // Generate odd n up to n_max\n        n = rnd.next(1, n_max / 2) * 2 - 1;\n        if (n < 1) n = 1;\n    } else if (type == \"random\") {\n        n = rnd.next(1, n_max);\n    } else if (type == \"n_minus_one\") {\n        n = n_max - 1;\n    } else if (type == \"near_three\") {\n        n = 3;\n    } else if (type == \"even_small\") {\n        n = rnd.next(1, 5) * 2;\n    } else if (type == \"odd_small\") {\n        n = rnd.next(1, 5) * 2 - 1;\n    } else if (type == \"multiple_of_three\") {\n        n = rnd.next(1, n_max / 3) * 3;\n    } else if (type == \"multiple_of_five\") {\n        n = rnd.next(1, n_max / 5) * 5;\n    } else if (type == \"multiple_of_seven\") {\n        n = rnd.next(1, n_max / 7) * 7;\n    } else if (type == \"multiple_of_ten\") {\n        n = rnd.next(1, n_max / 10) * 10;\n    } else {\n        // Default to random\n        n = rnd.next(1, n_max);\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type near_three\n./gen -type small\n./gen -type small\n./gen -type small\n./gen -type medium\n./gen -type medium\n./gen -type medium\n./gen -type large\n./gen -type large\n./gen -type large\n./gen -type max\n./gen -type n_minus_one\n./gen -type even_small\n./gen -type odd_small\n./gen -type even\n./gen -type odd\n./gen -type multiple_of_three\n./gen -type multiple_of_five\n./gen -type multiple_of_seven\n./gen -type multiple_of_ten\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:27.269174",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "235/B",
      "title": "B. Сыграем в Osu!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество кликов. Во второй строке записаны n вещественных чисел через пробел p1, p2, ..., pn (0 ≤ pi ≤ 1).Гарантируется, что заданные pi содержат не больше шести знаков после десятичной точки.",
      "output_spec": "Выходные данныеВыведите единственное вещественное число — ожидаемый счет Вашей игры. Ваш ответ будет считаться корректным, если его абсолютная или относительная погрешность не превышает 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать30.5 0.5 0.5Выходные данныеСкопировать2.750000000000000Входные данныеСкопировать40.7 0.2 0.1 0.9Выходные данныеСкопировать2.489200000000000Входные данныеСкопировать51 1 1 1 1Выходные данныеСкопировать25.000000000000000",
      "description": "B. Сыграем в Osu!\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество кликов. Во второй строке записаны n вещественных чисел через пробел p1, p2, ..., pn (0 ≤ pi ≤ 1).Гарантируется, что заданные pi содержат не больше шести знаков после десятичной точки.\n\nВходные данные\n\nВыходные данныеВыведите единственное вещественное число — ожидаемый счет Вашей игры. Ваш ответ будет считаться корректным, если его абсолютная или относительная погрешность не превышает 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать30.5 0.5 0.5Выходные данныеСкопировать2.750000000000000Входные данныеСкопировать40.7 0.2 0.1 0.9Выходные данныеСкопировать2.489200000000000Входные данныеСкопировать51 1 1 1 1Выходные данныеСкопировать25.000000000000000\n\nВходные данныеСкопировать30.5 0.5 0.5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.750000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать40.7 0.2 0.1 0.9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.489200000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 1 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать25.000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПояснение к первому примеру. Есть 8 возможных исходов. Вероятность каждого из них составляет 0.125.  «OOO»  →  32 = 9;  «OOX»  →  22 = 4;  «OXO»  →  12 + 12 = 2;  «OXX»  →  12 = 1;  «XOO»  →  22 = 4;  «XOX»  →  12 = 1;  «XXO»  →  12 = 1;  «XXX»  →  0. Таким образом, ожидаемый счет составляет .",
      "solutions": [
        {
          "title": "Codeforces Round #146 - Codeforces",
          "content": "Всем привет!Совсем скоро начнется соревнование Codeforces Round #146. Этот раунд был приготовлен YuukaKazami, MinakoKojima. Я сделал задачи для Div I, а MinakoKojima — для Div II. Как обычно, Gerald очень сильно помог нам в подготовке раунда, давая много советов по задачам. Спасибо ему за это. Традиционно спасибо Михаилу Мирзаянову (MikeMirzayanov) за прекрасные системы Codeforces и Polygon, а также Марии Беловой (Delinur) за перевод задач. Также хочется сказать спасибо donehl за тестирование задач и за его ценные комментарии к задачам.В обоих дивизионах будет использоваться стандартная разбалловка 500-1000-1500-2000-2500.Надеюсь вам понравятся задачи! =)Это перевод оригинального поста автора с английского языка. Английский в комментариях приветствуется.Прошу прощения за 10-минутную задержку. Мне очень жаль за доставленные неудобства, которые я вызвал. В качестве компенсации, я напишу хороший разбор =)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5586",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 915
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces",
          "content": "236A - Boy or GirlIt is a very simple problem, just count how many distinct chars in the input and output the correct answer.236B - Easy Number ChallengeFirst of all, we can make a table of size a*b*c to store every number's d value. Then we can just brute force through every tripe to calculate the answer.235A - LCM ChallengeIt is a simple problem, but many competitors used some wrong guesses and failed. First of all, we should check if n is at most 3 and then we can simply output 1,2,6.Now there are two cases: When n is odd, the answer is obviously n(n-1)(n-2). When n is even, we can still get at least (n-1)(n-2)(n-3), so these three numbers in the optimal answer would not be very small compared to n. So we can just iterate every 3 number triple in [n-50,n] and update the answer.235B - Let's Play Osu!Let us take a deep look at how this score is calculated. For an n long 'O' block, it contributes n2 to the answer.Let us reformat this problem a bit and consider the following alternative definition of the score: (1) For each two 'O' pair which there is no 'X' between them, they add 2 to the score. (2) For each 'O', it adds 1 to the score.We claim that this new definition of the score is equivalent to the definition in the problem statement.Proof of the claim: For an n long 'O' block, there are Cn2 pairs of 'O' in it and n 'O' in it. Note that 2Cn2 + n = n2. So now we work with the new definition of the score. For each event(i,j) (which means s[i] and s[j] are 'O', and there is no 'X' between them). If event(i,j) happens, it adds 2 to the score. So we only need to sum up the probabilities of all events and multiply them by 2, and our task becomes how to calculate the sum of probabilities of all the event(i,j). Let P(i,j) be the probability of event(i,j).We can see that P(i,j) can be computed by . Then we denote P(j) as the sum of all event(i,j) for i<j. We have dp(0)=0 and dp(j)=(dp(j-1)+pj - 1)*pj235C - Cyclical QuestThis problem can be solved by many suffix structures. Probably using suffix automaton is the best way to solve it since suffix automaton is simple and clear.Let us build a suffix automaton of the input string S, and consider the query string x.Let us also build a string t as x concatenated with x dropping the last char. One can see that every consecutive sub-string of t with length |x| is a rotation of x.Let us read the string t with suffix automaton we have build, and every time take the first char out and add a new char, add the answer by the number of string equal to this current sub-string of t (which is a rotation of x).And one more thing, we should consider the repetend of x as well, check my solution here:2403375.Check here if you are not familiar with suffix automaton :e-maxx's blog235D - Graph GameFirst of all, let us consider the simpler case of trees.Let us use Event(A,B) to denote the following event \"when we select A as the deleting point, B is connected to A\".Clearly, if Event(A,B) happens, it would add 1 to totolCost.So we can just simply calculate the probability of every Event(A,B), and add them up.Let us consider how to calculate the probability of Event(A,B).Assume there are n vertices in the path between A and B, we claim that the probability is simply 1 / n.Let us try to prove it using induction.First let us assume there's a connected sub-graph of the tree containing both A and B, if the sub-graph only has n vertices, then the event happens only if we select vertex A, so the probability is 1 / n.Otherwise, assume it has x vertices there is two cases: whether the selected vertex is on the path between A and B or not.In the first case, the probability of Event(A,B) happen is 1 / x because if we don't select A, Event(A,B) will never happen.In the second case, the sub-graph containing A,B has become smaller, so the probability is (x - n) / xn.So add them up we can prove this statement.Then we can solve the tree case by simply add up the inverse of every path's length in the tree.And for the original case, there's at most 2 paths between A and B.If there's only one path, then everything is the same with the tree case.Otherwise, the path between A and B should pass the cycle in the graph.Let us examine this case, you can see that there 2 types of vertex:Vertex on the path of A to cycle or B to cycle, they should not be selected before A because once they're selected, A and B lost connectivity, let us call them X.Vertex on the cycle, the two paths from A to B, each path contains a path in the cycle, let us call them Y and Z.So there are two possibilities: X and Y are free when A is selected, X and Z are free when A is selected.And we should subtract the case that X and Y, Z are all free when A is selected because it double-counts before.So the probability is 1 / (X + Y + 1) + 1 / (X + Z + 1) - 1 / (X + Y + Z + 1).Check Petr 's solution for the details: 2401228And my C++ implementation: 2403938235E - Number ChallengeLet us consider each prime in one step, the upper limit for a, b, c is recorded.So if we fixed the power of 2 in each i, j, k like 2x, 2y, 2z, then their upper limit becomes a / 2x, b / 2y, c / 2z, and the power of 2 in their multiplication is just x+y+z.Let us denote dp(a, b, c, p) for the answer to the original problem that i, j, k 's upper limit is a, b, c. And their can only use the prime factors which are not less than p.Let the next prime to be q, so we can try to fix the power of p in i, j, k and get the new upper limit.So we can do transform like this: dp(a, b, c, p) = sum of dp(a / px, b / py, c / pz, q)·(x + y + z + 1)Check my code here: 2404223Also you can check rng_58 solution here: http://codeforces.com/blog/entry/5600If you have any problems, you can ask here :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 235\\s*B"
          },
          "content_length": 5718
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #146 - Codeforces - Code 1",
          "code": "IGNORE HER!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 2",
          "code": "s11 = P*s1+P*s2+2*P*s3;\ns22 = P*s2+(1-P);\ns33 = P*(s3+s2);\ns44 = s4*P+(1-P)*dp[i-1];\ndp[i] = s44+s11+cp*(i+1)*(i+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 3",
          "code": "s11 = P*s1+P*s2+2*P*s3;\ns22 = P*s2+(1-P);\ns33 = P*(s3+s2);\ns44 = s4*P+(1-P)*dp[i-1];\ndp[i] = s44+s11+cp*(i+1)*(i+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 4",
          "code": "q_j*dp[i-j-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 5",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 6",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 7",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 8",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 1",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 2",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 3",
          "code": "n = int(input())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 4",
          "code": "if n==1 or n==2:     print(n)     exit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 5",
          "code": "if n&1:     print((n)*(n-1)*(n-2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 6",
          "code": "else:     print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 7",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 8",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"0(\\\\.\\\\d{1,6})?|1(\\\\.0{1,6})?\";\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        string pi_str = inf.readToken(pattern);\n        double p_i = stod(pi_str);\n        ensuref(p_i >= 0.0 && p_i <= 1.0, \"p[%d] = %lf is not in range [0, 1]\", i + 1, p_i);\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"0(\\\\.\\\\d{1,6})?|1(\\\\.0{1,6})?\";\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        string pi_str = inf.readToken(pattern);\n        double p_i = stod(pi_str);\n        ensuref(p_i >= 0.0 && p_i <= 1.0, \"p[%d] = %lf is not in range [0, 1]\", i + 1, p_i);\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"0(\\\\.\\\\d{1,6})?|1(\\\\.0{1,6})?\";\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        string pi_str = inf.readToken(pattern);\n        double p_i = stod(pi_str);\n        ensuref(p_i >= 0.0 && p_i <= 1.0, \"p[%d] = %lf is not in range [0, 1]\", i + 1, p_i);\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<double> p;\n    p.reserve(n);\n\n    if (type == \"all_zero\") {\n        for(int i = 0; i < n; ++i)\n            p.push_back(0.0);\n    } else if (type == \"all_one\") {\n        for(int i = 0; i < n; ++i)\n            p.push_back(1.0);\n    } else if (type == \"alternating_zero_one\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                p.push_back(0.0);\n            else\n                p.push_back(1.0);\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            p.push_back(rnd.next(0.0, 1.0));\n        }\n    } else if (type == \"small_values\") {\n        for(int i = 0; i < n; ++i) {\n            p.push_back(rnd.next(0.0, 1e-6));\n        }\n    } else if (type == \"large_values\") {\n        for(int i = 0; i < n; ++i) {\n            p.push_back(1.0 - rnd.next(0.0, 1e-6));\n        }\n    } else if (type == \"increasing\") {\n        if (n == 1)\n            p.push_back(0.0);\n        else {\n            for(int i = 0; i < n; ++i) {\n                p.push_back(1.0 * i / (n - 1));\n            }\n        }\n    } else if (type == \"decreasing\") {\n        if (n == 1)\n            p.push_back(1.0);\n        else {\n            for(int i = 0; i < n; ++i) {\n                p.push_back(1.0 - 1.0 * i / (n - 1));\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure that p_i has at most six digits after decimal point\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        // Round p[i] to six decimal places\n        double pi = (int)(p[i] * 1e6 + 0.5) / 1e6;\n        printf(\"%.6f\", pi);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<double> p;\n    p.reserve(n);\n\n    if (type == \"all_zero\") {\n        for(int i = 0; i < n; ++i)\n            p.push_back(0.0);\n    } else if (type == \"all_one\") {\n        for(int i = 0; i < n; ++i)\n            p.push_back(1.0);\n    } else if (type == \"alternating_zero_one\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                p.push_back(0.0);\n            else\n                p.push_back(1.0);\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            p.push_back(rnd.next(0.0, 1.0));\n        }\n    } else if (type == \"small_values\") {\n        for(int i = 0; i < n; ++i) {\n            p.push_back(rnd.next(0.0, 1e-6));\n        }\n    } else if (type == \"large_values\") {\n        for(int i = 0; i < n; ++i) {\n            p.push_back(1.0 - rnd.next(0.0, 1e-6));\n        }\n    } else if (type == \"increasing\") {\n        if (n == 1)\n            p.push_back(0.0);\n        else {\n            for(int i = 0; i < n; ++i) {\n                p.push_back(1.0 * i / (n - 1));\n            }\n        }\n    } else if (type == \"decreasing\") {\n        if (n == 1)\n            p.push_back(1.0);\n        else {\n            for(int i = 0; i < n; ++i) {\n                p.push_back(1.0 - 1.0 * i / (n - 1));\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure that p_i has at most six digits after decimal point\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        // Round p[i] to six decimal places\n        double pi = (int)(p[i] * 1e6 + 0.5) / 1e6;\n        printf(\"%.6f\", pi);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zero\n./gen -n 1 -type all_one\n./gen -n 1 -type random\n./gen -n 1 -type alternating_zero_one\n./gen -n 1 -type small_values\n./gen -n 1 -type large_values\n./gen -n 1 -type increasing\n./gen -n 1 -type decreasing\n\n./gen -n 10 -type all_zero\n./gen -n 10 -type all_one\n./gen -n 10 -type random\n./gen -n 10 -type alternating_zero_one\n./gen -n 10 -type small_values\n./gen -n 10 -type large_values\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_zero\n./gen -n 100000 -type all_one\n./gen -n 100000 -type small_values\n./gen -n 100000 -type large_values\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type alternating_zero_one\n\n./gen -n 99999 -type random\n./gen -n 99999 -type small_values\n./gen -n 99999 -type large_values\n\n./gen -n 12345 -type random\n\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n\n./gen -n 100000 -type small_values\n./gen -n 100000 -type large_values\n\n./gen -n 50000 -type random\n./gen -n 50000 -type alternating_zero_one\n./gen -n 50000 -type increasing\n./gen -n 50000 -type decreasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:29.289571",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "235/C",
      "title": "C. Циклическая Задача",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит непустую строку s. Длина строки s не превышает 106 символов.Вторая строка содержит целое число n (1 ≤ n ≤ 105) — количество запросов. Затем следуют n строк: в i-ой из них записана строка xi — строка для i-го запроса. Общая длина xi не превышает 106 символов.В этой задаче строки состоят только из строчных букв латинского алфавита.",
      "output_spec": "Выходные данныеДля каждого запроса xi выведите единственное целое число — количество последовательных подстрок в s, которые циклически изоморфны xi. Выводите ответы на запросы в том порядке, в котором запросы заданы во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопироватьbaabaabaaa5ababaaaabaaaabaВыходные данныеСкопировать75735Входные данныеСкопироватьaabbaa3aaaabbabbaВыходные данныеСкопировать233",
      "description": "C. Циклическая Задача\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит непустую строку s. Длина строки s не превышает 106 символов.Вторая строка содержит целое число n (1 ≤ n ≤ 105) — количество запросов. Затем следуют n строк: в i-ой из них записана строка xi — строка для i-го запроса. Общая длина xi не превышает 106 символов.В этой задаче строки состоят только из строчных букв латинского алфавита.\n\nВходные данные\n\nВыходные данныеДля каждого запроса xi выведите единственное целое число — количество последовательных подстрок в s, которые циклически изоморфны xi. Выводите ответы на запросы в том порядке, в котором запросы заданы во входных данных.\n\nВыходные данные\n\nВходные данныеСкопироватьbaabaabaaa5ababaaaabaaaabaВыходные данныеСкопировать75735Входные данныеСкопироватьaabbaa3aaaabbabbaВыходные данныеСкопировать233\n\nВходные данныеСкопироватьbaabaabaaa5ababaaaabaaaaba\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать75735\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьaabbaa3aaaabbabba\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать233\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #146 - Codeforces",
          "content": "Всем привет!Совсем скоро начнется соревнование Codeforces Round #146. Этот раунд был приготовлен YuukaKazami, MinakoKojima. Я сделал задачи для Div I, а MinakoKojima — для Div II. Как обычно, Gerald очень сильно помог нам в подготовке раунда, давая много советов по задачам. Спасибо ему за это. Традиционно спасибо Михаилу Мирзаянову (MikeMirzayanov) за прекрасные системы Codeforces и Polygon, а также Марии Беловой (Delinur) за перевод задач. Также хочется сказать спасибо donehl за тестирование задач и за его ценные комментарии к задачам.В обоих дивизионах будет использоваться стандартная разбалловка 500-1000-1500-2000-2500.Надеюсь вам понравятся задачи! =)Это перевод оригинального поста автора с английского языка. Английский в комментариях приветствуется.Прошу прощения за 10-минутную задержку. Мне очень жаль за доставленные неудобства, которые я вызвал. В качестве компенсации, я напишу хороший разбор =)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5586",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 915
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces",
          "content": "236A - Boy or GirlIt is a very simple problem, just count how many distinct chars in the input and output the correct answer.236B - Easy Number ChallengeFirst of all, we can make a table of size a*b*c to store every number's d value. Then we can just brute force through every tripe to calculate the answer.235A - LCM ChallengeIt is a simple problem, but many competitors used some wrong guesses and failed. First of all, we should check if n is at most 3 and then we can simply output 1,2,6.Now there are two cases: When n is odd, the answer is obviously n(n-1)(n-2). When n is even, we can still get at least (n-1)(n-2)(n-3), so these three numbers in the optimal answer would not be very small compared to n. So we can just iterate every 3 number triple in [n-50,n] and update the answer.235B - Let's Play Osu!Let us take a deep look at how this score is calculated. For an n long 'O' block, it contributes n2 to the answer.Let us reformat this problem a bit and consider the following alternative definition of the score: (1) For each two 'O' pair which there is no 'X' between them, they add 2 to the score. (2) For each 'O', it adds 1 to the score.We claim that this new definition of the score is equivalent to the definition in the problem statement.Proof of the claim: For an n long 'O' block, there are Cn2 pairs of 'O' in it and n 'O' in it. Note that 2Cn2 + n = n2. So now we work with the new definition of the score. For each event(i,j) (which means s[i] and s[j] are 'O', and there is no 'X' between them). If event(i,j) happens, it adds 2 to the score. So we only need to sum up the probabilities of all events and multiply them by 2, and our task becomes how to calculate the sum of probabilities of all the event(i,j). Let P(i,j) be the probability of event(i,j).We can see that P(i,j) can be computed by . Then we denote P(j) as the sum of all event(i,j) for i<j. We have dp(0)=0 and dp(j)=(dp(j-1)+pj - 1)*pj235C - Cyclical QuestThis problem can be solved by many suffix structures. Probably using suffix automaton is the best way to solve it since suffix automaton is simple and clear.Let us build a suffix automaton of the input string S, and consider the query string x.Let us also build a string t as x concatenated with x dropping the last char. One can see that every consecutive sub-string of t with length |x| is a rotation of x.Let us read the string t with suffix automaton we have build, and every time take the first char out and add a new char, add the answer by the number of string equal to this current sub-string of t (which is a rotation of x).And one more thing, we should consider the repetend of x as well, check my solution here:2403375.Check here if you are not familiar with suffix automaton :e-maxx's blog235D - Graph GameFirst of all, let us consider the simpler case of trees.Let us use Event(A,B) to denote the following event \"when we select A as the deleting point, B is connected to A\".Clearly, if Event(A,B) happens, it would add 1 to totolCost.So we can just simply calculate the probability of every Event(A,B), and add them up.Let us consider how to calculate the probability of Event(A,B).Assume there are n vertices in the path between A and B, we claim that the probability is simply 1 / n.Let us try to prove it using induction.First let us assume there's a connected sub-graph of the tree containing both A and B, if the sub-graph only has n vertices, then the event happens only if we select vertex A, so the probability is 1 / n.Otherwise, assume it has x vertices there is two cases: whether the selected vertex is on the path between A and B or not.In the first case, the probability of Event(A,B) happen is 1 / x because if we don't select A, Event(A,B) will never happen.In the second case, the sub-graph containing A,B has become smaller, so the probability is (x - n) / xn.So add them up we can prove this statement.Then we can solve the tree case by simply add up the inverse of every path's length in the tree.And for the original case, there's at most 2 paths between A and B.If there's only one path, then everything is the same with the tree case.Otherwise, the path between A and B should pass the cycle in the graph.Let us examine this case, you can see that there 2 types of vertex:Vertex on the path of A to cycle or B to cycle, they should not be selected before A because once they're selected, A and B lost connectivity, let us call them X.Vertex on the cycle, the two paths from A to B, each path contains a path in the cycle, let us call them Y and Z.So there are two possibilities: X and Y are free when A is selected, X and Z are free when A is selected.And we should subtract the case that X and Y, Z are all free when A is selected because it double-counts before.So the probability is 1 / (X + Y + 1) + 1 / (X + Z + 1) - 1 / (X + Y + Z + 1).Check Petr 's solution for the details: 2401228And my C++ implementation: 2403938235E - Number ChallengeLet us consider each prime in one step, the upper limit for a, b, c is recorded.So if we fixed the power of 2 in each i, j, k like 2x, 2y, 2z, then their upper limit becomes a / 2x, b / 2y, c / 2z, and the power of 2 in their multiplication is just x+y+z.Let us denote dp(a, b, c, p) for the answer to the original problem that i, j, k 's upper limit is a, b, c. And their can only use the prime factors which are not less than p.Let the next prime to be q, so we can try to fix the power of p in i, j, k and get the new upper limit.So we can do transform like this: dp(a, b, c, p) = sum of dp(a / px, b / py, c / pz, q)·(x + y + z + 1)Check my code here: 2404223Also you can check rng_58 solution here: http://codeforces.com/blog/entry/5600If you have any problems, you can ask here :)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 235\\s*C"
          },
          "content_length": 5718
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #146 - Codeforces - Code 1",
          "code": "IGNORE HER!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 2",
          "code": "s11 = P*s1+P*s2+2*P*s3;\ns22 = P*s2+(1-P);\ns33 = P*(s3+s2);\ns44 = s4*P+(1-P)*dp[i-1];\ndp[i] = s44+s11+cp*(i+1)*(i+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 3",
          "code": "s11 = P*s1+P*s2+2*P*s3;\ns22 = P*s2+(1-P);\ns33 = P*(s3+s2);\ns44 = s4*P+(1-P)*dp[i-1];\ndp[i] = s44+s11+cp*(i+1)*(i+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 4",
          "code": "q_j*dp[i-j-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 5",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 6",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 7",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 8",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 1",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 2",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 3",
          "code": "n = int(input())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 4",
          "code": "if n==1 or n==2:     print(n)     exit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 5",
          "code": "if n&1:     print((n)*(n-1)*(n-2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 6",
          "code": "else:     print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 7",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 8",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(int argc, char* argv[]) {\r\n    registerValidation(argc, argv);\r\n\r\n    // First line: s\r\n    string s = inf.readLine();\r\n    ensuref(s.size()>=1 && s.size()<=1000000, \"The length of string s should be in [1, 1000000].\");\r\n    for (char i: s) ensuref(i >= 'a' && i<= 'z', \"String s does not match pattern [a-z].\");\r\n\r\n    // Second line: n\r\n    int n = inf.readInt(1, 100000, \"n\");\r\n    inf.readEoln();\r\n\r\n    long long sum_length_xi = 0;\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        string xi = inf.readLine(\"[a-z]*\", \"xi\");\r\n        sum_length_xi += xi.length();\r\n    }\r\n    ensuref(sum_length_xi <= 1000000, \"The total length of xi should be at most 1e6\");\r\n\r\n    inf.readEof();\r\n    return 0;\r\n}",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(int argc, char* argv[]) {\r\n    registerValidation(argc, argv);\r\n\r\n    // First line: s\r\n    string s = inf.readLine();\r\n    ensuref(s.size()>=1 && s.size()<=1000000, \"The length of string s should be in [1, 1000000].\");\r\n    for (char i: s) ensuref(i >= 'a' && i<= 'z', \"String s does not match pattern [a-z].\");\r\n\r\n    // Second line: n\r\n    int n = inf.readInt(1, 100000, \"n\");\r\n    inf.readEoln();\r\n\r\n    long long sum_length_xi = 0;\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        string xi = inf.readLine(\"[a-z]*\", \"xi\");\r\n        sum_length_xi += xi.length();\r\n    }\r\n    ensuref(sum_length_xi <= 1000000, \"The total length of xi should be at most 1e6\");\r\n\r\n    inf.readEof();\r\n    return 0;\r\n}",
            "output_validator": "#include \"testlib.h\"\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(int argc, char* argv[]) {\r\n    registerValidation(argc, argv);\r\n\r\n    // First line: s\r\n    string s = inf.readLine();\r\n    ensuref(s.size()>=1 && s.size()<=1000000, \"The length of string s should be in [1, 1000000].\");\r\n    for (char i: s) ensuref(i >= 'a' && i<= 'z', \"String s does not match pattern [a-z].\");\r\n\r\n    // Second line: n\r\n    int n = inf.readInt(1, 100000, \"n\");\r\n    inf.readEoln();\r\n\r\n    long long sum_length_xi = 0;\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        string xi = inf.readLine(\"[a-z]*\", \"xi\");\r\n        sum_length_xi += xi.length();\r\n    }\r\n    ensuref(sum_length_xi <= 1000000, \"The total length of xi should be at most 1e6\");\r\n\r\n    inf.readEof();\r\n    return 0;\r\n}",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly ONE test case per execution.\n\n  Test case format:\n    1) A single string s (length <= 1e6).\n    2) An integer n (1 <= n <= 1e5).\n    3) n lines, each a query string x_i.\n       The total length of all queries should stay around or below 1e6.\n\n  Command-line parameters:\n    -len_s    (int) : size of the main string s\n    -n        (int) : number of queries\n    -sType    (string) : type of main string (\"random\", \"periodic\", \"all_a\", \"palindrome\", \"smallalpha\")\n    -qType    (string) : type of queries (\"random\", \"bigger\", \"substrings\", \"small\", \"mix\")\n\n  Example usage:\n    ./gen -len_s 10 -n 5 -sType random -qType random\n*/\n\n// Alphabet size for lowercase English letters.\nstatic const int ALPH_SIZE = 26;\n\n/*\n  Generates a random string of given length using characters\n  ['a'.. 'a'+alphaSize-1].\n*/\nstring generateRandomString(int length, int alphaSize = ALPH_SIZE) {\n    // Fallback if length <= 0.\n    if (length <= 0) {\n        return \"a\";\n    }\n    string result;\n    result.reserve(length);\n    for (int i = 0; i < length; i++) {\n        result.push_back(char('a' + rnd.next(alphaSize)));\n    }\n    return result;\n}\n\n/*\n  Generate a periodic string of length 'length',\n  repeating a pattern of length 'period'.\n*/\nstring generatePeriodicString(int length, int period, int alphaSize = ALPH_SIZE) {\n    if (period <= 0) {\n        return generateRandomString(length, alphaSize);\n    }\n    string unit = generateRandomString(period, alphaSize);\n    string ret;\n    ret.reserve(length);\n    for (int i = 0; i < length; i++) {\n        ret.push_back(unit[i % period]);\n    }\n    return ret;\n}\n\n/*\n  Generate a palindrome of length 'length'.\n*/\nstring generatePalindrome(int length, int alphaSize = ALPH_SIZE) {\n    if (length <= 0) {\n        return \"a\";\n    }\n    string s(length, 'a');\n    for (int i = 0; i < (length + 1) / 2; i++) {\n        s[i] = char('a' + rnd.next(alphaSize));\n    }\n    for (int i = 0; i < length / 2; i++) {\n        s[length - 1 - i] = s[i];\n    }\n    return s;\n}\n\n/*\n  Generate the main string s according to sType.\n*/\nstring generateString(int lenS, const string &sType) {\n    if (lenS <= 0) {\n        return \"a\";\n    }\n    if (sType == \"random\") {\n        return generateRandomString(lenS);\n    } else if (sType == \"periodic\") {\n        // period is up to min(lenS, 10)\n        int period = rnd.next(1, min(lenS, 10));\n        return generatePeriodicString(lenS, period);\n    } else if (sType == \"all_a\") {\n        return string(lenS, 'a');\n    } else if (sType == \"palindrome\") {\n        return generatePalindrome(lenS);\n    } else if (sType == \"smallalpha\") {\n        // an alphabet of size 3\n        return generateRandomString(lenS, 3);\n    }\n    // default fallback\n    return generateRandomString(lenS);\n}\n\n/*\n  Generate n query strings of various patterns. \n  Each query is formed according to qType, and we clamp the lengths\n  so total won't exceed ~1e6.\n\n  qType:\n    \"random\":     random length up to 2*lenS (clamped).\n    \"bigger\":     attempt queries > lenS, with offsets, also clamped.\n    \"substrings\": random substring of s (optional rotation).\n    \"small\":      length in {1,2}.\n    \"mix\":        a random combination of the above ideas.\n\n  To reduce risk of segfault, we carefully clamp index choices and lengths.\n*/\nvector<string> generateQueries(int n, int lenS, const string &originalS, const string &qType) {\n    vector<string> queries;\n    queries.reserve(n);\n\n    // Approx. max length per query so total won't exceed ~1e6\n    int maxAllowedLen = (n == 0 ? 1 : max<int>(1, 1000000 / n));\n\n    for (int i = 0; i < n; i++) {\n        int lengthQuery = 1;\n        string qStr;\n\n        if (qType == \"random\") {\n            // length range 1..(2*lenS), clamp by maxAllowedLen, fallback if lenS=0\n            if (lenS > 0) {\n                int bound = min(2 * lenS, maxAllowedLen);\n                bound = max(bound, 1); // ensure at least 1\n                lengthQuery = rnd.next(1, bound);\n            } else {\n                lengthQuery = rnd.next(1, maxAllowedLen);\n            }\n            qStr = generateRandomString(lengthQuery);\n        }\n        else if (qType == \"bigger\") {\n            /*\n              Range [lenS+1 .. lenS+5], clamp to [1..maxAllowedLen].\n              We keep it small to avoid huge queries that might cause environment issues.\n            */\n            int lower = lenS + 1;\n            int upper = lenS + 5;\n            if (lower > maxAllowedLen) {\n                lower = 1;\n                upper = maxAllowedLen;\n            } else {\n                upper = min(upper, maxAllowedLen);\n            }\n            if (lower > upper) {\n                lower = 1;\n            }\n            lengthQuery = rnd.next(lower, upper);\n            qStr = generateRandomString(lengthQuery);\n        }\n        else if (qType == \"substrings\") {\n            // pick a substring in s, optionally rotate\n            if (lenS <= 0) {\n                qStr = \"a\";\n            } else {\n                int start = rnd.next(0, lenS - 1); \n                int possibleLen = lenS - start;\n                possibleLen = max(possibleLen, 1); \n                int chosenMax = min(possibleLen, maxAllowedLen);\n                chosenMax = max(chosenMax, 1);\n                int subLen = rnd.next(1, chosenMax);\n                string sub = originalS.substr(start, subLen);\n                // optional rotation\n                if (subLen > 1 && rnd.next(2)) {\n                    int r = rnd.next(0, subLen);\n                    sub = sub.substr(r) + sub.substr(0, r);\n                }\n                qStr = sub;\n            }\n        }\n        else if (qType == \"small\") {\n            // length 1 or 2\n            lengthQuery = rnd.next(1, 2);\n            qStr = generateRandomString(lengthQuery);\n        }\n        else if (qType == \"mix\") {\n            /*\n              We'll pick from sub-modes:\n                0 -> small range\n                1 -> bigger style\n                2 -> substring\n                3 -> single repeated char\n                4 -> random up to 2*lenS\n            */\n            int mode = rnd.next(5);\n            switch (mode) {\n                case 0: {\n                    // small range [1..5], clamp by maxAllowedLen\n                    int upper = min(5, maxAllowedLen);\n                    upper = max(upper, 1);\n                    lengthQuery = rnd.next(1, upper);\n                    qStr = generateRandomString(lengthQuery);\n                    break;\n                }\n                case 1: {\n                    // bigger style with offset\n                    int lower = lenS + 1;\n                    int upper = lenS + 5; \n                    if (lower > maxAllowedLen) {\n                        lower = 1;\n                        upper = maxAllowedLen;\n                    } else {\n                        upper = min(upper, maxAllowedLen);\n                    }\n                    if (lower > upper) {\n                        lower = 1;\n                    }\n                    lengthQuery = rnd.next(lower, upper);\n                    qStr = generateRandomString(lengthQuery);\n                    break;\n                }\n                case 2: {\n                    // substring approach\n                    if (lenS <= 0) {\n                        qStr = \"a\";\n                    } else {\n                        int start = rnd.next(0, lenS - 1);\n                        int possibleLen = lenS - start;\n                        possibleLen = max(possibleLen, 1);\n                        int chosenMax = min(possibleLen, maxAllowedLen);\n                        chosenMax = max(chosenMax, 1);\n                        int subLen = rnd.next(1, chosenMax);\n                        string sub = originalS.substr(start, subLen);\n                        if (subLen > 1 && rnd.next(2)) {\n                            int r = rnd.next(0, subLen);\n                            sub = sub.substr(r) + sub.substr(0, r);\n                        }\n                        qStr = sub;\n                    }\n                    break;\n                }\n                case 3: {\n                    // single repeated char\n                    lengthQuery = rnd.next(1, maxAllowedLen);\n                    char c = char('a' + rnd.next(ALPH_SIZE));\n                    qStr = string(lengthQuery, c);\n                    break;\n                }\n                default: {\n                    // random up to 2*lenS\n                    if (lenS > 0) {\n                        int bound = min(2 * lenS, maxAllowedLen);\n                        bound = max(bound, 1);\n                        lengthQuery = rnd.next(1, bound);\n                    } else {\n                        lengthQuery = rnd.next(1, maxAllowedLen);\n                    }\n                    qStr = generateRandomString(lengthQuery);\n                    break;\n                }\n            }\n        }\n        else {\n            // default fallback: random up to 2*lenS\n            if (lenS > 0) {\n                int bound = min(2 * lenS, maxAllowedLen);\n                bound = max(bound, 1);\n                lengthQuery = rnd.next(1, bound);\n            } else {\n                lengthQuery = rnd.next(1, maxAllowedLen);\n            }\n            qStr = generateRandomString(lengthQuery);\n        }\n\n        // Safeguard if empty\n        if (qStr.empty()) {\n            qStr = \"a\";\n        }\n\n        queries.push_back(qStr);\n    }\n\n    return queries;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line parameters\n    int lenS  = opt<int>(\"len_s\", 10);               // length of main string s\n    int n     = opt<int>(\"n\", 5);                    // number of queries\n    string sType = opt<string>(\"sType\", \"random\");   // type of s\n    string qType = opt<string>(\"qType\", \"random\");   // type of queries\n\n    // Generate s\n    string s_str = generateString(lenS, sType);\n\n    // Generate queries\n    vector<string> queries = generateQueries(n, lenS, s_str, qType);\n\n    // Output format:\n    //   1) s\n    //   2) n\n    //   3..(n+2)) queries\n    cout << s_str << \"\\n\";\n    cout << n << \"\\n\";\n    for (auto &q : queries) {\n        cout << q << \"\\n\";\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly ONE test case per execution.\n\n  Test case format:\n    1) A single string s (length <= 1e6).\n    2) An integer n (1 <= n <= 1e5).\n    3) n lines, each a query string x_i.\n       The total length of all queries should stay around or below 1e6.\n\n  Command-line parameters:\n    -len_s    (int) : size of the main string s\n    -n        (int) : number of queries\n    -sType    (string) : type of main string (\"random\", \"periodic\", \"all_a\", \"palindrome\", \"smallalpha\")\n    -qType    (string) : type of queries (\"random\", \"bigger\", \"substrings\", \"small\", \"mix\")\n\n  Example usage:\n    ./gen -len_s 10 -n 5 -sType random -qType random\n*/\n\n// Alphabet size for lowercase English letters.\nstatic const int ALPH_SIZE = 26;\n\n/*\n  Generates a random string of given length using characters\n  ['a'.. 'a'+alphaSize-1].\n*/\nstring generateRandomString(int length, int alphaSize = ALPH_SIZE) {\n    // Fallback if length <= 0.\n    if (length <= 0) {\n        return \"a\";\n    }\n    string result;\n    result.reserve(length);\n    for (int i = 0; i < length; i++) {\n        result.push_back(char('a' + rnd.next(alphaSize)));\n    }\n    return result;\n}\n\n/*\n  Generate a periodic string of length 'length',\n  repeating a pattern of length 'period'.\n*/\nstring generatePeriodicString(int length, int period, int alphaSize = ALPH_SIZE) {\n    if (period <= 0) {\n        return generateRandomString(length, alphaSize);\n    }\n    string unit = generateRandomString(period, alphaSize);\n    string ret;\n    ret.reserve(length);\n    for (int i = 0; i < length; i++) {\n        ret.push_back(unit[i % period]);\n    }\n    return ret;\n}\n\n/*\n  Generate a palindrome of length 'length'.\n*/\nstring generatePalindrome(int length, int alphaSize = ALPH_SIZE) {\n    if (length <= 0) {\n        return \"a\";\n    }\n    string s(length, 'a');\n    for (int i = 0; i < (length + 1) / 2; i++) {\n        s[i] = char('a' + rnd.next(alphaSize));\n    }\n    for (int i = 0; i < length / 2; i++) {\n        s[length - 1 - i] = s[i];\n    }\n    return s;\n}\n\n/*\n  Generate the main string s according to sType.\n*/\nstring generateString(int lenS, const string &sType) {\n    if (lenS <= 0) {\n        return \"a\";\n    }\n    if (sType == \"random\") {\n        return generateRandomString(lenS);\n    } else if (sType == \"periodic\") {\n        // period is up to min(lenS, 10)\n        int period = rnd.next(1, min(lenS, 10));\n        return generatePeriodicString(lenS, period);\n    } else if (sType == \"all_a\") {\n        return string(lenS, 'a');\n    } else if (sType == \"palindrome\") {\n        return generatePalindrome(lenS);\n    } else if (sType == \"smallalpha\") {\n        // an alphabet of size 3\n        return generateRandomString(lenS, 3);\n    }\n    // default fallback\n    return generateRandomString(lenS);\n}\n\n/*\n  Generate n query strings of various patterns. \n  Each query is formed according to qType, and we clamp the lengths\n  so total won't exceed ~1e6.\n\n  qType:\n    \"random\":     random length up to 2*lenS (clamped).\n    \"bigger\":     attempt queries > lenS, with offsets, also clamped.\n    \"substrings\": random substring of s (optional rotation).\n    \"small\":      length in {1,2}.\n    \"mix\":        a random combination of the above ideas.\n\n  To reduce risk of segfault, we carefully clamp index choices and lengths.\n*/\nvector<string> generateQueries(int n, int lenS, const string &originalS, const string &qType) {\n    vector<string> queries;\n    queries.reserve(n);\n\n    // Approx. max length per query so total won't exceed ~1e6\n    int maxAllowedLen = (n == 0 ? 1 : max<int>(1, 1000000 / n));\n\n    for (int i = 0; i < n; i++) {\n        int lengthQuery = 1;\n        string qStr;\n\n        if (qType == \"random\") {\n            // length range 1..(2*lenS), clamp by maxAllowedLen, fallback if lenS=0\n            if (lenS > 0) {\n                int bound = min(2 * lenS, maxAllowedLen);\n                bound = max(bound, 1); // ensure at least 1\n                lengthQuery = rnd.next(1, bound);\n            } else {\n                lengthQuery = rnd.next(1, maxAllowedLen);\n            }\n            qStr = generateRandomString(lengthQuery);\n        }\n        else if (qType == \"bigger\") {\n            /*\n              Range [lenS+1 .. lenS+5], clamp to [1..maxAllowedLen].\n              We keep it small to avoid huge queries that might cause environment issues.\n            */\n            int lower = lenS + 1;\n            int upper = lenS + 5;\n            if (lower > maxAllowedLen) {\n                lower = 1;\n                upper = maxAllowedLen;\n            } else {\n                upper = min(upper, maxAllowedLen);\n            }\n            if (lower > upper) {\n                lower = 1;\n            }\n            lengthQuery = rnd.next(lower, upper);\n            qStr = generateRandomString(lengthQuery);\n        }\n        else if (qType == \"substrings\") {\n            // pick a substring in s, optionally rotate\n            if (lenS <= 0) {\n                qStr = \"a\";\n            } else {\n                int start = rnd.next(0, lenS - 1); \n                int possibleLen = lenS - start;\n                possibleLen = max(possibleLen, 1); \n                int chosenMax = min(possibleLen, maxAllowedLen);\n                chosenMax = max(chosenMax, 1);\n                int subLen = rnd.next(1, chosenMax);\n                string sub = originalS.substr(start, subLen);\n                // optional rotation\n                if (subLen > 1 && rnd.next(2)) {\n                    int r = rnd.next(0, subLen);\n                    sub = sub.substr(r) + sub.substr(0, r);\n                }\n                qStr = sub;\n            }\n        }\n        else if (qType == \"small\") {\n            // length 1 or 2\n            lengthQuery = rnd.next(1, 2);\n            qStr = generateRandomString(lengthQuery);\n        }\n        else if (qType == \"mix\") {\n            /*\n              We'll pick from sub-modes:\n                0 -> small range\n                1 -> bigger style\n                2 -> substring\n                3 -> single repeated char\n                4 -> random up to 2*lenS\n            */\n            int mode = rnd.next(5);\n            switch (mode) {\n                case 0: {\n                    // small range [1..5], clamp by maxAllowedLen\n                    int upper = min(5, maxAllowedLen);\n                    upper = max(upper, 1);\n                    lengthQuery = rnd.next(1, upper);\n                    qStr = generateRandomString(lengthQuery);\n                    break;\n                }\n                case 1: {\n                    // bigger style with offset\n                    int lower = lenS + 1;\n                    int upper = lenS + 5; \n                    if (lower > maxAllowedLen) {\n                        lower = 1;\n                        upper = maxAllowedLen;\n                    } else {\n                        upper = min(upper, maxAllowedLen);\n                    }\n                    if (lower > upper) {\n                        lower = 1;\n                    }\n                    lengthQuery = rnd.next(lower, upper);\n                    qStr = generateRandomString(lengthQuery);\n                    break;\n                }\n                case 2: {\n                    // substring approach\n                    if (lenS <= 0) {\n                        qStr = \"a\";\n                    } else {\n                        int start = rnd.next(0, lenS - 1);\n                        int possibleLen = lenS - start;\n                        possibleLen = max(possibleLen, 1);\n                        int chosenMax = min(possibleLen, maxAllowedLen);\n                        chosenMax = max(chosenMax, 1);\n                        int subLen = rnd.next(1, chosenMax);\n                        string sub = originalS.substr(start, subLen);\n                        if (subLen > 1 && rnd.next(2)) {\n                            int r = rnd.next(0, subLen);\n                            sub = sub.substr(r) + sub.substr(0, r);\n                        }\n                        qStr = sub;\n                    }\n                    break;\n                }\n                case 3: {\n                    // single repeated char\n                    lengthQuery = rnd.next(1, maxAllowedLen);\n                    char c = char('a' + rnd.next(ALPH_SIZE));\n                    qStr = string(lengthQuery, c);\n                    break;\n                }\n                default: {\n                    // random up to 2*lenS\n                    if (lenS > 0) {\n                        int bound = min(2 * lenS, maxAllowedLen);\n                        bound = max(bound, 1);\n                        lengthQuery = rnd.next(1, bound);\n                    } else {\n                        lengthQuery = rnd.next(1, maxAllowedLen);\n                    }\n                    qStr = generateRandomString(lengthQuery);\n                    break;\n                }\n            }\n        }\n        else {\n            // default fallback: random up to 2*lenS\n            if (lenS > 0) {\n                int bound = min(2 * lenS, maxAllowedLen);\n                bound = max(bound, 1);\n                lengthQuery = rnd.next(1, bound);\n            } else {\n                lengthQuery = rnd.next(1, maxAllowedLen);\n            }\n            qStr = generateRandomString(lengthQuery);\n        }\n\n        // Safeguard if empty\n        if (qStr.empty()) {\n            qStr = \"a\";\n        }\n\n        queries.push_back(qStr);\n    }\n\n    return queries;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line parameters\n    int lenS  = opt<int>(\"len_s\", 10);               // length of main string s\n    int n     = opt<int>(\"n\", 5);                    // number of queries\n    string sType = opt<string>(\"sType\", \"random\");   // type of s\n    string qType = opt<string>(\"qType\", \"random\");   // type of queries\n\n    // Generate s\n    string s_str = generateString(lenS, sType);\n\n    // Generate queries\n    vector<string> queries = generateQueries(n, lenS, s_str, qType);\n\n    // Output format:\n    //   1) s\n    //   2) n\n    //   3..(n+2)) queries\n    cout << s_str << \"\\n\";\n    cout << n << \"\\n\";\n    for (auto &q : queries) {\n        cout << q << \"\\n\";\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are the revised commands for generating distinct test cases.\n# We have reduced \"bigger\" offsets and random upper bounds\n# to lessen the chance of large memory usage or environment issues.\n\n# 1. Very small random case\n./gen -len_s 5 -n 3 -sType random -qType random\n\n# 2. Small palindrome s, random queries\n./gen -len_s 5 -n 5 -sType palindrome -qType random\n\n# 3. Random s (length 20), bigger queries\n./gen -len_s 20 -n 5 -sType random -qType bigger\n\n# 4. Periodic s (length 30), random queries\n./gen -len_s 30 -n 5 -sType periodic -qType random\n\n# 5. All 'a' s (length 40), random queries\n./gen -len_s 40 -n 5 -sType all_a -qType random\n\n# 6. smallalpha s (length 50), random queries\n./gen -len_s 50 -n 5 -sType smallalpha -qType random\n\n# 7. Palindromic s (length 60), small queries\n./gen -len_s 60 -n 5 -sType palindrome -qType small\n\n# 8. random s (length 80), bigger queries\n./gen -len_s 80 -n 5 -sType random -qType bigger\n\n# 9. periodic s (length 100), substrings\n./gen -len_s 100 -n 5 -sType periodic -qType substrings\n\n# 10. random s (length 100), mix queries\n./gen -len_s 100 -n 5 -sType random -qType mix\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:31.372661",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "235/D",
      "title": "D. Graph Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (3 ≤ n ≤ 3000) — the number of nodes and edges in the graph. Each of the next n lines contains two space-separated integers ai, bi (0 ≤ ai, bi ≤ n - 1) indicating an edge between nodes ai and bi.Consider that the graph nodes are numbered from 0 to (n - 1). It's guaranteed that there are no self-loops, no multiple edges in that graph. It's guaranteed that the graph is connected.",
      "output_spec": "OutputPrint a single real number — the expectation of totalCost. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy53 42 32 40 41 2OutputCopy13.166666666666666InputCopy30 11 20 2OutputCopy6.000000000000000InputCopy50 11 22 03 04 1OutputCopy13.166666666666666",
      "description": "D. Graph Game\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (3 ≤ n ≤ 3000) — the number of nodes and edges in the graph. Each of the next n lines contains two space-separated integers ai, bi (0 ≤ ai, bi ≤ n - 1) indicating an edge between nodes ai and bi.Consider that the graph nodes are numbered from 0 to (n - 1). It's guaranteed that there are no self-loops, no multiple edges in that graph. It's guaranteed that the graph is connected.\n\nOutputPrint a single real number — the expectation of totalCost. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.\n\nInputCopy53 42 32 40 41 2OutputCopy13.166666666666666InputCopy30 11 20 2OutputCopy6.000000000000000InputCopy50 11 22 03 04 1OutputCopy13.166666666666666\n\nInputCopy53 42 32 40 41 2\n\nOutputCopy13.166666666666666\n\nInputCopy30 11 20 2\n\nOutputCopy6.000000000000000\n\nInputCopy50 11 22 03 04 1\n\nOutputCopy13.166666666666666\n\nNoteConsider the second example. No matter what we choose first, the totalCost will always be 3 + 2 + 1 = 6.",
      "solutions": [
        {
          "title": "Codeforces Round #146 - Codeforces",
          "content": "Hi!Codeforces Round #146 is going to be here soon. Round is prepared by YuukaKazami, MinakoKojima. I write problems for Div I and MinakoKojima write for Div II. Gerald did a great job in coordinating round preparing, and he also give some pretty good advise about problems. I'd like to express my gratitude to him. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Polygon system as well and Mary Belova (Delinur) for translating problems. Also thanks to donehl for testing the problems and making his comments about the problems.Score distribution is 500-1000-1500-2000-2500 in both divisions.Hope you enjoy the problems! =)I apologize for the 10 minutes delay.I'm very sorry for the inconvenience I caused. So I'm writing a good editorial for compensation :)The Editorial is here: EditorialCongrats to winners!Div1:1.rng_582.Dmitry_Egorov3.bjin4.Petr5.Egor6.touristDiv2:1.RiKang2.Caesar113.Gabaum4.ilona5.Bidhan6.sm_hossein",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5586",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 969
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces",
          "content": "236A - Boy or GirlIt is a very simple problem, just count how many distinct chars in the input and output the correct answer.236B - Easy Number ChallengeFirst of all, we can make a table of size a*b*c to store every number's d value. Then we can just brute force through every tripe to calculate the answer.235A - LCM ChallengeIt is a simple problem, but many competitors used some wrong guesses and failed. First of all, we should check if n is at most 3 and then we can simply output 1,2,6.Now there are two cases: When n is odd, the answer is obviously n(n-1)(n-2). When n is even, we can still get at least (n-1)(n-2)(n-3), so these three numbers in the optimal answer would not be very small compared to n. So we can just iterate every 3 number triple in [n-50,n] and update the answer.235B - Let's Play Osu!Let us take a deep look at how this score is calculated. For an n long 'O' block, it contributes n2 to the answer.Let us reformat this problem a bit and consider the following alternative definition of the score: (1) For each two 'O' pair which there is no 'X' between them, they add 2 to the score. (2) For each 'O', it adds 1 to the score.We claim that this new definition of the score is equivalent to the definition in the problem statement.Proof of the claim: For an n long 'O' block, there are Cn2 pairs of 'O' in it and n 'O' in it. Note that 2Cn2 + n = n2. So now we work with the new definition of the score. For each event(i,j) (which means s[i] and s[j] are 'O', and there is no 'X' between them). If event(i,j) happens, it adds 2 to the score. So we only need to sum up the probabilities of all events and multiply them by 2, and our task becomes how to calculate the sum of probabilities of all the event(i,j). Let P(i,j) be the probability of event(i,j).We can see that P(i,j) can be computed by . Then we denote P(j) as the sum of all event(i,j) for i<j. We have dp(0)=0 and dp(j)=(dp(j-1)+pj - 1)*pj235C - Cyclical QuestThis problem can be solved by many suffix structures. Probably using suffix automaton is the best way to solve it since suffix automaton is simple and clear.Let us build a suffix automaton of the input string S, and consider the query string x.Let us also build a string t as x concatenated with x dropping the last char. One can see that every consecutive sub-string of t with length |x| is a rotation of x.Let us read the string t with suffix automaton we have build, and every time take the first char out and add a new char, add the answer by the number of string equal to this current sub-string of t (which is a rotation of x).And one more thing, we should consider the repetend of x as well, check my solution here:2403375.Check here if you are not familiar with suffix automaton :e-maxx's blog235D - Graph GameFirst of all, let us consider the simpler case of trees.Let us use Event(A,B) to denote the following event \"when we select A as the deleting point, B is connected to A\".Clearly, if Event(A,B) happens, it would add 1 to totolCost.So we can just simply calculate the probability of every Event(A,B), and add them up.Let us consider how to calculate the probability of Event(A,B).Assume there are n vertices in the path between A and B, we claim that the probability is simply 1 / n.Let us try to prove it using induction.First let us assume there's a connected sub-graph of the tree containing both A and B, if the sub-graph only has n vertices, then the event happens only if we select vertex A, so the probability is 1 / n.Otherwise, assume it has x vertices there is two cases: whether the selected vertex is on the path between A and B or not.In the first case, the probability of Event(A,B) happen is 1 / x because if we don't select A, Event(A,B) will never happen.In the second case, the sub-graph containing A,B has become smaller, so the probability is (x - n) / xn.So add them up we can prove this statement.Then we can solve the tree case by simply add up the inverse of every path's length in the tree.And for the original case, there's at most 2 paths between A and B.If there's only one path, then everything is the same with the tree case.Otherwise, the path between A and B should pass the cycle in the graph.Let us examine this case, you can see that there 2 types of vertex:Vertex on the path of A to cycle or B to cycle, they should not be selected before A because once they're selected, A and B lost connectivity, let us call them X.Vertex on the cycle, the two paths from A to B, each path contains a path in the cycle, let us call them Y and Z.So there are two possibilities: X and Y are free when A is selected, X and Z are free when A is selected.And we should subtract the case that X and Y, Z are all free when A is selected because it double-counts before.So the probability is 1 / (X + Y + 1) + 1 / (X + Z + 1) - 1 / (X + Y + Z + 1).Check Petr 's solution for the details: 2401228And my C++ implementation: 2403938235E - Number ChallengeLet us consider each prime in one step, the upper limit for a, b, c is recorded.So if we fixed the power of 2 in each i, j, k like 2x, 2y, 2z, then their upper limit becomes a / 2x, b / 2y, c / 2z, and the power of 2 in their multiplication is just x+y+z.Let us denote dp(a, b, c, p) for the answer to the original problem that i, j, k 's upper limit is a, b, c. And their can only use the prime factors which are not less than p.Let the next prime to be q, so we can try to fix the power of p in i, j, k and get the new upper limit.So we can do transform like this: dp(a, b, c, p) = sum of dp(a / px, b / py, c / pz, q)·(x + y + z + 1)Check my code here: 2404223Also you can check rng_58 solution here: http://codeforces.com/blog/entry/5600If you have any problems, you can ask here :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 235\\s*D"
          },
          "content_length": 5718
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #146 - Codeforces - Code 1",
          "code": "IGNORE HER!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 2",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 3",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 4",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 5",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 1",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 2",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 3",
          "code": "n = int(input())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 4",
          "code": "if n==1 or n==2:     print(n)     exit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 5",
          "code": "if n&1:     print((n)*(n-1)*(n-2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 6",
          "code": "else:     print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 7",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 8",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n\n    int n = inf.readInt(3, 3000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n    vector<vector<int>> adj(n);\n\n    for (int i = 0; i < n; i++) {\n        int a = inf.readInt(0, n - 1, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(0, n - 1, \"b_i\");\n        inf.readEoln();\n\n        // Check no self-loops\n        ensuref(a != b, \"Edge cannot be a self-loop: edge from %d to %d\", a, b);\n\n        // Check no multiple edges\n        pair<int, int> edge = (a < b) ? make_pair(a, b) : make_pair(b, a);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Multiple edges between %d and %d\", a, b);\n        edgeSet.insert(edge);\n\n        // Add edge to adjacency list\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check that number of edges is n\n    ensuref((int)edgeSet.size() == n, \"Number of edges (%d) is not equal to n (%d)\", (int)edgeSet.size(), n);\n\n    // Check that the graph is connected\n    vector<bool> visited(n, false);\n    queue<int> q;\n    q.push(0);\n    visited[0] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        ensuref(visited[i], \"Graph is not connected: node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n\n    int n = inf.readInt(3, 3000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n    vector<vector<int>> adj(n);\n\n    for (int i = 0; i < n; i++) {\n        int a = inf.readInt(0, n - 1, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(0, n - 1, \"b_i\");\n        inf.readEoln();\n\n        // Check no self-loops\n        ensuref(a != b, \"Edge cannot be a self-loop: edge from %d to %d\", a, b);\n\n        // Check no multiple edges\n        pair<int, int> edge = (a < b) ? make_pair(a, b) : make_pair(b, a);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Multiple edges between %d and %d\", a, b);\n        edgeSet.insert(edge);\n\n        // Add edge to adjacency list\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check that number of edges is n\n    ensuref((int)edgeSet.size() == n, \"Number of edges (%d) is not equal to n (%d)\", (int)edgeSet.size(), n);\n\n    // Check that the graph is connected\n    vector<bool> visited(n, false);\n    queue<int> q;\n    q.push(0);\n    visited[0] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        ensuref(visited[i], \"Graph is not connected: node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n\n    int n = inf.readInt(3, 3000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n    vector<vector<int>> adj(n);\n\n    for (int i = 0; i < n; i++) {\n        int a = inf.readInt(0, n - 1, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(0, n - 1, \"b_i\");\n        inf.readEoln();\n\n        // Check no self-loops\n        ensuref(a != b, \"Edge cannot be a self-loop: edge from %d to %d\", a, b);\n\n        // Check no multiple edges\n        pair<int, int> edge = (a < b) ? make_pair(a, b) : make_pair(b, a);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Multiple edges between %d and %d\", a, b);\n        edgeSet.insert(edge);\n\n        // Add edge to adjacency list\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check that number of edges is n\n    ensuref((int)edgeSet.size() == n, \"Number of edges (%d) is not equal to n (%d)\", (int)edgeSet.size(), n);\n\n    // Check that the graph is connected\n    vector<bool> visited(n, false);\n    queue<int> q;\n    q.push(0);\n    visited[0] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        ensuref(visited[i], \"Graph is not connected: node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int, int>> edge_set;\n    vector<pair<int, int>> edges;\n\n    if (n < 3) {\n        fprintf(stderr, \"n must be at least 3\\n\");\n        exit(1);\n    }\n\n    if (type == \"cycle\") {\n        // Generate a simple cycle of length n\n\n        for (int i = 0; i < n; ++i) {\n            int u = i;\n            int v = (i + 1) % n;\n            if (u > v) swap(u, v);\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"star\") {\n        // Build a star tree, then add an edge to make it unicyclic\n\n        int center = 0;\n        for (int i = 1; i < n; ++i) {\n            int u = center;\n            int v = i;\n            if (u > v) swap(u, v);\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n        // Add an edge between two leaves to create a cycle\n\n        int u = 1, v = 2;\n        if (u > v) swap(u, v);\n        if (edge_set.count(make_pair(u, v)) == 0) {\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"path\") {\n        // Build a path, then connect ends to make a cycle\n\n        for (int i = 0; i < n - 1; ++i) {\n            int u = i;\n            int v = i + 1;\n            if (u > v) swap(u, v);\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n        // Add edge between first and last node\n\n        int u = 0, v = n - 1;\n        if (u > v) swap(u, v);\n        if (edge_set.count(make_pair(u, v)) == 0) {\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"special1\") {\n        // Build tree with small cycle among nodes 0,1,2\n\n        int u = 0, v = 1, w = 2;\n\n        edges.push_back(make_pair(min(u,v), max(u,v)));\n        edges.push_back(make_pair(min(v,w), max(v,w)));\n        edges.push_back(make_pair(min(w,u), max(w,u)));\n        edge_set.insert(make_pair(min(u,v), max(u,v)));\n        edge_set.insert(make_pair(min(v,w), max(v,w)));\n        edge_set.insert(make_pair(min(w,u), max(w,u)));\n\n        for (int i = 3; i < n; ++i) {\n            int parent = rnd.next(0, i - 1);\n            int u = parent;\n            int v = i;\n            if (u > v) swap(u, v);\n            if (edge_set.count(make_pair(u, v)) == 0) {\n                edges.emplace_back(u, v);\n                edge_set.insert(make_pair(u, v));\n            }\n        }\n\n    } else if (type == \"complete3\") {\n        // Build complete graph of 3 nodes, add the rest connected in a line\n\n        if (n < 3) {\n            fprintf(stderr, \"n must be at least 3 for type complete3\\n\");\n            exit(1);\n        }\n\n        edges.emplace_back(0, 1);\n        edges.emplace_back(0, 2);\n        edges.emplace_back(1, 2);\n        edge_set.insert(make_pair(0, 1));\n        edge_set.insert(make_pair(0,2));\n        edge_set.insert(make_pair(1,2));\n\n        for (int i = 3; i < n; ++i) {\n            int u = i - 1;\n            int v = i;\n            if (u > v) swap(u, v);\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n        // Now total edges = 3 + (n - 3) = n edges.\n\n    } else { // \"random\" and default\n        // Start by building a random tree\n\n        vector<int> parent(n);\n        for (int i = 1; i < n; ++i) {\n            parent[i] = rnd.next(0, i - 1);\n            int u = parent[i];\n            int v = i;\n            if (u > v) swap(u, v);\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n        // Add an edge between two random nodes not already connected\n\n        int a = rnd.next(0, n - 1);\n        int b = rnd.next(0, n - 1);\n\n        while (a == b || (edge_set.count(make_pair(min(a,b),max(a,b))) > 0))\n            b = rnd.next(0, n - 1);\n\n        if (a > b) swap(a, b);\n        edges.emplace_back(a, b);\n        edge_set.insert(make_pair(a, b));\n\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output the graph\n\n    printf(\"%d\\n\", n);\n    for (auto e : edges)\n        printf(\"%d %d\\n\", e.first, e.second);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int, int>> edge_set;\n    vector<pair<int, int>> edges;\n\n    if (n < 3) {\n        fprintf(stderr, \"n must be at least 3\\n\");\n        exit(1);\n    }\n\n    if (type == \"cycle\") {\n        // Generate a simple cycle of length n\n\n        for (int i = 0; i < n; ++i) {\n            int u = i;\n            int v = (i + 1) % n;\n            if (u > v) swap(u, v);\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"star\") {\n        // Build a star tree, then add an edge to make it unicyclic\n\n        int center = 0;\n        for (int i = 1; i < n; ++i) {\n            int u = center;\n            int v = i;\n            if (u > v) swap(u, v);\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n        // Add an edge between two leaves to create a cycle\n\n        int u = 1, v = 2;\n        if (u > v) swap(u, v);\n        if (edge_set.count(make_pair(u, v)) == 0) {\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"path\") {\n        // Build a path, then connect ends to make a cycle\n\n        for (int i = 0; i < n - 1; ++i) {\n            int u = i;\n            int v = i + 1;\n            if (u > v) swap(u, v);\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n        // Add edge between first and last node\n\n        int u = 0, v = n - 1;\n        if (u > v) swap(u, v);\n        if (edge_set.count(make_pair(u, v)) == 0) {\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"special1\") {\n        // Build tree with small cycle among nodes 0,1,2\n\n        int u = 0, v = 1, w = 2;\n\n        edges.push_back(make_pair(min(u,v), max(u,v)));\n        edges.push_back(make_pair(min(v,w), max(v,w)));\n        edges.push_back(make_pair(min(w,u), max(w,u)));\n        edge_set.insert(make_pair(min(u,v), max(u,v)));\n        edge_set.insert(make_pair(min(v,w), max(v,w)));\n        edge_set.insert(make_pair(min(w,u), max(w,u)));\n\n        for (int i = 3; i < n; ++i) {\n            int parent = rnd.next(0, i - 1);\n            int u = parent;\n            int v = i;\n            if (u > v) swap(u, v);\n            if (edge_set.count(make_pair(u, v)) == 0) {\n                edges.emplace_back(u, v);\n                edge_set.insert(make_pair(u, v));\n            }\n        }\n\n    } else if (type == \"complete3\") {\n        // Build complete graph of 3 nodes, add the rest connected in a line\n\n        if (n < 3) {\n            fprintf(stderr, \"n must be at least 3 for type complete3\\n\");\n            exit(1);\n        }\n\n        edges.emplace_back(0, 1);\n        edges.emplace_back(0, 2);\n        edges.emplace_back(1, 2);\n        edge_set.insert(make_pair(0, 1));\n        edge_set.insert(make_pair(0,2));\n        edge_set.insert(make_pair(1,2));\n\n        for (int i = 3; i < n; ++i) {\n            int u = i - 1;\n            int v = i;\n            if (u > v) swap(u, v);\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n        // Now total edges = 3 + (n - 3) = n edges.\n\n    } else { // \"random\" and default\n        // Start by building a random tree\n\n        vector<int> parent(n);\n        for (int i = 1; i < n; ++i) {\n            parent[i] = rnd.next(0, i - 1);\n            int u = parent[i];\n            int v = i;\n            if (u > v) swap(u, v);\n            edges.emplace_back(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n\n        // Add an edge between two random nodes not already connected\n\n        int a = rnd.next(0, n - 1);\n        int b = rnd.next(0, n - 1);\n\n        while (a == b || (edge_set.count(make_pair(min(a,b),max(a,b))) > 0))\n            b = rnd.next(0, n - 1);\n\n        if (a > b) swap(a, b);\n        edges.emplace_back(a, b);\n        edge_set.insert(make_pair(a, b));\n\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output the graph\n\n    printf(\"%d\\n\", n);\n    for (auto e : edges)\n        printf(\"%d %d\\n\", e.first, e.second);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type cycle\n./gen -n 3 -type star\n./gen -n 3 -type path\n./gen -n 3 -type special1\n./gen -n 3 -type random\n./gen -n 3 -type complete3\n\n./gen -n 4 -type cycle\n./gen -n 4 -type star\n./gen -n 4 -type path\n./gen -n 4 -type random\n\n./gen -n 10 -type cycle\n./gen -n 10 -type star\n./gen -n 10 -type path\n./gen -n 10 -type special1\n./gen -n 10 -type random\n./gen -n 10 -type complete3\n\n./gen -n 50 -type cycle\n./gen -n 50 -type star\n./gen -n 50 -type path\n./gen -n 50 -type special1\n./gen -n 50 -type random\n./gen -n 50 -type complete3\n\n./gen -n 100 -type cycle\n./gen -n 100 -type star\n./gen -n 100 -type path\n./gen -n 100 -type special1\n./gen -n 100 -type random\n./gen -n 100 -type complete3\n\n./gen -n 500 -type cycle\n./gen -n 500 -type star\n./gen -n 500 -type path\n./gen -n 500 -type special1\n./gen -n 500 -type random\n./gen -n 500 -type complete3\n\n./gen -n 1000 -type cycle\n./gen -n 1000 -type star\n./gen -n 1000 -type path\n./gen -n 1000 -type special1\n./gen -n 1000 -type random\n./gen -n 1000 -type complete3\n\n./gen -n 2000 -type random\n./gen -n 2500 -type random\n./gen -n 3000 -type cycle\n./gen -n 3000 -type star\n./gen -n 3000 -type path\n./gen -n 3000 -type special1\n./gen -n 3000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:33.498418",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "235/E",
      "title": "E. Задача с Числами",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа через пробел — a, b и c (1 ≤ a, b, c ≤ 2000).",
      "output_spec": "Выходные данныеВыведите единственное целое число — остаток от деления искомой суммы на 1073741824 (230).",
      "sample_tests": "ПримерыВходные данныеСкопировать2 2 2Выходные данныеСкопировать20Входные данныеСкопировать4 4 4Выходные данныеСкопировать328Входные данныеСкопировать10 10 10Выходные данныеСкопировать11536",
      "description": "E. Задача с Числами\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа через пробел — a, b и c (1 ≤ a, b, c ≤ 2000).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — остаток от деления искомой суммы на 1073741824 (230).\n\nВыходные данные\n\nВходные данныеСкопировать2 2 2Выходные данныеСкопировать20Входные данныеСкопировать4 4 4Выходные данныеСкопировать328Входные данныеСкопировать10 10 10Выходные данныеСкопировать11536\n\nВходные данныеСкопировать2 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать20\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 4 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать328\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 10 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11536\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПояснение к первому примеру.  d(1·1·1) = d(1) = 1;  d(1·1·2) = d(2) = 2;  d(1·2·1) = d(2) = 2;  d(1·2·2) = d(4) = 3;  d(2·1·1) = d(2) = 2;  d(2·1·2) = d(4) = 3;  d(2·2·1) = d(4) = 3;  d(2·2·2) = d(8) = 4. Следовательно, ответ — 1 + 2 + 2 + 3 + 2 + 3 + 3 + 4 = 20.",
      "solutions": [
        {
          "title": "Codeforces Round #146 - Codeforces",
          "content": "Всем привет!Совсем скоро начнется соревнование Codeforces Round #146. Этот раунд был приготовлен YuukaKazami, MinakoKojima. Я сделал задачи для Div I, а MinakoKojima — для Div II. Как обычно, Gerald очень сильно помог нам в подготовке раунда, давая много советов по задачам. Спасибо ему за это. Традиционно спасибо Михаилу Мирзаянову (MikeMirzayanov) за прекрасные системы Codeforces и Polygon, а также Марии Беловой (Delinur) за перевод задач. Также хочется сказать спасибо donehl за тестирование задач и за его ценные комментарии к задачам.В обоих дивизионах будет использоваться стандартная разбалловка 500-1000-1500-2000-2500.Надеюсь вам понравятся задачи! =)Это перевод оригинального поста автора с английского языка. Английский в комментариях приветствуется.Прошу прощения за 10-минутную задержку. Мне очень жаль за доставленные неудобства, которые я вызвал. В качестве компенсации, я напишу хороший разбор =)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5586",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 915
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces",
          "content": "236A - Boy or GirlIt is a very simple problem, just count how many distinct chars in the input and output the correct answer.236B - Easy Number ChallengeFirst of all, we can make a table of size a*b*c to store every number's d value. Then we can just brute force through every tripe to calculate the answer.235A - LCM ChallengeIt is a simple problem, but many competitors used some wrong guesses and failed. First of all, we should check if n is at most 3 and then we can simply output 1,2,6.Now there are two cases: When n is odd, the answer is obviously n(n-1)(n-2). When n is even, we can still get at least (n-1)(n-2)(n-3), so these three numbers in the optimal answer would not be very small compared to n. So we can just iterate every 3 number triple in [n-50,n] and update the answer.235B - Let's Play Osu!Let us take a deep look at how this score is calculated. For an n long 'O' block, it contributes n2 to the answer.Let us reformat this problem a bit and consider the following alternative definition of the score: (1) For each two 'O' pair which there is no 'X' between them, they add 2 to the score. (2) For each 'O', it adds 1 to the score.We claim that this new definition of the score is equivalent to the definition in the problem statement.Proof of the claim: For an n long 'O' block, there are Cn2 pairs of 'O' in it and n 'O' in it. Note that 2Cn2 + n = n2. So now we work with the new definition of the score. For each event(i,j) (which means s[i] and s[j] are 'O', and there is no 'X' between them). If event(i,j) happens, it adds 2 to the score. So we only need to sum up the probabilities of all events and multiply them by 2, and our task becomes how to calculate the sum of probabilities of all the event(i,j). Let P(i,j) be the probability of event(i,j).We can see that P(i,j) can be computed by . Then we denote P(j) as the sum of all event(i,j) for i<j. We have dp(0)=0 and dp(j)=(dp(j-1)+pj - 1)*pj235C - Cyclical QuestThis problem can be solved by many suffix structures. Probably using suffix automaton is the best way to solve it since suffix automaton is simple and clear.Let us build a suffix automaton of the input string S, and consider the query string x.Let us also build a string t as x concatenated with x dropping the last char. One can see that every consecutive sub-string of t with length |x| is a rotation of x.Let us read the string t with suffix automaton we have build, and every time take the first char out and add a new char, add the answer by the number of string equal to this current sub-string of t (which is a rotation of x).And one more thing, we should consider the repetend of x as well, check my solution here:2403375.Check here if you are not familiar with suffix automaton :e-maxx's blog235D - Graph GameFirst of all, let us consider the simpler case of trees.Let us use Event(A,B) to denote the following event \"when we select A as the deleting point, B is connected to A\".Clearly, if Event(A,B) happens, it would add 1 to totolCost.So we can just simply calculate the probability of every Event(A,B), and add them up.Let us consider how to calculate the probability of Event(A,B).Assume there are n vertices in the path between A and B, we claim that the probability is simply 1 / n.Let us try to prove it using induction.First let us assume there's a connected sub-graph of the tree containing both A and B, if the sub-graph only has n vertices, then the event happens only if we select vertex A, so the probability is 1 / n.Otherwise, assume it has x vertices there is two cases: whether the selected vertex is on the path between A and B or not.In the first case, the probability of Event(A,B) happen is 1 / x because if we don't select A, Event(A,B) will never happen.In the second case, the sub-graph containing A,B has become smaller, so the probability is (x - n) / xn.So add them up we can prove this statement.Then we can solve the tree case by simply add up the inverse of every path's length in the tree.And for the original case, there's at most 2 paths between A and B.If there's only one path, then everything is the same with the tree case.Otherwise, the path between A and B should pass the cycle in the graph.Let us examine this case, you can see that there 2 types of vertex:Vertex on the path of A to cycle or B to cycle, they should not be selected before A because once they're selected, A and B lost connectivity, let us call them X.Vertex on the cycle, the two paths from A to B, each path contains a path in the cycle, let us call them Y and Z.So there are two possibilities: X and Y are free when A is selected, X and Z are free when A is selected.And we should subtract the case that X and Y, Z are all free when A is selected because it double-counts before.So the probability is 1 / (X + Y + 1) + 1 / (X + Z + 1) - 1 / (X + Y + Z + 1).Check Petr 's solution for the details: 2401228And my C++ implementation: 2403938235E - Number ChallengeLet us consider each prime in one step, the upper limit for a, b, c is recorded.So if we fixed the power of 2 in each i, j, k like 2x, 2y, 2z, then their upper limit becomes a / 2x, b / 2y, c / 2z, and the power of 2 in their multiplication is just x+y+z.Let us denote dp(a, b, c, p) for the answer to the original problem that i, j, k 's upper limit is a, b, c. And their can only use the prime factors which are not less than p.Let the next prime to be q, so we can try to fix the power of p in i, j, k and get the new upper limit.So we can do transform like this: dp(a, b, c, p) = sum of dp(a / px, b / py, c / pz, q)·(x + y + z + 1)Check my code here: 2404223Also you can check rng_58 solution here: http://codeforces.com/blog/entry/5600If you have any problems, you can ask here :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 235\\s*E"
          },
          "content_length": 5718
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #146 - Codeforces - Code 1",
          "code": "IGNORE HER!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 2",
          "code": "s11 = P*s1+P*s2+2*P*s3;\ns22 = P*s2+(1-P);\ns33 = P*(s3+s2);\ns44 = s4*P+(1-P)*dp[i-1];\ndp[i] = s44+s11+cp*(i+1)*(i+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 3",
          "code": "s11 = P*s1+P*s2+2*P*s3;\ns22 = P*s2+(1-P);\ns33 = P*(s3+s2);\ns44 = s4*P+(1-P)*dp[i-1];\ndp[i] = s44+s11+cp*(i+1)*(i+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 4",
          "code": "q_j*dp[i-j-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 5",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 6",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 7",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 8",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 1",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 2",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 3",
          "code": "n = int(input())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 4",
          "code": "if n==1 or n==2:     print(n)     exit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 5",
          "code": "if n&1:     print((n)*(n-1)*(n-2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 6",
          "code": "else:     print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 7",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 8",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 2000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 2000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 2000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 2000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 2000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 2000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 2000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 2000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 2000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Get parameters\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // If a,b,c are not set (i.e., are -1), set them according to 'type'\n    if (a == -1 || b == -1 || c == -1) {\n        if (type == \"min\") {\n            a = b = c = 1;\n        } else if (type == \"max\") {\n            a = b = c = 2000;\n        } else if (type == \"small\") {\n            a = rnd.next(1, 10);\n            b = rnd.next(1, 10);\n            c = rnd.next(1, 10);\n        } else if (type == \"medium\") {\n            a = rnd.next(100, 500);\n            b = rnd.next(100, 500);\n            c = rnd.next(100, 500);\n        } else if (type == \"large\") {\n            a = rnd.next(1000, 2000);\n            b = rnd.next(1000, 2000);\n            c = rnd.next(1000, 2000);\n        } else if (type == \"one_small_rest_big\") {\n            int small = rnd.next(1, 10);\n            int large = rnd.next(1500, 2000);\n            int which = rnd.next(1, 3);\n            if (which == 1) { a = small; b = large; c = large; }\n            else if (which == 2) { a = large; b = small; c = large; }\n            else { a = large; b = large; c = small; }\n        } else if (type == \"power2\") {\n            a = 1 << (rnd.next(0, 10)); // 1 to 1024\n            b = 1 << (rnd.next(0, 10));\n            c = 1 << (rnd.next(0, 10));\n            a = min(a, 2000);\n            b = min(b, 2000);\n            c = min(c, 2000);\n        } else if (type == \"random\") {\n            a = rnd.next(1, 2000);\n            b = rnd.next(1, 2000);\n            c = rnd.next(1, 2000);\n        }\n    }\n\n    // If any of a,b,c is still -1, set it to random\n    if (a == -1) a = rnd.next(1, 2000);\n    if (b == -1) b = rnd.next(1, 2000);\n    if (c == -1) c = rnd.next(1, 2000);\n\n    // Ensure a, b, c are within [1,2000]\n    a = max(1, min(2000, a));\n    b = max(1, min(2000, b));\n    c = max(1, min(2000, c));\n\n    // Output\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Get parameters\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // If a,b,c are not set (i.e., are -1), set them according to 'type'\n    if (a == -1 || b == -1 || c == -1) {\n        if (type == \"min\") {\n            a = b = c = 1;\n        } else if (type == \"max\") {\n            a = b = c = 2000;\n        } else if (type == \"small\") {\n            a = rnd.next(1, 10);\n            b = rnd.next(1, 10);\n            c = rnd.next(1, 10);\n        } else if (type == \"medium\") {\n            a = rnd.next(100, 500);\n            b = rnd.next(100, 500);\n            c = rnd.next(100, 500);\n        } else if (type == \"large\") {\n            a = rnd.next(1000, 2000);\n            b = rnd.next(1000, 2000);\n            c = rnd.next(1000, 2000);\n        } else if (type == \"one_small_rest_big\") {\n            int small = rnd.next(1, 10);\n            int large = rnd.next(1500, 2000);\n            int which = rnd.next(1, 3);\n            if (which == 1) { a = small; b = large; c = large; }\n            else if (which == 2) { a = large; b = small; c = large; }\n            else { a = large; b = large; c = small; }\n        } else if (type == \"power2\") {\n            a = 1 << (rnd.next(0, 10)); // 1 to 1024\n            b = 1 << (rnd.next(0, 10));\n            c = 1 << (rnd.next(0, 10));\n            a = min(a, 2000);\n            b = min(b, 2000);\n            c = min(c, 2000);\n        } else if (type == \"random\") {\n            a = rnd.next(1, 2000);\n            b = rnd.next(1, 2000);\n            c = rnd.next(1, 2000);\n        }\n    }\n\n    // If any of a,b,c is still -1, set it to random\n    if (a == -1) a = rnd.next(1, 2000);\n    if (b == -1) b = rnd.next(1, 2000);\n    if (c == -1) c = rnd.next(1, 2000);\n\n    // Ensure a, b, c are within [1,2000]\n    a = max(1, min(2000, a));\n    b = max(1, min(2000, b));\n    c = max(1, min(2000, c));\n\n    // Output\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type small\n./gen -type medium\n./gen -type large\n./gen -type one_small_rest_big\n./gen -type power2\n./gen -type random\n\n./gen -a 1 -b 1 -c 1\n./gen -a 2 -b 2 -c 2\n./gen -a 10 -b 10 -c 10\n\n./gen -a 500 -b 500 -c 500\n\n./gen -a 1000 -b 1000 -c 1000\n\n./gen -a 2000 -b 2000 -c 2000\n\n./gen -a 2000 -b 1 -c 1\n./gen -a 1 -b 2000 -c 1\n./gen -a 1 -b 1 -c 2000\n\n./gen -type one_small_rest_big\n./gen -type one_small_rest_big\n./gen -type one_small_rest_big\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -a 1500 -b 1500 -c 1500\n./gen -a 1024 -b 1024 -c 1024\n\n./gen -a 1 -b 2000 -c 2000\n./gen -a 2000 -b 1 -c 2000\n./gen -a 2000 -b 2000 -c 1\n\n./gen -a 2 -b 3 -c 5\n./gen -a 10 -b 100 -c 1000\n\n./gen -type small\n./gen -type medium\n./gen -type large\n./gen -type power2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:35.276791",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "236/A",
      "title": "A. Boy or Girl",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-empty string, that contains only lowercase English letters — the user name. This string contains at most 100 letters.",
      "output_spec": "OutputIf it is a female by our hero's method, print \"CHAT WITH HER!\" (without the quotes), otherwise, print \"IGNORE HIM!\" (without the quotes).",
      "sample_tests": "ExamplesInputCopywjmzbmrOutputCopyCHAT WITH HER!InputCopyxiaodaoOutputCopyIGNORE HIM!InputCopysevenkplusOutputCopyCHAT WITH HER!",
      "description": "A. Boy or Girl\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty string, that contains only lowercase English letters — the user name. This string contains at most 100 letters.\n\nOutputIf it is a female by our hero's method, print \"CHAT WITH HER!\" (without the quotes), otherwise, print \"IGNORE HIM!\" (without the quotes).\n\nInputCopywjmzbmrOutputCopyCHAT WITH HER!InputCopyxiaodaoOutputCopyIGNORE HIM!InputCopysevenkplusOutputCopyCHAT WITH HER!\n\nInputCopywjmzbmr\n\nOutputCopyCHAT WITH HER!\n\nInputCopyxiaodao\n\nOutputCopyIGNORE HIM!\n\nInputCopysevenkplus\n\nOutputCopyCHAT WITH HER!\n\nNoteFor the first example. There are 6 distinct characters in \"wjmzbmr\". These characters are: \"w\", \"j\", \"m\", \"z\", \"b\", \"r\". So wjmzbmr is a female and you should print \"CHAT WITH HER!\".",
      "solutions": [
        {
          "title": "Codeforces Round #146 - Codeforces",
          "content": "Hi!Codeforces Round #146 is going to be here soon. Round is prepared by YuukaKazami, MinakoKojima. I write problems for Div I and MinakoKojima write for Div II. Gerald did a great job in coordinating round preparing, and he also give some pretty good advise about problems. I'd like to express my gratitude to him. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Polygon system as well and Mary Belova (Delinur) for translating problems. Also thanks to donehl for testing the problems and making his comments about the problems.Score distribution is 500-1000-1500-2000-2500 in both divisions.Hope you enjoy the problems! =)I apologize for the 10 minutes delay.I'm very sorry for the inconvenience I caused. So I'm writing a good editorial for compensation :)The Editorial is here: EditorialCongrats to winners!Div1:1.rng_582.Dmitry_Egorov3.bjin4.Petr5.Egor6.touristDiv2:1.RiKang2.Caesar113.Gabaum4.ilona5.Bidhan6.sm_hossein",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5586",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 969
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces",
          "content": "236A - Boy or GirlIt is a very simple problem, just count how many distinct chars in the input and output the correct answer.236B - Easy Number ChallengeFirst of all, we can make a table of size a*b*c to store every number's d value. Then we can just brute force through every tripe to calculate the answer.235A - LCM ChallengeIt is a simple problem, but many competitors used some wrong guesses and failed. First of all, we should check if n is at most 3 and then we can simply output 1,2,6.Now there are two cases: When n is odd, the answer is obviously n(n-1)(n-2). When n is even, we can still get at least (n-1)(n-2)(n-3), so these three numbers in the optimal answer would not be very small compared to n. So we can just iterate every 3 number triple in [n-50,n] and update the answer.235B - Let's Play Osu!Let us take a deep look at how this score is calculated. For an n long 'O' block, it contributes n2 to the answer.Let us reformat this problem a bit and consider the following alternative definition of the score: (1) For each two 'O' pair which there is no 'X' between them, they add 2 to the score. (2) For each 'O', it adds 1 to the score.We claim that this new definition of the score is equivalent to the definition in the problem statement.Proof of the claim: For an n long 'O' block, there are Cn2 pairs of 'O' in it and n 'O' in it. Note that 2Cn2 + n = n2. So now we work with the new definition of the score. For each event(i,j) (which means s[i] and s[j] are 'O', and there is no 'X' between them). If event(i,j) happens, it adds 2 to the score. So we only need to sum up the probabilities of all events and multiply them by 2, and our task becomes how to calculate the sum of probabilities of all the event(i,j). Let P(i,j) be the probability of event(i,j).We can see that P(i,j) can be computed by . Then we denote P(j) as the sum of all event(i,j) for i<j. We have dp(0)=0 and dp(j)=(dp(j-1)+pj - 1)*pj235C - Cyclical QuestThis problem can be solved by many suffix structures. Probably using suffix automaton is the best way to solve it since suffix automaton is simple and clear.Let us build a suffix automaton of the input string S, and consider the query string x.Let us also build a string t as x concatenated with x dropping the last char. One can see that every consecutive sub-string of t with length |x| is a rotation of x.Let us read the string t with suffix automaton we have build, and every time take the first char out and add a new char, add the answer by the number of string equal to this current sub-string of t (which is a rotation of x).And one more thing, we should consider the repetend of x as well, check my solution here:2403375.Check here if you are not familiar with suffix automaton :e-maxx's blog235D - Graph GameFirst of all, let us consider the simpler case of trees.Let us use Event(A,B) to denote the following event \"when we select A as the deleting point, B is connected to A\".Clearly, if Event(A,B) happens, it would add 1 to totolCost.So we can just simply calculate the probability of every Event(A,B), and add them up.Let us consider how to calculate the probability of Event(A,B).Assume there are n vertices in the path between A and B, we claim that the probability is simply 1 / n.Let us try to prove it using induction.First let us assume there's a connected sub-graph of the tree containing both A and B, if the sub-graph only has n vertices, then the event happens only if we select vertex A, so the probability is 1 / n.Otherwise, assume it has x vertices there is two cases: whether the selected vertex is on the path between A and B or not.In the first case, the probability of Event(A,B) happen is 1 / x because if we don't select A, Event(A,B) will never happen.In the second case, the sub-graph containing A,B has become smaller, so the probability is (x - n) / xn.So add them up we can prove this statement.Then we can solve the tree case by simply add up the inverse of every path's length in the tree.And for the original case, there's at most 2 paths between A and B.If there's only one path, then everything is the same with the tree case.Otherwise, the path between A and B should pass the cycle in the graph.Let us examine this case, you can see that there 2 types of vertex:Vertex on the path of A to cycle or B to cycle, they should not be selected before A because once they're selected, A and B lost connectivity, let us call them X.Vertex on the cycle, the two paths from A to B, each path contains a path in the cycle, let us call them Y and Z.So there are two possibilities: X and Y are free when A is selected, X and Z are free when A is selected.And we should subtract the case that X and Y, Z are all free when A is selected because it double-counts before.So the probability is 1 / (X + Y + 1) + 1 / (X + Z + 1) - 1 / (X + Y + Z + 1).Check Petr 's solution for the details: 2401228And my C++ implementation: 2403938235E - Number ChallengeLet us consider each prime in one step, the upper limit for a, b, c is recorded.So if we fixed the power of 2 in each i, j, k like 2x, 2y, 2z, then their upper limit becomes a / 2x, b / 2y, c / 2z, and the power of 2 in their multiplication is just x+y+z.Let us denote dp(a, b, c, p) for the answer to the original problem that i, j, k 's upper limit is a, b, c. And their can only use the prime factors which are not less than p.Let the next prime to be q, so we can try to fix the power of p in i, j, k and get the new upper limit.So we can do transform like this: dp(a, b, c, p) = sum of dp(a / px, b / py, c / pz, q)·(x + y + z + 1)Check my code here: 2404223Also you can check rng_58 solution here: http://codeforces.com/blog/entry/5600If you have any problems, you can ask here :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 236\\s*A"
          },
          "content_length": 5718
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #146 - Codeforces - Code 1",
          "code": "IGNORE HER!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 2",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 3",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 4",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 5",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 1",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 2",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 3",
          "code": "n = int(input())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 4",
          "code": "if n==1 or n==2:     print(n)     exit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 5",
          "code": "if n&1:     print((n)*(n-1)*(n-2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 6",
          "code": "else:     print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 7",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 8",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,100}\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,100}\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,100}\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    if (n < 1 || n > 100) {\n        fprintf(stderr, \"Invalid n: n must be between 1 and 100\\n\");\n        return 1;\n    }\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // number of distinct characters\n\n    string s;\n\n    if (type == \"all_same\") {\n        // Generate a string of length n with all the same character\n        char c = 'a' + rnd.next(0, 25);\n        s = string(n, c);\n    } else if (type == \"all_diff\") {\n        // Generate a string with all different characters\n        if (n > 26) {\n            fprintf(stderr, \"Invalid parameters: n cannot be greater than 26 for type 'all_diff'\\n\");\n            return 1;\n        }\n        vector<char> letters(26);\n        for (int i = 0; i < 26; ++i) letters[i] = 'a' + i;\n        shuffle(letters.begin(), letters.end());\n        s = string(letters.begin(), letters.begin() + n);\n    } else if (type == \"some_duplicates\") {\n        if (k == -1) {\n            fprintf(stderr, \"Invalid parameters: k must be specified for type 'some_duplicates'\\n\");\n            return 1;\n        }\n        if (k < 1 || k > 26) {\n            fprintf(stderr, \"Invalid k: must be between 1 and 26\\n\");\n            return 1;\n        }\n        vector<char> letters(26);\n        for (int i = 0; i < 26; ++i) letters[i] = 'a' + i;\n        shuffle(letters.begin(), letters.end());\n        vector<char> chosen(letters.begin(), letters.begin() + k);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = chosen[rnd.next(0, k - 1)];\n        }\n    } else if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(0, 25);\n        }\n    } else if (type == \"alternating\") {\n        // Generate a string with alternating characters\n        char c1 = 'a' + rnd.next(0, 25);\n        char c2 = 'a' + rnd.next(0, 25);\n        if (c1 == c2) {\n            c2 = 'a' + ((c1 - 'a' + 1) % 26);\n        }\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome string\n        s.resize(n);\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            char c = 'a' + rnd.next(0, 25);\n            s[i] = s[n - i - 1] = c;\n        }\n    } else {\n        fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    assert(1 <= s.length() && s.length() <= 100);\n    for (char c : s) {\n        assert('a' <= c && c <= 'z');\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    if (n < 1 || n > 100) {\n        fprintf(stderr, \"Invalid n: n must be between 1 and 100\\n\");\n        return 1;\n    }\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // number of distinct characters\n\n    string s;\n\n    if (type == \"all_same\") {\n        // Generate a string of length n with all the same character\n        char c = 'a' + rnd.next(0, 25);\n        s = string(n, c);\n    } else if (type == \"all_diff\") {\n        // Generate a string with all different characters\n        if (n > 26) {\n            fprintf(stderr, \"Invalid parameters: n cannot be greater than 26 for type 'all_diff'\\n\");\n            return 1;\n        }\n        vector<char> letters(26);\n        for (int i = 0; i < 26; ++i) letters[i] = 'a' + i;\n        shuffle(letters.begin(), letters.end());\n        s = string(letters.begin(), letters.begin() + n);\n    } else if (type == \"some_duplicates\") {\n        if (k == -1) {\n            fprintf(stderr, \"Invalid parameters: k must be specified for type 'some_duplicates'\\n\");\n            return 1;\n        }\n        if (k < 1 || k > 26) {\n            fprintf(stderr, \"Invalid k: must be between 1 and 26\\n\");\n            return 1;\n        }\n        vector<char> letters(26);\n        for (int i = 0; i < 26; ++i) letters[i] = 'a' + i;\n        shuffle(letters.begin(), letters.end());\n        vector<char> chosen(letters.begin(), letters.begin() + k);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = chosen[rnd.next(0, k - 1)];\n        }\n    } else if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(0, 25);\n        }\n    } else if (type == \"alternating\") {\n        // Generate a string with alternating characters\n        char c1 = 'a' + rnd.next(0, 25);\n        char c2 = 'a' + rnd.next(0, 25);\n        if (c1 == c2) {\n            c2 = 'a' + ((c1 - 'a' + 1) % 26);\n        }\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome string\n        s.resize(n);\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            char c = 'a' + rnd.next(0, 25);\n            s[i] = s[n - i - 1] = c;\n        }\n    } else {\n        fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    assert(1 <= s.length() && s.length() <= 100);\n    for (char c : s) {\n        assert('a' <= c && c <= 'z');\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: All same character, length 1\n./gen -n 1 -type all_same\n\n# Test case 2: All same character, maximum length 100\n./gen -n 100 -type all_same\n\n# Test case 3: All different characters, length 26\n./gen -n 26 -type all_diff\n\n# Test cases 4-13: 'some_duplicates' with various k, n=50\n./gen -n 50 -type some_duplicates -k 1\n./gen -n 50 -type some_duplicates -k 2\n./gen -n 50 -type some_duplicates -k 3\n./gen -n 50 -type some_duplicates -k 4\n./gen -n 50 -type some_duplicates -k 5\n./gen -n 50 -type some_duplicates -k 10\n./gen -n 50 -type some_duplicates -k 15\n./gen -n 50 -type some_duplicates -k 20\n./gen -n 50 -type some_duplicates -k 25\n./gen -n 50 -type some_duplicates -k 26\n\n# Test cases 14-23: 'some_duplicates' with various k, n=100\n./gen -n 100 -type some_duplicates -k 1\n./gen -n 100 -type some_duplicates -k 2\n./gen -n 100 -type some_duplicates -k 3\n./gen -n 100 -type some_duplicates -k 4\n./gen -n 100 -type some_duplicates -k 5\n./gen -n 100 -type some_duplicates -k 10\n./gen -n 100 -type some_duplicates -k 15\n./gen -n 100 -type some_duplicates -k 20\n./gen -n 100 -type some_duplicates -k 25\n./gen -n 100 -type some_duplicates -k 26\n\n# Test cases 24-26: Random strings of various lengths\n./gen -n 1 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n\n# Test cases 27-28: Alternating characters\n./gen -n 50 -type alternating\n./gen -n 100 -type alternating\n\n# Test cases 29-30: Palindromes\n./gen -n 50 -type palindrome\n./gen -n 100 -type palindrome\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:37.109524",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "236/B",
      "title": "B. Easy Number Challenge",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers a, b and c (1 ≤ a, b, c ≤ 100).",
      "output_spec": "OutputPrint a single integer — the required sum modulo 1073741824 (230).",
      "sample_tests": "ExamplesInputCopy2 2 2OutputCopy20InputCopy5 6 7OutputCopy1520",
      "description": "B. Easy Number Challenge\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers a, b and c (1 ≤ a, b, c ≤ 100).\n\nOutputPrint a single integer — the required sum modulo 1073741824 (230).\n\nInputCopy2 2 2OutputCopy20InputCopy5 6 7OutputCopy1520\n\nInputCopy2 2 2\n\nOutputCopy20\n\nInputCopy5 6 7\n\nOutputCopy1520\n\nNoteFor the first example.  d(1·1·1) = d(1) = 1;  d(1·1·2) = d(2) = 2;  d(1·2·1) = d(2) = 2;  d(1·2·2) = d(4) = 3;  d(2·1·1) = d(2) = 2;  d(2·1·2) = d(4) = 3;  d(2·2·1) = d(4) = 3;  d(2·2·2) = d(8) = 4. So the result is 1 + 2 + 2 + 3 + 2 + 3 + 3 + 4 = 20.",
      "solutions": [
        {
          "title": "Codeforces Round #146 - Codeforces",
          "content": "Hi!Codeforces Round #146 is going to be here soon. Round is prepared by YuukaKazami, MinakoKojima. I write problems for Div I and MinakoKojima write for Div II. Gerald did a great job in coordinating round preparing, and he also give some pretty good advise about problems. I'd like to express my gratitude to him. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Polygon system as well and Mary Belova (Delinur) for translating problems. Also thanks to donehl for testing the problems and making his comments about the problems.Score distribution is 500-1000-1500-2000-2500 in both divisions.Hope you enjoy the problems! =)I apologize for the 10 minutes delay.I'm very sorry for the inconvenience I caused. So I'm writing a good editorial for compensation :)The Editorial is here: EditorialCongrats to winners!Div1:1.rng_582.Dmitry_Egorov3.bjin4.Petr5.Egor6.touristDiv2:1.RiKang2.Caesar113.Gabaum4.ilona5.Bidhan6.sm_hossein",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5586",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 969
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces",
          "content": "236A - Boy or GirlIt is a very simple problem, just count how many distinct chars in the input and output the correct answer.236B - Easy Number ChallengeFirst of all, we can make a table of size a*b*c to store every number's d value. Then we can just brute force through every tripe to calculate the answer.235A - LCM ChallengeIt is a simple problem, but many competitors used some wrong guesses and failed. First of all, we should check if n is at most 3 and then we can simply output 1,2,6.Now there are two cases: When n is odd, the answer is obviously n(n-1)(n-2). When n is even, we can still get at least (n-1)(n-2)(n-3), so these three numbers in the optimal answer would not be very small compared to n. So we can just iterate every 3 number triple in [n-50,n] and update the answer.235B - Let's Play Osu!Let us take a deep look at how this score is calculated. For an n long 'O' block, it contributes n2 to the answer.Let us reformat this problem a bit and consider the following alternative definition of the score: (1) For each two 'O' pair which there is no 'X' between them, they add 2 to the score. (2) For each 'O', it adds 1 to the score.We claim that this new definition of the score is equivalent to the definition in the problem statement.Proof of the claim: For an n long 'O' block, there are Cn2 pairs of 'O' in it and n 'O' in it. Note that 2Cn2 + n = n2. So now we work with the new definition of the score. For each event(i,j) (which means s[i] and s[j] are 'O', and there is no 'X' between them). If event(i,j) happens, it adds 2 to the score. So we only need to sum up the probabilities of all events and multiply them by 2, and our task becomes how to calculate the sum of probabilities of all the event(i,j). Let P(i,j) be the probability of event(i,j).We can see that P(i,j) can be computed by . Then we denote P(j) as the sum of all event(i,j) for i<j. We have dp(0)=0 and dp(j)=(dp(j-1)+pj - 1)*pj235C - Cyclical QuestThis problem can be solved by many suffix structures. Probably using suffix automaton is the best way to solve it since suffix automaton is simple and clear.Let us build a suffix automaton of the input string S, and consider the query string x.Let us also build a string t as x concatenated with x dropping the last char. One can see that every consecutive sub-string of t with length |x| is a rotation of x.Let us read the string t with suffix automaton we have build, and every time take the first char out and add a new char, add the answer by the number of string equal to this current sub-string of t (which is a rotation of x).And one more thing, we should consider the repetend of x as well, check my solution here:2403375.Check here if you are not familiar with suffix automaton :e-maxx's blog235D - Graph GameFirst of all, let us consider the simpler case of trees.Let us use Event(A,B) to denote the following event \"when we select A as the deleting point, B is connected to A\".Clearly, if Event(A,B) happens, it would add 1 to totolCost.So we can just simply calculate the probability of every Event(A,B), and add them up.Let us consider how to calculate the probability of Event(A,B).Assume there are n vertices in the path between A and B, we claim that the probability is simply 1 / n.Let us try to prove it using induction.First let us assume there's a connected sub-graph of the tree containing both A and B, if the sub-graph only has n vertices, then the event happens only if we select vertex A, so the probability is 1 / n.Otherwise, assume it has x vertices there is two cases: whether the selected vertex is on the path between A and B or not.In the first case, the probability of Event(A,B) happen is 1 / x because if we don't select A, Event(A,B) will never happen.In the second case, the sub-graph containing A,B has become smaller, so the probability is (x - n) / xn.So add them up we can prove this statement.Then we can solve the tree case by simply add up the inverse of every path's length in the tree.And for the original case, there's at most 2 paths between A and B.If there's only one path, then everything is the same with the tree case.Otherwise, the path between A and B should pass the cycle in the graph.Let us examine this case, you can see that there 2 types of vertex:Vertex on the path of A to cycle or B to cycle, they should not be selected before A because once they're selected, A and B lost connectivity, let us call them X.Vertex on the cycle, the two paths from A to B, each path contains a path in the cycle, let us call them Y and Z.So there are two possibilities: X and Y are free when A is selected, X and Z are free when A is selected.And we should subtract the case that X and Y, Z are all free when A is selected because it double-counts before.So the probability is 1 / (X + Y + 1) + 1 / (X + Z + 1) - 1 / (X + Y + Z + 1).Check Petr 's solution for the details: 2401228And my C++ implementation: 2403938235E - Number ChallengeLet us consider each prime in one step, the upper limit for a, b, c is recorded.So if we fixed the power of 2 in each i, j, k like 2x, 2y, 2z, then their upper limit becomes a / 2x, b / 2y, c / 2z, and the power of 2 in their multiplication is just x+y+z.Let us denote dp(a, b, c, p) for the answer to the original problem that i, j, k 's upper limit is a, b, c. And their can only use the prime factors which are not less than p.Let the next prime to be q, so we can try to fix the power of p in i, j, k and get the new upper limit.So we can do transform like this: dp(a, b, c, p) = sum of dp(a / px, b / py, c / pz, q)·(x + y + z + 1)Check my code here: 2404223Also you can check rng_58 solution here: http://codeforces.com/blog/entry/5600If you have any problems, you can ask here :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 236\\s*B"
          },
          "content_length": 5718
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #146 - Codeforces - Code 1",
          "code": "IGNORE HER!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 2",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 3",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 4",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 5",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 1",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 2",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 3",
          "code": "n = int(input())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 4",
          "code": "if n==1 or n==2:     print(n)     exit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 5",
          "code": "if n&1:     print((n)*(n-1)*(n-2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 6",
          "code": "else:     print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 7",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 8",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 100, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 100, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 100, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        a = b = c = 1;\n    } else if (type == \"max\") {\n        a = b = c = 100;\n    } else if (type == \"one_large\") {\n        int which = rnd.next(3);\n        if (which == 0) {\n            a = 100;\n            b = c = rnd.next(1, 5);\n        } else if (which == 1) {\n            b = 100;\n            a = c = rnd.next(1, 5);\n        } else {\n            c = 100;\n            a = b = rnd.next(1, 5);\n        }\n    } else if (type == \"primes\") {\n        /* Generate random prime numbers between 1 and 100 */\n        vector<int> primes;\n        for (int i = 2; i <= 100; ++i) {\n            bool is_prime = true;\n            for (int j = 2; j * j <= i; ++j)\n                if (i % j == 0) {\n                    is_prime = false;\n                    break;\n                }\n            if (is_prime)\n                primes.push_back(i);\n        }\n        a = primes[rnd.next(primes.size())];\n        b = primes[rnd.next(primes.size())];\n        c = primes[rnd.next(primes.size())];\n    } else if (type == \"all_same\") {\n        a = b = c = rnd.next(1, 100);\n    } else if (type == \"random\") {\n        if (a == -1) a = rnd.next(1, 100);\n        if (b == -1) b = rnd.next(1, 100);\n        if (c == -1) c = rnd.next(1, 100);\n    } else {\n        /* If type not recognized, default to random */\n        if (a == -1) a = rnd.next(1, 100);\n        if (b == -1) b = rnd.next(1, 100);\n        if (c == -1) c = rnd.next(1, 100);\n    }\n\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        a = b = c = 1;\n    } else if (type == \"max\") {\n        a = b = c = 100;\n    } else if (type == \"one_large\") {\n        int which = rnd.next(3);\n        if (which == 0) {\n            a = 100;\n            b = c = rnd.next(1, 5);\n        } else if (which == 1) {\n            b = 100;\n            a = c = rnd.next(1, 5);\n        } else {\n            c = 100;\n            a = b = rnd.next(1, 5);\n        }\n    } else if (type == \"primes\") {\n        /* Generate random prime numbers between 1 and 100 */\n        vector<int> primes;\n        for (int i = 2; i <= 100; ++i) {\n            bool is_prime = true;\n            for (int j = 2; j * j <= i; ++j)\n                if (i % j == 0) {\n                    is_prime = false;\n                    break;\n                }\n            if (is_prime)\n                primes.push_back(i);\n        }\n        a = primes[rnd.next(primes.size())];\n        b = primes[rnd.next(primes.size())];\n        c = primes[rnd.next(primes.size())];\n    } else if (type == \"all_same\") {\n        a = b = c = rnd.next(1, 100);\n    } else if (type == \"random\") {\n        if (a == -1) a = rnd.next(1, 100);\n        if (b == -1) b = rnd.next(1, 100);\n        if (c == -1) c = rnd.next(1, 100);\n    } else {\n        /* If type not recognized, default to random */\n        if (a == -1) a = rnd.next(1, 100);\n        if (b == -1) b = rnd.next(1, 100);\n        if (c == -1) c = rnd.next(1, 100);\n    }\n\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type one_large\n./gen -type one_large\n./gen -type one_large\n./gen -type primes\n./gen -type primes\n./gen -type primes\n./gen -type all_same\n./gen -type all_same\n./gen -type random -a 100 -b 100 -c 1\n./gen -type random -a 100 -b 1 -c 100\n./gen -type random -a 1 -b 100 -c 100\n./gen -type random -a 1 -b 1 -c 100\n./gen -type random -a 1 -b 100 -c 1\n./gen -type random -a 100 -b 1 -c 1\n./gen -type random -a 50 -b 50 -c 50\n./gen -type random -a 2 -b 2 -c 2\n./gen -type random -a 99 -b 99 -c 99\n./gen -type random -a 2 -b 100 -c 2\n./gen -type random -a 100 -b 2 -c 2\n./gen -type random -a 2 -b 2 -c 100\n./gen -type random -a 100 -b 100 -c 2\n./gen -type random -a 100 -b 2 -c 100\n./gen -type random -a 2 -b 100 -c 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:39.291917",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "236/C",
      "title": "C. Задача на НОК",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 106) — переменная n из условия.",
      "output_spec": "Выходные данныеВыведите единственное целое число — максимально возможное наименьшее общее кратное трех необязательно различных целых чисел, которые не превышают n.",
      "sample_tests": "ПримерыВходные данныеСкопировать9Выходные данныеСкопировать504Входные данныеСкопировать7Выходные данныеСкопировать210",
      "description": "C. Задача на НОК\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 106) — переменная n из условия.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — максимально возможное наименьшее общее кратное трех необязательно различных целых чисел, которые не превышают n.\n\nВыходные данные\n\nВходные данныеСкопировать9Выходные данныеСкопировать504Входные данныеСкопировать7Выходные данныеСкопировать210\n\nВходные данныеСкопировать9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать504\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать210\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеНаименьшее общее кратное нескольких положительных целых чисел — это наименьшее положительное целое число, кратное им всем.Результат может получиться достаточно большим. Возможно, 32-битного целого числа не будет достаточно для его хранения. Поэтому рекомендуется использовать 64-битные целые числа.В последнем примере мы можем выбрать числа 7, 6, 5, их НОК равен 7·6·5 = 210. Это — максимальный НОК, который мы можем получить.",
      "solutions": [
        {
          "title": "Codeforces Round #146 - Codeforces",
          "content": "Всем привет!Совсем скоро начнется соревнование Codeforces Round #146. Этот раунд был приготовлен YuukaKazami, MinakoKojima. Я сделал задачи для Div I, а MinakoKojima — для Div II. Как обычно, Gerald очень сильно помог нам в подготовке раунда, давая много советов по задачам. Спасибо ему за это. Традиционно спасибо Михаилу Мирзаянову (MikeMirzayanov) за прекрасные системы Codeforces и Polygon, а также Марии Беловой (Delinur) за перевод задач. Также хочется сказать спасибо donehl за тестирование задач и за его ценные комментарии к задачам.В обоих дивизионах будет использоваться стандартная разбалловка 500-1000-1500-2000-2500.Надеюсь вам понравятся задачи! =)Это перевод оригинального поста автора с английского языка. Английский в комментариях приветствуется.Прошу прощения за 10-минутную задержку. Мне очень жаль за доставленные неудобства, которые я вызвал. В качестве компенсации, я напишу хороший разбор =)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5586",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 915
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces",
          "content": "236A - Boy or GirlIt is a very simple problem, just count how many distinct chars in the input and output the correct answer.236B - Easy Number ChallengeFirst of all, we can make a table of size a*b*c to store every number's d value. Then we can just brute force through every tripe to calculate the answer.235A - LCM ChallengeIt is a simple problem, but many competitors used some wrong guesses and failed. First of all, we should check if n is at most 3 and then we can simply output 1,2,6.Now there are two cases: When n is odd, the answer is obviously n(n-1)(n-2). When n is even, we can still get at least (n-1)(n-2)(n-3), so these three numbers in the optimal answer would not be very small compared to n. So we can just iterate every 3 number triple in [n-50,n] and update the answer.235B - Let's Play Osu!Let us take a deep look at how this score is calculated. For an n long 'O' block, it contributes n2 to the answer.Let us reformat this problem a bit and consider the following alternative definition of the score: (1) For each two 'O' pair which there is no 'X' between them, they add 2 to the score. (2) For each 'O', it adds 1 to the score.We claim that this new definition of the score is equivalent to the definition in the problem statement.Proof of the claim: For an n long 'O' block, there are Cn2 pairs of 'O' in it and n 'O' in it. Note that 2Cn2 + n = n2. So now we work with the new definition of the score. For each event(i,j) (which means s[i] and s[j] are 'O', and there is no 'X' between them). If event(i,j) happens, it adds 2 to the score. So we only need to sum up the probabilities of all events and multiply them by 2, and our task becomes how to calculate the sum of probabilities of all the event(i,j). Let P(i,j) be the probability of event(i,j).We can see that P(i,j) can be computed by . Then we denote P(j) as the sum of all event(i,j) for i<j. We have dp(0)=0 and dp(j)=(dp(j-1)+pj - 1)*pj235C - Cyclical QuestThis problem can be solved by many suffix structures. Probably using suffix automaton is the best way to solve it since suffix automaton is simple and clear.Let us build a suffix automaton of the input string S, and consider the query string x.Let us also build a string t as x concatenated with x dropping the last char. One can see that every consecutive sub-string of t with length |x| is a rotation of x.Let us read the string t with suffix automaton we have build, and every time take the first char out and add a new char, add the answer by the number of string equal to this current sub-string of t (which is a rotation of x).And one more thing, we should consider the repetend of x as well, check my solution here:2403375.Check here if you are not familiar with suffix automaton :e-maxx's blog235D - Graph GameFirst of all, let us consider the simpler case of trees.Let us use Event(A,B) to denote the following event \"when we select A as the deleting point, B is connected to A\".Clearly, if Event(A,B) happens, it would add 1 to totolCost.So we can just simply calculate the probability of every Event(A,B), and add them up.Let us consider how to calculate the probability of Event(A,B).Assume there are n vertices in the path between A and B, we claim that the probability is simply 1 / n.Let us try to prove it using induction.First let us assume there's a connected sub-graph of the tree containing both A and B, if the sub-graph only has n vertices, then the event happens only if we select vertex A, so the probability is 1 / n.Otherwise, assume it has x vertices there is two cases: whether the selected vertex is on the path between A and B or not.In the first case, the probability of Event(A,B) happen is 1 / x because if we don't select A, Event(A,B) will never happen.In the second case, the sub-graph containing A,B has become smaller, so the probability is (x - n) / xn.So add them up we can prove this statement.Then we can solve the tree case by simply add up the inverse of every path's length in the tree.And for the original case, there's at most 2 paths between A and B.If there's only one path, then everything is the same with the tree case.Otherwise, the path between A and B should pass the cycle in the graph.Let us examine this case, you can see that there 2 types of vertex:Vertex on the path of A to cycle or B to cycle, they should not be selected before A because once they're selected, A and B lost connectivity, let us call them X.Vertex on the cycle, the two paths from A to B, each path contains a path in the cycle, let us call them Y and Z.So there are two possibilities: X and Y are free when A is selected, X and Z are free when A is selected.And we should subtract the case that X and Y, Z are all free when A is selected because it double-counts before.So the probability is 1 / (X + Y + 1) + 1 / (X + Z + 1) - 1 / (X + Y + Z + 1).Check Petr 's solution for the details: 2401228And my C++ implementation: 2403938235E - Number ChallengeLet us consider each prime in one step, the upper limit for a, b, c is recorded.So if we fixed the power of 2 in each i, j, k like 2x, 2y, 2z, then their upper limit becomes a / 2x, b / 2y, c / 2z, and the power of 2 in their multiplication is just x+y+z.Let us denote dp(a, b, c, p) for the answer to the original problem that i, j, k 's upper limit is a, b, c. And their can only use the prime factors which are not less than p.Let the next prime to be q, so we can try to fix the power of p in i, j, k and get the new upper limit.So we can do transform like this: dp(a, b, c, p) = sum of dp(a / px, b / py, c / pz, q)·(x + y + z + 1)Check my code here: 2404223Also you can check rng_58 solution here: http://codeforces.com/blog/entry/5600If you have any problems, you can ask here :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 236 和字母"
          },
          "content_length": 5718
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #146 - Codeforces - Code 1",
          "code": "IGNORE HER!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 2",
          "code": "s11 = P*s1+P*s2+2*P*s3;\ns22 = P*s2+(1-P);\ns33 = P*(s3+s2);\ns44 = s4*P+(1-P)*dp[i-1];\ndp[i] = s44+s11+cp*(i+1)*(i+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 3",
          "code": "s11 = P*s1+P*s2+2*P*s3;\ns22 = P*s2+(1-P);\ns33 = P*(s3+s2);\ns44 = s4*P+(1-P)*dp[i-1];\ndp[i] = s44+s11+cp*(i+1)*(i+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 4",
          "code": "q_j*dp[i-j-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 5",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 6",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 7",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 8",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 1",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 2",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 3",
          "code": "n = int(input())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 4",
          "code": "if n==1 or n==2:     print(n)     exit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 5",
          "code": "if n&1:     print((n)*(n-1)*(n-2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 6",
          "code": "else:     print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 7",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 8",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n\n    if (n == -1) {\n        n = rnd.next(1, 1000000);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n\n    if (n == -1) {\n        n = rnd.next(1, 1000000);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n./gen -n 8\n./gen -n 9\n./gen -n 10\n\n./gen -n 100\n./gen -n 500\n./gen -n 1000\n./gen -n 5000\n./gen -n 10000\n./gen -n 50000\n./gen -n 100000\n./gen -n 500000\n./gen -n 999999\n./gen -n 1000000\n\n./gen\n./gen\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:41.113821",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "236/D",
      "title": "D. Let's Play Osu!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 105) — the number of clicks. The second line contains n space-separated real numbers p1, p2, ..., pn (0 ≤ pi ≤ 1).There will be at most six digits after the decimal point in the given pi.",
      "output_spec": "OutputPrint a single real number — the expected score for your play. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy30.5 0.5 0.5OutputCopy2.750000000000000InputCopy40.7 0.2 0.1 0.9OutputCopy2.489200000000000InputCopy51 1 1 1 1OutputCopy25.000000000000000",
      "description": "D. Let's Play Osu!\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 105) — the number of clicks. The second line contains n space-separated real numbers p1, p2, ..., pn (0 ≤ pi ≤ 1).There will be at most six digits after the decimal point in the given pi.\n\nOutputPrint a single real number — the expected score for your play. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.\n\nInputCopy30.5 0.5 0.5OutputCopy2.750000000000000InputCopy40.7 0.2 0.1 0.9OutputCopy2.489200000000000InputCopy51 1 1 1 1OutputCopy25.000000000000000\n\nInputCopy30.5 0.5 0.5\n\nOutputCopy2.750000000000000\n\nInputCopy40.7 0.2 0.1 0.9\n\nOutputCopy2.489200000000000\n\nInputCopy51 1 1 1 1\n\nOutputCopy25.000000000000000\n\nNoteFor the first example. There are 8 possible outcomes. Each has a probability of 0.125.  \"OOO\"  →  32 = 9;  \"OOX\"  →  22 = 4;  \"OXO\"  →  12 + 12 = 2;  \"OXX\"  →  12 = 1;  \"XOO\"  →  22 = 4;  \"XOX\"  →  12 = 1;  \"XXO\"  →  12 = 1;  \"XXX\"  →  0. So the expected score is",
      "solutions": [
        {
          "title": "Codeforces Round #146 - Codeforces",
          "content": "Hi!Codeforces Round #146 is going to be here soon. Round is prepared by YuukaKazami, MinakoKojima. I write problems for Div I and MinakoKojima write for Div II. Gerald did a great job in coordinating round preparing, and he also give some pretty good advise about problems. I'd like to express my gratitude to him. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Polygon system as well and Mary Belova (Delinur) for translating problems. Also thanks to donehl for testing the problems and making his comments about the problems.Score distribution is 500-1000-1500-2000-2500 in both divisions.Hope you enjoy the problems! =)I apologize for the 10 minutes delay.I'm very sorry for the inconvenience I caused. So I'm writing a good editorial for compensation :)The Editorial is here: EditorialCongrats to winners!Div1:1.rng_582.Dmitry_Egorov3.bjin4.Petr5.Egor6.touristDiv2:1.RiKang2.Caesar113.Gabaum4.ilona5.Bidhan6.sm_hossein",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5586",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 969
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces",
          "content": "236A - Boy or GirlIt is a very simple problem, just count how many distinct chars in the input and output the correct answer.236B - Easy Number ChallengeFirst of all, we can make a table of size a*b*c to store every number's d value. Then we can just brute force through every tripe to calculate the answer.235A - LCM ChallengeIt is a simple problem, but many competitors used some wrong guesses and failed. First of all, we should check if n is at most 3 and then we can simply output 1,2,6.Now there are two cases: When n is odd, the answer is obviously n(n-1)(n-2). When n is even, we can still get at least (n-1)(n-2)(n-3), so these three numbers in the optimal answer would not be very small compared to n. So we can just iterate every 3 number triple in [n-50,n] and update the answer.235B - Let's Play Osu!Let us take a deep look at how this score is calculated. For an n long 'O' block, it contributes n2 to the answer.Let us reformat this problem a bit and consider the following alternative definition of the score: (1) For each two 'O' pair which there is no 'X' between them, they add 2 to the score. (2) For each 'O', it adds 1 to the score.We claim that this new definition of the score is equivalent to the definition in the problem statement.Proof of the claim: For an n long 'O' block, there are Cn2 pairs of 'O' in it and n 'O' in it. Note that 2Cn2 + n = n2. So now we work with the new definition of the score. For each event(i,j) (which means s[i] and s[j] are 'O', and there is no 'X' between them). If event(i,j) happens, it adds 2 to the score. So we only need to sum up the probabilities of all events and multiply them by 2, and our task becomes how to calculate the sum of probabilities of all the event(i,j). Let P(i,j) be the probability of event(i,j).We can see that P(i,j) can be computed by . Then we denote P(j) as the sum of all event(i,j) for i<j. We have dp(0)=0 and dp(j)=(dp(j-1)+pj - 1)*pj235C - Cyclical QuestThis problem can be solved by many suffix structures. Probably using suffix automaton is the best way to solve it since suffix automaton is simple and clear.Let us build a suffix automaton of the input string S, and consider the query string x.Let us also build a string t as x concatenated with x dropping the last char. One can see that every consecutive sub-string of t with length |x| is a rotation of x.Let us read the string t with suffix automaton we have build, and every time take the first char out and add a new char, add the answer by the number of string equal to this current sub-string of t (which is a rotation of x).And one more thing, we should consider the repetend of x as well, check my solution here:2403375.Check here if you are not familiar with suffix automaton :e-maxx's blog235D - Graph GameFirst of all, let us consider the simpler case of trees.Let us use Event(A,B) to denote the following event \"when we select A as the deleting point, B is connected to A\".Clearly, if Event(A,B) happens, it would add 1 to totolCost.So we can just simply calculate the probability of every Event(A,B), and add them up.Let us consider how to calculate the probability of Event(A,B).Assume there are n vertices in the path between A and B, we claim that the probability is simply 1 / n.Let us try to prove it using induction.First let us assume there's a connected sub-graph of the tree containing both A and B, if the sub-graph only has n vertices, then the event happens only if we select vertex A, so the probability is 1 / n.Otherwise, assume it has x vertices there is two cases: whether the selected vertex is on the path between A and B or not.In the first case, the probability of Event(A,B) happen is 1 / x because if we don't select A, Event(A,B) will never happen.In the second case, the sub-graph containing A,B has become smaller, so the probability is (x - n) / xn.So add them up we can prove this statement.Then we can solve the tree case by simply add up the inverse of every path's length in the tree.And for the original case, there's at most 2 paths between A and B.If there's only one path, then everything is the same with the tree case.Otherwise, the path between A and B should pass the cycle in the graph.Let us examine this case, you can see that there 2 types of vertex:Vertex on the path of A to cycle or B to cycle, they should not be selected before A because once they're selected, A and B lost connectivity, let us call them X.Vertex on the cycle, the two paths from A to B, each path contains a path in the cycle, let us call them Y and Z.So there are two possibilities: X and Y are free when A is selected, X and Z are free when A is selected.And we should subtract the case that X and Y, Z are all free when A is selected because it double-counts before.So the probability is 1 / (X + Y + 1) + 1 / (X + Z + 1) - 1 / (X + Y + Z + 1).Check Petr 's solution for the details: 2401228And my C++ implementation: 2403938235E - Number ChallengeLet us consider each prime in one step, the upper limit for a, b, c is recorded.So if we fixed the power of 2 in each i, j, k like 2x, 2y, 2z, then their upper limit becomes a / 2x, b / 2y, c / 2z, and the power of 2 in their multiplication is just x+y+z.Let us denote dp(a, b, c, p) for the answer to the original problem that i, j, k 's upper limit is a, b, c. And their can only use the prime factors which are not less than p.Let the next prime to be q, so we can try to fix the power of p in i, j, k and get the new upper limit.So we can do transform like this: dp(a, b, c, p) = sum of dp(a / px, b / py, c / pz, q)·(x + y + z + 1)Check my code here: 2404223Also you can check rng_58 solution here: http://codeforces.com/blog/entry/5600If you have any problems, you can ask here :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 236 和字母"
          },
          "content_length": 5718
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #146 - Codeforces - Code 1",
          "code": "IGNORE HER!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 2",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 3",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 4",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 5",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 1",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 2",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 3",
          "code": "n = int(input())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 4",
          "code": "if n==1 or n==2:     print(n)     exit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 5",
          "code": "if n&1:     print((n)*(n-1)*(n-2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 6",
          "code": "else:     print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 7",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 8",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        if (i > 0)\n            inf.readSpace();\n        string s = inf.readToken(\"^(0(\\\\.[0-9]{1,6})?|1(\\\\.0{0,6})?)$\", \"p_i\");\n        double pi = atof(s.c_str());\n        ensuref(0.0 <= pi && pi <= 1.0, \"p[%d]=%f is not in [0,1]\", i+1, pi);\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        if (i > 0)\n            inf.readSpace();\n        string s = inf.readToken(\"^(0(\\\\.[0-9]{1,6})?|1(\\\\.0{0,6})?)$\", \"p_i\");\n        double pi = atof(s.c_str());\n        ensuref(0.0 <= pi && pi <= 1.0, \"p[%d]=%f is not in [0,1]\", i+1, pi);\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        if (i > 0)\n            inf.readSpace();\n        string s = inf.readToken(\"^(0(\\\\.[0-9]{1,6})?|1(\\\\.0{0,6})?)$\", \"p_i\");\n        double pi = atof(s.c_str());\n        ensuref(0.0 <= pi && pi <= 1.0, \"p[%d]=%f is not in [0,1]\", i+1, pi);\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble round6(double x) {\n    return round(x * 1e6) / 1e6;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<double> pi(n);\n\n    if (type == \"all_zero\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = 0.0;\n    } else if (type == \"all_one\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = 1.0;\n    } else if (type == \"all_half\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = 0.5;\n    } else if (type == \"small_probs\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = 1e-6;\n    } else if (type == \"high_probs\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = 0.999999;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = rnd.next(0, 1000000) / 1e6;\n    } else if (type == \"alternating_01\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = (i % 2 == 0) ? 0.0 : 1.0;\n    } else if (type == \"alternating_small_large\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = (i % 2 == 0) ? 1e-6 : 0.999999;\n    } else if (type == \"grad_increase\") {\n        if (n == 1)\n            pi[0] = round6(1e-6);\n        else {\n            for(int i = 0; i < n; ++i) {\n                pi[i] = 1e-6 + (0.999999 - 1e-6) * i / (n -1);\n                pi[i] = round6(pi[i]);\n            }\n        }\n    } else if (type == \"grad_decrease\") {\n        if (n == 1)\n            pi[0] = round6(0.999999);\n        else {\n            for(int i = 0; i < n; ++i) {\n                pi[i] = 0.999999 - (0.999999 - 1e-6) * i / (n -1);\n                pi[i] = round6(pi[i]);\n            }\n        }\n    }\n    \n    // Output n\n    printf(\"%d\\n\", n);\n    \n    // Output pi values\n    for(int i = 0; i < n; ++i) {\n        // Print pi[i] with up to 6 decimal places\n        printf(\"%.6f\", pi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ndouble round6(double x) {\n    return round(x * 1e6) / 1e6;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<double> pi(n);\n\n    if (type == \"all_zero\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = 0.0;\n    } else if (type == \"all_one\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = 1.0;\n    } else if (type == \"all_half\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = 0.5;\n    } else if (type == \"small_probs\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = 1e-6;\n    } else if (type == \"high_probs\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = 0.999999;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = rnd.next(0, 1000000) / 1e6;\n    } else if (type == \"alternating_01\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = (i % 2 == 0) ? 0.0 : 1.0;\n    } else if (type == \"alternating_small_large\") {\n        for(int i = 0; i < n; ++i)\n            pi[i] = (i % 2 == 0) ? 1e-6 : 0.999999;\n    } else if (type == \"grad_increase\") {\n        if (n == 1)\n            pi[0] = round6(1e-6);\n        else {\n            for(int i = 0; i < n; ++i) {\n                pi[i] = 1e-6 + (0.999999 - 1e-6) * i / (n -1);\n                pi[i] = round6(pi[i]);\n            }\n        }\n    } else if (type == \"grad_decrease\") {\n        if (n == 1)\n            pi[0] = round6(0.999999);\n        else {\n            for(int i = 0; i < n; ++i) {\n                pi[i] = 0.999999 - (0.999999 - 1e-6) * i / (n -1);\n                pi[i] = round6(pi[i]);\n            }\n        }\n    }\n    \n    // Output n\n    printf(\"%d\\n\", n);\n    \n    // Output pi values\n    for(int i = 0; i < n; ++i) {\n        // Print pi[i] with up to 6 decimal places\n        printf(\"%.6f\", pi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zero\n./gen -n 1 -type all_one\n./gen -n 1 -type all_half\n./gen -n 1 -type random\n./gen -n 1 -type small_probs\n./gen -n 1 -type high_probs\n\n./gen -n 2 -type alternating_01\n./gen -n 2 -type alternating_small_large\n./gen -n 2 -type grad_increase\n./gen -n 2 -type grad_decrease\n\n./gen -n 10 -type all_zero\n./gen -n 10 -type all_one\n./gen -n 10 -type all_half\n./gen -n 10 -type random\n./gen -n 10 -type small_probs\n./gen -n 10 -type high_probs\n./gen -n 10 -type alternating_01\n./gen -n 10 -type alternating_small_large\n./gen -n 10 -type grad_increase\n./gen -n 10 -type grad_decrease\n\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n\n./gen -n 100000 -type all_zero\n./gen -n 100000 -type all_one\n\n./gen -n 100000 -type grad_increase\n./gen -n 100000 -type grad_decrease\n./gen -n 100000 -type alternating_01\n./gen -n 100000 -type alternating_small_large\n\n./gen -n 99999 -type random\n./gen -n 100000 -type small_probs\n./gen -n 100000 -type high_probs\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:43.267466",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "236/E",
      "title": "E. Cyclical Quest",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains a non-empty string s. The length of string s is not greater than 106 characters.The second line contains an integer n (1 ≤ n ≤ 105) — the number of queries. Then n lines follow: the i-th line contains the string xi — the string for the i-th query. The total length of xi is less than or equal to 106 characters.In this problem, strings only consist of lowercase English letters.",
      "output_spec": "OutputFor each query xi print a single integer that shows how many consecutive substrings of s are cyclical isomorphic to xi. Print the answers to the queries in the order they are given in the input.",
      "sample_tests": "ExamplesInputCopybaabaabaaa5ababaaaabaaaabaOutputCopy75735InputCopyaabbaa3aaaabbabbaOutputCopy233",
      "description": "E. Cyclical Quest\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty string s. The length of string s is not greater than 106 characters.The second line contains an integer n (1 ≤ n ≤ 105) — the number of queries. Then n lines follow: the i-th line contains the string xi — the string for the i-th query. The total length of xi is less than or equal to 106 characters.In this problem, strings only consist of lowercase English letters.\n\nOutputFor each query xi print a single integer that shows how many consecutive substrings of s are cyclical isomorphic to xi. Print the answers to the queries in the order they are given in the input.\n\nInputCopybaabaabaaa5ababaaaabaaaabaOutputCopy75735InputCopyaabbaa3aaaabbabbaOutputCopy233\n\nInputCopybaabaabaaa5ababaaaabaaaaba\n\nOutputCopy75735\n\nInputCopyaabbaa3aaaabbabba\n\nOutputCopy233",
      "solutions": [
        {
          "title": "Codeforces Round #146 - Codeforces",
          "content": "Hi!Codeforces Round #146 is going to be here soon. Round is prepared by YuukaKazami, MinakoKojima. I write problems for Div I and MinakoKojima write for Div II. Gerald did a great job in coordinating round preparing, and he also give some pretty good advise about problems. I'd like to express my gratitude to him. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Polygon system as well and Mary Belova (Delinur) for translating problems. Also thanks to donehl for testing the problems and making his comments about the problems.Score distribution is 500-1000-1500-2000-2500 in both divisions.Hope you enjoy the problems! =)I apologize for the 10 minutes delay.I'm very sorry for the inconvenience I caused. So I'm writing a good editorial for compensation :)The Editorial is here: EditorialCongrats to winners!Div1:1.rng_582.Dmitry_Egorov3.bjin4.Petr5.Egor6.touristDiv2:1.RiKang2.Caesar113.Gabaum4.ilona5.Bidhan6.sm_hossein",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5586",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 969
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces",
          "content": "236A - Boy or GirlIt is a very simple problem, just count how many distinct chars in the input and output the correct answer.236B - Easy Number ChallengeFirst of all, we can make a table of size a*b*c to store every number's d value. Then we can just brute force through every tripe to calculate the answer.235A - LCM ChallengeIt is a simple problem, but many competitors used some wrong guesses and failed. First of all, we should check if n is at most 3 and then we can simply output 1,2,6.Now there are two cases: When n is odd, the answer is obviously n(n-1)(n-2). When n is even, we can still get at least (n-1)(n-2)(n-3), so these three numbers in the optimal answer would not be very small compared to n. So we can just iterate every 3 number triple in [n-50,n] and update the answer.235B - Let's Play Osu!Let us take a deep look at how this score is calculated. For an n long 'O' block, it contributes n2 to the answer.Let us reformat this problem a bit and consider the following alternative definition of the score: (1) For each two 'O' pair which there is no 'X' between them, they add 2 to the score. (2) For each 'O', it adds 1 to the score.We claim that this new definition of the score is equivalent to the definition in the problem statement.Proof of the claim: For an n long 'O' block, there are Cn2 pairs of 'O' in it and n 'O' in it. Note that 2Cn2 + n = n2. So now we work with the new definition of the score. For each event(i,j) (which means s[i] and s[j] are 'O', and there is no 'X' between them). If event(i,j) happens, it adds 2 to the score. So we only need to sum up the probabilities of all events and multiply them by 2, and our task becomes how to calculate the sum of probabilities of all the event(i,j). Let P(i,j) be the probability of event(i,j).We can see that P(i,j) can be computed by . Then we denote P(j) as the sum of all event(i,j) for i<j. We have dp(0)=0 and dp(j)=(dp(j-1)+pj - 1)*pj235C - Cyclical QuestThis problem can be solved by many suffix structures. Probably using suffix automaton is the best way to solve it since suffix automaton is simple and clear.Let us build a suffix automaton of the input string S, and consider the query string x.Let us also build a string t as x concatenated with x dropping the last char. One can see that every consecutive sub-string of t with length |x| is a rotation of x.Let us read the string t with suffix automaton we have build, and every time take the first char out and add a new char, add the answer by the number of string equal to this current sub-string of t (which is a rotation of x).And one more thing, we should consider the repetend of x as well, check my solution here:2403375.Check here if you are not familiar with suffix automaton :e-maxx's blog235D - Graph GameFirst of all, let us consider the simpler case of trees.Let us use Event(A,B) to denote the following event \"when we select A as the deleting point, B is connected to A\".Clearly, if Event(A,B) happens, it would add 1 to totolCost.So we can just simply calculate the probability of every Event(A,B), and add them up.Let us consider how to calculate the probability of Event(A,B).Assume there are n vertices in the path between A and B, we claim that the probability is simply 1 / n.Let us try to prove it using induction.First let us assume there's a connected sub-graph of the tree containing both A and B, if the sub-graph only has n vertices, then the event happens only if we select vertex A, so the probability is 1 / n.Otherwise, assume it has x vertices there is two cases: whether the selected vertex is on the path between A and B or not.In the first case, the probability of Event(A,B) happen is 1 / x because if we don't select A, Event(A,B) will never happen.In the second case, the sub-graph containing A,B has become smaller, so the probability is (x - n) / xn.So add them up we can prove this statement.Then we can solve the tree case by simply add up the inverse of every path's length in the tree.And for the original case, there's at most 2 paths between A and B.If there's only one path, then everything is the same with the tree case.Otherwise, the path between A and B should pass the cycle in the graph.Let us examine this case, you can see that there 2 types of vertex:Vertex on the path of A to cycle or B to cycle, they should not be selected before A because once they're selected, A and B lost connectivity, let us call them X.Vertex on the cycle, the two paths from A to B, each path contains a path in the cycle, let us call them Y and Z.So there are two possibilities: X and Y are free when A is selected, X and Z are free when A is selected.And we should subtract the case that X and Y, Z are all free when A is selected because it double-counts before.So the probability is 1 / (X + Y + 1) + 1 / (X + Z + 1) - 1 / (X + Y + Z + 1).Check Petr 's solution for the details: 2401228And my C++ implementation: 2403938235E - Number ChallengeLet us consider each prime in one step, the upper limit for a, b, c is recorded.So if we fixed the power of 2 in each i, j, k like 2x, 2y, 2z, then their upper limit becomes a / 2x, b / 2y, c / 2z, and the power of 2 in their multiplication is just x+y+z.Let us denote dp(a, b, c, p) for the answer to the original problem that i, j, k 's upper limit is a, b, c. And their can only use the prime factors which are not less than p.Let the next prime to be q, so we can try to fix the power of p in i, j, k and get the new upper limit.So we can do transform like this: dp(a, b, c, p) = sum of dp(a / px, b / py, c / pz, q)·(x + y + z + 1)Check my code here: 2404223Also you can check rng_58 solution here: http://codeforces.com/blog/entry/5600If you have any problems, you can ask here :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 236 和字母"
          },
          "content_length": 5718
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #146 - Codeforces - Code 1",
          "code": "IGNORE HER!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 2",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 3",
          "code": "E[i, j] = E[i, k] + E[k + 1, j] + 2 * R[i, k] * L[k+1, j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 4",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 - Codeforces - Code 5",
          "code": "e[j] = E[0, j] = E[0, j-1] + E[j, j] + 2 * R[0, j-1] * L[j,j] \n     = e[j-1] + p[j] + 2 * r[j] * p[j]\nr[j] = (r[j-1] + 1) * p[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5586",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 1",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 2",
          "code": "readln( n );\n                if n = 1 then Result( 1 );\n                if n = 2 then Result( 2 );\n                if n = 3 then Result( 6 );\n                if odd( n ) then\n                        res := n * ( n - 1 ) * ( n - 2 )\n                else\n                        begin\n                                if n mod 3 = 0 then\n                                        res := ( n - 1 ) * ( n - 2 ) * ( n - 3 )\n                                else\n                                        res := n * ( n - 1 ) * ( n - 3 );\n                        end; \n                Result( res );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 3",
          "code": "n = int(input())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 4",
          "code": "if n==1 or n==2:     print(n)     exit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 5",
          "code": "if n&1:     print((n)*(n-1)*(n-2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 6",
          "code": "else:     print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 7",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #146 Tutorial - Codeforces - Code 8",
          "code": "So if they are i, j , ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5592",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s\n    string s = inf.readLine(\"[a-z]+\");\n    ensuref(s.length() <= 1000000, \"Length of s must be at most 1e6, but it is %d\", (int)s.length());\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    long long total_xi_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string xi = inf.readLine(\"[a-z]*\");\n        total_xi_length += xi.length();\n    }\n\n    ensuref(total_xi_length <= 1000000, \"Total length of xi's must be at most 1e6, but it is %lld\", total_xi_length);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s\n    string s = inf.readLine(\"[a-z]+\");\n    ensuref(s.length() <= 1000000, \"Length of s must be at most 1e6, but it is %d\", (int)s.length());\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    long long total_xi_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string xi = inf.readLine(\"[a-z]*\");\n        total_xi_length += xi.length();\n    }\n\n    ensuref(total_xi_length <= 1000000, \"Total length of xi's must be at most 1e6, but it is %lld\", total_xi_length);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read s\n    string s = inf.readLine(\"[a-z]+\");\n    ensuref(s.length() <= 1000000, \"Length of s must be at most 1e6, but it is %d\", (int)s.length());\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    long long total_xi_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string xi = inf.readLine(\"[a-z]*\");\n        total_xi_length += xi.length();\n    }\n\n    ensuref(total_xi_length <= 1000000, \"Total length of xi's must be at most 1e6, but it is %lld\", total_xi_length);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * This generator produces a single test input for the \"cyclical isomorphic substring\" problem:\n *\n *    1) A string s (non-empty, length up to 1e6)\n *    2) An integer n (1 ≤ n ≤ 1e5)\n *    3) Then n strings x_i (total length ≤ 1e6)\n *\n * Usage example:\n *   ./gen -lenS 10 -typeS random -n 5 -typeQ random\n *\n *    - lenS : length of s\n *    - typeS: how to generate the string s; one of { random, repeated, small, palindrome }\n *    - n    : number of queries\n *    - typeQ: how to generate the query strings; one of { random, from_s, mixed }\n *\n * The generator does NOT set any random seed or accept a seed parameter.\n * The sum of the lengths of all queries is also enforced not to exceed 10^6.\n */\n\nstatic const int ALPH_SIZE = 26;  // number of lowercase English letters\nstatic const int MAX_TOTAL_Q_LEN = 1000000; // total length of queries must not exceed 1e6\n\n// Generate a random lowercase letter\nchar randomChar() {\n    return char('a' + rnd.next(ALPH_SIZE));\n}\n\n// Generate a string of chosen length using only lowercase letters\nstring genRandomString(int length) {\n    string s(length, 'a');\n    for (int i = 0; i < length; i++) {\n        s[i] = randomChar();\n    }\n    return s;\n}\n\n// Generate a repeated-character string\nstring genRepeatedString(int length) {\n    char c = randomChar();\n    return string(length, c);\n}\n\n// Generate a small-alphabet random string (only 'a'..'b')\nstring genSmallString(int length) {\n    string s(length, 'a');\n    for (int i = 0; i < length; i++) {\n        // only 'a' or 'b'\n        s[i] = char('a' + rnd.next(2)); \n    }\n    return s;\n}\n\n// Generate a palindrome\nstring genPalindrome(int length) {\n    // fill half randomly, mirror the rest\n    // if odd, the middle char is random\n    string s(length, 'a');\n    for(int i = 0; i < (length + 1)/2; i++) {\n        s[i] = randomChar();\n        s[length - 1 - i] = s[i];\n    }\n    return s;\n}\n\n// Helper to generate the main string s\nstring generateS(int lenS, const string &typeS) {\n    if (lenS <= 0) {\n        // problem states s is non-empty, but let's clamp here\n        lenS = 1;\n    }\n    if (typeS == \"random\") {\n        return genRandomString(lenS);\n    } else if (typeS == \"repeated\") {\n        return genRepeatedString(lenS);\n    } else if (typeS == \"small\") {\n        return genSmallString(lenS);\n    } else if (typeS == \"palindrome\") {\n        return genPalindrome(lenS);\n    } else {\n        // default to random\n        return genRandomString(lenS);\n    }\n}\n\n// Generate a query string (various modes):\n//   - \"random\": fully random\n//   - \"from_s\": pick a random substring of 's' and possibly rotate it\n//   - \"mixed\":  sometimes random, sometimes from substring of 's'\nstring generateQuery(const string &s, const string &typeQ, int maxLen) {\n    // ensure we don't exceed s.size() if we plan to copy from s\n    int n = (int) s.size();\n    if (n == 0) {\n        // fallback if s is empty (though problem states it's non-empty)\n        return genRandomString(1);\n    }\n\n    // pick length of the query from 1..maxLen\n    int length = rnd.next(1, maxLen);\n\n    if (typeQ == \"random\") {\n        // generate a random string of length\n        return genRandomString(length);\n    }\n    else if (typeQ == \"from_s\") {\n        // pick a random substring of s and optionally rotate it\n        // if length > s.size(), we just do random\n        if (length <= n) {\n            int start = rnd.next(0, n - length);\n            // copy the substring\n            string q = s.substr(start, length);\n\n            // decide randomly whether to rotate\n            if (rnd.next(2) == 1) {\n                int rot = rnd.next(0, length - 1); // rotate some positions\n                rotate(q.begin(), q.begin() + rot, q.end());\n            }\n            return q;\n        } else {\n            return genRandomString(length);\n        }\n    }\n    else if (typeQ == \"mixed\") {\n        // 30% from S, 70% random\n        if (rnd.next(100) < 30) {\n            // same approach as \"from_s\"\n            if (length <= n) {\n                int start = rnd.next(0, n - length);\n                string q = s.substr(start, length);\n                // random rotation\n                if (rnd.next(2) == 1) {\n                    int rot = rnd.next(0, length - 1);\n                    rotate(q.begin(), q.begin() + rot, q.end());\n                }\n                return q;\n            } else {\n                return genRandomString(length);\n            }\n        } else {\n            return genRandomString(length);\n        }\n    }\n    // default fallback\n    return genRandomString(length);\n}\n\nint main(int argc, char* argv[]) {\n    // register generator\n    registerGen(argc, argv, 1);\n\n    // parse parameters\n    int lenS = opt<int>(\"lenS\");            // length of the main string s\n    string typeS = opt<string>(\"typeS\", \"random\"); // how to generate s\n    int n = opt<int>(\"n\");                 // number of queries\n    string typeQ = opt<string>(\"typeQ\", \"random\"); // how to generate queries\n\n    // generate s\n    // clamp to at least length 1\n    if (lenS < 1) {\n        lenS = 1;\n    }\n    string s = generateS(lenS, typeS);\n\n    // output s\n    cout << s << \"\\n\";\n\n    // output n\n    // must ensure 1 ≤ n ≤ 1e5\n    if (n < 1) {\n        n = 1;\n    }\n    cout << n << \"\\n\";\n\n    // We'll try to ensure total length of queries <= 1e6\n    // a naive approach: each query up to min(lenS, leftover)\n    // leftover starts at 1e6\n    int leftover = MAX_TOTAL_Q_LEN;\n    for (int i = 0; i < n; i++) {\n        // the maximum length for this query cannot exceed leftover - (n - i - 1)\n        // because we need at least 1 char for future queries\n        int maxPossible = leftover - (n - i - 1);\n        if (maxPossible < 1) {\n            // fallback if the sum is too big: enforce queries of length 1\n            maxPossible = 1;\n        }\n        // also clamp by lenS, but allow queries up to lenS\n        int maxLen = min(maxPossible, lenS);\n\n        // generate a query\n        string q = generateQuery(s, typeQ, maxLen);\n\n        // update leftover\n        leftover -= (int)q.size();\n\n        cout << q << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * This generator produces a single test input for the \"cyclical isomorphic substring\" problem:\n *\n *    1) A string s (non-empty, length up to 1e6)\n *    2) An integer n (1 ≤ n ≤ 1e5)\n *    3) Then n strings x_i (total length ≤ 1e6)\n *\n * Usage example:\n *   ./gen -lenS 10 -typeS random -n 5 -typeQ random\n *\n *    - lenS : length of s\n *    - typeS: how to generate the string s; one of { random, repeated, small, palindrome }\n *    - n    : number of queries\n *    - typeQ: how to generate the query strings; one of { random, from_s, mixed }\n *\n * The generator does NOT set any random seed or accept a seed parameter.\n * The sum of the lengths of all queries is also enforced not to exceed 10^6.\n */\n\nstatic const int ALPH_SIZE = 26;  // number of lowercase English letters\nstatic const int MAX_TOTAL_Q_LEN = 1000000; // total length of queries must not exceed 1e6\n\n// Generate a random lowercase letter\nchar randomChar() {\n    return char('a' + rnd.next(ALPH_SIZE));\n}\n\n// Generate a string of chosen length using only lowercase letters\nstring genRandomString(int length) {\n    string s(length, 'a');\n    for (int i = 0; i < length; i++) {\n        s[i] = randomChar();\n    }\n    return s;\n}\n\n// Generate a repeated-character string\nstring genRepeatedString(int length) {\n    char c = randomChar();\n    return string(length, c);\n}\n\n// Generate a small-alphabet random string (only 'a'..'b')\nstring genSmallString(int length) {\n    string s(length, 'a');\n    for (int i = 0; i < length; i++) {\n        // only 'a' or 'b'\n        s[i] = char('a' + rnd.next(2)); \n    }\n    return s;\n}\n\n// Generate a palindrome\nstring genPalindrome(int length) {\n    // fill half randomly, mirror the rest\n    // if odd, the middle char is random\n    string s(length, 'a');\n    for(int i = 0; i < (length + 1)/2; i++) {\n        s[i] = randomChar();\n        s[length - 1 - i] = s[i];\n    }\n    return s;\n}\n\n// Helper to generate the main string s\nstring generateS(int lenS, const string &typeS) {\n    if (lenS <= 0) {\n        // problem states s is non-empty, but let's clamp here\n        lenS = 1;\n    }\n    if (typeS == \"random\") {\n        return genRandomString(lenS);\n    } else if (typeS == \"repeated\") {\n        return genRepeatedString(lenS);\n    } else if (typeS == \"small\") {\n        return genSmallString(lenS);\n    } else if (typeS == \"palindrome\") {\n        return genPalindrome(lenS);\n    } else {\n        // default to random\n        return genRandomString(lenS);\n    }\n}\n\n// Generate a query string (various modes):\n//   - \"random\": fully random\n//   - \"from_s\": pick a random substring of 's' and possibly rotate it\n//   - \"mixed\":  sometimes random, sometimes from substring of 's'\nstring generateQuery(const string &s, const string &typeQ, int maxLen) {\n    // ensure we don't exceed s.size() if we plan to copy from s\n    int n = (int) s.size();\n    if (n == 0) {\n        // fallback if s is empty (though problem states it's non-empty)\n        return genRandomString(1);\n    }\n\n    // pick length of the query from 1..maxLen\n    int length = rnd.next(1, maxLen);\n\n    if (typeQ == \"random\") {\n        // generate a random string of length\n        return genRandomString(length);\n    }\n    else if (typeQ == \"from_s\") {\n        // pick a random substring of s and optionally rotate it\n        // if length > s.size(), we just do random\n        if (length <= n) {\n            int start = rnd.next(0, n - length);\n            // copy the substring\n            string q = s.substr(start, length);\n\n            // decide randomly whether to rotate\n            if (rnd.next(2) == 1) {\n                int rot = rnd.next(0, length - 1); // rotate some positions\n                rotate(q.begin(), q.begin() + rot, q.end());\n            }\n            return q;\n        } else {\n            return genRandomString(length);\n        }\n    }\n    else if (typeQ == \"mixed\") {\n        // 30% from S, 70% random\n        if (rnd.next(100) < 30) {\n            // same approach as \"from_s\"\n            if (length <= n) {\n                int start = rnd.next(0, n - length);\n                string q = s.substr(start, length);\n                // random rotation\n                if (rnd.next(2) == 1) {\n                    int rot = rnd.next(0, length - 1);\n                    rotate(q.begin(), q.begin() + rot, q.end());\n                }\n                return q;\n            } else {\n                return genRandomString(length);\n            }\n        } else {\n            return genRandomString(length);\n        }\n    }\n    // default fallback\n    return genRandomString(length);\n}\n\nint main(int argc, char* argv[]) {\n    // register generator\n    registerGen(argc, argv, 1);\n\n    // parse parameters\n    int lenS = opt<int>(\"lenS\");            // length of the main string s\n    string typeS = opt<string>(\"typeS\", \"random\"); // how to generate s\n    int n = opt<int>(\"n\");                 // number of queries\n    string typeQ = opt<string>(\"typeQ\", \"random\"); // how to generate queries\n\n    // generate s\n    // clamp to at least length 1\n    if (lenS < 1) {\n        lenS = 1;\n    }\n    string s = generateS(lenS, typeS);\n\n    // output s\n    cout << s << \"\\n\";\n\n    // output n\n    // must ensure 1 ≤ n ≤ 1e5\n    if (n < 1) {\n        n = 1;\n    }\n    cout << n << \"\\n\";\n\n    // We'll try to ensure total length of queries <= 1e6\n    // a naive approach: each query up to min(lenS, leftover)\n    // leftover starts at 1e6\n    int leftover = MAX_TOTAL_Q_LEN;\n    for (int i = 0; i < n; i++) {\n        // the maximum length for this query cannot exceed leftover - (n - i - 1)\n        // because we need at least 1 char for future queries\n        int maxPossible = leftover - (n - i - 1);\n        if (maxPossible < 1) {\n            // fallback if the sum is too big: enforce queries of length 1\n            maxPossible = 1;\n        }\n        // also clamp by lenS, but allow queries up to lenS\n        int maxLen = min(maxPossible, lenS);\n\n        // generate a query\n        string q = generateQuery(s, typeQ, maxLen);\n\n        // update leftover\n        leftover -= (int)q.size();\n\n        cout << q << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands to generate approximately 20 distinct test cases.\n# Each command prints a single test to stdout.\n\n# 1) Very small s, single query\n./gen -lenS 1 -typeS random -n 1 -typeQ random\n\n# 2) Small repeated s, small number of queries\n./gen -lenS 5 -typeS repeated -n 3 -typeQ random\n\n# 3) Small s with only 'a'/'b', random queries\n./gen -lenS 6 -typeS small -n 5 -typeQ random\n\n# 4) Palindromic s, random queries\n./gen -lenS 7 -typeS palindrome -n 5 -typeQ random\n\n# 5) Random s of length 10, from_s queries\n./gen -lenS 10 -typeS random -n 5 -typeQ from_s\n\n# 6) Random s of length 10, mixed queries\n./gen -lenS 10 -typeS random -n 5 -typeQ mixed\n\n# 7) Medium-length s=50, random queries\n./gen -lenS 50 -typeS random -n 10 -typeQ random\n\n# 8) Medium-length repeated s=50, from_s queries\n./gen -lenS 50 -typeS repeated -n 10 -typeQ from_s\n\n# 9) Medium-length small s=50, mixed queries\n./gen -lenS 50 -typeS small -n 10 -typeQ mixed\n\n# 10) Palindromic s=50, random queries\n./gen -lenS 50 -typeS palindrome -n 10 -typeQ random\n\n# 11) Larger s=200, random queries\n./gen -lenS 200 -typeS random -n 20 -typeQ random\n\n# 12) Larger s=200, from_s queries\n./gen -lenS 200 -typeS repeated -n 20 -typeQ from_s\n\n# 13) Larger s=200, mixed queries\n./gen -lenS 200 -typeS small -n 20 -typeQ mixed\n\n# 14) Palindromic s=200, random queries\n./gen -lenS 200 -typeS palindrome -n 20 -typeQ random\n\n# 15) Big s=10000, small number of queries\n./gen -lenS 10000 -typeS random -n 3 -typeQ random\n\n# 16) Big s=10000, repeated, few queries\n./gen -lenS 10000 -typeS repeated -n 3 -typeQ from_s\n\n# 17) Big s=10000, palindrome, few queries\n./gen -lenS 10000 -typeS palindrome -n 3 -typeQ mixed\n\n# 18) Larger n=100, s=300, random\n./gen -lenS 300 -typeS random -n 100 -typeQ random\n\n# 19) Larger n=100, s=300, from_s\n./gen -lenS 300 -typeS repeated -n 100 -typeQ from_s\n\n# 20) Larger n=100, s=300, mixed\n./gen -lenS 300 -typeS small -n 100 -typeQ mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:45.339406",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "237/A",
      "title": "A. Free Cash",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105), that is the number of cafe visitors.Each of the following n lines has two space-separated integers hi and mi (0 ≤ hi ≤ 23; 0 ≤ mi ≤ 59), representing the time when the i-th person comes into the cafe. Note that the time is given in the chronological order. All time is given within one 24-hour period.",
      "output_spec": "OutputPrint a single integer — the minimum number of cashes, needed to serve all clients next day.",
      "sample_tests": "ExamplesInputCopy48 08 108 108 45OutputCopy2InputCopy30 1210 1122 22OutputCopy1",
      "description": "A. Free Cash\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105), that is the number of cafe visitors.Each of the following n lines has two space-separated integers hi and mi (0 ≤ hi ≤ 23; 0 ≤ mi ≤ 59), representing the time when the i-th person comes into the cafe. Note that the time is given in the chronological order. All time is given within one 24-hour period.\n\nOutputPrint a single integer — the minimum number of cashes, needed to serve all clients next day.\n\nInputCopy48 08 108 108 45OutputCopy2InputCopy30 1210 1122 22OutputCopy1\n\nInputCopy48 08 108 108 45\n\nOutputCopy2\n\nInputCopy30 1210 1122 22\n\nOutputCopy1\n\nNoteIn the first sample it is not enough one cash to serve all clients, because two visitors will come into cafe in 8:10. Therefore, if there will be one cash in cafe, then one customer will be served by it, and another one will not wait and will go away.In the second sample all visitors will come in different times, so it will be enough one cash.",
      "solutions": [
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces",
          "content": "Hi!A few hours later you're lucky to participate in Codeforces Round #147 for Div.2 participants, but traditionally the others can take part out of the competition. It has been prepared by me (NALP), Igor Kudryashov (Igor_Kudryashov), Pavlik Holkin (HolkinPV), Gerald Agapov (Gerald), Mary Belova (Delinur) and Mike Mirzayanov (MikeMirzayanov).Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!The standart scoring system will be used: 500-1000-1500-2000-2500UPD: The contest has ended, congratulations to the winners: try_skycn AntiKismet dianbei_03 Uncia Bigsophie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5640",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 607
        },
        {
          "title": "Codeforces Round #147 (Div. 2) Разбор Задач - Codeforces",
          "content": "Приветствую всех участников раунда!237A - Free CashИз условия задачи легко понять, что если в некоторую минуту придут k человек, то Валере нужно иметь в кафе не менее k касс. Значит, требуется найти максимальное количество людей, которые придут в одну и ту же минуту, а это делается очень просто множеством способов, например, просто насчитав в массив cnt[h][m] количество людей, которые придут в час h и минуту m, а потом найдя в этом массиве максимум.237B - Young TableРешение, которое опишем ниже, почти никак не использует хитрую форму таблицы (кстати, такая таблица называется диаграммой Юнга). Заполним таблицу числами от 1 до s следующим способом: будем идти по строкам таблицы начиная с первой слева направо, после конца текущей строки переходим на начало следующей, и в процессе каждой из клеточек присвоим число по порядку обхода от 1 до s. Очень просто показать, что такой порядок чисел удовлетворяет оба неравенства из условия.Теперь опишем алгоритм приведения таблицы из того вида, как она нам дана во входных данных, в описанный выше вид.Возьмем число 1 и посмотрим, где оно находится в этих двух таблицах. Если это число стоит не на своем месте, то поставим его на свое место, соответственно то число, которое там стояло, встанет на старое место единицы. Аналогично сделаем для 2, 3, ..., s. Очевидно, что этот алгоритм сделает не более s шагов и приведет таблицу в вид, описанный в первом абзаце.237C - Primes on IntervalДля начала с помощью решета Эратосфена выделим все простые числа от 1 до b и пометим их единичками в массиве d, то есть если p — простое, то d[p] = 1, иначе d[p] = 0.Заметим, что если l — корректное число, то l + 1 тоже корректно. В самом деле, для позиций x от a до b - l количество простых в отрезке с началом в x могло лишь увеличиться (мы же длину отрезка увеличили, а значит, количество простых в нем никак не могло уменьшиться). А кроме того исчез из рассмотрения один отрезок с началом в точке b - l + 1, так как при увеличении длины его правый конец стал больше, чем число b.Таким образом, мы показали, что функция f(l), возвращающая TRUE или FALSE (корректно число или нет) монотонна, а значит, мы можем с помощью бинарного поиска найти наименьшее l, для которого f(l) = TRUE, или ответить, что такого не существует.Функция f(l) считается очень просто — можно проитерироваться по всем числам от a до b - l + 1 и найти для каждого начала количество простых чисел в соответствующем отрезке длины l, это можно сделать с помощью частичных сумм, насчитанных по массиву d.237D - T-decompositionВозьмем любое ребро начального графа, очевидно два его конца принадлежат некоторому множеству xi, значит, вес любой его Д-декомпозиции как минимум 2. Покажем, как постороить декомпозицию именно такого веса. Для этого каждое из ребер исходного графа превратим в отдельное множество xi, то есть все они будут состоять из двух элементов.Очевидно, что первые два условия выполняются. Для выполнения третьего условия для начала соединим все множества по принципу: добавим ребро между двуми множествами, если их пересечение не пусто. Однако построенный таким образом граф не является деревом, покажем другой способ соединения вершин.Для того, чтобы сделать из него дерево, достаточно для каждой вершины v начального дерева выделить все xi, в которых она содержится, и соединить их в цепочку в любом порядке, добавив нужное количество ребер.Несложно понять, что такой граф не будет содержать циклов, будет связен, а значит является деревом. Постоенная Д-декомпозиция будет иметь вес 2, и количество вершин n - 1.237E - Build StringЭта задача несложно решается алгоритмом поиска максимального потока минимальной стоимости на трехслойном графе: первый слой состоит из n вершин, каждая из которых отвечает за свою строку из входных данных; в i-ую вершину этого слоя входит по одному ребру из истока с пропускной способностью ci и стоимостью i; второй стой состоит за 26·n вершин, каждая из которых отвечает за количество определенных букв в каждой из строк из входных данных; в вершины этого слоя входят ребра только из первого слоя стоимостью 0 и пропускной способностью равной количеству соответствующих букв в соответствующей строке; третий слой состоит из 26 вершин, каждая из которых отвечает за количество соответствующих букв в строке t; в вершины этого слоя входят ребра только из второго слоя стоимостью 0 и бесконечной пропускной способностью; кроме того, из вершин третьего слоя выходят ребра в сток стоимостью 0 и пропускной способностью, равной количеству соответствующих букв в строке t. Если максимальный поток в этой сети меньше, чем |t|, то ответ равен  - 1, а иначе — минимальной стоимости максимального потока.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5648",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 237\\s*A"
          },
          "content_length": 4653
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 1",
          "code": "6\n2 2 1 1\n3 1 1 2\n1 2 1 3\n1 1 2 1\n1 3 2 2\n2 1 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 2",
          "code": "6\n2 2 1 1\n3 1 1 2\n1 2 1 3\n1 1 2 1\n1 3 2 2\n2 1 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 3",
          "code": "co place[mo];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 4",
          "code": "bool check(int l)   {      for(int x=a;x<=b-l+1;x++)           { if(prime[x+l-1]-prime[x-1]<k)             return false;         }           return true;    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 5",
          "code": "#define MAX 11111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 6",
          "code": "#define MAX 111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int h_prev = -1, m_prev = -1;\n    for (int i = 1; i <= n; i++) {\n        int hi = inf.readInt(0, 23, \"hi\");\n        inf.readSpace();\n        int mi = inf.readInt(0, 59, \"mi\");\n        inf.readEoln();\n        if (i > 1) {\n            int prev_time = h_prev * 60 + m_prev;\n            int current_time = hi * 60 + mi;\n            ensuref(prev_time <= current_time, \"Time not non-decreasing at entry %d: previous time %02d:%02d, current time %02d:%02d\", i, h_prev, m_prev, hi, mi);\n        }\n        h_prev = hi;\n        m_prev = mi;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int h_prev = -1, m_prev = -1;\n    for (int i = 1; i <= n; i++) {\n        int hi = inf.readInt(0, 23, \"hi\");\n        inf.readSpace();\n        int mi = inf.readInt(0, 59, \"mi\");\n        inf.readEoln();\n        if (i > 1) {\n            int prev_time = h_prev * 60 + m_prev;\n            int current_time = hi * 60 + mi;\n            ensuref(prev_time <= current_time, \"Time not non-decreasing at entry %d: previous time %02d:%02d, current time %02d:%02d\", i, h_prev, m_prev, hi, mi);\n        }\n        h_prev = hi;\n        m_prev = mi;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int h_prev = -1, m_prev = -1;\n    for (int i = 1; i <= n; i++) {\n        int hi = inf.readInt(0, 23, \"hi\");\n        inf.readSpace();\n        int mi = inf.readInt(0, 59, \"mi\");\n        inf.readEoln();\n        if (i > 1) {\n            int prev_time = h_prev * 60 + m_prev;\n            int current_time = hi * 60 + mi;\n            ensuref(prev_time <= current_time, \"Time not non-decreasing at entry %d: previous time %02d:%02d, current time %02d:%02d\", i, h_prev, m_prev, hi, mi);\n        }\n        h_prev = hi;\n        m_prev = mi;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<int, int>> times(n);\n    if (type == \"same_time\") {\n        // All customers come at the same time\n        int h = rnd.next(0,23);\n        int m = rnd.next(0,59);\n        for(int i = 0; i < n; ++i) {\n            times[i] = make_pair(h, m);\n        }\n    } else if (type == \"increasing\") {\n        // Customers come at increasing times, spread as evenly as possible\n        int total_minutes = 24*60 - 1; // from 0 to 1439 minutes\n        for (int i = 0; i < n; ++i) {\n            int minutes = (long long)i * total_minutes / n;\n            int h = minutes / 60;\n            int m = minutes % 60;\n            times[i] = make_pair(h, m);\n        }\n    } else if (type == \"max_overlap\") {\n        // All customers arrive at the same time\n        int h = rnd.next(0, 23);\n        int m = rnd.next(0, 59);\n        for (int i = 0; i < n; ++i) {\n            times[i] = make_pair(h, m);\n        }\n    } else if (type == \"min_overlap\") {\n        // Customers arrive at different times if possible\n        int total_minutes = 24*60; // 1440 minutes\n        if (n <= total_minutes) {\n            vector<int> minutes_list(total_minutes);\n            for (int i = 0; i < total_minutes; ++i) {\n                minutes_list[i] = i;\n            }\n            shuffle(minutes_list.begin(), minutes_list.end());\n            minutes_list.resize(n);\n            sort(minutes_list.begin(), minutes_list.end());\n            for (int i = 0; i < n; ++i) {\n                int minutes = minutes_list[i];\n                int h = minutes / 60;\n                int m = minutes % 60;\n                times[i] = make_pair(h, m);\n            }\n        } else {\n            // Cannot assign unique times, assign random times\n            for (int i = 0; i < n; ++i) {\n                int minutes = rnd.next(0, total_minutes -1);\n                int h = minutes / 60;\n                int m = minutes % 60;\n                times[i] = make_pair(h, m);\n            }\n            sort(times.begin(), times.end());\n        }\n    } else if (type == \"batches\") {\n        int batch_size = opt<int>(\"batch_size\", 1000);\n        vector<pair<int, int>> batch_times;\n        int num_batches = (n + batch_size -1) / batch_size;\n        int total_minutes = 24*60 - 1; // from 0 to 1439 minutes\n        for (int i = 0; i < num_batches; ++i) {\n            int minutes = (long long)i * total_minutes / num_batches;\n            int h = minutes / 60;\n            int m = minutes % 60;\n            for (int j = 0; j < batch_size && batch_times.size() < n; ++j) {\n                batch_times.push_back(make_pair(h, m));\n            }\n        }\n        times = batch_times;\n        sort(times.begin(), times.end());\n    } else if (type == \"edge_times\") {\n        // Customers arriving at edge times\n        for (int i = 0; i < n; ++i) {\n            int h, m;\n            if (i % 2 == 0) {\n                h = 0;\n                m = 0;\n            } else {\n                h = 23;\n                m = 59;\n            }\n            times[i] = make_pair(h, m);\n        }\n        sort(times.begin(), times.end());\n    } else { // default or \"random\"\n        // Generate random times and sort them\n        for (int i = 0; i < n; ++i) {\n            int h = rnd.next(0, 23);\n            int m = rnd.next(0, 59);\n            times[i] = make_pair(h, m);\n        }\n        sort(times.begin(), times.end());\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output times\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", times[i].first, times[i].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<int, int>> times(n);\n    if (type == \"same_time\") {\n        // All customers come at the same time\n        int h = rnd.next(0,23);\n        int m = rnd.next(0,59);\n        for(int i = 0; i < n; ++i) {\n            times[i] = make_pair(h, m);\n        }\n    } else if (type == \"increasing\") {\n        // Customers come at increasing times, spread as evenly as possible\n        int total_minutes = 24*60 - 1; // from 0 to 1439 minutes\n        for (int i = 0; i < n; ++i) {\n            int minutes = (long long)i * total_minutes / n;\n            int h = minutes / 60;\n            int m = minutes % 60;\n            times[i] = make_pair(h, m);\n        }\n    } else if (type == \"max_overlap\") {\n        // All customers arrive at the same time\n        int h = rnd.next(0, 23);\n        int m = rnd.next(0, 59);\n        for (int i = 0; i < n; ++i) {\n            times[i] = make_pair(h, m);\n        }\n    } else if (type == \"min_overlap\") {\n        // Customers arrive at different times if possible\n        int total_minutes = 24*60; // 1440 minutes\n        if (n <= total_minutes) {\n            vector<int> minutes_list(total_minutes);\n            for (int i = 0; i < total_minutes; ++i) {\n                minutes_list[i] = i;\n            }\n            shuffle(minutes_list.begin(), minutes_list.end());\n            minutes_list.resize(n);\n            sort(minutes_list.begin(), minutes_list.end());\n            for (int i = 0; i < n; ++i) {\n                int minutes = minutes_list[i];\n                int h = minutes / 60;\n                int m = minutes % 60;\n                times[i] = make_pair(h, m);\n            }\n        } else {\n            // Cannot assign unique times, assign random times\n            for (int i = 0; i < n; ++i) {\n                int minutes = rnd.next(0, total_minutes -1);\n                int h = minutes / 60;\n                int m = minutes % 60;\n                times[i] = make_pair(h, m);\n            }\n            sort(times.begin(), times.end());\n        }\n    } else if (type == \"batches\") {\n        int batch_size = opt<int>(\"batch_size\", 1000);\n        vector<pair<int, int>> batch_times;\n        int num_batches = (n + batch_size -1) / batch_size;\n        int total_minutes = 24*60 - 1; // from 0 to 1439 minutes\n        for (int i = 0; i < num_batches; ++i) {\n            int minutes = (long long)i * total_minutes / num_batches;\n            int h = minutes / 60;\n            int m = minutes % 60;\n            for (int j = 0; j < batch_size && batch_times.size() < n; ++j) {\n                batch_times.push_back(make_pair(h, m));\n            }\n        }\n        times = batch_times;\n        sort(times.begin(), times.end());\n    } else if (type == \"edge_times\") {\n        // Customers arriving at edge times\n        for (int i = 0; i < n; ++i) {\n            int h, m;\n            if (i % 2 == 0) {\n                h = 0;\n                m = 0;\n            } else {\n                h = 23;\n                m = 59;\n            }\n            times[i] = make_pair(h, m);\n        }\n        sort(times.begin(), times.end());\n    } else { // default or \"random\"\n        // Generate random times and sort them\n        for (int i = 0; i < n; ++i) {\n            int h = rnd.next(0, 23);\n            int m = rnd.next(0, 59);\n            times[i] = make_pair(h, m);\n        }\n        sort(times.begin(), times.end());\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output times\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", times[i].first, times[i].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -type random\n./gen -n 4 -type same_time\n./gen -n 4 -type increasing\n./gen -n 4 -type min_overlap\n./gen -n 4 -type max_overlap\n./gen -n 4 -type edge_times\n./gen -n 4 -type batches -batch_size 2\n\n./gen -n 10 -type random\n./gen -n 10 -type same_time\n./gen -n 10 -type increasing\n./gen -n 10 -type min_overlap\n./gen -n 10 -type max_overlap\n./gen -n 10 -type edge_times\n./gen -n 10 -type batches -batch_size 5\n\n./gen -n 1000 -type random\n./gen -n 1000 -type same_time\n./gen -n 1000 -type increasing\n./gen -n 1000 -type min_overlap\n./gen -n 1000 -type max_overlap\n./gen -n 1000 -type edge_times\n./gen -n 1000 -type batches -batch_size 100\n\n./gen -n 100000 -type random\n./gen -n 100000 -type same_time\n./gen -n 100000 -type increasing\n./gen -n 100000 -type min_overlap\n./gen -n 100000 -type max_overlap\n./gen -n 100000 -type edge_times\n./gen -n 100000 -type batches -batch_size 10000\n\n# Additional random test cases\n./gen -n 100000 -type random\n./gen -n 100000 -type random\n./gen -n 100000 -type random\n\n# Edge cases\n./gen -n 1440 -type min_overlap\n\n./gen -n 1440 -type increasing\n\n./gen -n 1 -type random\n\n./gen -n 1 -type same_time\n\n./gen -n 100000 -type batches -batch_size 1  # Equivalent to increasing\n\n./gen -n 100000 -type batches -batch_size 100\n\n./gen -n 100000 -type batches -batch_size 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:47.566570",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "237/B",
      "title": "B. Таблица Юнга",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 50), обозначающее количество строк в таблице. Во второй строке через пробел записаны n целых чисел ci (1 ≤ ci ≤ 50; ci ≤ ci - 1) — количества клеточек в соответствующих строках.В следующих n строках задана таблица а. В i-той из них через пробел записаны ci целых чисел: j-тое число в этой строке обозначает ai, j.Гарантируется, что все заданные числа ai, j положительны и не превосходят s. Гарантируется, что все ai, j различны.",
      "output_spec": "Выходные данныеВ первой строке выведите единственное целое число m (0 ≤ m ≤ s), обозначающее количество произведенных операций обмена.В следующих m строках выведите описание этих операций обмена. В i-той из них выведите через пробел четыре целых числа xi, yi, pi, qi (1 ≤ xi, pi ≤ n; 1 ≤ yi ≤ cxi; 1 ≤ qi ≤ cpi). Выведенные числа обозначают операцию обмена содержимого клеток axi, yi и api, qi. Обратите внимание, что операцией обмена можно менять содержимое различных клеток таблицы. Выводите обмены в том порядке, в котором они должны производиться.",
      "sample_tests": "ПримерыВходные данныеСкопировать33 2 14 3 56 12Выходные данныеСкопировать21 1 2 22 1 3 1Входные данныеСкопировать144 3 2 1Выходные данныеСкопировать21 1 1 41 2 1 3",
      "description": "B. Таблица Юнга\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 50), обозначающее количество строк в таблице. Во второй строке через пробел записаны n целых чисел ci (1 ≤ ci ≤ 50; ci ≤ ci - 1) — количества клеточек в соответствующих строках.В следующих n строках задана таблица а. В i-той из них через пробел записаны ci целых чисел: j-тое число в этой строке обозначает ai, j.Гарантируется, что все заданные числа ai, j положительны и не превосходят s. Гарантируется, что все ai, j различны.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите единственное целое число m (0 ≤ m ≤ s), обозначающее количество произведенных операций обмена.В следующих m строках выведите описание этих операций обмена. В i-той из них выведите через пробел четыре целых числа xi, yi, pi, qi (1 ≤ xi, pi ≤ n; 1 ≤ yi ≤ cxi; 1 ≤ qi ≤ cpi). Выведенные числа обозначают операцию обмена содержимого клеток axi, yi и api, qi. Обратите внимание, что операцией обмена можно менять содержимое различных клеток таблицы. Выводите обмены в том порядке, в котором они должны производиться.\n\nВыходные данные\n\nВходные данныеСкопировать33 2 14 3 56 12Выходные данныеСкопировать21 1 2 22 1 3 1Входные данныеСкопировать144 3 2 1Выходные данныеСкопировать21 1 1 41 2 1 3\n\nВходные данныеСкопировать33 2 14 3 56 12\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21 1 2 22 1 3 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать144 3 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21 1 1 41 2 1 3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces",
          "content": "Доброе время суток!Через несколько часов начнется очередной Codeforces Round #147 для участников Div.2, но традиционно остальные могут поучаствовать вне конкурса. Он был подготовлен небольшой командой авторов: я (NALP), Игорь Кудряшов (Igor_Kudryashov), Павлик Холкин (HolkinPV), Геральд Агапов (Gerald), Мария Белова (Delinur) и Михаил Мирзаянов (MikeMirzayanov).Традиционно всем удачи, полных решений и удачных взломов!В раунде будет использована стандарная разбалловка: 500-1000-1500-2000-2500UPD: Соревнование завершено, поздравляем победителей: try_skycn AntiKismet dianbei_03 Uncia Bigsophie UPD: Разбор уже опубликован тут.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5640",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 630
        },
        {
          "title": "Codeforces Round #147 (Div. 2) Разбор Задач - Codeforces",
          "content": "Приветствую всех участников раунда!237A - Free CashИз условия задачи легко понять, что если в некоторую минуту придут k человек, то Валере нужно иметь в кафе не менее k касс. Значит, требуется найти максимальное количество людей, которые придут в одну и ту же минуту, а это делается очень просто множеством способов, например, просто насчитав в массив cnt[h][m] количество людей, которые придут в час h и минуту m, а потом найдя в этом массиве максимум.237B - Young TableРешение, которое опишем ниже, почти никак не использует хитрую форму таблицы (кстати, такая таблица называется диаграммой Юнга). Заполним таблицу числами от 1 до s следующим способом: будем идти по строкам таблицы начиная с первой слева направо, после конца текущей строки переходим на начало следующей, и в процессе каждой из клеточек присвоим число по порядку обхода от 1 до s. Очень просто показать, что такой порядок чисел удовлетворяет оба неравенства из условия.Теперь опишем алгоритм приведения таблицы из того вида, как она нам дана во входных данных, в описанный выше вид.Возьмем число 1 и посмотрим, где оно находится в этих двух таблицах. Если это число стоит не на своем месте, то поставим его на свое место, соответственно то число, которое там стояло, встанет на старое место единицы. Аналогично сделаем для 2, 3, ..., s. Очевидно, что этот алгоритм сделает не более s шагов и приведет таблицу в вид, описанный в первом абзаце.237C - Primes on IntervalДля начала с помощью решета Эратосфена выделим все простые числа от 1 до b и пометим их единичками в массиве d, то есть если p — простое, то d[p] = 1, иначе d[p] = 0.Заметим, что если l — корректное число, то l + 1 тоже корректно. В самом деле, для позиций x от a до b - l количество простых в отрезке с началом в x могло лишь увеличиться (мы же длину отрезка увеличили, а значит, количество простых в нем никак не могло уменьшиться). А кроме того исчез из рассмотрения один отрезок с началом в точке b - l + 1, так как при увеличении длины его правый конец стал больше, чем число b.Таким образом, мы показали, что функция f(l), возвращающая TRUE или FALSE (корректно число или нет) монотонна, а значит, мы можем с помощью бинарного поиска найти наименьшее l, для которого f(l) = TRUE, или ответить, что такого не существует.Функция f(l) считается очень просто — можно проитерироваться по всем числам от a до b - l + 1 и найти для каждого начала количество простых чисел в соответствующем отрезке длины l, это можно сделать с помощью частичных сумм, насчитанных по массиву d.237D - T-decompositionВозьмем любое ребро начального графа, очевидно два его конца принадлежат некоторому множеству xi, значит, вес любой его Д-декомпозиции как минимум 2. Покажем, как постороить декомпозицию именно такого веса. Для этого каждое из ребер исходного графа превратим в отдельное множество xi, то есть все они будут состоять из двух элементов.Очевидно, что первые два условия выполняются. Для выполнения третьего условия для начала соединим все множества по принципу: добавим ребро между двуми множествами, если их пересечение не пусто. Однако построенный таким образом граф не является деревом, покажем другой способ соединения вершин.Для того, чтобы сделать из него дерево, достаточно для каждой вершины v начального дерева выделить все xi, в которых она содержится, и соединить их в цепочку в любом порядке, добавив нужное количество ребер.Несложно понять, что такой граф не будет содержать циклов, будет связен, а значит является деревом. Постоенная Д-декомпозиция будет иметь вес 2, и количество вершин n - 1.237E - Build StringЭта задача несложно решается алгоритмом поиска максимального потока минимальной стоимости на трехслойном графе: первый слой состоит из n вершин, каждая из которых отвечает за свою строку из входных данных; в i-ую вершину этого слоя входит по одному ребру из истока с пропускной способностью ci и стоимостью i; второй стой состоит за 26·n вершин, каждая из которых отвечает за количество определенных букв в каждой из строк из входных данных; в вершины этого слоя входят ребра только из первого слоя стоимостью 0 и пропускной способностью равной количеству соответствующих букв в соответствующей строке; третий слой состоит из 26 вершин, каждая из которых отвечает за количество соответствующих букв в строке t; в вершины этого слоя входят ребра только из второго слоя стоимостью 0 и бесконечной пропускной способностью; кроме того, из вершин третьего слоя выходят ребра в сток стоимостью 0 и пропускной способностью, равной количеству соответствующих букв в строке t. Если максимальный поток в этой сети меньше, чем |t|, то ответ равен  - 1, а иначе — минимальной стоимости максимального потока.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5648",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 237\\s*B"
          },
          "content_length": 4653
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 1",
          "code": "Заплывший мужчина",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 2",
          "code": "for(int i = 0; i < n; i++)\n{\n\tчитаем строку, достраиваем граф;\n\tобычныйMaxFlow();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 3",
          "code": "for(int i = 0; i < n; i++)\n{\n\tчитаем строку, достраиваем граф;\n\tобычныйMaxFlow();\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 4",
          "code": "a\n2\na 1\na 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 5",
          "code": "a\n2\na 1\na 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 6",
          "code": "6\n2 2 1 1\n3 1 1 2\n1 2 1 3\n1 1 2 1\n1 3 2 2\n2 1 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 7",
          "code": "6\n2 2 1 1\n3 1 1 2\n1 2 1 3\n1 1 2 1\n1 3 2 2\n2 1 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 8",
          "code": "if (prevtime != newtime) {current_casses_needed++;}\nelse {if (current_casses_needed > max_casses_needed) ...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 9",
          "code": "if (prevtime != newtime) {current_casses_needed++;}\nelse {if (current_casses_needed > max_casses_needed) ...}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 10",
          "code": "Test: #11, время: 62 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n10\n1 30\n1 30\n1 30\n1 30\n1 30\n1 30\n1 30\n1 30\n1 30\n1 30\nВывод\n10\nОтвет\n10\nПротокол тестирования\nok 1 number(s): \"10\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 11",
          "code": "Test: #11, время: 62 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n10\n1 30\n1 30\n1 30\n1 30\n1 30\n1 30\n1 30\n1 30\n1 30\n1 30\nВывод\n10\nОтвет\n10\nПротокол тестирования\nok 1 number(s): \"10\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 12",
          "code": "co place[mo];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 13",
          "code": "bool check(int l)   {      for(int x=a;x<=b-l+1;x++)           { if(prime[x+l-1]-prime[x-1]<k)             return false;         }           return true;    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 14",
          "code": "#define MAX 11111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 15",
          "code": "#define MAX 111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) Разбор Задач - Codeforces - Code 1",
          "code": "var  n,k,i:longint; h,m: array [1..50] of byte;\n...\nfor i:=1 to n do begin\nreadln(h[i],m[i]);",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/5648",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) Разбор Задач - Codeforces - Code 2",
          "code": "var  n,k,i:longint; h,m: array [1..50] of byte;\n...\nfor i:=1 to n do begin\nreadln(h[i],m[i]);",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/5648",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 50, \"c\");\n    inf.readEoln();\n    for (int i = 1; i < n; i++) {\n        ensuref(c[i] <= c[i - 1], \"c[%d]=%d is greater than c[%d]=%d\", i + 1, c[i], i, c[i - 1]);\n    }\n    int s = 0;\n    for (int i = 0; i < n; i++) {\n        s += c[i];\n    }\n    set<int> seen;\n    for (int i = 0; i < n; i++) {\n        vector<int> a = inf.readInts(c[i], 1, s, \"a_i\");\n        inf.readEoln();\n        for (int val : a) {\n            ensuref(seen.count(val) == 0, \"Number %d appears multiple times\", val);\n            seen.insert(val);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 50, \"c\");\n    inf.readEoln();\n    for (int i = 1; i < n; i++) {\n        ensuref(c[i] <= c[i - 1], \"c[%d]=%d is greater than c[%d]=%d\", i + 1, c[i], i, c[i - 1]);\n    }\n    int s = 0;\n    for (int i = 0; i < n; i++) {\n        s += c[i];\n    }\n    set<int> seen;\n    for (int i = 0; i < n; i++) {\n        vector<int> a = inf.readInts(c[i], 1, s, \"a_i\");\n        inf.readEoln();\n        for (int val : a) {\n            ensuref(seen.count(val) == 0, \"Number %d appears multiple times\", val);\n            seen.insert(val);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 50, \"c\");\n    inf.readEoln();\n    for (int i = 1; i < n; i++) {\n        ensuref(c[i] <= c[i - 1], \"c[%d]=%d is greater than c[%d]=%d\", i + 1, c[i], i, c[i - 1]);\n    }\n    int s = 0;\n    for (int i = 0; i < n; i++) {\n        s += c[i];\n    }\n    set<int> seen;\n    for (int i = 0; i < n; i++) {\n        vector<int> a = inf.readInts(c[i], 1, s, \"a_i\");\n        inf.readEoln();\n        for (int val : a) {\n            ensuref(seen.count(val) == 0, \"Number %d appears multiple times\", val);\n            seen.insert(val);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    vector<int> c(n);\n    int total_cells = 0;\n    for (int i = 0; i < n; ++i) {\n        c[i] = inf.readInt(1, 50, format(\"c[%d]\", i+1).c_str());\n        if (i > 0 && c[i] > c[i-1]) {\n            quitf(_fail, \"Invalid input: c[%d]=%d > c[%d]=%d\", i+1, c[i], i, c[i-1]);\n        }\n        total_cells += c[i];\n    }\n    vector<vector<int> > table(n);\n    set<int> numbers_in_table;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < c[i]; ++j) {\n            int val = inf.readInt(1, total_cells, format(\"a[%d][%d]\", i+1, j+1).c_str());\n            if (numbers_in_table.count(val)) {\n                quitf(_fail, \"Invalid input: number %d occurs more than once\", val);\n            }\n            numbers_in_table.insert(val);\n            table[i].push_back(val);\n        }\n    }\n    if ((int)numbers_in_table.size() != total_cells) {\n        quitf(_fail, \"Invalid input: total unique numbers %d != s=%d\", (int)numbers_in_table.size(), total_cells);\n    }\n    int m = ouf.readInt(0, total_cells, \"m\");\n    for (int k = 0; k < m; ++k) {\n        int xi = ouf.readInt(1, n, format(\"xi[%d]\", k+1).c_str());\n        int yi = ouf.readInt(1, c[xi-1], format(\"yi[%d]\", k+1).c_str());\n        int pi = ouf.readInt(1, n, format(\"pi[%d]\", k+1).c_str());\n        int qi = ouf.readInt(1, c[pi-1], format(\"qi[%d]\", k+1).c_str());\n        swap(table[xi-1][yi-1], table[pi-1][qi-1]);\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < c[i]; ++j) {\n            if (table[i][j] <= table[i-1][j]) {\n                quitf(_wa, \"Condition 1 failed at position (%d,%d): %d <= %d\", i+1, j+1, table[i][j], table[i-1][j]);\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 1; j < c[i]; ++j) {\n            if (table[i][j] <= table[i][j-1]) {\n                quitf(_wa, \"Condition 2 failed at position (%d,%d): %d <= %d\", i+1, j+1, table[i][j], table[i][j-1]);\n            }\n        }\n    }\n    quitf(_ok, \"Accepted\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string c_type = opt<string>(\"c_type\", \"decreasing\");\n    int ci_value = opt<int>(\"ci_value\", 10); // default value\n    int ci_delta = opt<int>(\"ci_delta\", 1);\n    string initial_type = opt<string>(\"initial_type\", \"random\");\n    \n    vector<int> ci(n);\n    \n    if (c_type == \"constant\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = ci_value;\n        }\n    } else if (c_type == \"decreasing\") {\n        ci[0] = ci_value;\n        for (int i = 1; i < n; ++i) {\n            ci[i] = max(1, ci[i-1] - ci_delta);\n        }\n    } else if (c_type == \"random\") {\n        ci[0] = rnd.next(1, ci_value);\n        for (int i = 1; i < n; ++i) {\n            ci[i] = rnd.next(1, ci[i-1]); // ci[i] ≤ ci[i-1]\n        }\n    } else {\n        ensuref(false, \"Unknown c_type: %s\", c_type.c_str());\n    }\n    \n    int s = 0;\n    for (int i = 0; i < n; ++i) {\n        s += ci[i];\n    }\n    \n    vector<int> nums(s);\n    for (int i = 0; i < s; ++i) {\n        nums[i] = i + 1;\n    }\n    \n    vector<vector<int>> a(n);\n    \n    if (initial_type == \"sorted\") {\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i].resize(ci[i]);\n            for (int j = 0; j < ci[i]; ++j) {\n                a[i][j] = nums[idx++];\n            }\n        }\n    } else if (initial_type == \"reverse\") {\n        reverse(nums.begin(), nums.end());\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i].resize(ci[i]);\n            for (int j = 0; j < ci[i]; ++j) {\n                a[i][j] = nums[idx++];\n            }\n        }\n    } else if (initial_type == \"random\") {\n        shuffle(nums.begin(), nums.end());\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i].resize(ci[i]);\n            for (int j = 0; j < ci[i]; ++j) {\n                a[i][j] = nums[idx++];\n            }\n        }\n    } else if (initial_type == \"correct\") {\n        int value = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i].resize(ci[i]);\n            for (int j = 0; j < ci[i]; ++j) {\n                int max_previous = 0;\n                if (i > 0 && j < ci[i-1]) max_previous = max(max_previous, a[i-1][j]);\n                if (j > 0) max_previous = max(max_previous, a[i][j-1]);\n                a[i][j] = max_previous + 1;\n                value = a[i][j] + 1;\n            }\n        }\n    } else if (initial_type == \"worst\") {\n        reverse(nums.begin(), nums.end());\n        int idx = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            a[i].resize(ci[i]);\n            for (int j = ci[i] - 1; j >= 0; --j) {\n                a[i][j] = nums[idx++];\n            }\n        }\n    } else {\n        ensuref(false, \"Unknown initial_type: %s\", initial_type.c_str());\n    }\n    \n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ci[i], (i == n - 1 ? '\\n' : ' '));\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < ci[i]; ++j) {\n            printf(\"%d%c\", a[i][j], (j == ci[i] - 1 ? '\\n' : ' '));\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string c_type = opt<string>(\"c_type\", \"decreasing\");\n    int ci_value = opt<int>(\"ci_value\", 10); // default value\n    int ci_delta = opt<int>(\"ci_delta\", 1);\n    string initial_type = opt<string>(\"initial_type\", \"random\");\n    \n    vector<int> ci(n);\n    \n    if (c_type == \"constant\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = ci_value;\n        }\n    } else if (c_type == \"decreasing\") {\n        ci[0] = ci_value;\n        for (int i = 1; i < n; ++i) {\n            ci[i] = max(1, ci[i-1] - ci_delta);\n        }\n    } else if (c_type == \"random\") {\n        ci[0] = rnd.next(1, ci_value);\n        for (int i = 1; i < n; ++i) {\n            ci[i] = rnd.next(1, ci[i-1]); // ci[i] ≤ ci[i-1]\n        }\n    } else {\n        ensuref(false, \"Unknown c_type: %s\", c_type.c_str());\n    }\n    \n    int s = 0;\n    for (int i = 0; i < n; ++i) {\n        s += ci[i];\n    }\n    \n    vector<int> nums(s);\n    for (int i = 0; i < s; ++i) {\n        nums[i] = i + 1;\n    }\n    \n    vector<vector<int>> a(n);\n    \n    if (initial_type == \"sorted\") {\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i].resize(ci[i]);\n            for (int j = 0; j < ci[i]; ++j) {\n                a[i][j] = nums[idx++];\n            }\n        }\n    } else if (initial_type == \"reverse\") {\n        reverse(nums.begin(), nums.end());\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i].resize(ci[i]);\n            for (int j = 0; j < ci[i]; ++j) {\n                a[i][j] = nums[idx++];\n            }\n        }\n    } else if (initial_type == \"random\") {\n        shuffle(nums.begin(), nums.end());\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i].resize(ci[i]);\n            for (int j = 0; j < ci[i]; ++j) {\n                a[i][j] = nums[idx++];\n            }\n        }\n    } else if (initial_type == \"correct\") {\n        int value = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i].resize(ci[i]);\n            for (int j = 0; j < ci[i]; ++j) {\n                int max_previous = 0;\n                if (i > 0 && j < ci[i-1]) max_previous = max(max_previous, a[i-1][j]);\n                if (j > 0) max_previous = max(max_previous, a[i][j-1]);\n                a[i][j] = max_previous + 1;\n                value = a[i][j] + 1;\n            }\n        }\n    } else if (initial_type == \"worst\") {\n        reverse(nums.begin(), nums.end());\n        int idx = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            a[i].resize(ci[i]);\n            for (int j = ci[i] - 1; j >= 0; --j) {\n                a[i][j] = nums[idx++];\n            }\n        }\n    } else {\n        ensuref(false, \"Unknown initial_type: %s\", initial_type.c_str());\n    }\n    \n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ci[i], (i == n - 1 ? '\\n' : ' '));\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < ci[i]; ++j) {\n            printf(\"%d%c\", a[i][j], (j == ci[i] - 1 ? '\\n' : ' '));\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -ci_value 1 -c_type constant -initial_type correct\n./gen -n 1 -ci_value 50 -c_type constant -initial_type correct\n./gen -n 50 -ci_value 1 -c_type constant -initial_type correct\n./gen -n 50 -ci_value 50 -c_type constant -initial_type correct\n./gen -n 50 -ci_value 50 -c_type decreasing -ci_delta 1 -initial_type correct\n./gen -n 50 -ci_value 50 -c_type decreasing -ci_delta 0 -initial_type correct\n./gen -n 50 -ci_value 50 -c_type decreasing -ci_delta 2 -initial_type correct\n./gen -n 50 -ci_value 50 -c_type random -initial_type random\n./gen -n 50 -ci_value 50 -c_type random -initial_type reverse\n./gen -n 50 -ci_value 50 -c_type random -initial_type worst\n./gen -n 50 -ci_value 50 -c_type decreasing -ci_delta 1 -initial_type worst\n./gen -n 50 -ci_value 50 -c_type constant -initial_type random\n./gen -n 50 -ci_value 50 -c_type constant -initial_type reverse\n./gen -n 50 -ci_value 50 -c_type constant -initial_type worst\n./gen -n 50 -ci_value 25 -c_type constant -initial_type random\n./gen -n 50 -ci_value 1 -c_type constant -initial_type random\n./gen -n 50 -ci_value 50 -c_type decreasing -ci_delta 1 -initial_type random\n./gen -n 25 -ci_value 25 -c_type decreasing -ci_delta 1 -initial_type random\n./gen -n 25 -ci_value 25 -c_type decreasing -ci_delta 2 -initial_type random\n./gen -n 25 -ci_value 25 -c_type decreasing -ci_delta 1 -initial_type reverse\n./gen -n 10 -ci_value 10 -c_type random -initial_type random\n./gen -n 10 -ci_value 10 -c_type random -initial_type reverse\n./gen -n 10 -ci_value 10 -c_type random -initial_type worst\n./gen -n 5 -ci_value 5 -c_type decreasing -ci_delta 1 -initial_type worst\n./gen -n 5 -ci_value 5 -c_type constant -initial_type random\n./gen -n 5 -ci_value 5 -c_type constant -initial_type reverse\n./gen -n 1 -ci_value 50 -c_type constant -initial_type worst\n./gen -n 1 -ci_value 50 -c_type constant -initial_type random\n./gen -n 1 -ci_value 50 -c_type constant -initial_type reverse\n./gen -n 50 -ci_value 1 -c_type constant -initial_type worst\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:49.316812",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "237/C",
      "title": "C. Primes on Interval",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains three space-separated integers a, b, k (1 ≤ a, b, k ≤ 106; a ≤ b).",
      "output_spec": "OutputIn a single line print a single integer — the required minimum l. If there's no solution, print -1.",
      "sample_tests": "ExamplesInputCopy2 4 2OutputCopy3InputCopy6 13 1OutputCopy4InputCopy1 4 3OutputCopy-1",
      "description": "C. Primes on Interval\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains three space-separated integers a, b, k (1 ≤ a, b, k ≤ 106; a ≤ b).\n\nOutputIn a single line print a single integer — the required minimum l. If there's no solution, print -1.\n\nInputCopy2 4 2OutputCopy3InputCopy6 13 1OutputCopy4InputCopy1 4 3OutputCopy-1\n\nInputCopy2 4 2\n\nOutputCopy3\n\nInputCopy6 13 1\n\nOutputCopy4\n\nInputCopy1 4 3\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces",
          "content": "Hi!A few hours later you're lucky to participate in Codeforces Round #147 for Div.2 participants, but traditionally the others can take part out of the competition. It has been prepared by me (NALP), Igor Kudryashov (Igor_Kudryashov), Pavlik Holkin (HolkinPV), Gerald Agapov (Gerald), Mary Belova (Delinur) and Mike Mirzayanov (MikeMirzayanov).Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!The standart scoring system will be used: 500-1000-1500-2000-2500UPD: The contest has ended, congratulations to the winners: try_skycn AntiKismet dianbei_03 Uncia Bigsophie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5640",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 607
        },
        {
          "title": "Codeforces Round #147 (Div. 2) Разбор Задач - Codeforces",
          "content": "Приветствую всех участников раунда!237A - Free CashИз условия задачи легко понять, что если в некоторую минуту придут k человек, то Валере нужно иметь в кафе не менее k касс. Значит, требуется найти максимальное количество людей, которые придут в одну и ту же минуту, а это делается очень просто множеством способов, например, просто насчитав в массив cnt[h][m] количество людей, которые придут в час h и минуту m, а потом найдя в этом массиве максимум.237B - Young TableРешение, которое опишем ниже, почти никак не использует хитрую форму таблицы (кстати, такая таблица называется диаграммой Юнга). Заполним таблицу числами от 1 до s следующим способом: будем идти по строкам таблицы начиная с первой слева направо, после конца текущей строки переходим на начало следующей, и в процессе каждой из клеточек присвоим число по порядку обхода от 1 до s. Очень просто показать, что такой порядок чисел удовлетворяет оба неравенства из условия.Теперь опишем алгоритм приведения таблицы из того вида, как она нам дана во входных данных, в описанный выше вид.Возьмем число 1 и посмотрим, где оно находится в этих двух таблицах. Если это число стоит не на своем месте, то поставим его на свое место, соответственно то число, которое там стояло, встанет на старое место единицы. Аналогично сделаем для 2, 3, ..., s. Очевидно, что этот алгоритм сделает не более s шагов и приведет таблицу в вид, описанный в первом абзаце.237C - Primes on IntervalДля начала с помощью решета Эратосфена выделим все простые числа от 1 до b и пометим их единичками в массиве d, то есть если p — простое, то d[p] = 1, иначе d[p] = 0.Заметим, что если l — корректное число, то l + 1 тоже корректно. В самом деле, для позиций x от a до b - l количество простых в отрезке с началом в x могло лишь увеличиться (мы же длину отрезка увеличили, а значит, количество простых в нем никак не могло уменьшиться). А кроме того исчез из рассмотрения один отрезок с началом в точке b - l + 1, так как при увеличении длины его правый конец стал больше, чем число b.Таким образом, мы показали, что функция f(l), возвращающая TRUE или FALSE (корректно число или нет) монотонна, а значит, мы можем с помощью бинарного поиска найти наименьшее l, для которого f(l) = TRUE, или ответить, что такого не существует.Функция f(l) считается очень просто — можно проитерироваться по всем числам от a до b - l + 1 и найти для каждого начала количество простых чисел в соответствующем отрезке длины l, это можно сделать с помощью частичных сумм, насчитанных по массиву d.237D - T-decompositionВозьмем любое ребро начального графа, очевидно два его конца принадлежат некоторому множеству xi, значит, вес любой его Д-декомпозиции как минимум 2. Покажем, как постороить декомпозицию именно такого веса. Для этого каждое из ребер исходного графа превратим в отдельное множество xi, то есть все они будут состоять из двух элементов.Очевидно, что первые два условия выполняются. Для выполнения третьего условия для начала соединим все множества по принципу: добавим ребро между двуми множествами, если их пересечение не пусто. Однако построенный таким образом граф не является деревом, покажем другой способ соединения вершин.Для того, чтобы сделать из него дерево, достаточно для каждой вершины v начального дерева выделить все xi, в которых она содержится, и соединить их в цепочку в любом порядке, добавив нужное количество ребер.Несложно понять, что такой граф не будет содержать циклов, будет связен, а значит является деревом. Постоенная Д-декомпозиция будет иметь вес 2, и количество вершин n - 1.237E - Build StringЭта задача несложно решается алгоритмом поиска максимального потока минимальной стоимости на трехслойном графе: первый слой состоит из n вершин, каждая из которых отвечает за свою строку из входных данных; в i-ую вершину этого слоя входит по одному ребру из истока с пропускной способностью ci и стоимостью i; второй стой состоит за 26·n вершин, каждая из которых отвечает за количество определенных букв в каждой из строк из входных данных; в вершины этого слоя входят ребра только из первого слоя стоимостью 0 и пропускной способностью равной количеству соответствующих букв в соответствующей строке; третий слой состоит из 26 вершин, каждая из которых отвечает за количество соответствующих букв в строке t; в вершины этого слоя входят ребра только из второго слоя стоимостью 0 и бесконечной пропускной способностью; кроме того, из вершин третьего слоя выходят ребра в сток стоимостью 0 и пропускной способностью, равной количеству соответствующих букв в строке t. Если максимальный поток в этой сети меньше, чем |t|, то ответ равен  - 1, а иначе — минимальной стоимости максимального потока.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5648",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 237\\s*C"
          },
          "content_length": 4653
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 1",
          "code": "6\n2 2 1 1\n3 1 1 2\n1 2 1 3\n1 1 2 1\n1 3 2 2\n2 1 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 2",
          "code": "6\n2 2 1 1\n3 1 1 2\n1 2 1 3\n1 1 2 1\n1 3 2 2\n2 1 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 3",
          "code": "co place[mo];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 4",
          "code": "bool check(int l)   {      for(int x=a;x<=b-l+1;x++)           { if(prime[x+l-1]-prime[x-1]<k)             return false;         }           return true;    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 5",
          "code": "#define MAX 11111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 6",
          "code": "#define MAX 111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    ensuref(a <= b, \"a should be less than or equal to b, but a=%d, b=%d\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    ensuref(a <= b, \"a should be less than or equal to b, but a=%d, b=%d\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    ensuref(a <= b, \"a should be less than or equal to b, but a=%d, b=%d\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000000;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for(int i=3; i*i<=n; i+=2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Generate primes up to MAX_N\nvector<bool> sieve(MAX_N+1,false);\nvoid generate_sieve() {\n    fill(sieve.begin(), sieve.end(), true);\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i<=MAX_N; ++i)\n        if(sieve[i])\n            for(int j=2*i; j<=MAX_N; j+=i)\n                sieve[j] = false;\n}\n\nint count_primes(int a, int b) {\n    int cnt = 0;\n    for(int i=a; i<=b; ++i)\n        if(sieve[i]) cnt++;\n    return cnt;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    generate_sieve();\n\n    int a = opt<int>(\"a\", 1);\n    int b = opt<int>(\"b\", MAX_N);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"normal\");\n\n    if(type == \"no_solution\") {\n        // Set k to be larger than number of primes in [a,b]\n        int num_primes = count_primes(a,b);\n        k = num_primes + 1;\n    } else if(type == \"max_k\") {\n        // Set k to be the number of primes in [a,b]\n        int num_primes = count_primes(a,b);\n        k = num_primes;\n    } else if(type == \"over_k\") {\n        // Set k to be greater than number of primes in minimal window\n        int min_l = b - a + 1;\n        for (int l = 1; l <= b - a + 1; l++) {\n            bool exists = false;\n            int x = a;\n            while(x <= b - l + 1) {\n                int primes_in_window = 0;\n                for(int i = x; i < x + l; i++) {\n                    if(sieve[i]) primes_in_window++;\n                }\n                if(primes_in_window >= k) {\n                    exists = true;\n                    break;\n                }\n                x++;\n            }\n            if (!exists) {\n                min_l = l;\n                break;\n            }\n        }\n        int num_primes_in_min_window = k - 1;\n        k = num_primes_in_min_window + 1;\n    } else if(type == \"random\") {\n        // Do nothing, use provided a, b, k\n    }\n\n    // Ensure that a, b, k satisfy constraints\n    if(a < 1) a = 1;\n    if(b > MAX_N) b = MAX_N;\n    if(k < 1) k = 1;\n    if(k > b - a + 1) k = b - a + 1;\n    if(a > b) swap(a, b);\n\n    printf(\"%d %d %d\\n\", a, b, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000000;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for(int i=3; i*i<=n; i+=2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Generate primes up to MAX_N\nvector<bool> sieve(MAX_N+1,false);\nvoid generate_sieve() {\n    fill(sieve.begin(), sieve.end(), true);\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i<=MAX_N; ++i)\n        if(sieve[i])\n            for(int j=2*i; j<=MAX_N; j+=i)\n                sieve[j] = false;\n}\n\nint count_primes(int a, int b) {\n    int cnt = 0;\n    for(int i=a; i<=b; ++i)\n        if(sieve[i]) cnt++;\n    return cnt;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    generate_sieve();\n\n    int a = opt<int>(\"a\", 1);\n    int b = opt<int>(\"b\", MAX_N);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"normal\");\n\n    if(type == \"no_solution\") {\n        // Set k to be larger than number of primes in [a,b]\n        int num_primes = count_primes(a,b);\n        k = num_primes + 1;\n    } else if(type == \"max_k\") {\n        // Set k to be the number of primes in [a,b]\n        int num_primes = count_primes(a,b);\n        k = num_primes;\n    } else if(type == \"over_k\") {\n        // Set k to be greater than number of primes in minimal window\n        int min_l = b - a + 1;\n        for (int l = 1; l <= b - a + 1; l++) {\n            bool exists = false;\n            int x = a;\n            while(x <= b - l + 1) {\n                int primes_in_window = 0;\n                for(int i = x; i < x + l; i++) {\n                    if(sieve[i]) primes_in_window++;\n                }\n                if(primes_in_window >= k) {\n                    exists = true;\n                    break;\n                }\n                x++;\n            }\n            if (!exists) {\n                min_l = l;\n                break;\n            }\n        }\n        int num_primes_in_min_window = k - 1;\n        k = num_primes_in_min_window + 1;\n    } else if(type == \"random\") {\n        // Do nothing, use provided a, b, k\n    }\n\n    // Ensure that a, b, k satisfy constraints\n    if(a < 1) a = 1;\n    if(b > MAX_N) b = MAX_N;\n    if(k < 1) k = 1;\n    if(k > b - a + 1) k = b - a + 1;\n    if(a > b) swap(a, b);\n\n    printf(\"%d %d %d\\n\", a, b, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -a 1 -b 10 -k 1 -type normal\n./gen -a 1 -b 10 -k 5 -type no_solution\n./gen -a 1 -b 100 -k 25 -type max_k\n./gen -a 1 -b 1000000 -k 78498 -type max_k\n./gen -type small_range\n./gen -type max_range\n./gen -type all_primes\n./gen -type all_composites\n./gen -type random\n./gen -a 1 -b 1 -k 1 -type normal\n./gen -a 1 -b 1 -k 2 -type no_solution\n./gen -a 2 -b 2 -k 1 -type normal\n./gen -a 2 -b 2 -k 1 -type no_solution\n./gen -a 999983 -b 1000000 -k 1 -type normal\n./gen -a 999983 -b 1000000 -k 2 -type no_solution\n./gen -a 2 -b 100 -k 25 -type over_k\n./gen -a 1 -b 100 -k 30 -type over_k\n./gen -a 1000 -b 2000 -k 135 -type max_k\n./gen -a 1 -b 1000 -k 168 -type max_k\n./gen -a 24 -b 28 -k 1 -type all_composites\n./gen -a 90 -b 100 -k 5 -type normal\n./gen -a 90 -b 100 -k 5 -type over_k\n./gen -a 90 -b 100 -k 2 -type no_solution\n./gen -a 1 -b 1000000 -k 1 -type normal\n./gen -a 500000 -b 500000 -k 1 -type normal\n./gen -a 1 -b 1 -k 1 -type normal\n./gen -a 1 -b 2 -k 1 -type normal\n./gen -a 999999 -b 1000000 -k 1 -type normal\n./gen -a 2 -b 3 -k 2 -type normal\n./gen -a 2 -b 3 -k 3 -type over_k\n./gen -a 2 -b 3 -k 1 -type normal\n./gen -a 123456 -b 123654 -k 10 -type normal\n./gen -a 1 -b 1000000 -k 1000000 -type over_k\n./gen -a 1 -b 1000000 -k 1 -type normal\n./gen -a 1 -b 500000 -k 100 -type normal\n./gen -a 500000 -b 1000000 -k 100 -type normal\n./gen -a 104729 -b 104729 -k 1 -type normal\n./gen -a 104725 -b 104729 -k 1 -type normal\n./gen -a 1000000 -b 1000000 -k 1 -type normal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:51.460676",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "237/D",
      "title": "D. T-decomposition",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 105), that denotes the number of nodes in tree s.Each of the following n - 1 lines contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi), denoting that the nodes of tree s with indices ai and bi are connected by an edge.Consider the nodes of tree s indexed from 1 to n. It is guaranteed that s is a tree.",
      "output_spec": "OutputIn the first line print a single integer m that denotes the number of nodes in the required T-decomposition.Then print m lines, containing descriptions of the T-decomposition nodes. In the i-th (1 ≤ i ≤ m) of them print the description of node xi of the T-decomposition. The description of each node xi should start from an integer ki, that represents the number of nodes of the initial tree s, that are contained in the node xi. Then you should print ki distinct space-separated integers — the numbers of nodes from s, contained in xi, in arbitrary order.Then print m - 1 lines, each consisting two integers pi, qi (1 ≤ pi, qi ≤ m; pi ≠ qi). The pair of integers pi, qi means there is an edge between nodes xpi and xqi of T-decomposition.The printed T-decomposition should be the optimal T-decomposition for the given tree s and have the minimum possible number of nodes among all optimal T-decompositions. If there are multiple optimal T-decompositions with the minimum number of nodes, print any of them.",
      "sample_tests": "ExamplesInputCopy21 2OutputCopy12 1 2InputCopy31 22 3OutputCopy22 1 22 2 31 2InputCopy42 13 14 1OutputCopy32 2 12 3 12 4 11 22 3",
      "description": "D. T-decomposition\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 105), that denotes the number of nodes in tree s.Each of the following n - 1 lines contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi), denoting that the nodes of tree s with indices ai and bi are connected by an edge.Consider the nodes of tree s indexed from 1 to n. It is guaranteed that s is a tree.\n\nOutputIn the first line print a single integer m that denotes the number of nodes in the required T-decomposition.Then print m lines, containing descriptions of the T-decomposition nodes. In the i-th (1 ≤ i ≤ m) of them print the description of node xi of the T-decomposition. The description of each node xi should start from an integer ki, that represents the number of nodes of the initial tree s, that are contained in the node xi. Then you should print ki distinct space-separated integers — the numbers of nodes from s, contained in xi, in arbitrary order.Then print m - 1 lines, each consisting two integers pi, qi (1 ≤ pi, qi ≤ m; pi ≠ qi). The pair of integers pi, qi means there is an edge between nodes xpi and xqi of T-decomposition.The printed T-decomposition should be the optimal T-decomposition for the given tree s and have the minimum possible number of nodes among all optimal T-decompositions. If there are multiple optimal T-decompositions with the minimum number of nodes, print any of them.\n\nInputCopy21 2OutputCopy12 1 2InputCopy31 22 3OutputCopy22 1 22 2 31 2InputCopy42 13 14 1OutputCopy32 2 12 3 12 4 11 22 3\n\nInputCopy21 2\n\nOutputCopy12 1 2\n\nInputCopy31 22 3\n\nOutputCopy22 1 22 2 31 2\n\nInputCopy42 13 14 1\n\nOutputCopy32 2 12 3 12 4 11 22 3",
      "solutions": [
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces",
          "content": "Hi!A few hours later you're lucky to participate in Codeforces Round #147 for Div.2 participants, but traditionally the others can take part out of the competition. It has been prepared by me (NALP), Igor Kudryashov (Igor_Kudryashov), Pavlik Holkin (HolkinPV), Gerald Agapov (Gerald), Mary Belova (Delinur) and Mike Mirzayanov (MikeMirzayanov).Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!The standart scoring system will be used: 500-1000-1500-2000-2500UPD: The contest has ended, congratulations to the winners: try_skycn AntiKismet dianbei_03 Uncia Bigsophie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5640",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 607
        },
        {
          "title": "Codeforces Round #147 (Div. 2) Разбор Задач - Codeforces",
          "content": "Приветствую всех участников раунда!237A - Free CashИз условия задачи легко понять, что если в некоторую минуту придут k человек, то Валере нужно иметь в кафе не менее k касс. Значит, требуется найти максимальное количество людей, которые придут в одну и ту же минуту, а это делается очень просто множеством способов, например, просто насчитав в массив cnt[h][m] количество людей, которые придут в час h и минуту m, а потом найдя в этом массиве максимум.237B - Young TableРешение, которое опишем ниже, почти никак не использует хитрую форму таблицы (кстати, такая таблица называется диаграммой Юнга). Заполним таблицу числами от 1 до s следующим способом: будем идти по строкам таблицы начиная с первой слева направо, после конца текущей строки переходим на начало следующей, и в процессе каждой из клеточек присвоим число по порядку обхода от 1 до s. Очень просто показать, что такой порядок чисел удовлетворяет оба неравенства из условия.Теперь опишем алгоритм приведения таблицы из того вида, как она нам дана во входных данных, в описанный выше вид.Возьмем число 1 и посмотрим, где оно находится в этих двух таблицах. Если это число стоит не на своем месте, то поставим его на свое место, соответственно то число, которое там стояло, встанет на старое место единицы. Аналогично сделаем для 2, 3, ..., s. Очевидно, что этот алгоритм сделает не более s шагов и приведет таблицу в вид, описанный в первом абзаце.237C - Primes on IntervalДля начала с помощью решета Эратосфена выделим все простые числа от 1 до b и пометим их единичками в массиве d, то есть если p — простое, то d[p] = 1, иначе d[p] = 0.Заметим, что если l — корректное число, то l + 1 тоже корректно. В самом деле, для позиций x от a до b - l количество простых в отрезке с началом в x могло лишь увеличиться (мы же длину отрезка увеличили, а значит, количество простых в нем никак не могло уменьшиться). А кроме того исчез из рассмотрения один отрезок с началом в точке b - l + 1, так как при увеличении длины его правый конец стал больше, чем число b.Таким образом, мы показали, что функция f(l), возвращающая TRUE или FALSE (корректно число или нет) монотонна, а значит, мы можем с помощью бинарного поиска найти наименьшее l, для которого f(l) = TRUE, или ответить, что такого не существует.Функция f(l) считается очень просто — можно проитерироваться по всем числам от a до b - l + 1 и найти для каждого начала количество простых чисел в соответствующем отрезке длины l, это можно сделать с помощью частичных сумм, насчитанных по массиву d.237D - T-decompositionВозьмем любое ребро начального графа, очевидно два его конца принадлежат некоторому множеству xi, значит, вес любой его Д-декомпозиции как минимум 2. Покажем, как постороить декомпозицию именно такого веса. Для этого каждое из ребер исходного графа превратим в отдельное множество xi, то есть все они будут состоять из двух элементов.Очевидно, что первые два условия выполняются. Для выполнения третьего условия для начала соединим все множества по принципу: добавим ребро между двуми множествами, если их пересечение не пусто. Однако построенный таким образом граф не является деревом, покажем другой способ соединения вершин.Для того, чтобы сделать из него дерево, достаточно для каждой вершины v начального дерева выделить все xi, в которых она содержится, и соединить их в цепочку в любом порядке, добавив нужное количество ребер.Несложно понять, что такой граф не будет содержать циклов, будет связен, а значит является деревом. Постоенная Д-декомпозиция будет иметь вес 2, и количество вершин n - 1.237E - Build StringЭта задача несложно решается алгоритмом поиска максимального потока минимальной стоимости на трехслойном графе: первый слой состоит из n вершин, каждая из которых отвечает за свою строку из входных данных; в i-ую вершину этого слоя входит по одному ребру из истока с пропускной способностью ci и стоимостью i; второй стой состоит за 26·n вершин, каждая из которых отвечает за количество определенных букв в каждой из строк из входных данных; в вершины этого слоя входят ребра только из первого слоя стоимостью 0 и пропускной способностью равной количеству соответствующих букв в соответствующей строке; третий слой состоит из 26 вершин, каждая из которых отвечает за количество соответствующих букв в строке t; в вершины этого слоя входят ребра только из второго слоя стоимостью 0 и бесконечной пропускной способностью; кроме того, из вершин третьего слоя выходят ребра в сток стоимостью 0 и пропускной способностью, равной количеству соответствующих букв в строке t. Если максимальный поток в этой сети меньше, чем |t|, то ответ равен  - 1, а иначе — минимальной стоимости максимального потока.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5648",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 237\\s*D"
          },
          "content_length": 4653
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 1",
          "code": "6\n2 2 1 1\n3 1 1 2\n1 2 1 3\n1 1 2 1\n1 3 2 2\n2 1 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 2",
          "code": "6\n2 2 1 1\n3 1 1 2\n1 2 1 3\n1 1 2 1\n1 3 2 2\n2 1 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 3",
          "code": "co place[mo];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 4",
          "code": "bool check(int l)   {      for(int x=a;x<=b-l+1;x++)           { if(prime[x+l-1]-prime[x-1]<k)             return false;         }           return true;    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 5",
          "code": "#define MAX 11111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 6",
          "code": "#define MAX 111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    if (px == py) {\n        // Cycle detected\n        return false;\n    }\n    parent[px] = py;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected on node %d\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        auto edge = make_pair(u, v);\n        ensuref(!edges.count(edge), \"Duplicate edge between %d and %d\", u, v);\n        edges.insert(edge);\n\n        ensuref(unite(a, b), \"Cycle detected when adding edge between %d and %d\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    if (px == py) {\n        // Cycle detected\n        return false;\n    }\n    parent[px] = py;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected on node %d\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        auto edge = make_pair(u, v);\n        ensuref(!edges.count(edge), \"Duplicate edge between %d and %d\", u, v);\n        edges.insert(edge);\n\n        ensuref(unite(a, b), \"Cycle detected when adding edge between %d and %d\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    if (px == py) {\n        // Cycle detected\n        return false;\n    }\n    parent[px] = py;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop detected on node %d\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        auto edge = make_pair(u, v);\n        ensuref(!edges.count(edge), \"Duplicate edge between %d and %d\", u, v);\n        edges.insert(edge);\n\n        ensuref(unite(a, b), \"Cycle detected when adding edge between %d and %d\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This checker compares the contestant's T-decomposition to the jury's T-decomposition and verifies:\n    1) Both are valid T-decompositions of the original tree s.\n    2) Their \"weights\" (maximum subset cardinality) are the same.\n    3) Among all T-decompositions with that weight, the number of nodes in T is minimal.\n       - We compare to the jury's T-decomposition:\n         * If the contestant's decomposition is invalid, we report WA.\n         * If the jury's decomposition is invalid, we report FAIL (shouldn't happen with correct jury).\n         * Then compare weights:\n             If contestant's < jury's => FAIL (official solution wasn’t minimal).\n             If contestant's > jury's => WA.\n             If equal => compare number of nodes:\n                 If contestant's < jury's => FAIL (official solution wasn’t minimal).\n                 If contestant's > jury's => WA.\n                 Otherwise => OK.\n*/\n\nstatic const string TREE_NOT_CONNECTED = \"T-decomposition graph is not connected\";\nstatic const string WRONG_NUMBER_OF_EDGES = \"T-decomposition must have (m - 1) edges if it has m nodes\";\n\n// Global storage\nint n;\nvector<vector<int>> adj; // adjacency of the original tree s, 1-based\n\n// Data structure to store a T-decomposition\nstruct TDecomposition {\n    int m; // number of nodes in T\n    vector<vector<int>> subsets; // subsets[i] is the list of tree-s nodes in the T's node i\n    vector<vector<int>> tAdj;    // adjacency of T\n    int weight;                  // maximum subset cardinality\n};\n\n// Reads T-decomposition from stream\nTDecomposition readDecomposition(InStream &stream) {\n    TDecomposition dec;\n    dec.m = stream.readInt(1, n, \"number_of_nodes_in_T_decomposition\");\n    dec.subsets.resize(dec.m);\n    for(int i = 0; i < dec.m; i++){\n        // read each T-decomposition node\n        int k = stream.readInt(1, n, \"size_of_subset\");\n        dec.subsets[i].resize(k);\n        set<int> used; \n        for(int j = 0; j < k; j++){\n            int v = stream.readInt(1, n, \"tree_node_in_subset\");\n            if(!used.insert(v).second){\n                stream.quitf(_wa, \"A subset of T-decomposition contains duplicate node %d\", v);\n            }\n            dec.subsets[i][j] = v;\n        }\n    }\n    dec.tAdj.assign(dec.m, {});\n    // read edges of T\n    // T must have exactly dec.m - 1 edges\n    if(dec.m == 1){\n        // no edges to read\n    } else {\n        for(int e = 0; e < dec.m - 1; e++){\n            int p = stream.readInt(1, dec.m, \"t_edge_p\");\n            int q = stream.readInt(1, dec.m, \"t_edge_q\");\n            if(p == q){\n                stream.quitf(_wa, \"T-decomposition edge connects the same node %d\", p);\n            }\n            // convert to zero-based\n            p--; q--;\n            dec.tAdj[p].push_back(q);\n            dec.tAdj[q].push_back(p);\n        }\n    }\n    // no more edges for T\n    // compute weight\n    dec.weight = 0;\n    for(int i = 0; i < dec.m; i++){\n        dec.weight = max(dec.weight, (int)(dec.subsets[i].size()));\n    }\n    return dec;\n}\n\n// Checks if T-decomposition is connected graph with exactly m-1 edges\nbool checkTConnected(const TDecomposition &dec){\n    // BFS or DFS\n    int m = dec.m;\n    // check number of edges\n    // sum of adjacency is 2*(m-1) if T is correct => let's verify quickly\n    int countEdges = 0;\n    for(int i = 0; i < m; i++){\n        countEdges += (int)dec.tAdj[i].size();\n    }\n    if(m > 1 && countEdges != 2*(m-1)) return false;\n    // connectivity check\n    vector<bool> visited(m, false);\n    int compCount = 0;\n    function<void(int)> dfs = [&](int u){\n        visited[u] = true;\n        for(int w: dec.tAdj[u]){\n            if(!visited[w]){\n                dfs(w);\n            }\n        }\n    };\n    for(int i=0; i<m; i++){\n        if(!visited[i]){\n            compCount++;\n            if(compCount > 1) return false;\n            dfs(i);\n        }\n    }\n    return true;\n}\n\n// Checks validity of T-decomposition\n// Conditions:\n//   1) union of subsets = {1..n}\n//   2) for each edge (a,b) in s there is a subset containing both\n//   3) for each vertex v in s, the subsets that contain v form a connected subgraph in T\n// Returns true if valid, false otherwise. If invalid and stream==ans => _fail, else _wa.\nbool checkValidity(InStream &stream, const TDecomposition &dec){\n    // Condition 1: union of subsets = {1..n}\n    vector<bool> used(n+1,false);\n    for(int i=0; i<dec.m; i++){\n        for(int v: dec.subsets[i]){\n            used[v] = true;\n        }\n    }\n    for(int v=1; v<=n; v++){\n        if(!used[v]){\n            // missing\n            stream.quitf(_wa, \"Not all nodes appear in the union of T-decomposition. Missing node %d\", v);\n        }\n    }\n    // Condition 2: for each edge (a,b) in original tree S, there is a subset containing both\n    // We'll store adjacency in global 'adj'\n    for(int v=1; v<=n; v++){\n        for(int w: adj[v]){\n            if(v < w){ // ensure each edge once\n                bool found = false;\n                for(int i=0; i<dec.m && !found; i++){\n                    // check if dec.subsets[i] contains both v and w\n                    // to speed up checking, we might store them in a set, but n can be large\n                    // We'll do a direct membership test\n                    // We'll do a small trick: if subsets are large, this can be slow, but let's keep it simpler for the example\n                    // A real system solution might require a more optimal approach\n                    // or a hashing approach\n                    bool vIn = false, wIn = false;\n                    for(int nodeInSubset: dec.subsets[i]){\n                        if(nodeInSubset == v) vIn = true;\n                        if(nodeInSubset == w) wIn = true;\n                        if(vIn && wIn) {found = true; break;}\n                    }\n                }\n                if(!found){\n                    stream.quitf(_wa, \"No subset in T-decomposition contains edge (%d, %d)\", v, w);\n                }\n            }\n        }\n    }\n    // Condition 3: for each vertex v in s, the subsets containing v form a connected subgraph in T\n    // We'll gather the T-nodes that contain v\n    // Then check if they form a connected subgraph in the T\n    // We'll do a BFS/DFS inside T restricted to those T-nodes.\n    for(int vert = 1; vert <= n; vert++){\n        vector<int> nodesInT;\n        for(int i=0; i<dec.m; i++){\n            // check membership\n            // we do a quick membership check\n            // for a real solution we might store sets or use hashing\n            // here just do it plainly\n            bool found = false;\n            for(int nodeInSubset: dec.subsets[i]){\n                if(nodeInSubset == vert){\n                    found = true; \n                    break;\n                }\n            }\n            if(found){\n                nodesInT.push_back(i);\n            }\n        }\n        // nodesInT should form a connected subgraph\n        // We'll pick any, BFS, and see if we reach all\n        if(!nodesInT.empty()){\n            vector<bool> usedT(dec.m,false);\n            queue<int>q;\n            usedT[nodesInT[0]] = true;\n            q.push(nodesInT[0]);\n            int countVisited = 0;\n            unordered_set<int> mustVisit(nodesInT.begin(), nodesInT.end());\n            while(!q.empty()){\n                int u = q.front(); q.pop();\n                if(mustVisit.count(u)) countVisited++;\n                for(int nxt: dec.tAdj[u]){\n                    // only traverse if that T-node also contains v\n                    // check membership\n                    if(!usedT[nxt]){\n                        bool hasVert = false;\n                        // check quickly\n                        for(int nodeInSubset: dec.subsets[nxt]){\n                            if(nodeInSubset == vert) { hasVert=true; break; }\n                        }\n                        if(hasVert){\n                            usedT[nxt] = true;\n                            q.push(nxt);\n                        }\n                    }\n                }\n            }\n            if(countVisited != (int)nodesInT.size()){\n                stream.quitf(_wa, \n                    \"T-decomposition violates condition 3 for original node %d. Sets containing %d are not all connected in T\",\n                    vert, vert);\n            }\n        }\n    }\n    // check T is connected and has exactly m-1 edges => otherwise it's not a tree\n    if(!checkTConnected(dec)){\n        stream.quitf(_wa, \"The T-decomposition is not a tree (connected with exactly m-1 edges).\");\n    }\n    return true;\n}\n\n// We'll read and validate both the jury's solution (ans) and the participant's solution (ouf).\n// If the jury's T-decomposition is invalid => quitf(_fail).\n// If the participant's T-decomposition is invalid => quitf(_wa).\n// Then compare weight, compare number of nodes.\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n    // Read original tree s\n    n = inf.readInt(2, 100000,\"n\");\n    adj.resize(n+1);\n    for(int i=0; i<n-1; i++){\n        int a = inf.readInt(1,n,\"edge_a\");\n        int b = inf.readInt(1,n,\"edge_b\");\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    // read ans\n    TDecomposition decAns = readDecomposition(ans);\n    // check ans validity\n    // if invalid => _fail\n    // else we have ansWeight, ansNodes\n    checkValidity(ans, decAns); // will _fail if invalid\n    int ansWeight = decAns.weight;\n    int ansNodesCount = decAns.m;\n\n    // read ouf\n    TDecomposition decOuf = readDecomposition(ouf);\n    // check ouf validity\n    // if invalid => _wa\n    checkValidity(ouf, decOuf); // will _wa if invalid\n    int oufWeight = decOuf.weight;\n    int oufNodesCount = decOuf.m;\n\n    // compare\n    if(oufWeight < ansWeight){\n        // that means official answer wasn't minimal\n        quitf(_fail,\n            \"Participant's T-decomposition has smaller weight (%d) than jury's (%d). Jury not minimal?\",\n            oufWeight, ansWeight);\n    } else if(oufWeight > ansWeight){\n        // participant's solution is worse\n        quitf(_wa,\n            \"Participant's T-decomposition has weight %d but jury's is %d, which is better.\",\n            oufWeight, ansWeight);\n    } else {\n        // weights are the same; compare number of nodes\n        if(oufNodesCount < ansNodesCount){\n            // participant found same weight with fewer nodes! => official solution not minimal in # of nodes\n            quitf(_fail,\n                \"Participant's T-decomposition has the same weight (%d) but fewer T-nodes (%d < %d). Jury not minimal?\",\n                oufWeight, oufNodesCount, ansNodesCount);\n        } else if(oufNodesCount > ansNodesCount){\n            // participant used more T-nodes => WA\n            quitf(_wa,\n                \"Participant's T-decomposition has the same weight (%d) but uses more T-nodes (%d > %d).\",\n                oufWeight, oufNodesCount, ansNodesCount);\n        } else {\n            // all match\n            quitf(_ok, \"OK. weight=%d, #nodes=%d\", oufWeight, oufNodesCount);\n        }\n    }\n    return 0; // unreachable, but just for completeness\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Generate a chain (linear tree)\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Generate a star tree (node 1 connected to all others)\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        // Generate a complete binary tree\n        queue<int> q;\n        int currentNode = 1;\n        int nodeCount = 1;\n        q.push(currentNode);\n        while (nodeCount < n) {\n            int parent = q.front();\n            q.pop();\n            if (nodeCount < n) {\n                ++currentNode;\n                edges.push_back({parent, currentNode});\n                q.push(currentNode);\n                ++nodeCount;\n            }\n            if (nodeCount < n) {\n                ++currentNode;\n                edges.push_back({parent, currentNode});\n                q.push(currentNode);\n                ++nodeCount;\n            }\n        }\n    } else if (type == \"comb\") {\n        // Generate a comb-like tree\n        int dir = 0;\n        int parent = 1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({parent, i});\n            if (dir == 0) {\n                parent = i;\n                dir = 1;\n            } else {\n                dir = 0;\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        // Optionally shuffle edges\n        shuffle(edges.begin(), edges.end());\n    } else {\n        // Default to random tree if type is unrecognized\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Generate a chain (linear tree)\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Generate a star tree (node 1 connected to all others)\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        // Generate a complete binary tree\n        queue<int> q;\n        int currentNode = 1;\n        int nodeCount = 1;\n        q.push(currentNode);\n        while (nodeCount < n) {\n            int parent = q.front();\n            q.pop();\n            if (nodeCount < n) {\n                ++currentNode;\n                edges.push_back({parent, currentNode});\n                q.push(currentNode);\n                ++nodeCount;\n            }\n            if (nodeCount < n) {\n                ++currentNode;\n                edges.push_back({parent, currentNode});\n                q.push(currentNode);\n                ++nodeCount;\n            }\n        }\n    } else if (type == \"comb\") {\n        // Generate a comb-like tree\n        int dir = 0;\n        int parent = 1;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({parent, i});\n            if (dir == 0) {\n                parent = i;\n                dir = 1;\n            } else {\n                dir = 0;\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        // Optionally shuffle edges\n        shuffle(edges.begin(), edges.end());\n    } else {\n        // Default to random tree if type is unrecognized\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type binary\n./gen -n 2 -type random\n\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type binary\n./gen -n 3 -type random\n\n./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type binary\n./gen -n 5 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type binary\n./gen -n 10 -type random\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type binary\n./gen -n 100 -type random\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type binary\n./gen -n 1000 -type random\n\n./gen -n 10000 -type chain\n./gen -n 10000 -type star\n./gen -n 10000 -type binary\n./gen -n 10000 -type random\n\n./gen -n 50000 -type chain\n./gen -n 50000 -type star\n./gen -n 50000 -type binary\n./gen -n 50000 -type comb\n./gen -n 50000 -type random\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type binary\n./gen -n 100000 -type comb\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:53.572656",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "237/E",
      "title": "E. Build String",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains string t — the string that you need to build.The second line contains a single integer n (1 ≤ n ≤ 100) — the number of strings to which you are allowed to apply the described operation. Each of the next n lines contains a string and an integer. The i-th line contains space-separated string si and integer ai (0 ≤ ai ≤ 100). Number ai represents the maximum number of characters that can be deleted from string si.All strings in the input only consist of lowercase English letters. All strings are non-empty. The lengths of all strings do not exceed 100 characters.",
      "output_spec": "OutputPrint a single number — the minimum money (in rubles) you need in order to build string t. If there is no solution, print -1.",
      "sample_tests": "ExamplesInputCopybbaze3bzb 2aeb 3ba 10OutputCopy8InputCopyabacaba4aba 2bcc 1caa 2bbb 5OutputCopy18InputCopyxyz4axx 8za 1efg 4t 1OutputCopy-1",
      "description": "E. Build String\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains string t — the string that you need to build.The second line contains a single integer n (1 ≤ n ≤ 100) — the number of strings to which you are allowed to apply the described operation. Each of the next n lines contains a string and an integer. The i-th line contains space-separated string si and integer ai (0 ≤ ai ≤ 100). Number ai represents the maximum number of characters that can be deleted from string si.All strings in the input only consist of lowercase English letters. All strings are non-empty. The lengths of all strings do not exceed 100 characters.\n\nOutputPrint a single number — the minimum money (in rubles) you need in order to build string t. If there is no solution, print -1.\n\nInputCopybbaze3bzb 2aeb 3ba 10OutputCopy8InputCopyabacaba4aba 2bcc 1caa 2bbb 5OutputCopy18InputCopyxyz4axx 8za 1efg 4t 1OutputCopy-1\n\nInputCopybbaze3bzb 2aeb 3ba 10\n\nOutputCopy8\n\nInputCopyabacaba4aba 2bcc 1caa 2bbb 5\n\nOutputCopy18\n\nInputCopyxyz4axx 8za 1efg 4t 1\n\nOutputCopy-1\n\nNoteNotes to the samples:In the first sample from the first string you should take characters \"b\" and \"z\" with price 1 ruble, from the second string characters \"a\", \"e\" и \"b\" with price 2 rubles. The price of the string t in this case is 2·1 + 3·2 = 8.In the second sample from the first string you should take two characters \"a\" with price 1 ruble, from the second string character \"c\" with price 2 rubles, from the third string two characters \"a\" with price 3 rubles, from the fourth string two characters \"b\" with price 4 rubles. The price of the string t in this case is 2·1 + 1·2 + 2·3 + 2·4 = 18.In the third sample the solution doesn't exist because there is no character \"y\" in given strings.",
      "solutions": [
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces",
          "content": "Hi!A few hours later you're lucky to participate in Codeforces Round #147 for Div.2 participants, but traditionally the others can take part out of the competition. It has been prepared by me (NALP), Igor Kudryashov (Igor_Kudryashov), Pavlik Holkin (HolkinPV), Gerald Agapov (Gerald), Mary Belova (Delinur) and Mike Mirzayanov (MikeMirzayanov).Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!The standart scoring system will be used: 500-1000-1500-2000-2500UPD: The contest has ended, congratulations to the winners: try_skycn AntiKismet dianbei_03 Uncia Bigsophie",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5640",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 607
        },
        {
          "title": "Codeforces Round #147 (Div. 2) Разбор Задач - Codeforces",
          "content": "Приветствую всех участников раунда!237A - Free CashИз условия задачи легко понять, что если в некоторую минуту придут k человек, то Валере нужно иметь в кафе не менее k касс. Значит, требуется найти максимальное количество людей, которые придут в одну и ту же минуту, а это делается очень просто множеством способов, например, просто насчитав в массив cnt[h][m] количество людей, которые придут в час h и минуту m, а потом найдя в этом массиве максимум.237B - Young TableРешение, которое опишем ниже, почти никак не использует хитрую форму таблицы (кстати, такая таблица называется диаграммой Юнга). Заполним таблицу числами от 1 до s следующим способом: будем идти по строкам таблицы начиная с первой слева направо, после конца текущей строки переходим на начало следующей, и в процессе каждой из клеточек присвоим число по порядку обхода от 1 до s. Очень просто показать, что такой порядок чисел удовлетворяет оба неравенства из условия.Теперь опишем алгоритм приведения таблицы из того вида, как она нам дана во входных данных, в описанный выше вид.Возьмем число 1 и посмотрим, где оно находится в этих двух таблицах. Если это число стоит не на своем месте, то поставим его на свое место, соответственно то число, которое там стояло, встанет на старое место единицы. Аналогично сделаем для 2, 3, ..., s. Очевидно, что этот алгоритм сделает не более s шагов и приведет таблицу в вид, описанный в первом абзаце.237C - Primes on IntervalДля начала с помощью решета Эратосфена выделим все простые числа от 1 до b и пометим их единичками в массиве d, то есть если p — простое, то d[p] = 1, иначе d[p] = 0.Заметим, что если l — корректное число, то l + 1 тоже корректно. В самом деле, для позиций x от a до b - l количество простых в отрезке с началом в x могло лишь увеличиться (мы же длину отрезка увеличили, а значит, количество простых в нем никак не могло уменьшиться). А кроме того исчез из рассмотрения один отрезок с началом в точке b - l + 1, так как при увеличении длины его правый конец стал больше, чем число b.Таким образом, мы показали, что функция f(l), возвращающая TRUE или FALSE (корректно число или нет) монотонна, а значит, мы можем с помощью бинарного поиска найти наименьшее l, для которого f(l) = TRUE, или ответить, что такого не существует.Функция f(l) считается очень просто — можно проитерироваться по всем числам от a до b - l + 1 и найти для каждого начала количество простых чисел в соответствующем отрезке длины l, это можно сделать с помощью частичных сумм, насчитанных по массиву d.237D - T-decompositionВозьмем любое ребро начального графа, очевидно два его конца принадлежат некоторому множеству xi, значит, вес любой его Д-декомпозиции как минимум 2. Покажем, как постороить декомпозицию именно такого веса. Для этого каждое из ребер исходного графа превратим в отдельное множество xi, то есть все они будут состоять из двух элементов.Очевидно, что первые два условия выполняются. Для выполнения третьего условия для начала соединим все множества по принципу: добавим ребро между двуми множествами, если их пересечение не пусто. Однако построенный таким образом граф не является деревом, покажем другой способ соединения вершин.Для того, чтобы сделать из него дерево, достаточно для каждой вершины v начального дерева выделить все xi, в которых она содержится, и соединить их в цепочку в любом порядке, добавив нужное количество ребер.Несложно понять, что такой граф не будет содержать циклов, будет связен, а значит является деревом. Постоенная Д-декомпозиция будет иметь вес 2, и количество вершин n - 1.237E - Build StringЭта задача несложно решается алгоритмом поиска максимального потока минимальной стоимости на трехслойном графе: первый слой состоит из n вершин, каждая из которых отвечает за свою строку из входных данных; в i-ую вершину этого слоя входит по одному ребру из истока с пропускной способностью ci и стоимостью i; второй стой состоит за 26·n вершин, каждая из которых отвечает за количество определенных букв в каждой из строк из входных данных; в вершины этого слоя входят ребра только из первого слоя стоимостью 0 и пропускной способностью равной количеству соответствующих букв в соответствующей строке; третий слой состоит из 26 вершин, каждая из которых отвечает за количество соответствующих букв в строке t; в вершины этого слоя входят ребра только из второго слоя стоимостью 0 и бесконечной пропускной способностью; кроме того, из вершин третьего слоя выходят ребра в сток стоимостью 0 и пропускной способностью, равной количеству соответствующих букв в строке t. Если максимальный поток в этой сети меньше, чем |t|, то ответ равен  - 1, а иначе — минимальной стоимости максимального потока.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5648",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 237\\s*E"
          },
          "content_length": 4653
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 1",
          "code": "6\n2 2 1 1\n3 1 1 2\n1 2 1 3\n1 1 2 1\n1 3 2 2\n2 1 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 2",
          "code": "6\n2 2 1 1\n3 1 1 2\n1 2 1 3\n1 1 2 1\n1 3 2 2\n2 1 3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 3",
          "code": "co place[mo];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 4",
          "code": "bool check(int l)   {      for(int x=a;x<=b-l+1;x++)           { if(prime[x+l-1]-prime[x-1]<k)             return false;         }           return true;    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 5",
          "code": "#define MAX 11111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #147 (Div. 2) - Codeforces - Code 6",
          "code": "#define MAX 111111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5640",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read t\n    string t = inf.readToken(\"[a-z]+\", \"t\");\n    ensuref(1 <= t.length() && t.length() <= 10000, \"Length of t must be between 1 and 10000\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    // For each s_i and a_i\n    for (int i = 0; i < n; i++) {\n        // Read s_i\n        string si = inf.readToken(\"[a-z]+\", \"s_i\");\n        ensuref(1 <= si.length() && si.length() <= 100, \"Length of s_i must be between 1 and 100\");\n        inf.readSpace();\n\n        // Read a_i\n        int ai = inf.readInt(0, 100, \"a_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read t\n    string t = inf.readToken(\"[a-z]+\", \"t\");\n    ensuref(1 <= t.length() && t.length() <= 10000, \"Length of t must be between 1 and 10000\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    // For each s_i and a_i\n    for (int i = 0; i < n; i++) {\n        // Read s_i\n        string si = inf.readToken(\"[a-z]+\", \"s_i\");\n        ensuref(1 <= si.length() && si.length() <= 100, \"Length of s_i must be between 1 and 100\");\n        inf.readSpace();\n\n        // Read a_i\n        int ai = inf.readInt(0, 100, \"a_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read t\n    string t = inf.readToken(\"[a-z]+\", \"t\");\n    ensuref(1 <= t.length() && t.length() <= 10000, \"Length of t must be between 1 and 10000\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    // For each s_i and a_i\n    for (int i = 0; i < n; i++) {\n        // Read s_i\n        string si = inf.readToken(\"[a-z]+\", \"s_i\");\n        ensuref(1 <= si.length() && si.length() <= 100, \"Length of s_i must be between 1 and 100\");\n        inf.readSpace();\n\n        // Read a_i\n        int ai = inf.readInt(0, 100, \"a_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxlen = opt<int>(\"maxlen\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and maxlen stay within problem constraints\n    n = min(n, 100);\n    maxlen = min(maxlen, 100);\n\n    // Variables for target string t, strings s_i, and their limits a_i\n    string t;\n    vector<string> s(n);\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate a random t\n        int tlen = rnd.next(1, maxlen);\n        t = \"\";\n        for (int i = 0; i < tlen; ++i) {\n            t += (char)rnd.next('a', 'z');\n        }\n        // Generate random s_i and a_i\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                s[i] += (char)rnd.next('a', 'z');\n            }\n            a[i] = rnd.next(0, si_len);\n        }\n    } else if (type == \"no_solution\") {\n        // Ensure t contains a character not in s_i\n        char missing_char;\n        do {\n            missing_char = (char)rnd.next('a', 'z');\n        } while (missing_char == 'z'); // Avoid 'z' to have another character to use\n\n        // Generate s_i without the missing_char\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                char c;\n                do {\n                    c = (char)rnd.next('a', 'z');\n                } while (c == missing_char);\n                s[i] += c;\n            }\n            a[i] = rnd.next(0, si_len);\n        }\n        // Generate t and include the missing_char\n        int tlen = rnd.next(1, maxlen);\n        t = \"\";\n        for (int i = 0; i < tlen; ++i) {\n            t += (char)rnd.next('a', 'z');\n        }\n        t[rnd.next(0, tlen - 1)] = missing_char; // Ensure t contains the missing character\n    } else if (type == \"tight_ai\") {\n        // Generate t and s_i such that ai is exactly what is needed\n        int tlen = rnd.next(1, maxlen);\n        t = \"\";\n        map<char, int> freq_t;\n        for (int i = 0; i < tlen; ++i) {\n            char c = (char)rnd.next('a', 'z');\n            t += c;\n            freq_t[c]++;\n        }\n        // Initialize s_i\n        for (int i = 0; i < n; ++i) {\n            s[i] = \"\";\n            a[i] = 0;\n        }\n        // Distribute character frequencies among s_i\n        vector<char> chars_in_t;\n        for (auto it : freq_t) {\n            chars_in_t.push_back(it.first);\n        }\n        for (auto it : freq_t) {\n            char c = it.first;\n            int total_needed = it.second;\n            int remaining = total_needed;\n            for (int i = 0; i < n && remaining > 0; ++i) {\n                int amount = rnd.next(0, remaining);\n                if (i == n - 1) amount = remaining; // Ensure we cover all\n                remaining -= amount;\n                if (amount > 0) {\n                    s[i] += string(amount, c);\n                    a[i] += amount;\n                }\n            }\n        }\n        // Add extra characters to s_i\n        for (int i = 0; i < n; ++i) {\n            int extra_len = rnd.next(0, maxlen - (int)s[i].length());\n            for (int j = 0; j < extra_len; ++j) {\n                s[i] += (char)rnd.next('a', 'z');\n            }\n            // Shuffle the string\n            shuffle(s[i].begin(), s[i].end());\n            // Set a_i to the exact number of needed deletions\n            a[i] = min(a[i], (int)s[i].length());\n        }\n    } else if (type == \"large_t\") {\n        // Generate t with maximum length\n        int tlen = maxlen;\n        t = \"\";\n        for (int i = 0; i < tlen; ++i) {\n            t += (char)rnd.next('a', 'z');\n        }\n        // Use maximum n\n        n = 100;\n        s.resize(n);\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                s[i] += (char)rnd.next('a', 'z');\n            }\n            a[i] = rnd.next(0, si_len);\n        }\n    } else if (type == \"max_n\") {\n        // Use maximum n\n        n = 100;\n        s.resize(n);\n        a.resize(n);\n        int tlen = rnd.next(1, maxlen);\n        t = \"\";\n        for (int i = 0; i < tlen; ++i) {\n            t += (char)rnd.next('a', 'z');\n        }\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                s[i] += (char)rnd.next('a', 'z');\n            }\n            a[i] = rnd.next(0, si_len);\n        }\n    } else if (type == \"single_char\") {\n        // t consists of the same character\n        char c = (char)rnd.next('a', 'z');\n        int tlen = rnd.next(1, maxlen);\n        t = string(tlen, c);\n        // Generate s_i\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                if (rnd.next(0, 1))\n                    s[i] += c;\n                else\n                    s[i] += (char)rnd.next('a', 'z');\n            }\n            // Set a_i to count of c in s_i\n            a[i] = rnd.next(0, (int)count(s[i].begin(), s[i].end(), c));\n        }\n    } else {\n        // Default to random if unknown type\n        int tlen = rnd.next(1, maxlen);\n        t = \"\";\n        for (int i = 0; i < tlen; ++i) {\n            t += (char)rnd.next('a', 'z');\n        }\n        // Generate s_i and a_i\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                s[i] += (char)rnd.next('a', 'z');\n            }\n            a[i] = rnd.next(0, si_len);\n        }\n    }\n\n    // Output the test case\n    cout << t << endl;\n    cout << n << endl;\n    for (int i = 0; i < n; ++i) {\n        cout << s[i] << \" \" << a[i] << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int maxlen = opt<int>(\"maxlen\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and maxlen stay within problem constraints\n    n = min(n, 100);\n    maxlen = min(maxlen, 100);\n\n    // Variables for target string t, strings s_i, and their limits a_i\n    string t;\n    vector<string> s(n);\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate a random t\n        int tlen = rnd.next(1, maxlen);\n        t = \"\";\n        for (int i = 0; i < tlen; ++i) {\n            t += (char)rnd.next('a', 'z');\n        }\n        // Generate random s_i and a_i\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                s[i] += (char)rnd.next('a', 'z');\n            }\n            a[i] = rnd.next(0, si_len);\n        }\n    } else if (type == \"no_solution\") {\n        // Ensure t contains a character not in s_i\n        char missing_char;\n        do {\n            missing_char = (char)rnd.next('a', 'z');\n        } while (missing_char == 'z'); // Avoid 'z' to have another character to use\n\n        // Generate s_i without the missing_char\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                char c;\n                do {\n                    c = (char)rnd.next('a', 'z');\n                } while (c == missing_char);\n                s[i] += c;\n            }\n            a[i] = rnd.next(0, si_len);\n        }\n        // Generate t and include the missing_char\n        int tlen = rnd.next(1, maxlen);\n        t = \"\";\n        for (int i = 0; i < tlen; ++i) {\n            t += (char)rnd.next('a', 'z');\n        }\n        t[rnd.next(0, tlen - 1)] = missing_char; // Ensure t contains the missing character\n    } else if (type == \"tight_ai\") {\n        // Generate t and s_i such that ai is exactly what is needed\n        int tlen = rnd.next(1, maxlen);\n        t = \"\";\n        map<char, int> freq_t;\n        for (int i = 0; i < tlen; ++i) {\n            char c = (char)rnd.next('a', 'z');\n            t += c;\n            freq_t[c]++;\n        }\n        // Initialize s_i\n        for (int i = 0; i < n; ++i) {\n            s[i] = \"\";\n            a[i] = 0;\n        }\n        // Distribute character frequencies among s_i\n        vector<char> chars_in_t;\n        for (auto it : freq_t) {\n            chars_in_t.push_back(it.first);\n        }\n        for (auto it : freq_t) {\n            char c = it.first;\n            int total_needed = it.second;\n            int remaining = total_needed;\n            for (int i = 0; i < n && remaining > 0; ++i) {\n                int amount = rnd.next(0, remaining);\n                if (i == n - 1) amount = remaining; // Ensure we cover all\n                remaining -= amount;\n                if (amount > 0) {\n                    s[i] += string(amount, c);\n                    a[i] += amount;\n                }\n            }\n        }\n        // Add extra characters to s_i\n        for (int i = 0; i < n; ++i) {\n            int extra_len = rnd.next(0, maxlen - (int)s[i].length());\n            for (int j = 0; j < extra_len; ++j) {\n                s[i] += (char)rnd.next('a', 'z');\n            }\n            // Shuffle the string\n            shuffle(s[i].begin(), s[i].end());\n            // Set a_i to the exact number of needed deletions\n            a[i] = min(a[i], (int)s[i].length());\n        }\n    } else if (type == \"large_t\") {\n        // Generate t with maximum length\n        int tlen = maxlen;\n        t = \"\";\n        for (int i = 0; i < tlen; ++i) {\n            t += (char)rnd.next('a', 'z');\n        }\n        // Use maximum n\n        n = 100;\n        s.resize(n);\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                s[i] += (char)rnd.next('a', 'z');\n            }\n            a[i] = rnd.next(0, si_len);\n        }\n    } else if (type == \"max_n\") {\n        // Use maximum n\n        n = 100;\n        s.resize(n);\n        a.resize(n);\n        int tlen = rnd.next(1, maxlen);\n        t = \"\";\n        for (int i = 0; i < tlen; ++i) {\n            t += (char)rnd.next('a', 'z');\n        }\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                s[i] += (char)rnd.next('a', 'z');\n            }\n            a[i] = rnd.next(0, si_len);\n        }\n    } else if (type == \"single_char\") {\n        // t consists of the same character\n        char c = (char)rnd.next('a', 'z');\n        int tlen = rnd.next(1, maxlen);\n        t = string(tlen, c);\n        // Generate s_i\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                if (rnd.next(0, 1))\n                    s[i] += c;\n                else\n                    s[i] += (char)rnd.next('a', 'z');\n            }\n            // Set a_i to count of c in s_i\n            a[i] = rnd.next(0, (int)count(s[i].begin(), s[i].end(), c));\n        }\n    } else {\n        // Default to random if unknown type\n        int tlen = rnd.next(1, maxlen);\n        t = \"\";\n        for (int i = 0; i < tlen; ++i) {\n            t += (char)rnd.next('a', 'z');\n        }\n        // Generate s_i and a_i\n        for (int i = 0; i < n; ++i) {\n            int si_len = rnd.next(1, maxlen);\n            s[i] = \"\";\n            for (int j = 0; j < si_len; ++j) {\n                s[i] += (char)rnd.next('a', 'z');\n            }\n            a[i] = rnd.next(0, si_len);\n        }\n    }\n\n    // Output the test case\n    cout << t << endl;\n    cout << n << endl;\n    for (int i = 0; i < n; ++i) {\n        cout << s[i] << \" \" << a[i] << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 20 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random -maxlen 100\n\n./gen -n 10 -type no_solution\n./gen -n 20 -type no_solution\n./gen -n 50 -type no_solution\n./gen -n 100 -type no_solution -maxlen 100\n\n./gen -n 10 -type tight_ai\n./gen -n 20 -type tight_ai\n./gen -n 50 -type tight_ai\n./gen -n 100 -type tight_ai -maxlen 100\n\n./gen -n 10 -type large_t -maxlen 100\n./gen -n 100 -type large_t -maxlen 100\n\n./gen -n 100 -type max_n -maxlen 50\n\n./gen -n 10 -type single_char\n./gen -n 20 -type single_char\n./gen -n 50 -type single_char\n./gen -n 100 -type single_char -maxlen 100\n\n# Additional variations to cover more cases\n./gen -n 1 -type random\n./gen -n 1 -type no_solution\n./gen -n 1 -type tight_ai\n./gen -n 1 -type single_char\n\n./gen -n 100 -type random -maxlen 1\n\n./gen -n 50 -type random -maxlen 100\n\n./gen -n 75 -type tight_ai -maxlen 50\n\n./gen -n 30 -type single_char -maxlen 70\n\n./gen -n 100 -type no_solution -maxlen 100\n\n./gen -n 2 -type tight_ai -maxlen 100\n\n./gen -n 100 -type large_t -maxlen 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:55.332046",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "238/A",
      "title": "A. Not Wool Sequences",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of input contains two space-separated integers n and m (1 ≤ n, m ≤ 105).",
      "output_spec": "OutputPrint the required number of sequences modulo 1000000009 (109 + 9) on the only line of output.",
      "sample_tests": "ExamplesInputCopy3 2OutputCopy6",
      "description": "A. Not Wool Sequences\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line of input contains two space-separated integers n and m (1 ≤ n, m ≤ 105).\n\nOutputPrint the required number of sequences modulo 1000000009 (109 + 9) on the only line of output.\n\nInputCopy3 2OutputCopy6\n\nInputCopy3 2\n\nOutputCopy6\n\nNoteSequences of length 3 made of integers 0, 1, 2 and 3 that are not a wool sequence are (1, 3, 1), (1, 2, 1), (2, 1, 2), (2, 3, 2), (3, 1, 3) and (3, 2, 3).",
      "solutions": [
        {
          "title": "Codeforces Round #148 - Codeforces",
          "content": "Hi all! :)I'm glad to invite you to participate in Codeforces Round #148 today. I (Hamed Valizadeh) am the author of this round. I'd like to thank Gerald (Gerald Agapov) MikeMirzayanov (Mike Mirzayanov) Delinur (Maria Belova) and Saeed_Reza (SaeedReza Seddighin) who helped me in preparing the round.Score distribution will be the standard 500-1000-1500-2000-2500 in both divisions.Hope you find the problems interesting to solve.Good luck and have fun ;)Update. Contest is over. Congratulations to the winners of both divisions! :)Div1: tourist cerealguy Dmitry_Egorov RAVEman UESTC_Nocturne Div2: LiWenHaoTianXiaDiYi goooooooopan jthread kolina xcodevn And congrats to Endagorion who was the only one solving 238D - Tape Programming correctly during the contest.BTW, I hope you didn't get sick of that boring problem! :-\"Update 2. The editorial is ready now, sorry for the delay. http://codeforces.com/blog/entry/5765",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 238 和字母"
          },
          "content_length": 919
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces",
          "content": "Hi :)Here is the editorial for round #148. I just tried to explain the ideas rather than detailed implementation explanation. I'm sorry for my bad English, so please tell me if something is not clear in the descriptions.Two Bags of PotatoesThe author of this problem is Gerald. The total number of potatoes is a multiple of k and constraint there will be at most 105 multiples of k in range 1 to n. So you can iterate on multiples of k and print the ones that satisfy the problem.Easy Tape ProgrammingIn this problem you just need to simulate every thing which is written in the statement step by step. You can see a simple implementation of this here: http://www.codeforces.com/contest/239/submission/2512422Not Wool SequencesLet a1, ..., an be a not-wool-sequence. We define another sequence called b in which bi is xor of the first i elements of a, and b0 = 0.Now xor of elements of a consecutive subsequence like ai, ..., aj will be equal to . So we know that all elements of b should be different. Therefore b is a sequence of distinct integers of length n + 1 starting with 0 made of numbers 0 to 2m - 1. The number of such sequences is and this is the answer to problem.Boring PartitionComing soon...World Eater BrothersConsider we only want to change direction of minimum number of roads so that all other countries are reachable from a specific country x. This problem can be solved in O(n) and it's exactly what 219D - Choosing Capital for Treeland asks for. If you don't know how to solve it you can read the editorial of that contest.Consider two countries A and B which can be chosen by world eater brothers to achieve the minimum number of road direction changes. After changing the direction of roads, there exists a country on the undirected path between A and B which is reachable from both A and B using roads. We call such country a middle-country.We want to iterate on middle-countries and find the best two countries for ruling for each middle-country. For each neighbor of the current middle-country calculate the minimum number of road changes in the subtree rooted at that neighbor so that all countries will be reachable from some country in that subtree. Then from two of these subtrees we need to pick A and B and all other subtrees will have edges pointing to the root of subtree. This can be computed in O(n) for each middle-city. So the overall complexity will be O(n2).Tape ProgrammingThis problem was my favorite in the problemset. The primary point is that at any moment during the interpretation of a program only a prefix of the program is modified and used by IP.Consider we want to calculate the output of subsequence sl, ..., sr. While running the original program s1, ..., sn if at any moment CP enters the interval [l, r] it should be pointing to position l and the direction of DP should be right. So it's like we have started interpreting sl, ..., sr independently. The termination of execution of sl, ..., sr is the first time CP points to somewhere outside interval [l, r]. Therefore what we need to solve the problem is to run the original program. And after each termination if the program is nonempty then run it again until program is empty. Then we should keep a log of positions we have visited and the time of each visit and the number of printed digits of each type until then. After this preprocessing the to calculate the answer of query (li, ri) its enough to find the first time CP visited sli and the first time CP visited sri + 1 or sli - 1 after that.The described approach can be implemented in O(nlog(n) + qlog(n)).Meeting herConsider a bus passing a shortest path from si to ti. There are some points that are necessary to pass in order to obtain a shortest path. Firstly we compute them. This can be done in O(n3) with Floyd-Warshall and some processing after that. Urpal is sure that a bus from i-th company always passes such vertices on his path from si to ti. So he can get on a bus from i-th company only at vertices the bus surely passes.At any moment Urpal's status can be uniquely determined by his position on the map and the bus he's traveling with. So we have nk states (position, bus).Our goal is to reach some (b, ...) state from a (a, v) state which bus v surely passes a (source states). So let's find all states that can reach a goal state. We call such states good states.Consider Urpal is at junction x and he's traveling with a bus of type y. Let v1, v2, ..., vw be the list of junctions the bus might go on its shortest path from sy to ty. And let c1, c2, ..., cl be the list of companies that their bus surely passes junction x, excluding y-th company. For state (x, y) we know we can reach junction b (it's a good state) if one of the following is true: x = b, the minimum cost of solving the problem will be 0. All states (v1, y), (v2, y), ... and (vw, y) are good states, the minimum cost of solving the problem will be the maximum of all these states. At least one of states (x, c1), (x, c2), ... or (x, cl) is a good state, the minimum cost of solving the problem will be the minimum the good ones plus one. At first the only good states we know are states with junction b, (b, ...). Now some new states might have become good states. So we add those states to the list of known good states. We do this until no state becomes good anymore.At the end we print the minimum cost of source states which are good, and if they don't exist we print -1.The process thing can be implemented in O(n4). :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5483
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 1",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 2",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 3",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 4",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max_n\") {\n        n = 100000;\n        if (m == -1) m = rnd.next(1, 100000);\n    } else if (type == \"max_m\") {\n        m = 100000;\n        if (n == -1) n = rnd.next(1, 100000);\n    } else if (type == \"min_n\") {\n        n = 1;\n        if (m == -1) m = rnd.next(1, 100000);\n    } else if (type == \"min_m\") {\n        m = 1;\n        if (n == -1) n = rnd.next(1, 100000);\n    } else if (type == \"max_both\") {\n        n = 100000;\n        m = 100000;\n    } else if (type == \"min_both\") {\n        n = 1;\n        m = 1;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n    } else if (type == \"n_equals_m\") {\n        n = rnd.next(1, 100000);\n        m = n;\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, 100000);\n        if (m == -1) m = rnd.next(1, 100000);\n    } else {\n        // If type is unrecognized, default to random values\n        if (n == -1) n = rnd.next(1, 100000);\n        if (m == -1) m = rnd.next(1, 100000);\n    }\n\n    // Ensure n and m are within the allowed ranges\n    n = max(1, min(n, 100000));\n    m = max(1, min(m, 100000));\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max_n\") {\n        n = 100000;\n        if (m == -1) m = rnd.next(1, 100000);\n    } else if (type == \"max_m\") {\n        m = 100000;\n        if (n == -1) n = rnd.next(1, 100000);\n    } else if (type == \"min_n\") {\n        n = 1;\n        if (m == -1) m = rnd.next(1, 100000);\n    } else if (type == \"min_m\") {\n        m = 1;\n        if (n == -1) n = rnd.next(1, 100000);\n    } else if (type == \"max_both\") {\n        n = 100000;\n        m = 100000;\n    } else if (type == \"min_both\") {\n        n = 1;\n        m = 1;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n    } else if (type == \"n_equals_m\") {\n        n = rnd.next(1, 100000);\n        m = n;\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, 100000);\n        if (m == -1) m = rnd.next(1, 100000);\n    } else {\n        // If type is unrecognized, default to random values\n        if (n == -1) n = rnd.next(1, 100000);\n        if (m == -1) m = rnd.next(1, 100000);\n    }\n\n    // Ensure n and m are within the allowed ranges\n    n = max(1, min(n, 100000));\n    m = max(1, min(m, 100000));\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_both\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type min_n\n./gen -type min_n\n./gen -type min_n\n\n./gen -type min_m\n./gen -type min_m\n./gen -type min_m\n\n./gen -type n_equals_m\n./gen -type n_equals_m\n./gen -type n_equals_m\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type max_n\n./gen -type max_n\n\n./gen -type max_m\n./gen -type max_m\n\n./gen -type max_both\n\n./gen -n 1 -m 100000\n./gen -n 5 -m 100000\n\n./gen -n 100000 -m 1\n./gen -n 100000 -m 5\n\n./gen -n 100 -m 100\n\n./gen -n 99999 -m 99999\n\n./gen -n 12345 -m 67890\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:57.428055",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "238/B",
      "title": "B. Boring Partition",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integers n and h (2 ≤ n ≤ 105, 0 ≤ h ≤ 108). In the second line there is a list of n space-separated integers representing a1, a2, ..., an (0 ≤ ai ≤ 108).",
      "output_spec": "OutputThe first line of output should contain the required minimum goodness. The second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if ai is in the first subsequence otherwise it should be 2.If there are several possible correct answers you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy3 21 2 3OutputCopy11 2 2 InputCopy5 100 1 0 2 1OutputCopy32 2 2 2 2",
      "description": "B. Boring Partition\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains integers n and h (2 ≤ n ≤ 105, 0 ≤ h ≤ 108). In the second line there is a list of n space-separated integers representing a1, a2, ..., an (0 ≤ ai ≤ 108).\n\nOutputThe first line of output should contain the required minimum goodness. The second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if ai is in the first subsequence otherwise it should be 2.If there are several possible correct answers you are allowed to print any of them.\n\nInputCopy3 21 2 3OutputCopy11 2 2 InputCopy5 100 1 0 2 1OutputCopy32 2 2 2 2\n\nInputCopy3 21 2 3\n\nOutputCopy11 2 2\n\nInputCopy5 100 1 0 2 1\n\nOutputCopy32 2 2 2 2\n\nNoteIn the first sample the values of f are as follows: f(1, 2) = 1 + 2 + 2 = 5, f(1, 3) = 1 + 3 + 2 = 6 and f(2, 3) = 2 + 3 = 5. So the difference between maximum and minimum values of f is 1.In the second sample the value of h is large, so it's better for one of the sub-sequences to be empty.",
      "solutions": [
        {
          "title": "Codeforces Round #148 - Codeforces",
          "content": "Hi all! :)I'm glad to invite you to participate in Codeforces Round #148 today. I (Hamed Valizadeh) am the author of this round. I'd like to thank Gerald (Gerald Agapov) MikeMirzayanov (Mike Mirzayanov) Delinur (Maria Belova) and Saeed_Reza (SaeedReza Seddighin) who helped me in preparing the round.Score distribution will be the standard 500-1000-1500-2000-2500 in both divisions.Hope you find the problems interesting to solve.Good luck and have fun ;)Update. Contest is over. Congratulations to the winners of both divisions! :)Div1: tourist cerealguy Dmitry_Egorov RAVEman UESTC_Nocturne Div2: LiWenHaoTianXiaDiYi goooooooopan jthread kolina xcodevn And congrats to Endagorion who was the only one solving 238D - Tape Programming correctly during the contest.BTW, I hope you didn't get sick of that boring problem! :-\"Update 2. The editorial is ready now, sorry for the delay. http://codeforces.com/blog/entry/5765",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 238 和字母"
          },
          "content_length": 919
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces",
          "content": "Hi :)Here is the editorial for round #148. I just tried to explain the ideas rather than detailed implementation explanation. I'm sorry for my bad English, so please tell me if something is not clear in the descriptions.Two Bags of PotatoesThe author of this problem is Gerald. The total number of potatoes is a multiple of k and constraint there will be at most 105 multiples of k in range 1 to n. So you can iterate on multiples of k and print the ones that satisfy the problem.Easy Tape ProgrammingIn this problem you just need to simulate every thing which is written in the statement step by step. You can see a simple implementation of this here: http://www.codeforces.com/contest/239/submission/2512422Not Wool SequencesLet a1, ..., an be a not-wool-sequence. We define another sequence called b in which bi is xor of the first i elements of a, and b0 = 0.Now xor of elements of a consecutive subsequence like ai, ..., aj will be equal to . So we know that all elements of b should be different. Therefore b is a sequence of distinct integers of length n + 1 starting with 0 made of numbers 0 to 2m - 1. The number of such sequences is and this is the answer to problem.Boring PartitionComing soon...World Eater BrothersConsider we only want to change direction of minimum number of roads so that all other countries are reachable from a specific country x. This problem can be solved in O(n) and it's exactly what 219D - Choosing Capital for Treeland asks for. If you don't know how to solve it you can read the editorial of that contest.Consider two countries A and B which can be chosen by world eater brothers to achieve the minimum number of road direction changes. After changing the direction of roads, there exists a country on the undirected path between A and B which is reachable from both A and B using roads. We call such country a middle-country.We want to iterate on middle-countries and find the best two countries for ruling for each middle-country. For each neighbor of the current middle-country calculate the minimum number of road changes in the subtree rooted at that neighbor so that all countries will be reachable from some country in that subtree. Then from two of these subtrees we need to pick A and B and all other subtrees will have edges pointing to the root of subtree. This can be computed in O(n) for each middle-city. So the overall complexity will be O(n2).Tape ProgrammingThis problem was my favorite in the problemset. The primary point is that at any moment during the interpretation of a program only a prefix of the program is modified and used by IP.Consider we want to calculate the output of subsequence sl, ..., sr. While running the original program s1, ..., sn if at any moment CP enters the interval [l, r] it should be pointing to position l and the direction of DP should be right. So it's like we have started interpreting sl, ..., sr independently. The termination of execution of sl, ..., sr is the first time CP points to somewhere outside interval [l, r]. Therefore what we need to solve the problem is to run the original program. And after each termination if the program is nonempty then run it again until program is empty. Then we should keep a log of positions we have visited and the time of each visit and the number of printed digits of each type until then. After this preprocessing the to calculate the answer of query (li, ri) its enough to find the first time CP visited sli and the first time CP visited sri + 1 or sli - 1 after that.The described approach can be implemented in O(nlog(n) + qlog(n)).Meeting herConsider a bus passing a shortest path from si to ti. There are some points that are necessary to pass in order to obtain a shortest path. Firstly we compute them. This can be done in O(n3) with Floyd-Warshall and some processing after that. Urpal is sure that a bus from i-th company always passes such vertices on his path from si to ti. So he can get on a bus from i-th company only at vertices the bus surely passes.At any moment Urpal's status can be uniquely determined by his position on the map and the bus he's traveling with. So we have nk states (position, bus).Our goal is to reach some (b, ...) state from a (a, v) state which bus v surely passes a (source states). So let's find all states that can reach a goal state. We call such states good states.Consider Urpal is at junction x and he's traveling with a bus of type y. Let v1, v2, ..., vw be the list of junctions the bus might go on its shortest path from sy to ty. And let c1, c2, ..., cl be the list of companies that their bus surely passes junction x, excluding y-th company. For state (x, y) we know we can reach junction b (it's a good state) if one of the following is true: x = b, the minimum cost of solving the problem will be 0. All states (v1, y), (v2, y), ... and (vw, y) are good states, the minimum cost of solving the problem will be the maximum of all these states. At least one of states (x, c1), (x, c2), ... or (x, cl) is a good state, the minimum cost of solving the problem will be the minimum the good ones plus one. At first the only good states we know are states with junction b, (b, ...). Now some new states might have become good states. So we add those states to the list of known good states. We do this until no state becomes good anymore.At the end we print the minimum cost of source states which are good, and if they don't exist we print -1.The process thing can be implemented in O(n4). :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5483
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 1",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 2",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 3",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 4",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int h = inf.readInt(0, 100000000, \"h\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int h = inf.readInt(0, 100000000, \"h\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int h = inf.readInt(0, 100000000, \"h\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll computeGoodness(const vector<int> &a, const vector<int> &P, int h) {\n    int n = a.size();\n    vector<int> s1_ai, s2_ai;\n    for (int i = 0; i < n; ++i) {\n        if (P[i] == 1) {\n            s1_ai.push_back(a[i]);\n        } else if (P[i] == 2) {\n            s2_ai.push_back(a[i]);\n        } else {\n            // This should not happen as we validate P[i] earlier\n            return -1;\n        }\n    }\n    ll min_same_1 = LLONG_MAX, max_same_1 = LLONG_MIN;\n    ll min_same_2 = LLONG_MAX, max_same_2 = LLONG_MIN;\n\n    if (s1_ai.size() >= 2) {\n        sort(s1_ai.begin(), s1_ai.end());\n        min_same_1 = s1_ai[0] + s1_ai[1];\n        max_same_1 = s1_ai[s1_ai.size() - 2] + s1_ai[s1_ai.size() - 1];\n    }\n    if (s2_ai.size() >=2) {\n        sort(s2_ai.begin(), s2_ai.end());\n        min_same_2 = s2_ai[0] + s2_ai[1];\n        max_same_2 = s2_ai[s2_ai.size() - 2] + s2_ai[s2_ai.size() - 1];\n    }\n\n    ll min_same = min(min_same_1, min_same_2);\n    ll max_same = max(max_same_1, max_same_2);\n\n    if (min_same == LLONG_MAX) min_same = LLONG_MAX;\n    if (max_same == LLONG_MIN) max_same = LLONG_MIN;\n\n    ll min_different = LLONG_MAX;\n    ll max_different = LLONG_MIN;\n\n    if (!s1_ai.empty() && !s2_ai.empty()) {\n        int s1_min = *min_element(s1_ai.begin(), s1_ai.end());\n        int s1_max = *max_element(s1_ai.begin(), s1_ai.end());\n        int s2_min = *min_element(s2_ai.begin(), s2_ai.end());\n        int s2_max = *max_element(s2_ai.begin(), s2_ai.end());\n        min_different = (ll)s1_min + s2_min + h;\n        max_different = (ll)s1_max + s2_max + h;\n    }\n\n    ll min_f = min(min_same, min_different);\n    if (min_f == LLONG_MAX) min_f = 0; // No pairs\n    ll max_f = max(max_same, max_different);\n    if (max_f == LLONG_MIN) max_f = 0; // No pairs\n\n    ll goodness = max_f - min_f;\n    return goodness;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(2, 100000);\n    int h = inf.readInt(0, 100000000);\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        a[i] = inf.readInt(0, 100000000);\n    // Read jury's answer\n    ll G_jury = ans.readLong();\n    vector<int> P_jury(n);\n    for (int i = 0; i < n; ++i)\n        P_jury[i] = ans.readInt(1,2);\n    // Read participant's answer\n    ll G_participant = ouf.readLong();\n    vector<int> P_participant(n);\n    for (int i = 0; i < n; ++i) {\n        P_participant[i] = ouf.readInt();\n        if (P_participant[i] != 1 && P_participant[i] !=2)\n            ouf.quitf(_wa, \"Invalid partition element P[%d] = %d\", i+1, P_participant[i]);\n    }\n    // Compute goodness for participant's partition\n    ll G_p = computeGoodness(a, P_participant, h);\n    if (G_p != G_participant)\n        quitf(_wa, \"Goodness claimed %lld does not match computed goodness %lld\", G_participant, G_p);\n    if (G_participant > G_jury)\n        quitf(_wa, \"Participant's goodness %lld is worse than jury's goodness %lld\", G_participant, G_jury);\n    else if (G_participant == G_jury)\n        quitf(_ok, \"Goodness = %lld\", G_participant);\n    else // G_participant < G_jury\n        quitf(_fail, \"Participant's goodness %lld is better than jury's goodness %lld\", G_participant, G_jury);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int h = opt<int>(\"h\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        /* Generate random ai in [0, max_ai] */\n        int max_ai = opt<int>(\"max_ai\", 100000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, max_ai);\n        }\n    } else if (type == \"all_same\") {\n        int value = opt<int>(\"value\", rnd.next(0, 100000000));\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"max_ai\") {\n        /* All ai are maximum value */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000000;\n        }\n    } else if (type == \"min_ai\") {\n        /* All ai are zero */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"alternate\") {\n        /* Alternate between small and large values */\n        int small_value = opt<int>(\"small\", 0);\n        int large_value = opt<int>(\"large\", 100000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? small_value : large_value;\n        }\n    } else if (type == \"increasing\") {\n        /* ai increases from 0 to max_ai */\n        int max_ai = opt<int>(\"max_ai\", 100000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (long long)i * max_ai / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        /* ai decreases from max_ai to 0 */\n        int max_ai = opt<int>(\"max_ai\", 100000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_ai - ((long long)i * max_ai / (n - 1));\n        }\n    } else if (type == \"small_variance\") {\n        /* ai are small values with small variance */\n        int base_value = opt<int>(\"base\", 10000);\n        int variance = opt<int>(\"variance\", 100);\n        for (int i = 0; i < n; ++i) {\n            a[i] = base_value + rnd.next(-variance, variance);\n            if (a[i] < 0) a[i] = 0;\n            if (a[i] > 100000000) a[i] = 100000000;\n        }\n    } else if (type == \"large_variance\") {\n        /* ai are random values with large variance */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000000);\n        }\n    } else if (type == \"zeros\") {\n        /* All ai are zero */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000000);\n        }\n    }\n\n    /* Output n h */\n    printf(\"%d %d\\n\", n, h);\n\n    /* Output ai */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n -1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int h = opt<int>(\"h\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        /* Generate random ai in [0, max_ai] */\n        int max_ai = opt<int>(\"max_ai\", 100000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, max_ai);\n        }\n    } else if (type == \"all_same\") {\n        int value = opt<int>(\"value\", rnd.next(0, 100000000));\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"max_ai\") {\n        /* All ai are maximum value */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000000;\n        }\n    } else if (type == \"min_ai\") {\n        /* All ai are zero */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"alternate\") {\n        /* Alternate between small and large values */\n        int small_value = opt<int>(\"small\", 0);\n        int large_value = opt<int>(\"large\", 100000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? small_value : large_value;\n        }\n    } else if (type == \"increasing\") {\n        /* ai increases from 0 to max_ai */\n        int max_ai = opt<int>(\"max_ai\", 100000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (long long)i * max_ai / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        /* ai decreases from max_ai to 0 */\n        int max_ai = opt<int>(\"max_ai\", 100000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_ai - ((long long)i * max_ai / (n - 1));\n        }\n    } else if (type == \"small_variance\") {\n        /* ai are small values with small variance */\n        int base_value = opt<int>(\"base\", 10000);\n        int variance = opt<int>(\"variance\", 100);\n        for (int i = 0; i < n; ++i) {\n            a[i] = base_value + rnd.next(-variance, variance);\n            if (a[i] < 0) a[i] = 0;\n            if (a[i] > 100000000) a[i] = 100000000;\n        }\n    } else if (type == \"large_variance\") {\n        /* ai are random values with large variance */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000000);\n        }\n    } else if (type == \"zeros\") {\n        /* All ai are zero */\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 100000000);\n        }\n    }\n\n    /* Output n h */\n    printf(\"%d %d\\n\", n, h);\n\n    /* Output ai */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n -1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random ai, h=0\n./gen -n 2 -h 0 -type random\n\n# Small n, random ai, h large\n./gen -n 2 -h 100000000 -type random\n\n# Small n, ai zeros, h=0\n./gen -n 2 -h 0 -type zeros\n\n# Small n, ai zeros, h large\n./gen -n 2 -h 100000000 -type zeros\n\n# n=10, random ai, h small\n./gen -n 10 -h 1 -type random\n\n# n=10, random ai, h large\n./gen -n 10 -h 100000000 -type random\n\n# n=100, ai all same\n./gen -n 100 -h 0 -type all_same -value 50000\n\n# n=100, ai all same, h large\n./gen -n 100 -h 100000000 -type all_same -value 100000000\n\n# n=1000, ai increasing\n./gen -n 1000 -h 10000 -type increasing -max_ai 100000000\n\n# n=1000, ai decreasing\n./gen -n 1000 -h 10000 -type decreasing -max_ai 100000000\n\n# n=10000, ai alternate between small and large\n./gen -n 10000 -h 50000 -type alternate -small 0 -large 100000000\n\n# n=10000, ai with small variance\n./gen -n 10000 -h 1000 -type small_variance -base 50000 -variance 1000\n\n# n=100000, ai random, h=0\n./gen -n 100000 -h 0 -type random\n\n# n=100000, ai random, h=100000000\n./gen -n 100000 -h 100000000 -type random\n\n# n=100000, ai max_ai\n./gen -n 100000 -h 100000000 -type max_ai\n\n# n=100000, ai min_ai\n./gen -n 100000 -h 100000000 -type min_ai\n\n# n=100000, ai with large variance\n./gen -n 100000 -h 50000000 -type large_variance\n\n# n=100000, h=0, ai random\n./gen -n 100000 -h 0 -type random\n\n# n=100000, h=1, ai random\n./gen -n 100000 -h 1 -type random\n\n# n=2, h=50000000, ai extreme values\n./gen -n 2 -h 50000000 -type alternate -small 0 -large 100000000\n\n# n=2, h=0, ai extreme values\n./gen -n 2 -h 0 -type alternate -small 0 -large 100000000\n\n# n=99999, h=1, ai random\n./gen -n 99999 -h 1 -type random\n\n# n=99999, h=100000000, ai random\n./gen -n 99999 -h 100000000 -type random\n\n# n=100000, ai increasing with max_ai=1000000\n./gen -n 100000 -h 10000000 -type increasing -max_ai 1000000\n\n# n=100000, ai decreasing with max_ai=1000000\n./gen -n 100000 -h 10000000 -type decreasing -max_ai 1000000\n\n# n=100000, ai zeros, h=10000\n./gen -n 100000 -h 10000 -type zeros\n\n# n=100000, ai ones\n./gen -n 100000 -h 100000000 -type all_same -value 1\n\n# n=100000, ai all same, h=0\n./gen -n 100000 -h 0 -type all_same -value 1000\n\n# n=100000, ai small variance around large value\n./gen -n 100000 -h 10000 -type small_variance -base 100000000 -variance 1000\n\n# n=100000, ai small variance around small value\n./gen -n 100000 -h 10000 -type small_variance -base 0 -variance 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:53:59.456355",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "238/C",
      "title": "C. World Eater Brothers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains an integer n (1 ≤ n ≤ 3000). Each of the next n - 1 lines contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi) saying there is a road from country ai to country bi.Consider that countries are numbered from 1 to n. It's guaranteed that if you don't consider direction of the roads there is a unique path between every pair of countries in the world, passing through each road at most once.",
      "output_spec": "OutputIn the only line of output print the minimum number of roads that their direction should be changed so that the brothers will be able to rule the world.",
      "sample_tests": "ExamplesInputCopy42 13 14 1OutputCopy1InputCopy52 12 34 34 5OutputCopy0",
      "description": "C. World Eater Brothers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains an integer n (1 ≤ n ≤ 3000). Each of the next n - 1 lines contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi) saying there is a road from country ai to country bi.Consider that countries are numbered from 1 to n. It's guaranteed that if you don't consider direction of the roads there is a unique path between every pair of countries in the world, passing through each road at most once.\n\nOutputIn the only line of output print the minimum number of roads that their direction should be changed so that the brothers will be able to rule the world.\n\nInputCopy42 13 14 1OutputCopy1InputCopy52 12 34 34 5OutputCopy0\n\nInputCopy42 13 14 1\n\nOutputCopy1\n\nInputCopy52 12 34 34 5\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #148 - Codeforces",
          "content": "Hi all! :)I'm glad to invite you to participate in Codeforces Round #148 today. I (Hamed Valizadeh) am the author of this round. I'd like to thank Gerald (Gerald Agapov) MikeMirzayanov (Mike Mirzayanov) Delinur (Maria Belova) and Saeed_Reza (SaeedReza Seddighin) who helped me in preparing the round.Score distribution will be the standard 500-1000-1500-2000-2500 in both divisions.Hope you find the problems interesting to solve.Good luck and have fun ;)Update. Contest is over. Congratulations to the winners of both divisions! :)Div1: tourist cerealguy Dmitry_Egorov RAVEman UESTC_Nocturne Div2: LiWenHaoTianXiaDiYi goooooooopan jthread kolina xcodevn And congrats to Endagorion who was the only one solving 238D - Tape Programming correctly during the contest.BTW, I hope you didn't get sick of that boring problem! :-\"Update 2. The editorial is ready now, sorry for the delay. http://codeforces.com/blog/entry/5765",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 238 和字母"
          },
          "content_length": 919
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces",
          "content": "Hi :)Here is the editorial for round #148. I just tried to explain the ideas rather than detailed implementation explanation. I'm sorry for my bad English, so please tell me if something is not clear in the descriptions.Two Bags of PotatoesThe author of this problem is Gerald. The total number of potatoes is a multiple of k and constraint there will be at most 105 multiples of k in range 1 to n. So you can iterate on multiples of k and print the ones that satisfy the problem.Easy Tape ProgrammingIn this problem you just need to simulate every thing which is written in the statement step by step. You can see a simple implementation of this here: http://www.codeforces.com/contest/239/submission/2512422Not Wool SequencesLet a1, ..., an be a not-wool-sequence. We define another sequence called b in which bi is xor of the first i elements of a, and b0 = 0.Now xor of elements of a consecutive subsequence like ai, ..., aj will be equal to . So we know that all elements of b should be different. Therefore b is a sequence of distinct integers of length n + 1 starting with 0 made of numbers 0 to 2m - 1. The number of such sequences is and this is the answer to problem.Boring PartitionComing soon...World Eater BrothersConsider we only want to change direction of minimum number of roads so that all other countries are reachable from a specific country x. This problem can be solved in O(n) and it's exactly what 219D - Choosing Capital for Treeland asks for. If you don't know how to solve it you can read the editorial of that contest.Consider two countries A and B which can be chosen by world eater brothers to achieve the minimum number of road direction changes. After changing the direction of roads, there exists a country on the undirected path between A and B which is reachable from both A and B using roads. We call such country a middle-country.We want to iterate on middle-countries and find the best two countries for ruling for each middle-country. For each neighbor of the current middle-country calculate the minimum number of road changes in the subtree rooted at that neighbor so that all countries will be reachable from some country in that subtree. Then from two of these subtrees we need to pick A and B and all other subtrees will have edges pointing to the root of subtree. This can be computed in O(n) for each middle-city. So the overall complexity will be O(n2).Tape ProgrammingThis problem was my favorite in the problemset. The primary point is that at any moment during the interpretation of a program only a prefix of the program is modified and used by IP.Consider we want to calculate the output of subsequence sl, ..., sr. While running the original program s1, ..., sn if at any moment CP enters the interval [l, r] it should be pointing to position l and the direction of DP should be right. So it's like we have started interpreting sl, ..., sr independently. The termination of execution of sl, ..., sr is the first time CP points to somewhere outside interval [l, r]. Therefore what we need to solve the problem is to run the original program. And after each termination if the program is nonempty then run it again until program is empty. Then we should keep a log of positions we have visited and the time of each visit and the number of printed digits of each type until then. After this preprocessing the to calculate the answer of query (li, ri) its enough to find the first time CP visited sli and the first time CP visited sri + 1 or sli - 1 after that.The described approach can be implemented in O(nlog(n) + qlog(n)).Meeting herConsider a bus passing a shortest path from si to ti. There are some points that are necessary to pass in order to obtain a shortest path. Firstly we compute them. This can be done in O(n3) with Floyd-Warshall and some processing after that. Urpal is sure that a bus from i-th company always passes such vertices on his path from si to ti. So he can get on a bus from i-th company only at vertices the bus surely passes.At any moment Urpal's status can be uniquely determined by his position on the map and the bus he's traveling with. So we have nk states (position, bus).Our goal is to reach some (b, ...) state from a (a, v) state which bus v surely passes a (source states). So let's find all states that can reach a goal state. We call such states good states.Consider Urpal is at junction x and he's traveling with a bus of type y. Let v1, v2, ..., vw be the list of junctions the bus might go on its shortest path from sy to ty. And let c1, c2, ..., cl be the list of companies that their bus surely passes junction x, excluding y-th company. For state (x, y) we know we can reach junction b (it's a good state) if one of the following is true: x = b, the minimum cost of solving the problem will be 0. All states (v1, y), (v2, y), ... and (vw, y) are good states, the minimum cost of solving the problem will be the maximum of all these states. At least one of states (x, c1), (x, c2), ... or (x, cl) is a good state, the minimum cost of solving the problem will be the minimum the good ones plus one. At first the only good states we know are states with junction b, (b, ...). Now some new states might have become good states. So we add those states to the list of known good states. We do this until no state becomes good anymore.At the end we print the minimum cost of source states which are good, and if they don't exist we print -1.The process thing can be implemented in O(n4). :)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5483
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 1",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 2",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 3",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "Qingyu"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 4",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nint n;\nset<pair<int, int>> edgeSet;\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, u);\n        } else if (v != parent) {\n            ensuref(false, \"Graph contains a cycle involving edge %d-%d\", u, v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n\n    adj.resize(n + 1); // Nodes are numbered from 1 to n\n    for (int i = 0; i < n - 1; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai and bi must be different, but both are %d\", ai);\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between nodes %d and %d\", u, v);\n        edgeSet.insert(edge);\n        adj[ai].push_back(bi);\n        adj[bi].push_back(ai);\n    }\n\n    visited.resize(n + 1, false);\n    dfs(1, -1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is disconnected, node %d is not reachable from node 1\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nint n;\nset<pair<int, int>> edgeSet;\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, u);\n        } else if (v != parent) {\n            ensuref(false, \"Graph contains a cycle involving edge %d-%d\", u, v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n\n    adj.resize(n + 1); // Nodes are numbered from 1 to n\n    for (int i = 0; i < n - 1; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai and bi must be different, but both are %d\", ai);\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between nodes %d and %d\", u, v);\n        edgeSet.insert(edge);\n        adj[ai].push_back(bi);\n        adj[bi].push_back(ai);\n    }\n\n    visited.resize(n + 1, false);\n    dfs(1, -1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is disconnected, node %d is not reachable from node 1\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\nint n;\nset<pair<int, int>> edgeSet;\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, u);\n        } else if (v != parent) {\n            ensuref(false, \"Graph contains a cycle involving edge %d-%d\", u, v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n\n    adj.resize(n + 1); // Nodes are numbered from 1 to n\n    for (int i = 0; i < n - 1; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai and bi must be different, but both are %d\", ai);\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between nodes %d and %d\", u, v);\n        edgeSet.insert(edge);\n        adj[ai].push_back(bi);\n        adj[bi].push_back(ai);\n    }\n\n    visited.resize(n + 1, false);\n    dfs(1, -1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is disconnected, node %d is not reachable from node 1\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string direction_type = opt<string>(\"direction_type\", \"random\");\n    \n    vector<int> p(n);\n    \n    if (tree_type == \"chain\") {\n        // Generate a chain\n        for(int i = 1; i < n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        // Generate a star\n        for(int i = 1; i < n; ++i) {\n            p[i] = 0;\n        }\n    } else if (tree_type == \"caterpillar\") {\n        // Generate a caterpillar: a central path with leaves\n        int backbone_len = max(1, n / 2);\n        for(int i = 1; i < backbone_len; ++i) {\n            p[i] = i - 1;\n        }\n        for(int i = backbone_len; i < n; ++i) {\n            p[i] = rnd.next(0, backbone_len - 1);\n        }\n    } else {\n        // Random tree\n        for(int i = 1; i < n; ++i) {\n            p[i] = rnd.next(0, i - 1);\n        }\n    }\n\n    // Now assign edge directions\n    vector<pair<int, int>> edges;\n\n    for(int i = 1; i < n; ++i) {\n        int u = i;\n        int v = p[i];\n        \n        if (direction_type == \"towards_root\") {\n            edges.push_back({u, v});\n        } else if (direction_type == \"away_from_root\") {\n            edges.push_back({v, u});\n        } else if (direction_type == \"random\") {\n            if(rnd.next(0, 1)) {\n                edges.push_back({u, v});\n            } else {\n                edges.push_back({v, u});\n            }\n        } else if (direction_type == \"balanced\") {\n            // Alternate directions\n            if (i % 2 == 0) {\n                edges.push_back({u, v});\n            } else {\n                edges.push_back({v, u});\n            }\n        } else {\n            // Default random direction\n            if(rnd.next(0, 1)) {\n                edges.push_back({u, v});\n            } else {\n                edges.push_back({v, u});\n            }\n        }\n    }\n\n    // Optionally shuffle nodes\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i)\n        perm[i] = i;\n\n    shuffle(perm.begin(), perm.end());\n\n    // Relabel edges according to permuted node labels\n    for(auto & edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output edges\n    for(auto & edge : edges) {\n        printf(\"%d %d\\n\", edge.first + 1, edge.second + 1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string direction_type = opt<string>(\"direction_type\", \"random\");\n    \n    vector<int> p(n);\n    \n    if (tree_type == \"chain\") {\n        // Generate a chain\n        for(int i = 1; i < n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        // Generate a star\n        for(int i = 1; i < n; ++i) {\n            p[i] = 0;\n        }\n    } else if (tree_type == \"caterpillar\") {\n        // Generate a caterpillar: a central path with leaves\n        int backbone_len = max(1, n / 2);\n        for(int i = 1; i < backbone_len; ++i) {\n            p[i] = i - 1;\n        }\n        for(int i = backbone_len; i < n; ++i) {\n            p[i] = rnd.next(0, backbone_len - 1);\n        }\n    } else {\n        // Random tree\n        for(int i = 1; i < n; ++i) {\n            p[i] = rnd.next(0, i - 1);\n        }\n    }\n\n    // Now assign edge directions\n    vector<pair<int, int>> edges;\n\n    for(int i = 1; i < n; ++i) {\n        int u = i;\n        int v = p[i];\n        \n        if (direction_type == \"towards_root\") {\n            edges.push_back({u, v});\n        } else if (direction_type == \"away_from_root\") {\n            edges.push_back({v, u});\n        } else if (direction_type == \"random\") {\n            if(rnd.next(0, 1)) {\n                edges.push_back({u, v});\n            } else {\n                edges.push_back({v, u});\n            }\n        } else if (direction_type == \"balanced\") {\n            // Alternate directions\n            if (i % 2 == 0) {\n                edges.push_back({u, v});\n            } else {\n                edges.push_back({v, u});\n            }\n        } else {\n            // Default random direction\n            if(rnd.next(0, 1)) {\n                edges.push_back({u, v});\n            } else {\n                edges.push_back({v, u});\n            }\n        }\n    }\n\n    // Optionally shuffle nodes\n    vector<int> perm(n);\n    for(int i = 0; i < n; ++i)\n        perm[i] = i;\n\n    shuffle(perm.begin(), perm.end());\n\n    // Relabel edges according to permuted node labels\n    for(auto & edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output edges\n    for(auto & edge : edges) {\n        printf(\"%d %d\\n\", edge.first + 1, edge.second + 1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -tree_type chain -direction_type towards_root\n./gen -n 2 -tree_type chain -direction_type towards_root\n./gen -n 2 -tree_type chain -direction_type away_from_root\n./gen -n 3 -tree_type star -direction_type towards_root\n./gen -n 3 -tree_type star -direction_type away_from_root\n./gen -n 10 -tree_type chain -direction_type towards_root\n./gen -n 10 -tree_type chain -direction_type away_from_root\n./gen -n 10 -tree_type chain -direction_type random\n./gen -n 10 -tree_type star -direction_type towards_root\n./gen -n 10 -tree_type star -direction_type away_from_root\n./gen -n 10 -tree_type star -direction_type random\n./gen -n 10 -tree_type random -direction_type random\n./gen -n 50 -tree_type chain -direction_type balanced\n./gen -n 100 -tree_type random -direction_type random\n./gen -n 100 -tree_type chain -direction_type balanced\n./gen -n 100 -tree_type star -direction_type towards_root\n./gen -n 100 -tree_type star -direction_type away_from_root\n./gen -n 1000 -tree_type random -direction_type random\n./gen -n 3000 -tree_type random -direction_type random\n./gen -n 3000 -tree_type chain -direction_type towards_root\n./gen -n 3000 -tree_type chain -direction_type away_from_root\n./gen -n 3000 -tree_type star -direction_type towards_root\n./gen -n 3000 -tree_type star -direction_type away_from_root\n./gen -n 3000 -tree_type random -direction_type balanced\n./gen -n 3000 -tree_type chain -direction_type balanced\n./gen -n 3000 -tree_type random -direction_type towards_root\n./gen -n 3000 -tree_type random -direction_type away_from_root\n./gen -n 2999 -tree_type random -direction_type random\n./gen -n 2999 -tree_type star -direction_type random\n./gen -n 2999 -tree_type chain -direction_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:54:01.215979",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "238/D",
      "title": "D. Tape Programming",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers n and q (1 ≤ n, q ≤ 105) — represents the length of the sequence s and the number of queries. The second line contains s, a sequence of \"<\", \">\" and digits (0..9) written from left to right. Note, that the characters of s are not separated with spaces. The next q lines each contains two integers li and ri (1 ≤ li ≤ ri ≤ n) — the i-th query.",
      "output_spec": "OutputFor each query print 10 space separated integers: x0, x1, ..., x9 where xi equals the number of times the interpreter prints i while running the corresponding program. Print answers to the queries in the order they are given in input.",
      "sample_tests": "ExamplesInputCopy7 41>3>22<1 34 77 71 7OutputCopy0 1 0 1 0 0 0 0 0 02 2 2 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 02 3 2 1 0 0 0 0 0 0",
      "description": "D. Tape Programming\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains two integers n and q (1 ≤ n, q ≤ 105) — represents the length of the sequence s and the number of queries. The second line contains s, a sequence of \"<\", \">\" and digits (0..9) written from left to right. Note, that the characters of s are not separated with spaces. The next q lines each contains two integers li and ri (1 ≤ li ≤ ri ≤ n) — the i-th query.\n\nOutputFor each query print 10 space separated integers: x0, x1, ..., x9 where xi equals the number of times the interpreter prints i while running the corresponding program. Print answers to the queries in the order they are given in input.\n\nInputCopy7 41>3>22<1 34 77 71 7OutputCopy0 1 0 1 0 0 0 0 0 02 2 2 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 02 3 2 1 0 0 0 0 0 0\n\nInputCopy7 41>3>22<1 34 77 71 7\n\nOutputCopy0 1 0 1 0 0 0 0 0 02 2 2 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 02 3 2 1 0 0 0 0 0 0",
      "solutions": [
        {
          "title": "Codeforces Round #148 - Codeforces",
          "content": "Hi all! :)I'm glad to invite you to participate in Codeforces Round #148 today. I (Hamed Valizadeh) am the author of this round. I'd like to thank Gerald (Gerald Agapov) MikeMirzayanov (Mike Mirzayanov) Delinur (Maria Belova) and Saeed_Reza (SaeedReza Seddighin) who helped me in preparing the round.Score distribution will be the standard 500-1000-1500-2000-2500 in both divisions.Hope you find the problems interesting to solve.Good luck and have fun ;)Update. Contest is over. Congratulations to the winners of both divisions! :)Div1: tourist cerealguy Dmitry_Egorov RAVEman UESTC_Nocturne Div2: LiWenHaoTianXiaDiYi goooooooopan jthread kolina xcodevn And congrats to Endagorion who was the only one solving 238D - Tape Programming correctly during the contest.BTW, I hope you didn't get sick of that boring problem! :-\"Update 2. The editorial is ready now, sorry for the delay. http://codeforces.com/blog/entry/5765",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 238\\s*D"
          },
          "content_length": 919
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces",
          "content": "Hi :)Here is the editorial for round #148. I just tried to explain the ideas rather than detailed implementation explanation. I'm sorry for my bad English, so please tell me if something is not clear in the descriptions.Two Bags of PotatoesThe author of this problem is Gerald. The total number of potatoes is a multiple of k and constraint there will be at most 105 multiples of k in range 1 to n. So you can iterate on multiples of k and print the ones that satisfy the problem.Easy Tape ProgrammingIn this problem you just need to simulate every thing which is written in the statement step by step. You can see a simple implementation of this here: http://www.codeforces.com/contest/239/submission/2512422Not Wool SequencesLet a1, ..., an be a not-wool-sequence. We define another sequence called b in which bi is xor of the first i elements of a, and b0 = 0.Now xor of elements of a consecutive subsequence like ai, ..., aj will be equal to . So we know that all elements of b should be different. Therefore b is a sequence of distinct integers of length n + 1 starting with 0 made of numbers 0 to 2m - 1. The number of such sequences is and this is the answer to problem.Boring PartitionComing soon...World Eater BrothersConsider we only want to change direction of minimum number of roads so that all other countries are reachable from a specific country x. This problem can be solved in O(n) and it's exactly what 219D - Choosing Capital for Treeland asks for. If you don't know how to solve it you can read the editorial of that contest.Consider two countries A and B which can be chosen by world eater brothers to achieve the minimum number of road direction changes. After changing the direction of roads, there exists a country on the undirected path between A and B which is reachable from both A and B using roads. We call such country a middle-country.We want to iterate on middle-countries and find the best two countries for ruling for each middle-country. For each neighbor of the current middle-country calculate the minimum number of road changes in the subtree rooted at that neighbor so that all countries will be reachable from some country in that subtree. Then from two of these subtrees we need to pick A and B and all other subtrees will have edges pointing to the root of subtree. This can be computed in O(n) for each middle-city. So the overall complexity will be O(n2).Tape ProgrammingThis problem was my favorite in the problemset. The primary point is that at any moment during the interpretation of a program only a prefix of the program is modified and used by IP.Consider we want to calculate the output of subsequence sl, ..., sr. While running the original program s1, ..., sn if at any moment CP enters the interval [l, r] it should be pointing to position l and the direction of DP should be right. So it's like we have started interpreting sl, ..., sr independently. The termination of execution of sl, ..., sr is the first time CP points to somewhere outside interval [l, r]. Therefore what we need to solve the problem is to run the original program. And after each termination if the program is nonempty then run it again until program is empty. Then we should keep a log of positions we have visited and the time of each visit and the number of printed digits of each type until then. After this preprocessing the to calculate the answer of query (li, ri) its enough to find the first time CP visited sli and the first time CP visited sri + 1 or sli - 1 after that.The described approach can be implemented in O(nlog(n) + qlog(n)).Meeting herConsider a bus passing a shortest path from si to ti. There are some points that are necessary to pass in order to obtain a shortest path. Firstly we compute them. This can be done in O(n3) with Floyd-Warshall and some processing after that. Urpal is sure that a bus from i-th company always passes such vertices on his path from si to ti. So he can get on a bus from i-th company only at vertices the bus surely passes.At any moment Urpal's status can be uniquely determined by his position on the map and the bus he's traveling with. So we have nk states (position, bus).Our goal is to reach some (b, ...) state from a (a, v) state which bus v surely passes a (source states). So let's find all states that can reach a goal state. We call such states good states.Consider Urpal is at junction x and he's traveling with a bus of type y. Let v1, v2, ..., vw be the list of junctions the bus might go on its shortest path from sy to ty. And let c1, c2, ..., cl be the list of companies that their bus surely passes junction x, excluding y-th company. For state (x, y) we know we can reach junction b (it's a good state) if one of the following is true: x = b, the minimum cost of solving the problem will be 0. All states (v1, y), (v2, y), ... and (vw, y) are good states, the minimum cost of solving the problem will be the maximum of all these states. At least one of states (x, c1), (x, c2), ... or (x, cl) is a good state, the minimum cost of solving the problem will be the minimum the good ones plus one. At first the only good states we know are states with junction b, (b, ...). Now some new states might have become good states. So we add those states to the list of known good states. We do this until no state becomes good anymore.At the end we print the minimum cost of source states which are good, and if they don't exist we print -1.The process thing can be implemented in O(n4). :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5483
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 1",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 2",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 3",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 4",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[0-9<>]+\", \"s\");\n    ensuref(int(s.length()) == n, \"The length of s must be equal to n\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[0-9<>]+\", \"s\");\n    ensuref(int(s.length()) == n, \"The length of s must be equal to n\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[0-9<>]+\", \"s\");\n    ensuref(int(s.length()) == n, \"The length of s must be equal to n\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int l_i = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r_i = inf.readInt(l_i, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate s according to s_type\n    string s;\n    if (s_type == \"digits\") {\n        // s is digits only\n        for (int i = 0; i < n; ++i) {\n            s += '0' + rnd.next(0, 9);\n        }\n    } else if (s_type == \"arrows\") {\n        // s is '<' and '>' only\n        char arrows[2] = {'<', '>'};\n        for (int i = 0; i < n; ++i) {\n            s += arrows[rnd.next(0, 1)];\n        }\n    } else if (s_type == \"mixed\") {\n        // s is random mixture of digits and arrows\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 2);\n            if (t == 0)\n                s += '<';\n            else if (t == 1)\n                s += '>';\n            else\n                s += '0' + rnd.next(0, 9);\n        }\n    } else if (s_type == \"alternating\") {\n        // s is alternating between digits and arrows\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s += '0' + rnd.next(0, 9);\n            else {\n                char arrows[2] = {'<', '>'};\n                s += arrows[rnd.next(0, 1)];\n            }\n        }\n    } else if (s_type == \"long_digit\") {\n        // s is a long sequence of one digit\n        char digit = '0' + rnd.next(0, 9);\n        s = string(n, digit);\n    } else if (s_type == \"zeros\") {\n        // s is a sequence of '0's\n        s = string(n, '0');\n    } else if (s_type == \"nines\") {\n        // s is a sequence of '9's\n        s = string(n, '9');\n    } else if (s_type == \"only_left_arrows\") {\n        // s is a sequence of '<'\n        s = string(n, '<');\n    } else if (s_type == \"only_right_arrows\") {\n        // s is a sequence of '>'\n        s = string(n, '>');\n    } else if (s_type == \"alternating_digits_left\") {\n        // s is alternating digits and '<'\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s += '0' + rnd.next(0, 9);\n            else\n                s += '<';\n        }\n    } else if (s_type == \"alternating_digits_right\") {\n        // s is alternating digits and '>'\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s += '0' + rnd.next(0, 9);\n            else\n                s += '>';\n        }\n    } else {\n        // random\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 3);\n            if (t == 0)\n                s += '<';\n            else if (t == 1)\n                s += '>';\n            else\n                s += '0' + rnd.next(0, 9);\n        }\n    }\n\n    // Generate queries according to query_type\n    vector<pair<int, int>> queries(q);\n    if (query_type == \"full_range\") {\n        // All queries are from 1 to n\n        for (int i = 0; i < q; ++i) {\n            queries[i] = make_pair(1, n);\n        }\n    } else if (query_type == \"single_point\") {\n        // Queries where l_i == r_i\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            queries[i] = make_pair(p, p);\n        }\n    } else if (query_type == \"edge\") {\n        // Queries at the edges\n        for (int i = 0; i < q; ++i) {\n            if (rnd.next(0, 1)) {\n                queries[i] = make_pair(1, rnd.next(1, n));\n            } else {\n                queries[i] = make_pair(rnd.next(1, n), n);\n            }\n        }\n    } else if (query_type == \"max_queries\") {\n        // q is maximum, and queries are random\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    } else {\n        // random\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    // Output queries\n    for (const auto& p : queries) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate s according to s_type\n    string s;\n    if (s_type == \"digits\") {\n        // s is digits only\n        for (int i = 0; i < n; ++i) {\n            s += '0' + rnd.next(0, 9);\n        }\n    } else if (s_type == \"arrows\") {\n        // s is '<' and '>' only\n        char arrows[2] = {'<', '>'};\n        for (int i = 0; i < n; ++i) {\n            s += arrows[rnd.next(0, 1)];\n        }\n    } else if (s_type == \"mixed\") {\n        // s is random mixture of digits and arrows\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 2);\n            if (t == 0)\n                s += '<';\n            else if (t == 1)\n                s += '>';\n            else\n                s += '0' + rnd.next(0, 9);\n        }\n    } else if (s_type == \"alternating\") {\n        // s is alternating between digits and arrows\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s += '0' + rnd.next(0, 9);\n            else {\n                char arrows[2] = {'<', '>'};\n                s += arrows[rnd.next(0, 1)];\n            }\n        }\n    } else if (s_type == \"long_digit\") {\n        // s is a long sequence of one digit\n        char digit = '0' + rnd.next(0, 9);\n        s = string(n, digit);\n    } else if (s_type == \"zeros\") {\n        // s is a sequence of '0's\n        s = string(n, '0');\n    } else if (s_type == \"nines\") {\n        // s is a sequence of '9's\n        s = string(n, '9');\n    } else if (s_type == \"only_left_arrows\") {\n        // s is a sequence of '<'\n        s = string(n, '<');\n    } else if (s_type == \"only_right_arrows\") {\n        // s is a sequence of '>'\n        s = string(n, '>');\n    } else if (s_type == \"alternating_digits_left\") {\n        // s is alternating digits and '<'\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s += '0' + rnd.next(0, 9);\n            else\n                s += '<';\n        }\n    } else if (s_type == \"alternating_digits_right\") {\n        // s is alternating digits and '>'\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s += '0' + rnd.next(0, 9);\n            else\n                s += '>';\n        }\n    } else {\n        // random\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 3);\n            if (t == 0)\n                s += '<';\n            else if (t == 1)\n                s += '>';\n            else\n                s += '0' + rnd.next(0, 9);\n        }\n    }\n\n    // Generate queries according to query_type\n    vector<pair<int, int>> queries(q);\n    if (query_type == \"full_range\") {\n        // All queries are from 1 to n\n        for (int i = 0; i < q; ++i) {\n            queries[i] = make_pair(1, n);\n        }\n    } else if (query_type == \"single_point\") {\n        // Queries where l_i == r_i\n        for (int i = 0; i < q; ++i) {\n            int p = rnd.next(1, n);\n            queries[i] = make_pair(p, p);\n        }\n    } else if (query_type == \"edge\") {\n        // Queries at the edges\n        for (int i = 0; i < q; ++i) {\n            if (rnd.next(0, 1)) {\n                queries[i] = make_pair(1, rnd.next(1, n));\n            } else {\n                queries[i] = make_pair(rnd.next(1, n), n);\n            }\n        }\n    } else if (query_type == \"max_queries\") {\n        // q is maximum, and queries are random\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    } else {\n        // random\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_pair(l, r);\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    // Output queries\n    for (const auto& p : queries) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -q 1 -s_type zeros -query_type full_range\n./gen -n 1 -q 1 -s_type digits -query_type single_point\n./gen -n 2 -q 1 -s_type arrows -query_type random\n\n# Maximum n\n./gen -n 100000 -q 1 -s_type random -query_type full_range\n./gen -n 100000 -q 100000 -s_type random -query_type random\n\n# All zeros\n./gen -n 1000 -q 100 -s_type zeros -query_type random\n./gen -n 100000 -q 100000 -s_type zeros -query_type max_queries\n\n# All nines\n./gen -n 1000 -q 100 -s_type nines -query_type random\n./gen -n 100000 -q 100000 -s_type nines -query_type max_queries\n\n# Only '<'\n./gen -n 1000 -q 100 -s_type only_left_arrows -query_type random\n./gen -n 100000 -q 100000 -s_type only_left_arrows -query_type max_queries\n\n# Only '>'\n./gen -n 1000 -q 100 -s_type only_right_arrows -query_type random\n./gen -n 100000 -q 100000 -s_type only_right_arrows -query_type max_queries\n\n# Alternating digits and '<'\n./gen -n 1000 -q 100 -s_type alternating_digits_left -query_type random\n./gen -n 100000 -q 100000 -s_type alternating_digits_left -query_type max_queries\n\n# Alternating digits and '>'\n./gen -n 1000 -q 100 -s_type alternating_digits_right -query_type random\n./gen -n 100000 -q 100000 -s_type alternating_digits_right -query_type max_queries\n\n# Mixed random\n./gen -n 1000 -q 100 -s_type mixed -query_type random\n./gen -n 100000 -q 100000 -s_type mixed -query_type random\n\n# Alternating digits and arrows\n./gen -n 1000 -q 100 -s_type alternating -query_type random\n./gen -n 100000 -q 100000 -s_type alternating -query_type random\n\n# Long digit sequence\n./gen -n 100000 -q 100000 -s_type long_digit -query_type random\n\n# Queries of single points\n./gen -n 100000 -q 100000 -s_type random -query_type single_point\n\n# Edge queries\n./gen -n 100000 -q 100000 -s_type random -query_type edge\n\n# Full range queries\n./gen -n 100000 -q 100000 -s_type random -query_type full_range\n\n# Random q between 1 and 1e5\n./gen -n 100000 -q 50000 -s_type random -query_type random\n\n# n small, q large\n./gen -n 10 -q 100000 -s_type random -query_type random\n\n# n large, q small\n./gen -n 100000 -q 10 -s_type random -query_type random\n\n# Maximum n and q\n./gen -n 100000 -q 100000 -s_type random -query_type random\n\n# Combinations of s_type 'digits' and query_types\n./gen -n 1000 -q 1000 -s_type digits -query_type single_point\n./gen -n 1000 -q 1000 -s_type digits -query_type edge\n./gen -n 1000 -q 1000 -s_type digits -query_type full_range\n\n# Combinations of s_type 'arrows' and query_types\n./gen -n 1000 -q 1000 -s_type arrows -query_type single_point\n./gen -n 1000 -q 1000 -s_type arrows -query_type edge\n./gen -n 1000 -q 1000 -s_type arrows -query_type full_range\n\n# Random with maximum n and q\n./gen -n 100000 -q 100000 -s_type random -query_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:54:02.859417",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "238/E",
      "title": "E. Meeting Her",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe \u001cfirst line of the input contains four integers n, m, a, b (2 ≤ n ≤ 100; 0 ≤ m ≤ n·(n - 1); 1 ≤ a, b ≤ n; a ≠ b). The next m lines contain two integers each ui and vi (1 ≤ ui, vi ≤ n; ui ≠ vi) describing a directed road from junction ui to junction vi. All roads in the input will be distinct. The next line contains an integer k (0 ≤ k ≤ 100). There will be k lines after this, each containing two integers si and ti (1 ≤ si, ti ≤ n; si ≠ ti) saying there is a bus route starting at si and ending at ti. Please note that there might be no path from si to ti, this case is described in the problem statement.",
      "output_spec": "OutputIn the only line of output print the minimum number of buses Urpal should get on on his way in the worst case. If it's not possible to reach the destination in the worst case print -1.",
      "sample_tests": "ExamplesInputCopy7 8 1 71 21 32 43 44 64 56 75 732 71 45 7OutputCopy2InputCopy4 4 1 21 21 32 43 411 4OutputCopy-1",
      "description": "E. Meeting Her\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe \u001cfirst line of the input contains four integers n, m, a, b (2 ≤ n ≤ 100; 0 ≤ m ≤ n·(n - 1); 1 ≤ a, b ≤ n; a ≠ b). The next m lines contain two integers each ui and vi (1 ≤ ui, vi ≤ n; ui ≠ vi) describing a directed road from junction ui to junction vi. All roads in the input will be distinct. The next line contains an integer k (0 ≤ k ≤ 100). There will be k lines after this, each containing two integers si and ti (1 ≤ si, ti ≤ n; si ≠ ti) saying there is a bus route starting at si and ending at ti. Please note that there might be no path from si to ti, this case is described in the problem statement.\n\nOutputIn the only line of output print the minimum number of buses Urpal should get on on his way in the worst case. If it's not possible to reach the destination in the worst case print -1.\n\nInputCopy7 8 1 71 21 32 43 44 64 56 75 732 71 45 7OutputCopy2InputCopy4 4 1 21 21 32 43 411 4OutputCopy-1\n\nInputCopy7 8 1 71 21 32 43 44 64 56 75 732 71 45 7\n\nOutputCopy2\n\nInputCopy4 4 1 21 21 32 43 411 4\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #148 - Codeforces",
          "content": "Hi all! :)I'm glad to invite you to participate in Codeforces Round #148 today. I (Hamed Valizadeh) am the author of this round. I'd like to thank Gerald (Gerald Agapov) MikeMirzayanov (Mike Mirzayanov) Delinur (Maria Belova) and Saeed_Reza (SaeedReza Seddighin) who helped me in preparing the round.Score distribution will be the standard 500-1000-1500-2000-2500 in both divisions.Hope you find the problems interesting to solve.Good luck and have fun ;)Update. Contest is over. Congratulations to the winners of both divisions! :)Div1: tourist cerealguy Dmitry_Egorov RAVEman UESTC_Nocturne Div2: LiWenHaoTianXiaDiYi goooooooopan jthread kolina xcodevn And congrats to Endagorion who was the only one solving 238D - Tape Programming correctly during the contest.BTW, I hope you didn't get sick of that boring problem! :-\"Update 2. The editorial is ready now, sorry for the delay. http://codeforces.com/blog/entry/5765",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 238 和字母"
          },
          "content_length": 919
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces",
          "content": "Hi :)Here is the editorial for round #148. I just tried to explain the ideas rather than detailed implementation explanation. I'm sorry for my bad English, so please tell me if something is not clear in the descriptions.Two Bags of PotatoesThe author of this problem is Gerald. The total number of potatoes is a multiple of k and constraint there will be at most 105 multiples of k in range 1 to n. So you can iterate on multiples of k and print the ones that satisfy the problem.Easy Tape ProgrammingIn this problem you just need to simulate every thing which is written in the statement step by step. You can see a simple implementation of this here: http://www.codeforces.com/contest/239/submission/2512422Not Wool SequencesLet a1, ..., an be a not-wool-sequence. We define another sequence called b in which bi is xor of the first i elements of a, and b0 = 0.Now xor of elements of a consecutive subsequence like ai, ..., aj will be equal to . So we know that all elements of b should be different. Therefore b is a sequence of distinct integers of length n + 1 starting with 0 made of numbers 0 to 2m - 1. The number of such sequences is and this is the answer to problem.Boring PartitionComing soon...World Eater BrothersConsider we only want to change direction of minimum number of roads so that all other countries are reachable from a specific country x. This problem can be solved in O(n) and it's exactly what 219D - Choosing Capital for Treeland asks for. If you don't know how to solve it you can read the editorial of that contest.Consider two countries A and B which can be chosen by world eater brothers to achieve the minimum number of road direction changes. After changing the direction of roads, there exists a country on the undirected path between A and B which is reachable from both A and B using roads. We call such country a middle-country.We want to iterate on middle-countries and find the best two countries for ruling for each middle-country. For each neighbor of the current middle-country calculate the minimum number of road changes in the subtree rooted at that neighbor so that all countries will be reachable from some country in that subtree. Then from two of these subtrees we need to pick A and B and all other subtrees will have edges pointing to the root of subtree. This can be computed in O(n) for each middle-city. So the overall complexity will be O(n2).Tape ProgrammingThis problem was my favorite in the problemset. The primary point is that at any moment during the interpretation of a program only a prefix of the program is modified and used by IP.Consider we want to calculate the output of subsequence sl, ..., sr. While running the original program s1, ..., sn if at any moment CP enters the interval [l, r] it should be pointing to position l and the direction of DP should be right. So it's like we have started interpreting sl, ..., sr independently. The termination of execution of sl, ..., sr is the first time CP points to somewhere outside interval [l, r]. Therefore what we need to solve the problem is to run the original program. And after each termination if the program is nonempty then run it again until program is empty. Then we should keep a log of positions we have visited and the time of each visit and the number of printed digits of each type until then. After this preprocessing the to calculate the answer of query (li, ri) its enough to find the first time CP visited sli and the first time CP visited sri + 1 or sli - 1 after that.The described approach can be implemented in O(nlog(n) + qlog(n)).Meeting herConsider a bus passing a shortest path from si to ti. There are some points that are necessary to pass in order to obtain a shortest path. Firstly we compute them. This can be done in O(n3) with Floyd-Warshall and some processing after that. Urpal is sure that a bus from i-th company always passes such vertices on his path from si to ti. So he can get on a bus from i-th company only at vertices the bus surely passes.At any moment Urpal's status can be uniquely determined by his position on the map and the bus he's traveling with. So we have nk states (position, bus).Our goal is to reach some (b, ...) state from a (a, v) state which bus v surely passes a (source states). So let's find all states that can reach a goal state. We call such states good states.Consider Urpal is at junction x and he's traveling with a bus of type y. Let v1, v2, ..., vw be the list of junctions the bus might go on its shortest path from sy to ty. And let c1, c2, ..., cl be the list of companies that their bus surely passes junction x, excluding y-th company. For state (x, y) we know we can reach junction b (it's a good state) if one of the following is true: x = b, the minimum cost of solving the problem will be 0. All states (v1, y), (v2, y), ... and (vw, y) are good states, the minimum cost of solving the problem will be the maximum of all these states. At least one of states (x, c1), (x, c2), ... or (x, cl) is a good state, the minimum cost of solving the problem will be the minimum the good ones plus one. At first the only good states we know are states with junction b, (b, ...). Now some new states might have become good states. So we add those states to the list of known good states. We do this until no state becomes good anymore.At the end we print the minimum cost of source states which are good, and if they don't exist we print -1.The process thing can be implemented in O(n4). :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5483
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 1",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 2",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 3",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 4",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n * (n - 1), \"m\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n    ensuref(a != b, \"a and b should be different\");\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"No self-loops allowed, but found loop at node %d\", ui);\n        pair<int, int> edge = make_pair(ui, vi);\n        ensuref(edges.find(edge) == edges.end(), \"Duplicate edge found from %d to %d\", ui, vi);\n        edges.insert(edge);\n    }\n\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        inf.readEoln();\n        ensuref(si != ti, \"si and ti must be different in bus route %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n * (n - 1), \"m\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n    ensuref(a != b, \"a and b should be different\");\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"No self-loops allowed, but found loop at node %d\", ui);\n        pair<int, int> edge = make_pair(ui, vi);\n        ensuref(edges.find(edge) == edges.end(), \"Duplicate edge found from %d to %d\", ui, vi);\n        edges.insert(edge);\n    }\n\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        inf.readEoln();\n        ensuref(si != ti, \"si and ti must be different in bus route %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n * (n - 1), \"m\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n    ensuref(a != b, \"a and b should be different\");\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"No self-loops allowed, but found loop at node %d\", ui);\n        pair<int, int> edge = make_pair(ui, vi);\n        ensuref(edges.find(edge) == edges.end(), \"Duplicate edge found from %d to %d\", ui, vi);\n        edges.insert(edge);\n    }\n\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        inf.readEoln();\n        ensuref(si != ti, \"si and ti must be different in bus route %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\", 0);\n    int a = opt<int>(\"a\", 1);\n    int b = opt<int>(\"b\", n);\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n    string bus_type = opt<string>(\"bus_type\", \"random\");\n\n    // Ensure parameters are within constraints\n    ensure(n >= 2 && n <= 100);\n    ensure(m >= 0 && m <= n * (n - 1));\n    ensure(a >= 1 && a <= n);\n    ensure(b >= 1 && b <= n);\n    ensure(a != b);\n    ensure(k >= 0 && k <= 100);\n\n    vector<pair<int,int>> edges;\n\n    if (graph_type == \"path\") {\n        // Create a path graph\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        m = n - 1;\n    }\n    else if (graph_type == \"cycle\") {\n        // Create a cycle\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        edges.push_back({n, 1});\n        m = n;\n    }\n    else if (graph_type == \"complete\") {\n        // Create a complete graph\n        for (int u = 1; u <= n; ++u) {\n            for (int v = 1; v <= n; ++v) {\n                if (u != v) {\n                    edges.push_back({u, v});\n                }\n            }\n        }\n        m = n * (n - 1);\n    }\n    else if (graph_type == \"star\") {\n        // Star graph: node 1 to all others\n        for (int v = 2; v <= n; ++v) {\n            edges.push_back({1, v});\n        }\n        m = n - 1;\n    }\n    else if (graph_type == \"disconnected\") {\n        // No edges\n        edges.clear();\n        m = 0;\n    }\n    else if (graph_type == \"dag\") {\n        // Directed acyclic graph\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u+1; v <= n; ++v) {\n                edges.push_back({u, v});\n            }\n        }\n        m = n * (n - 1) / 2;\n    }\n    else if (graph_type == \"random\") {\n        // Generate m random edges\n        set<pair<int,int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edgeSet.insert({u, v});\n            }\n        }\n        for (auto e : edgeSet) {\n            edges.push_back(e);\n        }\n    } else {\n        // Default to random\n        set<pair<int,int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edgeSet.insert({u, v});\n            }\n        }\n        for (auto e : edgeSet) {\n            edges.push_back(e);\n        }\n    }\n\n    // Output n, m, a, b\n    printf(\"%d %d %d %d\\n\", n, m, a, b);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Generate bus companies\n    vector<pair<int,int>> buses;\n    if (bus_type == \"none\") {\n        k = 0;\n    }\n    else if (bus_type == \"helpful\") {\n        // Create bus routes that help Urpal\n        buses.push_back({a, b});\n        k = 1;\n    }\n    else if (bus_type == \"unhelpful\") {\n        // Generate buses that do not help Urpal\n        set<pair<int,int>> busSet;\n        int max_buses = (n - 2) * (n - 3) + (n - 2);\n        if (k > max_buses) k = max_buses;\n        while ((int)busSet.size() < k) {\n            int si = rnd.next(1, n);\n            int ti = rnd.next(1, n);\n            if (si != ti && si != a && ti != a && si != b && ti != b) {\n                busSet.insert({si, ti});\n            }\n        }\n        for (auto b : busSet) {\n            buses.push_back(b);\n        }\n    }\n    else if (bus_type == \"random\") {\n        // Generate k random bus routes\n        set<pair<int,int>> busSet;\n        while ((int)busSet.size() < k) {\n            int si = rnd.next(1, n);\n            int ti = rnd.next(1, n);\n            if (si != ti) {\n                busSet.insert({si, ti});\n            }\n        }\n        for (auto b : busSet) {\n            buses.push_back(b);\n        }\n    }\n    else {\n        // Default to random buses\n        set<pair<int,int>> busSet;\n        while ((int)busSet.size() < k) {\n            int si = rnd.next(1, n);\n            int ti = rnd.next(1, n);\n            if (si != ti) {\n                busSet.insert({si, ti});\n            }\n        }\n        for (auto b : busSet) {\n            buses.push_back(b);\n        }\n    }\n\n    // Output k\n    printf(\"%d\\n\", k);\n\n    // Output bus routes\n    for (auto b : buses) {\n        printf(\"%d %d\\n\", b.first, b.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\", 0);\n    int a = opt<int>(\"a\", 1);\n    int b = opt<int>(\"b\", n);\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n    string bus_type = opt<string>(\"bus_type\", \"random\");\n\n    // Ensure parameters are within constraints\n    ensure(n >= 2 && n <= 100);\n    ensure(m >= 0 && m <= n * (n - 1));\n    ensure(a >= 1 && a <= n);\n    ensure(b >= 1 && b <= n);\n    ensure(a != b);\n    ensure(k >= 0 && k <= 100);\n\n    vector<pair<int,int>> edges;\n\n    if (graph_type == \"path\") {\n        // Create a path graph\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        m = n - 1;\n    }\n    else if (graph_type == \"cycle\") {\n        // Create a cycle\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        edges.push_back({n, 1});\n        m = n;\n    }\n    else if (graph_type == \"complete\") {\n        // Create a complete graph\n        for (int u = 1; u <= n; ++u) {\n            for (int v = 1; v <= n; ++v) {\n                if (u != v) {\n                    edges.push_back({u, v});\n                }\n            }\n        }\n        m = n * (n - 1);\n    }\n    else if (graph_type == \"star\") {\n        // Star graph: node 1 to all others\n        for (int v = 2; v <= n; ++v) {\n            edges.push_back({1, v});\n        }\n        m = n - 1;\n    }\n    else if (graph_type == \"disconnected\") {\n        // No edges\n        edges.clear();\n        m = 0;\n    }\n    else if (graph_type == \"dag\") {\n        // Directed acyclic graph\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u+1; v <= n; ++v) {\n                edges.push_back({u, v});\n            }\n        }\n        m = n * (n - 1) / 2;\n    }\n    else if (graph_type == \"random\") {\n        // Generate m random edges\n        set<pair<int,int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edgeSet.insert({u, v});\n            }\n        }\n        for (auto e : edgeSet) {\n            edges.push_back(e);\n        }\n    } else {\n        // Default to random\n        set<pair<int,int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u != v) {\n                edgeSet.insert({u, v});\n            }\n        }\n        for (auto e : edgeSet) {\n            edges.push_back(e);\n        }\n    }\n\n    // Output n, m, a, b\n    printf(\"%d %d %d %d\\n\", n, m, a, b);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Generate bus companies\n    vector<pair<int,int>> buses;\n    if (bus_type == \"none\") {\n        k = 0;\n    }\n    else if (bus_type == \"helpful\") {\n        // Create bus routes that help Urpal\n        buses.push_back({a, b});\n        k = 1;\n    }\n    else if (bus_type == \"unhelpful\") {\n        // Generate buses that do not help Urpal\n        set<pair<int,int>> busSet;\n        int max_buses = (n - 2) * (n - 3) + (n - 2);\n        if (k > max_buses) k = max_buses;\n        while ((int)busSet.size() < k) {\n            int si = rnd.next(1, n);\n            int ti = rnd.next(1, n);\n            if (si != ti && si != a && ti != a && si != b && ti != b) {\n                busSet.insert({si, ti});\n            }\n        }\n        for (auto b : busSet) {\n            buses.push_back(b);\n        }\n    }\n    else if (bus_type == \"random\") {\n        // Generate k random bus routes\n        set<pair<int,int>> busSet;\n        while ((int)busSet.size() < k) {\n            int si = rnd.next(1, n);\n            int ti = rnd.next(1, n);\n            if (si != ti) {\n                busSet.insert({si, ti});\n            }\n        }\n        for (auto b : busSet) {\n            buses.push_back(b);\n        }\n    }\n    else {\n        // Default to random buses\n        set<pair<int,int>> busSet;\n        while ((int)busSet.size() < k) {\n            int si = rnd.next(1, n);\n            int ti = rnd.next(1, n);\n            if (si != ti) {\n                busSet.insert({si, ti});\n            }\n        }\n        for (auto b : busSet) {\n            buses.push_back(b);\n        }\n    }\n\n    // Output k\n    printf(\"%d\\n\", k);\n\n    // Output bus routes\n    for (auto b : buses) {\n        printf(\"%d %d\\n\", b.first, b.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 0 -a 1 -b 2 -graph_type disconnected -k 0 -bus_type none\n./gen -n 2 -m 1 -a 1 -b 2 -graph_type path -k 0 -bus_type none\n\n./gen -n 5 -m 4 -a 1 -b 5 -graph_type path -k 1 -bus_type helpful\n./gen -n 5 -m 4 -a 5 -b 1 -graph_type path -k 1 -bus_type helpful\n\n./gen -n 5 -m 6 -a 1 -b 5 -graph_type star -k 2 -bus_type unhelpful\n./gen -n 5 -m 10 -a 2 -b 4 -graph_type complete -k 3 -bus_type unhelpful\n\n./gen -n 10 -m 0 -a 1 -b 10 -graph_type disconnected -k 0 -bus_type none\n./gen -n 10 -m 9 -a 1 -b 10 -graph_type path -k 1 -bus_type helpful\n\n./gen -n 10 -m 20 -a 1 -b 10 -graph_type random -k 0 -bus_type none\n./gen -n 10 -m 40 -a 1 -b 10 -graph_type random -k 5 -bus_type random\n\n./gen -n 10 -m 45 -a 1 -b 10 -graph_type dag -k 5 -bus_type helpful\n\n./gen -n 10 -m 90 -a 1 -b 10 -graph_type complete -k 10 -bus_type unhelpful\n\n./gen -n 50 -m 0 -a 1 -b 50 -graph_type disconnected -k 0 -bus_type none\n./gen -n 50 -m 49 -a 1 -b 50 -graph_type path -k 1 -bus_type helpful\n\n./gen -n 50 -m 200 -a 1 -b 50 -graph_type random -k 5 -bus_type unhelpful\n./gen -n 50 -m 600 -a 1 -b 50 -graph_type random -k 10 -bus_type random\n\n./gen -n 50 -m 1225 -a 1 -b 50 -graph_type dag -k 10 -bus_type helpful\n\n./gen -n 50 -m 2450 -a 1 -b 50 -graph_type complete -k 50 -bus_type random\n\n./gen -n 100 -m 0 -a 1 -b 100 -graph_type disconnected -k 0 -bus_type none\n./gen -n 100 -m 99 -a 1 -b 100 -graph_type path -k 1 -bus_type helpful\n\n./gen -n 100 -m 500 -a 1 -b 100 -graph_type random -k 10 -bus_type unhelpful\n./gen -n 100 -m 1000 -a 1 -b 100 -graph_type random -k 20 -bus_type random\n\n./gen -n 100 -m 4950 -a 1 -b 100 -graph_type dag -k 50 -bus_type helpful\n\n./gen -n 100 -m 9900 -a 1 -b 100 -graph_type complete -k 100 -bus_type random\n\n./gen -n 100 -m 5000 -a 50 -b 51 -graph_type random -k 50 -bus_type unhelpful\n\n./gen -n 100 -m 1000 -a 10 -b 90 -graph_type random -k 20 -bus_type helpful\n\n./gen -n 3 -m 0 -a 1 -b 2 -graph_type disconnected -k 0 -bus_type none\n./gen -n 3 -m 2 -a 1 -b 3 -graph_type path -k 1 -bus_type helpful\n\n./gen -n 4 -m 3 -a 1 -b 4 -graph_type random -k 2 -bus_type random\n./gen -n 4 -m 6 -a 2 -b 3 -graph_type complete -k 2 -bus_type unhelpful\n\n./gen -n 50 -m 0 -a 25 -b 26 -graph_type disconnected -k 0 -bus_type none\n./gen -n 50 -m 100 -a 25 -b 26 -graph_type random -k 5 -bus_type helpful\n\n./gen -n 75 -m 500 -a 10 -b 65 -graph_type random -k 15 -bus_type unhelpful\n./gen -n 75 -m 2775 -a 10 -b 65 -graph_type dag -k 20 -bus_type helpful\n\n./gen -n 100 -m 0 -a 50 -b 51 -graph_type disconnected -k 0 -bus_type none\n./gen -n 100 -m 99 -a 1 -b 100 -graph_type path -k 1 -bus_type unhelpful\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:54:04.669318",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "239/A",
      "title": "A. Два Мешка Картошки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа через пробел y, k, n (1 ≤ y, k, n ≤ 109;   ≤ 105).",
      "output_spec": "Выходные данныеВыведите список целых чисел разделенных пробельными символами — все возможные значения x в возрастающем порядке. Каждое значение, должно быть выведено ровно один раз. Если нет ни одного подходящего значения x, выведите единственное целое число -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 1 10Выходные данныеСкопировать-1Входные данныеСкопировать10 6 40Выходные данныеСкопировать2 8 14 20 26",
      "description": "A. Два Мешка Картошки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа через пробел y, k, n (1 ≤ y, k, n ≤ 109;   ≤ 105).\n\nВходные данные\n\nВыходные данныеВыведите список целых чисел разделенных пробельными символами — все возможные значения x в возрастающем порядке. Каждое значение, должно быть выведено ровно один раз. Если нет ни одного подходящего значения x, выведите единственное целое число -1.\n\nВыходные данные\n\nВходные данныеСкопировать10 1 10Выходные данныеСкопировать-1Входные данныеСкопировать10 6 40Выходные данныеСкопировать2 8 14 20 26\n\nВходные данныеСкопировать10 1 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 6 40\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 8 14 20 26\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #148 - Codeforces",
          "content": "Всем привет! :)Рад пригласить Вас на очередной Codeforces Round #148. Я (Hamed Valizadeh) автор этого раунда.Я благодарю Gerald (Геральд Агапов), MikeMirzayanov (Михаил Мирзаянов), Delinur (Мария Белова), и Saeed_Reza (SaeedReza Seddighin) за помощь в подготовке этого раунда.Распределение баллов по задачам стандартное в обоих дивизионах: 500-1000-1500-2000-2500.Надеюсь задачи Вам понравятся.Good luck and have fun ;)Update. Соревнование закончилось. Мои поздравления победителям обоих дивизионов! :)Div1: tourist cerealguy Dmitry_Egorov RAVEman UESTC_Nocturne Div2: LiWenHaoTianXiaDiYi goooooooopan jthread kolina xcodevn Поздравляю участника Endagorion — единственного, кто решил задачу 238D - Ленточное Программирование.Кстати, я надеюсь, что вас не сильно расстроила скучная задача!Update 2. Разбор готов. Прошу прощения за задержку. http://codeforces.com/blog/entry/5765",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 877
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces",
          "content": "Hi :)Here is the editorial for round #148. I just tried to explain the ideas rather than detailed implementation explanation. I'm sorry for my bad English, so please tell me if something is not clear in the descriptions.Two Bags of PotatoesThe author of this problem is Gerald. The total number of potatoes is a multiple of k and constraint there will be at most 105 multiples of k in range 1 to n. So you can iterate on multiples of k and print the ones that satisfy the problem.Easy Tape ProgrammingIn this problem you just need to simulate every thing which is written in the statement step by step. You can see a simple implementation of this here: http://www.codeforces.com/contest/239/submission/2512422Not Wool SequencesLet a1, ..., an be a not-wool-sequence. We define another sequence called b in which bi is xor of the first i elements of a, and b0 = 0.Now xor of elements of a consecutive subsequence like ai, ..., aj will be equal to . So we know that all elements of b should be different. Therefore b is a sequence of distinct integers of length n + 1 starting with 0 made of numbers 0 to 2m - 1. The number of such sequences is and this is the answer to problem.Boring PartitionComing soon...World Eater BrothersConsider we only want to change direction of minimum number of roads so that all other countries are reachable from a specific country x. This problem can be solved in O(n) and it's exactly what 219D - Choosing Capital for Treeland asks for. If you don't know how to solve it you can read the editorial of that contest.Consider two countries A and B which can be chosen by world eater brothers to achieve the minimum number of road direction changes. After changing the direction of roads, there exists a country on the undirected path between A and B which is reachable from both A and B using roads. We call such country a middle-country.We want to iterate on middle-countries and find the best two countries for ruling for each middle-country. For each neighbor of the current middle-country calculate the minimum number of road changes in the subtree rooted at that neighbor so that all countries will be reachable from some country in that subtree. Then from two of these subtrees we need to pick A and B and all other subtrees will have edges pointing to the root of subtree. This can be computed in O(n) for each middle-city. So the overall complexity will be O(n2).Tape ProgrammingThis problem was my favorite in the problemset. The primary point is that at any moment during the interpretation of a program only a prefix of the program is modified and used by IP.Consider we want to calculate the output of subsequence sl, ..., sr. While running the original program s1, ..., sn if at any moment CP enters the interval [l, r] it should be pointing to position l and the direction of DP should be right. So it's like we have started interpreting sl, ..., sr independently. The termination of execution of sl, ..., sr is the first time CP points to somewhere outside interval [l, r]. Therefore what we need to solve the problem is to run the original program. And after each termination if the program is nonempty then run it again until program is empty. Then we should keep a log of positions we have visited and the time of each visit and the number of printed digits of each type until then. After this preprocessing the to calculate the answer of query (li, ri) its enough to find the first time CP visited sli and the first time CP visited sri + 1 or sli - 1 after that.The described approach can be implemented in O(nlog(n) + qlog(n)).Meeting herConsider a bus passing a shortest path from si to ti. There are some points that are necessary to pass in order to obtain a shortest path. Firstly we compute them. This can be done in O(n3) with Floyd-Warshall and some processing after that. Urpal is sure that a bus from i-th company always passes such vertices on his path from si to ti. So he can get on a bus from i-th company only at vertices the bus surely passes.At any moment Urpal's status can be uniquely determined by his position on the map and the bus he's traveling with. So we have nk states (position, bus).Our goal is to reach some (b, ...) state from a (a, v) state which bus v surely passes a (source states). So let's find all states that can reach a goal state. We call such states good states.Consider Urpal is at junction x and he's traveling with a bus of type y. Let v1, v2, ..., vw be the list of junctions the bus might go on its shortest path from sy to ty. And let c1, c2, ..., cl be the list of companies that their bus surely passes junction x, excluding y-th company. For state (x, y) we know we can reach junction b (it's a good state) if one of the following is true: x = b, the minimum cost of solving the problem will be 0. All states (v1, y), (v2, y), ... and (vw, y) are good states, the minimum cost of solving the problem will be the maximum of all these states. At least one of states (x, c1), (x, c2), ... or (x, cl) is a good state, the minimum cost of solving the problem will be the minimum the good ones plus one. At first the only good states we know are states with junction b, (b, ...). Now some new states might have become good states. So we add those states to the list of known good states. We do this until no state becomes good anymore.At the end we print the minimum cost of source states which are good, and if they don't exist we print -1.The process thing can be implemented in O(n4). :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 239 和字母"
          },
          "content_length": 5483
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #148 - Codeforces - Code 1",
          "code": "(2 ^ m) % mod < n && 2 ^ m > n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5746",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #148 - Codeforces - Code 2",
          "code": "(2 ^ m) % mod < n && 2 ^ m > n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5746",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 1",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 2",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 3",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 4",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long y = inf.readLong(1, 1000000000LL, \"y\");\n    inf.readSpace();\n    long long k = inf.readLong(1, 1000000000LL, \"k\");\n    inf.readSpace();\n    long long n = inf.readLong(1, 1000000000LL, \"n\");\n    inf.readEoln();\n    \n    long long t_start = (y + 1 + k - 1) / k; // ceil((y + 1)/k)\n    long long t_end = n / k;\n    long long total_possible_x = t_end - t_start + 1;\n    if (total_possible_x < 0) total_possible_x = 0;\n    ensuref(total_possible_x <= 100000, \"Number of possible x's must not exceed 1e5, but found %lld\", total_possible_x);\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long y = inf.readLong(1, 1000000000LL, \"y\");\n    inf.readSpace();\n    long long k = inf.readLong(1, 1000000000LL, \"k\");\n    inf.readSpace();\n    long long n = inf.readLong(1, 1000000000LL, \"n\");\n    inf.readEoln();\n    \n    long long t_start = (y + 1 + k - 1) / k; // ceil((y + 1)/k)\n    long long t_end = n / k;\n    long long total_possible_x = t_end - t_start + 1;\n    if (total_possible_x < 0) total_possible_x = 0;\n    ensuref(total_possible_x <= 100000, \"Number of possible x's must not exceed 1e5, but found %lld\", total_possible_x);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long y = inf.readLong(1, 1000000000LL, \"y\");\n    inf.readSpace();\n    long long k = inf.readLong(1, 1000000000LL, \"k\");\n    inf.readSpace();\n    long long n = inf.readLong(1, 1000000000LL, \"n\");\n    inf.readEoln();\n    \n    long long t_start = (y + 1 + k - 1) / k; // ceil((y + 1)/k)\n    long long t_end = n / k;\n    long long total_possible_x = t_end - t_start + 1;\n    if (total_possible_x < 0) total_possible_x = 0;\n    ensuref(total_possible_x <= 100000, \"Number of possible x's must not exceed 1e5, but found %lld\", total_possible_x);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long y = opt<long long>(\"y\", -1);\n    long long k = opt<long long>(\"k\", -1);\n    long long n = opt<long long>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    const long long MAXN = 1000000000LL;\n    const long long MAX_X_VALUES = 100000;\n\n    if (type == \"no_solution\") {\n        // Generate y, k, n such that there is no x satisfying the conditions.\n        y = rnd.next(1LL, MAXN - 1);\n        k = rnd.next(1LL, MAXN);\n        n = y;\n\n        // Ensure that x + y > n for any x ≥ 1\n        // Since x ≥1, x + y ≥ y +1\n        // So if y + 1 > n, then x + y > n\n        // Set n = y, so y + 1 > n\n    } else if (type == \"single_solution\") {\n        // Generate y, k, n such that there is exactly one x satisfying the conditions.\n        y = rnd.next(1LL, MAXN - 100);\n        k = rnd.next(1LL, MAXN / 1000);\n        if (k == 0) k = 1;\n        long long x_candidate = rnd.next(1LL, 100LL);\n        long long total = y + x_candidate;\n        total = ((total + k - 1) / k) * k; // Next multiple of k\n        n = total;\n        x_candidate = total - y;\n        if (x_candidate < 1 || n > MAXN) {\n            n = y + x_candidate;\n        }\n        n = min(n, MAXN);\n    } else if (type == \"max_x_values\") {\n        // Generate y, k, n such that number of x-values is close to MAX_X_VALUES\n        k = rnd.next(1LL, MAXN / MAX_X_VALUES);\n        if (k == 0) k = 1;\n        y = rnd.next(1LL, MAXN - MAX_X_VALUES * k);\n        long long num_x = rnd.next(MAX_X_VALUES - 100, MAX_X_VALUES);\n        n = y + num_x * k;\n        if (n > MAXN) n = MAXN;\n    } else if (type == \"edge\") {\n        // Edge cases\n        int edge_case = rnd.next(1, 4);\n        if (edge_case == 1) {\n            y = 1;\n            k = 1;\n            n = 1;\n        } else if (edge_case == 2) {\n            y = MAXN;\n            k = 1;\n            n = MAXN;\n        } else if (edge_case == 3) {\n            y = 1;\n            k = MAXN;\n            n = MAXN;\n        } else if (edge_case == 4) {\n            y = MAXN;\n            k = MAXN;\n            n = MAXN;\n        }\n    } else {\n        // Random case\n        y = (y == -1) ? rnd.next(1LL, MAXN) : y;\n        k = (k == -1) ? rnd.next(1LL, MAXN) : k;\n        n = (n == -1) ? rnd.next(y + 1, MAXN) : n;\n    }\n\n    // Ensure that 1 ≤ y, k, n ≤ MAXN\n    y = max(1LL, min(y, MAXN));\n    k = max(1LL, min(k, MAXN));\n    n = max(1LL, min(n, MAXN));\n\n    // Output y k n\n    printf(\"%lld %lld %lld\\n\", y, k, n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long y = opt<long long>(\"y\", -1);\n    long long k = opt<long long>(\"k\", -1);\n    long long n = opt<long long>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    const long long MAXN = 1000000000LL;\n    const long long MAX_X_VALUES = 100000;\n\n    if (type == \"no_solution\") {\n        // Generate y, k, n such that there is no x satisfying the conditions.\n        y = rnd.next(1LL, MAXN - 1);\n        k = rnd.next(1LL, MAXN);\n        n = y;\n\n        // Ensure that x + y > n for any x ≥ 1\n        // Since x ≥1, x + y ≥ y +1\n        // So if y + 1 > n, then x + y > n\n        // Set n = y, so y + 1 > n\n    } else if (type == \"single_solution\") {\n        // Generate y, k, n such that there is exactly one x satisfying the conditions.\n        y = rnd.next(1LL, MAXN - 100);\n        k = rnd.next(1LL, MAXN / 1000);\n        if (k == 0) k = 1;\n        long long x_candidate = rnd.next(1LL, 100LL);\n        long long total = y + x_candidate;\n        total = ((total + k - 1) / k) * k; // Next multiple of k\n        n = total;\n        x_candidate = total - y;\n        if (x_candidate < 1 || n > MAXN) {\n            n = y + x_candidate;\n        }\n        n = min(n, MAXN);\n    } else if (type == \"max_x_values\") {\n        // Generate y, k, n such that number of x-values is close to MAX_X_VALUES\n        k = rnd.next(1LL, MAXN / MAX_X_VALUES);\n        if (k == 0) k = 1;\n        y = rnd.next(1LL, MAXN - MAX_X_VALUES * k);\n        long long num_x = rnd.next(MAX_X_VALUES - 100, MAX_X_VALUES);\n        n = y + num_x * k;\n        if (n > MAXN) n = MAXN;\n    } else if (type == \"edge\") {\n        // Edge cases\n        int edge_case = rnd.next(1, 4);\n        if (edge_case == 1) {\n            y = 1;\n            k = 1;\n            n = 1;\n        } else if (edge_case == 2) {\n            y = MAXN;\n            k = 1;\n            n = MAXN;\n        } else if (edge_case == 3) {\n            y = 1;\n            k = MAXN;\n            n = MAXN;\n        } else if (edge_case == 4) {\n            y = MAXN;\n            k = MAXN;\n            n = MAXN;\n        }\n    } else {\n        // Random case\n        y = (y == -1) ? rnd.next(1LL, MAXN) : y;\n        k = (k == -1) ? rnd.next(1LL, MAXN) : k;\n        n = (n == -1) ? rnd.next(y + 1, MAXN) : n;\n    }\n\n    // Ensure that 1 ≤ y, k, n ≤ MAXN\n    y = max(1LL, min(y, MAXN));\n    k = max(1LL, min(k, MAXN));\n    n = max(1LL, min(n, MAXN));\n\n    // Output y k n\n    printf(\"%lld %lld %lld\\n\", y, k, n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Edge cases\n./gen --type edge\n./gen --type edge\n./gen --type edge\n\n# No solution cases\n./gen --type no_solution\n./gen --type no_solution\n./gen --type no_solution\n\n# Single solution cases\n./gen --type single_solution\n./gen --type single_solution\n./gen --type single_solution\n\n# Max x-values cases\n./gen --type max_x_values\n./gen --type max_x_values\n./gen --type max_x_values\n\n# Random cases\n./gen --type random\n./gen --type random\n./gen --type random\n./gen --type random\n./gen --type random\n\n# Cases with specific parameters\n./gen --y 1 --k 1 --n 1\n./gen --y 1 --k 1 --n 10\n./gen --y 10 --k 5 --n 20\n\n# Cases to test integer overflows\n./gen --y 1000000000 --k 1000000000 --n 1000000000\n./gen --y 999999999 --k 999999999 --n 1000000000\n\n# Cases to test large number of x-values without exceeding the limit\n./gen --k 1 --y 1 --n 100000\n\n# Cases to test small k values\n./gen --k 1 --y 1000 --n 1000000\n./gen --k 2 --y 1000 --n 1000000\n\n# Cases where k > n\n./gen --k 1000000000 --y 1 --n 1000\n\n# Cases where k divides n\n./gen --k 1000 --y 500 --n 1000000\n\n# Additional edge cases\n./gen --type edge\n./gen --type edge\n./gen --type edge\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:54:06.390038",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "239/B",
      "title": "B. Easy Tape Programming",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers n and q (1 ≤ n, q ≤ 100) — represents the length of the sequence s and the number of queries. The second line contains s, a sequence of \"<\", \">\" and digits (0..9) written from left to right. Note, that the characters of s are not separated with spaces. The next q lines each contains two integers li and ri (1 ≤ li ≤ ri ≤ n) — the i-th query.",
      "output_spec": "OutputFor each query print 10 space separated integers: x0, x1, ..., x9 where xi equals the number of times the interpreter prints i while running the corresponding program. Print answers to the queries in the order they are given in input.",
      "sample_tests": "ExamplesInputCopy7 41>3>22<1 34 77 71 7OutputCopy0 1 0 1 0 0 0 0 0 0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 2 1 0 0 0 0 0 0",
      "description": "B. Easy Tape Programming\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains two integers n and q (1 ≤ n, q ≤ 100) — represents the length of the sequence s and the number of queries. The second line contains s, a sequence of \"<\", \">\" and digits (0..9) written from left to right. Note, that the characters of s are not separated with spaces. The next q lines each contains two integers li and ri (1 ≤ li ≤ ri ≤ n) — the i-th query.\n\nOutputFor each query print 10 space separated integers: x0, x1, ..., x9 where xi equals the number of times the interpreter prints i while running the corresponding program. Print answers to the queries in the order they are given in input.\n\nInputCopy7 41>3>22<1 34 77 71 7OutputCopy0 1 0 1 0 0 0 0 0 0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 2 1 0 0 0 0 0 0\n\nInputCopy7 41>3>22<1 34 77 71 7\n\nOutputCopy0 1 0 1 0 0 0 0 0 0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 2 1 0 0 0 0 0 0",
      "solutions": [
        {
          "title": "Codeforces Round #148 - Codeforces",
          "content": "Hi all! :)I'm glad to invite you to participate in Codeforces Round #148 today. I (Hamed Valizadeh) am the author of this round. I'd like to thank Gerald (Gerald Agapov) MikeMirzayanov (Mike Mirzayanov) Delinur (Maria Belova) and Saeed_Reza (SaeedReza Seddighin) who helped me in preparing the round.Score distribution will be the standard 500-1000-1500-2000-2500 in both divisions.Hope you find the problems interesting to solve.Good luck and have fun ;)Update. Contest is over. Congratulations to the winners of both divisions! :)Div1: tourist cerealguy Dmitry_Egorov RAVEman UESTC_Nocturne Div2: LiWenHaoTianXiaDiYi goooooooopan jthread kolina xcodevn And congrats to Endagorion who was the only one solving 238D - Tape Programming correctly during the contest.BTW, I hope you didn't get sick of that boring problem! :-\"Update 2. The editorial is ready now, sorry for the delay. http://codeforces.com/blog/entry/5765",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 919
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces",
          "content": "Hi :)Here is the editorial for round #148. I just tried to explain the ideas rather than detailed implementation explanation. I'm sorry for my bad English, so please tell me if something is not clear in the descriptions.Two Bags of PotatoesThe author of this problem is Gerald. The total number of potatoes is a multiple of k and constraint there will be at most 105 multiples of k in range 1 to n. So you can iterate on multiples of k and print the ones that satisfy the problem.Easy Tape ProgrammingIn this problem you just need to simulate every thing which is written in the statement step by step. You can see a simple implementation of this here: http://www.codeforces.com/contest/239/submission/2512422Not Wool SequencesLet a1, ..., an be a not-wool-sequence. We define another sequence called b in which bi is xor of the first i elements of a, and b0 = 0.Now xor of elements of a consecutive subsequence like ai, ..., aj will be equal to . So we know that all elements of b should be different. Therefore b is a sequence of distinct integers of length n + 1 starting with 0 made of numbers 0 to 2m - 1. The number of such sequences is and this is the answer to problem.Boring PartitionComing soon...World Eater BrothersConsider we only want to change direction of minimum number of roads so that all other countries are reachable from a specific country x. This problem can be solved in O(n) and it's exactly what 219D - Choosing Capital for Treeland asks for. If you don't know how to solve it you can read the editorial of that contest.Consider two countries A and B which can be chosen by world eater brothers to achieve the minimum number of road direction changes. After changing the direction of roads, there exists a country on the undirected path between A and B which is reachable from both A and B using roads. We call such country a middle-country.We want to iterate on middle-countries and find the best two countries for ruling for each middle-country. For each neighbor of the current middle-country calculate the minimum number of road changes in the subtree rooted at that neighbor so that all countries will be reachable from some country in that subtree. Then from two of these subtrees we need to pick A and B and all other subtrees will have edges pointing to the root of subtree. This can be computed in O(n) for each middle-city. So the overall complexity will be O(n2).Tape ProgrammingThis problem was my favorite in the problemset. The primary point is that at any moment during the interpretation of a program only a prefix of the program is modified and used by IP.Consider we want to calculate the output of subsequence sl, ..., sr. While running the original program s1, ..., sn if at any moment CP enters the interval [l, r] it should be pointing to position l and the direction of DP should be right. So it's like we have started interpreting sl, ..., sr independently. The termination of execution of sl, ..., sr is the first time CP points to somewhere outside interval [l, r]. Therefore what we need to solve the problem is to run the original program. And after each termination if the program is nonempty then run it again until program is empty. Then we should keep a log of positions we have visited and the time of each visit and the number of printed digits of each type until then. After this preprocessing the to calculate the answer of query (li, ri) its enough to find the first time CP visited sli and the first time CP visited sri + 1 or sli - 1 after that.The described approach can be implemented in O(nlog(n) + qlog(n)).Meeting herConsider a bus passing a shortest path from si to ti. There are some points that are necessary to pass in order to obtain a shortest path. Firstly we compute them. This can be done in O(n3) with Floyd-Warshall and some processing after that. Urpal is sure that a bus from i-th company always passes such vertices on his path from si to ti. So he can get on a bus from i-th company only at vertices the bus surely passes.At any moment Urpal's status can be uniquely determined by his position on the map and the bus he's traveling with. So we have nk states (position, bus).Our goal is to reach some (b, ...) state from a (a, v) state which bus v surely passes a (source states). So let's find all states that can reach a goal state. We call such states good states.Consider Urpal is at junction x and he's traveling with a bus of type y. Let v1, v2, ..., vw be the list of junctions the bus might go on its shortest path from sy to ty. And let c1, c2, ..., cl be the list of companies that their bus surely passes junction x, excluding y-th company. For state (x, y) we know we can reach junction b (it's a good state) if one of the following is true: x = b, the minimum cost of solving the problem will be 0. All states (v1, y), (v2, y), ... and (vw, y) are good states, the minimum cost of solving the problem will be the maximum of all these states. At least one of states (x, c1), (x, c2), ... or (x, cl) is a good state, the minimum cost of solving the problem will be the minimum the good ones plus one. At first the only good states we know are states with junction b, (b, ...). Now some new states might have become good states. So we add those states to the list of known good states. We do this until no state becomes good anymore.At the end we print the minimum cost of source states which are good, and if they don't exist we print -1.The process thing can be implemented in O(n4). :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 239 和字母"
          },
          "content_length": 5483
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 1",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 2",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 3",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 4",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100, \"q\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[<>0-9]{1,100}\", \"s\");\n    ensuref((int)s.size() == n, \"Length of s should be n=%d, but is %d\", n, (int)s.size());\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100, \"q\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[<>0-9]{1,100}\", \"s\");\n    ensuref((int)s.size() == n, \"Length of s should be n=%d, but is %d\", n, (int)s.size());\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100, \"q\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[<>0-9]{1,100}\", \"s\");\n    ensuref((int)s.size() == n, \"Length of s should be n=%d, but is %d\", n, (int)s.size());\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generateSequence(int n, const string& type) {\n    string s;\n    if (type == \"random\") {\n        // Generate a random sequence of length n containing '<', '>', or digits '0'..'9'\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(3); // 0: '<', 1: '>', 2: digit\n            if (choice == 0) {\n                s.push_back('<');\n            } else if (choice == 1) {\n                s.push_back('>');\n            } else {\n                char digit = '0' + rnd.next(10);\n                s.push_back(digit);\n            }\n        }\n    } else if (type == \"digits\") {\n        // Generate a sequence of digits\n        for (int i = 0; i < n; ++i) {\n            char digit = '0' + rnd.next(10);\n            s.push_back(digit);\n        }\n    } else if (type == \"directions\") {\n        // Generate a sequence of '<' and '>'\n        for (int i = 0; i < n; ++i) {\n            s.push_back(rnd.next(2) ? '<' : '>');\n        }\n    } else if (type == \"alternating\") {\n        // Alternate between digit and direction\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s.push_back('0' + rnd.next(10));\n            else\n                s.push_back(rnd.next(2) ? '<' : '>');\n        }\n    } else if (type == \"zeros\") {\n        // Generate a sequence of zeros\n        s = string(n, '0');\n    } else if (type == \"maxdigits\") {\n        // Generate a sequence of '9's\n        s = string(n, '9');\n    } else if (type == \"edge\") {\n        // Generate an edge case sequence\n        if (n >= 1) s.push_back('<');\n        for (int i = 1; i < n-1; ++i) {\n            s.push_back('0' + rnd.next(10));\n        }\n        if (n > 1) s.push_back('>');\n    } else if (type == \"special\") {\n        // Craft a special sequence\n        // For example, sequence that would cause CP to move off immediately\n        if (n >= 1) s.push_back('<');\n        for (int i = 1; i < n; ++i) s.push_back('9');\n    } else {\n        // Default to 'random' if unknown type\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(3);\n            if (choice == 0) {\n                s.push_back('<');\n            } else if (choice == 1) {\n                s.push_back('>');\n            } else {\n                char digit = '0' + rnd.next(10);\n                s.push_back(digit);\n            }\n        }\n    }\n    return s;\n}\n\nvector<pair<int,int>> generateQueries(int n, int q, const string& qtype) {\n    vector<pair<int,int>> queries;\n\n    if (qtype == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back({l, r});\n        }\n    } else if (qtype == \"full\") {\n        // All queries cover the full sequence\n        for (int i = 0; i < q; ++i) {\n            queries.push_back({1, n});\n        }\n    } else if (qtype == \"minimal\") {\n        // Queries of minimal length (l = r)\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            queries.push_back({l, l});\n        }\n    } else if (qtype == \"overlap\") {\n        // Overlapping queries\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n/2);\n            int r = rnd.next(n/2+1, n);\n            if (l > r) swap(l, r);\n            queries.push_back({l, r});\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back({l, r});\n        }\n    }\n    return queries;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    // generate s\n    string s = generateSequence(n, type);\n\n    // generate q queries\n    vector<pair<int,int>> queries = generateQueries(n, q, qtype);\n\n    // output n q\n    printf(\"%d %d\\n\", n, q);\n    // output s\n    printf(\"%s\\n\", s.c_str());\n\n    // output q queries\n    for (auto& p : queries) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generateSequence(int n, const string& type) {\n    string s;\n    if (type == \"random\") {\n        // Generate a random sequence of length n containing '<', '>', or digits '0'..'9'\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(3); // 0: '<', 1: '>', 2: digit\n            if (choice == 0) {\n                s.push_back('<');\n            } else if (choice == 1) {\n                s.push_back('>');\n            } else {\n                char digit = '0' + rnd.next(10);\n                s.push_back(digit);\n            }\n        }\n    } else if (type == \"digits\") {\n        // Generate a sequence of digits\n        for (int i = 0; i < n; ++i) {\n            char digit = '0' + rnd.next(10);\n            s.push_back(digit);\n        }\n    } else if (type == \"directions\") {\n        // Generate a sequence of '<' and '>'\n        for (int i = 0; i < n; ++i) {\n            s.push_back(rnd.next(2) ? '<' : '>');\n        }\n    } else if (type == \"alternating\") {\n        // Alternate between digit and direction\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s.push_back('0' + rnd.next(10));\n            else\n                s.push_back(rnd.next(2) ? '<' : '>');\n        }\n    } else if (type == \"zeros\") {\n        // Generate a sequence of zeros\n        s = string(n, '0');\n    } else if (type == \"maxdigits\") {\n        // Generate a sequence of '9's\n        s = string(n, '9');\n    } else if (type == \"edge\") {\n        // Generate an edge case sequence\n        if (n >= 1) s.push_back('<');\n        for (int i = 1; i < n-1; ++i) {\n            s.push_back('0' + rnd.next(10));\n        }\n        if (n > 1) s.push_back('>');\n    } else if (type == \"special\") {\n        // Craft a special sequence\n        // For example, sequence that would cause CP to move off immediately\n        if (n >= 1) s.push_back('<');\n        for (int i = 1; i < n; ++i) s.push_back('9');\n    } else {\n        // Default to 'random' if unknown type\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(3);\n            if (choice == 0) {\n                s.push_back('<');\n            } else if (choice == 1) {\n                s.push_back('>');\n            } else {\n                char digit = '0' + rnd.next(10);\n                s.push_back(digit);\n            }\n        }\n    }\n    return s;\n}\n\nvector<pair<int,int>> generateQueries(int n, int q, const string& qtype) {\n    vector<pair<int,int>> queries;\n\n    if (qtype == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back({l, r});\n        }\n    } else if (qtype == \"full\") {\n        // All queries cover the full sequence\n        for (int i = 0; i < q; ++i) {\n            queries.push_back({1, n});\n        }\n    } else if (qtype == \"minimal\") {\n        // Queries of minimal length (l = r)\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            queries.push_back({l, l});\n        }\n    } else if (qtype == \"overlap\") {\n        // Overlapping queries\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n/2);\n            int r = rnd.next(n/2+1, n);\n            if (l > r) swap(l, r);\n            queries.push_back({l, r});\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back({l, r});\n        }\n    }\n    return queries;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    // generate s\n    string s = generateSequence(n, type);\n\n    // generate q queries\n    vector<pair<int,int>> queries = generateQueries(n, q, qtype);\n\n    // output n q\n    printf(\"%d %d\\n\", n, q);\n    // output s\n    printf(\"%s\\n\", s.c_str());\n\n    // output q queries\n    for (auto& p : queries) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 100 -q 100 -type random -qtype random\n./gen -n 100 -q 100 -type digits -qtype full\n./gen -n 100 -q 100 -type directions -qtype minimal\n./gen -n 100 -q 100 -type alternating -qtype overlap\n./gen -n 100 -q 100 -type zeros -qtype full\n./gen -n 100 -q 100 -type maxdigits -qtype random\n./gen -n 100 -q 100 -type edge -qtype random\n./gen -n 100 -q 100 -type special -qtype minimal\n./gen -n 1 -q 1 -type digits -qtype full\n./gen -n 1 -q 1 -type directions -qtype minimal\n./gen -n 2 -q 2 -type alternating -qtype overlap\n./gen -n 50 -q 50 -type random -qtype random\n./gen -n 50 -q 50 -type digits -qtype full\n./gen -n 50 -q 50 -type zeros -qtype minimal\n./gen -n 10 -q 10 -type random -qtype random\n./gen -n 20 -q 100 -type random -qtype random\n./gen -n 70 -q 70 -type special -qtype overlap\n./gen -n 30 -q 30 -type edge -qtype full\n./gen -n 75 -q 100 -type maxdigits -qtype minimal\n./gen -n 80 -q 90 -type zeros -qtype minimal\n./gen -n 90 -q 80 -type directions -qtype overlap\n./gen -n 60 -q 100 -type digits -qtype random\n./gen -n 40 -q 40 -type special -qtype full\n./gen -n 100 -q 100 -type alternating -qtype random\n./gen -n 25 -q 25 -type alternating -qtype random\n./gen -n 15 -q 15 -type digits -qtype minimal\n./gen -n 85 -q 85 -type random -qtype random\n./gen -n 95 -q 100 -type edge -qtype random\n./gen -n 100 -q 100 -type zeros -qtype full\n\n# Randomly generate more test cases\nfor i in `seq 1 5`; do\n  ./gen -n 100 -q 100 -type random -qtype random\ndone\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:54:08.589459",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "239/C",
      "title": "C. Not Wool Sequences",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of input contains two space-separated integers n and m (1 ≤ n, m ≤ 105).",
      "output_spec": "OutputPrint the required number of sequences modulo 1000000009 (109 + 9) on the only line of output.",
      "sample_tests": "ExamplesInputCopy3 2OutputCopy6",
      "description": "C. Not Wool Sequences\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line of input contains two space-separated integers n and m (1 ≤ n, m ≤ 105).\n\nOutputPrint the required number of sequences modulo 1000000009 (109 + 9) on the only line of output.\n\nInputCopy3 2OutputCopy6\n\nInputCopy3 2\n\nOutputCopy6\n\nNoteSequences of length 3 made of integers 0, 1, 2 and 3 that are not a wool sequence are (1, 3, 1), (1, 2, 1), (2, 1, 2), (2, 3, 2), (3, 1, 3) and (3, 2, 3).",
      "solutions": [
        {
          "title": "Codeforces Round #148 - Codeforces",
          "content": "Hi all! :)I'm glad to invite you to participate in Codeforces Round #148 today. I (Hamed Valizadeh) am the author of this round. I'd like to thank Gerald (Gerald Agapov) MikeMirzayanov (Mike Mirzayanov) Delinur (Maria Belova) and Saeed_Reza (SaeedReza Seddighin) who helped me in preparing the round.Score distribution will be the standard 500-1000-1500-2000-2500 in both divisions.Hope you find the problems interesting to solve.Good luck and have fun ;)Update. Contest is over. Congratulations to the winners of both divisions! :)Div1: tourist cerealguy Dmitry_Egorov RAVEman UESTC_Nocturne Div2: LiWenHaoTianXiaDiYi goooooooopan jthread kolina xcodevn And congrats to Endagorion who was the only one solving 238D - Tape Programming correctly during the contest.BTW, I hope you didn't get sick of that boring problem! :-\"Update 2. The editorial is ready now, sorry for the delay. http://codeforces.com/blog/entry/5765",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 919
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces",
          "content": "Hi :)Here is the editorial for round #148. I just tried to explain the ideas rather than detailed implementation explanation. I'm sorry for my bad English, so please tell me if something is not clear in the descriptions.Two Bags of PotatoesThe author of this problem is Gerald. The total number of potatoes is a multiple of k and constraint there will be at most 105 multiples of k in range 1 to n. So you can iterate on multiples of k and print the ones that satisfy the problem.Easy Tape ProgrammingIn this problem you just need to simulate every thing which is written in the statement step by step. You can see a simple implementation of this here: http://www.codeforces.com/contest/239/submission/2512422Not Wool SequencesLet a1, ..., an be a not-wool-sequence. We define another sequence called b in which bi is xor of the first i elements of a, and b0 = 0.Now xor of elements of a consecutive subsequence like ai, ..., aj will be equal to . So we know that all elements of b should be different. Therefore b is a sequence of distinct integers of length n + 1 starting with 0 made of numbers 0 to 2m - 1. The number of such sequences is and this is the answer to problem.Boring PartitionComing soon...World Eater BrothersConsider we only want to change direction of minimum number of roads so that all other countries are reachable from a specific country x. This problem can be solved in O(n) and it's exactly what 219D - Choosing Capital for Treeland asks for. If you don't know how to solve it you can read the editorial of that contest.Consider two countries A and B which can be chosen by world eater brothers to achieve the minimum number of road direction changes. After changing the direction of roads, there exists a country on the undirected path between A and B which is reachable from both A and B using roads. We call such country a middle-country.We want to iterate on middle-countries and find the best two countries for ruling for each middle-country. For each neighbor of the current middle-country calculate the minimum number of road changes in the subtree rooted at that neighbor so that all countries will be reachable from some country in that subtree. Then from two of these subtrees we need to pick A and B and all other subtrees will have edges pointing to the root of subtree. This can be computed in O(n) for each middle-city. So the overall complexity will be O(n2).Tape ProgrammingThis problem was my favorite in the problemset. The primary point is that at any moment during the interpretation of a program only a prefix of the program is modified and used by IP.Consider we want to calculate the output of subsequence sl, ..., sr. While running the original program s1, ..., sn if at any moment CP enters the interval [l, r] it should be pointing to position l and the direction of DP should be right. So it's like we have started interpreting sl, ..., sr independently. The termination of execution of sl, ..., sr is the first time CP points to somewhere outside interval [l, r]. Therefore what we need to solve the problem is to run the original program. And after each termination if the program is nonempty then run it again until program is empty. Then we should keep a log of positions we have visited and the time of each visit and the number of printed digits of each type until then. After this preprocessing the to calculate the answer of query (li, ri) its enough to find the first time CP visited sli and the first time CP visited sri + 1 or sli - 1 after that.The described approach can be implemented in O(nlog(n) + qlog(n)).Meeting herConsider a bus passing a shortest path from si to ti. There are some points that are necessary to pass in order to obtain a shortest path. Firstly we compute them. This can be done in O(n3) with Floyd-Warshall and some processing after that. Urpal is sure that a bus from i-th company always passes such vertices on his path from si to ti. So he can get on a bus from i-th company only at vertices the bus surely passes.At any moment Urpal's status can be uniquely determined by his position on the map and the bus he's traveling with. So we have nk states (position, bus).Our goal is to reach some (b, ...) state from a (a, v) state which bus v surely passes a (source states). So let's find all states that can reach a goal state. We call such states good states.Consider Urpal is at junction x and he's traveling with a bus of type y. Let v1, v2, ..., vw be the list of junctions the bus might go on its shortest path from sy to ty. And let c1, c2, ..., cl be the list of companies that their bus surely passes junction x, excluding y-th company. For state (x, y) we know we can reach junction b (it's a good state) if one of the following is true: x = b, the minimum cost of solving the problem will be 0. All states (v1, y), (v2, y), ... and (vw, y) are good states, the minimum cost of solving the problem will be the maximum of all these states. At least one of states (x, c1), (x, c2), ... or (x, cl) is a good state, the minimum cost of solving the problem will be the minimum the good ones plus one. At first the only good states we know are states with junction b, (b, ...). Now some new states might have become good states. So we add those states to the list of known good states. We do this until no state becomes good anymore.At the end we print the minimum cost of source states which are good, and if they don't exist we print -1.The process thing can be implemented in O(n4). :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 239 和字母"
          },
          "content_length": 5483
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 1",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 2",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 3",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 4",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal n and m\n./gen -n 1 -m 1\n# Maximal n, minimal m\n./gen -n 100000 -m 1\n# Minimal n, maximal m\n./gen -n 1 -m 100000\n# Maximal n and m\n./gen -n 100000 -m 100000\n# n = 1, m = 0 (edge case)\n./gen -n 1 -m 0\n# n = maximum, m = 0 (edge case)\n./gen -n 100000 -m 0\n# Random small n and m\n./gen -n 10 -m 10\n# Random moderate n and m\n./gen -n 50000 -m 50000\n# n is large, m is small\n./gen -n 100000 -m 10\n# n is small, m is large\n./gen -n 10 -m 100000\n# m = 64 (possible overflow point)\n./gen -n 100000 -m 64\n./gen -n 1 -m 64\n# n and m near maximum\n./gen -n 99999 -m 99999\n# n and m are both even numbers\n./gen -n 100000 -m 100000\n# n and m are both odd numbers\n./gen -n 99999 -m 99999\n# Random n and m\n./gen -n 12345 -m 54321\n# n and m both prime numbers\n./gen -n 99991 -m 99991\n# n and m both powers of 2\n./gen -n 65536 -m 65536\n# Another set of random values\n./gen -n 32768 -m 32768\n# n is maximum, m is half maximum\n./gen -n 100000 -m 50000\n# m is maximum, n is half maximum\n./gen -n 50000 -m 100000\n# Edge case: m is just above 63\n./gen -n 100000 -m 65\n# Edge case: m is just below 63\n./gen -n 100000 -m 63\n# n is minimal, m is maximum\n./gen -n 1 -m 100000\n# Both n and m are 2\n./gen -n 2 -m 2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:54:10.853573",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "239/D",
      "title": "D. Boring Partition",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integers n and h (2 ≤ n ≤ 105, 0 ≤ h ≤ 108). In the second line there is a list of n space-separated integers representing a1, a2, ..., an (0 ≤ ai ≤ 108).",
      "output_spec": "OutputThe first line of output should contain the required minimum goodness. The second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if ai is in the first subsequence otherwise it should be 2.If there are several possible correct answers you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy3 21 2 3OutputCopy11 2 2 InputCopy5 100 1 0 2 1OutputCopy32 2 2 2 2",
      "description": "D. Boring Partition\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains integers n and h (2 ≤ n ≤ 105, 0 ≤ h ≤ 108). In the second line there is a list of n space-separated integers representing a1, a2, ..., an (0 ≤ ai ≤ 108).\n\nOutputThe first line of output should contain the required minimum goodness. The second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if ai is in the first subsequence otherwise it should be 2.If there are several possible correct answers you are allowed to print any of them.\n\nInputCopy3 21 2 3OutputCopy11 2 2 InputCopy5 100 1 0 2 1OutputCopy32 2 2 2 2\n\nInputCopy3 21 2 3\n\nOutputCopy11 2 2\n\nInputCopy5 100 1 0 2 1\n\nOutputCopy32 2 2 2 2\n\nNoteIn the first sample the values of f are as follows: f(1, 2) = 1 + 2 + 2 = 5, f(1, 3) = 1 + 3 + 2 = 6 and f(2, 3) = 2 + 3 = 5. So the difference between maximum and minimum values of f is 1.In the second sample the value of h is large, so it's better for one of the sub-sequences to be empty.",
      "solutions": [
        {
          "title": "Codeforces Round #148 - Codeforces",
          "content": "Hi all! :)I'm glad to invite you to participate in Codeforces Round #148 today. I (Hamed Valizadeh) am the author of this round. I'd like to thank Gerald (Gerald Agapov) MikeMirzayanov (Mike Mirzayanov) Delinur (Maria Belova) and Saeed_Reza (SaeedReza Seddighin) who helped me in preparing the round.Score distribution will be the standard 500-1000-1500-2000-2500 in both divisions.Hope you find the problems interesting to solve.Good luck and have fun ;)Update. Contest is over. Congratulations to the winners of both divisions! :)Div1: tourist cerealguy Dmitry_Egorov RAVEman UESTC_Nocturne Div2: LiWenHaoTianXiaDiYi goooooooopan jthread kolina xcodevn And congrats to Endagorion who was the only one solving 238D - Tape Programming correctly during the contest.BTW, I hope you didn't get sick of that boring problem! :-\"Update 2. The editorial is ready now, sorry for the delay. http://codeforces.com/blog/entry/5765",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 919
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces",
          "content": "Hi :)Here is the editorial for round #148. I just tried to explain the ideas rather than detailed implementation explanation. I'm sorry for my bad English, so please tell me if something is not clear in the descriptions.Two Bags of PotatoesThe author of this problem is Gerald. The total number of potatoes is a multiple of k and constraint there will be at most 105 multiples of k in range 1 to n. So you can iterate on multiples of k and print the ones that satisfy the problem.Easy Tape ProgrammingIn this problem you just need to simulate every thing which is written in the statement step by step. You can see a simple implementation of this here: http://www.codeforces.com/contest/239/submission/2512422Not Wool SequencesLet a1, ..., an be a not-wool-sequence. We define another sequence called b in which bi is xor of the first i elements of a, and b0 = 0.Now xor of elements of a consecutive subsequence like ai, ..., aj will be equal to . So we know that all elements of b should be different. Therefore b is a sequence of distinct integers of length n + 1 starting with 0 made of numbers 0 to 2m - 1. The number of such sequences is and this is the answer to problem.Boring PartitionComing soon...World Eater BrothersConsider we only want to change direction of minimum number of roads so that all other countries are reachable from a specific country x. This problem can be solved in O(n) and it's exactly what 219D - Choosing Capital for Treeland asks for. If you don't know how to solve it you can read the editorial of that contest.Consider two countries A and B which can be chosen by world eater brothers to achieve the minimum number of road direction changes. After changing the direction of roads, there exists a country on the undirected path between A and B which is reachable from both A and B using roads. We call such country a middle-country.We want to iterate on middle-countries and find the best two countries for ruling for each middle-country. For each neighbor of the current middle-country calculate the minimum number of road changes in the subtree rooted at that neighbor so that all countries will be reachable from some country in that subtree. Then from two of these subtrees we need to pick A and B and all other subtrees will have edges pointing to the root of subtree. This can be computed in O(n) for each middle-city. So the overall complexity will be O(n2).Tape ProgrammingThis problem was my favorite in the problemset. The primary point is that at any moment during the interpretation of a program only a prefix of the program is modified and used by IP.Consider we want to calculate the output of subsequence sl, ..., sr. While running the original program s1, ..., sn if at any moment CP enters the interval [l, r] it should be pointing to position l and the direction of DP should be right. So it's like we have started interpreting sl, ..., sr independently. The termination of execution of sl, ..., sr is the first time CP points to somewhere outside interval [l, r]. Therefore what we need to solve the problem is to run the original program. And after each termination if the program is nonempty then run it again until program is empty. Then we should keep a log of positions we have visited and the time of each visit and the number of printed digits of each type until then. After this preprocessing the to calculate the answer of query (li, ri) its enough to find the first time CP visited sli and the first time CP visited sri + 1 or sli - 1 after that.The described approach can be implemented in O(nlog(n) + qlog(n)).Meeting herConsider a bus passing a shortest path from si to ti. There are some points that are necessary to pass in order to obtain a shortest path. Firstly we compute them. This can be done in O(n3) with Floyd-Warshall and some processing after that. Urpal is sure that a bus from i-th company always passes such vertices on his path from si to ti. So he can get on a bus from i-th company only at vertices the bus surely passes.At any moment Urpal's status can be uniquely determined by his position on the map and the bus he's traveling with. So we have nk states (position, bus).Our goal is to reach some (b, ...) state from a (a, v) state which bus v surely passes a (source states). So let's find all states that can reach a goal state. We call such states good states.Consider Urpal is at junction x and he's traveling with a bus of type y. Let v1, v2, ..., vw be the list of junctions the bus might go on its shortest path from sy to ty. And let c1, c2, ..., cl be the list of companies that their bus surely passes junction x, excluding y-th company. For state (x, y) we know we can reach junction b (it's a good state) if one of the following is true: x = b, the minimum cost of solving the problem will be 0. All states (v1, y), (v2, y), ... and (vw, y) are good states, the minimum cost of solving the problem will be the maximum of all these states. At least one of states (x, c1), (x, c2), ... or (x, cl) is a good state, the minimum cost of solving the problem will be the minimum the good ones plus one. At first the only good states we know are states with junction b, (b, ...). Now some new states might have become good states. So we add those states to the list of known good states. We do this until no state becomes good anymore.At the end we print the minimum cost of source states which are good, and if they don't exist we print -1.The process thing can be implemented in O(n4). :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 239 和字母"
          },
          "content_length": 5483
        }
      ],
      "code_examples": [
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 1",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 2",
          "code": "1) {a[0]..a[n]} and {}\n2) {a[1]..a[n]} and {a[0]}\n'a' is sorted array of input data",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 3",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        },
        {
          "title": "Editorial for Codeforces Round #148 - Codeforces - Code 4",
          "code": "trivalAnswer = (a[n] + a[n-1]) - (a[1] + a[0]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int h = inf.readInt(0, 100000000, \"h\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int h = inf.readInt(0, 100000000, \"h\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int h = inf.readInt(0, 100000000, \"h\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 100000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long compute_goodness(InStream& stream, int n, int h, vector<int>& a, vector<int>& partition, long long claimed_goodness) {\n    vector<int> s1_elements;\n    vector<int> s2_elements;\n\n    for(int i = 0; i < n; i++) {\n        if(partition[i] == 1)\n            s1_elements.push_back(a[i]);\n        else if(partition[i] == 2)\n            s2_elements.push_back(a[i]);\n        else\n            stream.quitf(_wa, \"Invalid partition value at position %d: %d (should be 1 or 2)\", i+1, partition[i]);\n    }\n\n    long long min_f = LLONG_MAX;\n    long long max_f = LLONG_MIN;\n\n    // Pairs within S1\n    if(s1_elements.size() >= 2) {\n        sort(s1_elements.begin(), s1_elements.end());\n        long long min_same_S1 = (long long)s1_elements[0] + s1_elements[1];\n        long long max_same_S1 = (long long)s1_elements[s1_elements.size()-1] + s1_elements[s1_elements.size()-2];\n        min_f = min(min_f, min_same_S1);\n        max_f = max(max_f, max_same_S1);\n    }\n\n    // Pairs within S2\n    if(s2_elements.size() >= 2) {\n        sort(s2_elements.begin(), s2_elements.end());\n        long long min_same_S2 = (long long)s2_elements[0] + s2_elements[1];\n        long long max_same_S2 = (long long)s2_elements[s2_elements.size()-1] + s2_elements[s2_elements.size()-2];\n        min_f = min(min_f, min_same_S2);\n        max_f = max(max_f, max_same_S2);\n    }\n\n    // Pairs between S1 and S2\n    if(!s1_elements.empty() && !s2_elements.empty()) {\n        int min_s1 = *min_element(s1_elements.begin(), s1_elements.end());\n        int max_s1 = *max_element(s1_elements.begin(), s1_elements.end());\n        int min_s2 = *min_element(s2_elements.begin(), s2_elements.end());\n        int max_s2 = *max_element(s2_elements.begin(), s2_elements.end());\n\n        long long min_diff = (long long)min_s1 + min_s2 + h;\n        long long max_diff = (long long)max_s1 + max_s2 + h;\n        min_f = min(min_f, min_diff);\n        max_f = max(max_f, max_diff);\n    }\n\n    if(min_f == LLONG_MAX || max_f == LLONG_MIN) {\n        // No pairs were formed\n        stream.quitf(_wa, \"No valid pairs to compute goodness\");\n    }\n\n    long long actual_goodness = max_f - min_f;\n\n    if(actual_goodness != claimed_goodness) {\n        stream.quitf(_wa, \"Claimed goodness %lld does not match computed goodness %lld\", claimed_goodness, actual_goodness);\n    }\n\n    return actual_goodness;\n}\n\nlong long readAns(InStream& stream, int n, int h, vector<int>& a) {\n    long long claimed_goodness = stream.readLong(0, LLONG_MAX, \"goodness\");\n    vector<int> partition(n);\n    for(int i = 0; i < n; i++) {\n        partition[i] = stream.readInt(1, 2, format(\"partition[%d]\", i+1).c_str());\n    }\n    long long computed_goodness = compute_goodness(stream, n, h, a, partition, claimed_goodness);\n    return computed_goodness;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    int h = inf.readInt(0, 100000000, \"h\");\n    vector<int> a(n);\n    for(int i = 0; i < n; i++) {\n        a[i] = inf.readInt(0, 100000000, format(\"a[%d]\", i+1).c_str());\n    }\n\n    long long jury_goodness = readAns(ans, n, h, a);\n    long long participant_goodness = readAns(ouf, n, h, a);\n\n    if(participant_goodness > jury_goodness) {\n        quitf(_wa, \"Participant's goodness %lld is worse than jury's goodness %lld\", participant_goodness, jury_goodness);\n    } else if(participant_goodness == jury_goodness) {\n        quitf(_ok, \"Goodness = %lld\", participant_goodness);\n    } else {\n        quitf(_fail, \"Participant's goodness %lld is better than jury's goodness %lld\", participant_goodness, jury_goodness);\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int h = opt<int>(\"h\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"all_same\") {\n        int val = opt<int>(\"val\", 0);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = i;\n    } else if (type == \"decreasing\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"small_random\") {\n        int max_val = opt<int>(\"max_val\", 10);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, max_val);\n    } else if (type == \"large_random\") {\n        int max_val = opt<int>(\"max_val\", 100000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, max_val);\n    } else if (type == \"alternating\") {\n        int min_val = opt<int>(\"min_val\", 0);\n        int max_val = opt<int>(\"max_val\", 100000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? min_val : max_val;\n    } else {\n        // default is random between 0 and 1e8\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100000000);\n    }\n\n    // output n and h\n    printf(\"%d %d\\n\", n, h);\n    // output ai\n    for(int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int h = opt<int>(\"h\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"all_same\") {\n        int val = opt<int>(\"val\", 0);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = i;\n    } else if (type == \"decreasing\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"small_random\") {\n        int max_val = opt<int>(\"max_val\", 10);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, max_val);\n    } else if (type == \"large_random\") {\n        int max_val = opt<int>(\"max_val\", 100000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, max_val);\n    } else if (type == \"alternating\") {\n        int min_val = opt<int>(\"min_val\", 0);\n        int max_val = opt<int>(\"max_val\", 100000000);\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? min_val : max_val;\n    } else {\n        // default is random between 0 and 1e8\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100000000);\n    }\n\n    // output n and h\n    printf(\"%d %d\\n\", n, h);\n    // output ai\n    for(int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Minimal n, h=0, all zeros\n./gen -n 2 -h 0 -type all_zero\n\n# Test case 2: Minimal n, h=0, random small numbers\n./gen -n 2 -h 0 -type small_random -max_val 10\n\n# Test case 3: Minimal n, h=100000000, all zeros\n./gen -n 2 -h 100000000 -type all_zero\n\n# Test case 4: Minimal n, h=100000000, random large numbers\n./gen -n 2 -h 100000000 -type large_random -max_val 100000000\n\n# Test case 5: Small n, h=0, increasing sequence\n./gen -n 10 -h 0 -type increasing\n\n# Test case 6: Small n, h=100000000, decreasing sequence\n./gen -n 10 -h 100000000 -type decreasing\n\n# Test case 7: Small n, h=50000, alternating values\n./gen -n 10 -h 50000 -type alternating -min_val 0 -max_val 100\n\n# Test case 8: Medium n, h=0, all zeros\n./gen -n 1000 -h 0 -type all_zero\n\n# Test case 9: Medium n, h=100000000, all same value\n./gen -n 1000 -h 100000000 -type all_same -val 99999999\n\n# Test case 10: Medium n, h=0, random small numbers\n./gen -n 1000 -h 0 -type small_random -max_val 10\n\n# Test case 11: Medium n, h=100000000, random large numbers\n./gen -n 1000 -h 100000000 -type large_random -max_val 100000000\n\n# Test case 12: Large n, h=0, increasing sequence\n./gen -n 100000 -h 0 -type increasing\n\n# Test case 13: Large n, h=100000000, decreasing sequence\n./gen -n 100000 -h 100000000 -type decreasing\n\n# Test case 14: Large n, h=0, random small numbers\n./gen -n 100000 -h 0 -type small_random -max_val 10\n\n# Test case 15: Large n, h=100000000, random large numbers\n./gen -n 100000 -h 100000000 -type large_random -max_val 100000000\n\n# Test case 16: Large n, h=50000, alternating values\n./gen -n 100000 -h 50000 -type alternating -min_val 0 -max_val 100000000\n\n# Test case 17: Maximal values, n and h at maximum, all zeros\n./gen -n 100000 -h 100000000 -type all_zero\n\n# Test case 18: Maximal values, n and h at maximum, all same maximum value\n./gen -n 100000 -h 100000000 -type all_same -val 100000000\n\n# Test case 19: Maximal values, n and h at maximum, random maximum values\n./gen -n 100000 -h 100000000 -type large_random -max_val 100000000\n\n# Test case 20: n=2, h=0, minimal edge case\n./gen -n 2 -h 0 -type random\n\n# Test case 21: n=2, h=100000000, maximal edge case\n./gen -n 2 -h 100000000 -type random\n\n# Test case 22: n=99999, h=12345678, random small numbers\n./gen -n 99999 -h 12345678 -type small_random -max_val 100\n\n# Test case 23: n=100000, h=1, random large numbers\n./gen -n 100000 -h 1 -type large_random -max_val 100000000\n\n# Test case 24: n=100000, h=0, all ones\n./gen -n 100000 -h 0 -type all_same -val 1\n\n# Test case 25: n=100000, h=100000000, alternating zeros and maximum values\n./gen -n 100000 -h 100000000 -type alternating -min_val 0 -max_val 100000000\n\n# Test case 26: n=2, h=100000000, maximum values\n./gen -n 2 -h 100000000 -type large_random -max_val 100000000\n\n# Test case 27: n=2, h=0, zeros and ones\n./gen -n 2 -h 0 -type alternating -min_val 0 -max_val 1\n\n# Test case 28: n=50000, h=50000, random values\n./gen -n 50000 -h 50000 -type random\n\n# Test case 29: n=99999, h=99999, random small numbers\n./gen -n 99999 -h 99999 -type small_random -max_val 100\n\n# Test case 30: n=100000, h=100000000, random maximal numbers\n./gen -n 100000 -h 100000000 -type large_random -max_val 100000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:54:13.169122",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}